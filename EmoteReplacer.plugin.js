/**
 * @name EmoteReplacer
 * @version 1.13.0
 * @description Check for known emote names and replace them with an embedded image of the emote. Also supports modifiers similar to BetterDiscord's emotes. Standard emotes: https://yentis.github.io/emotes/
 * @license MIT
 * @author Yentis
 * @authorId 68834122860077056
 * @website https://github.com/Yentis/betterdiscord-emotereplacer
 * @source https://raw.githubusercontent.com/Yentis/betterdiscord-emotereplacer/master/EmoteReplacer.plugin.js
 */

"use strict";

var https = require("https"), fs = require("fs");

function _interopDefaultLegacy(e) {
    return e && "object" == typeof e && "default" in e ? e : {
        default: e
    };
}

function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = Object.create(null);
    return e && Object.keys(e).forEach((function(k) {
        if ("default" !== k) {
            var d = Object.getOwnPropertyDescriptor(e, k);
            Object.defineProperty(n, k, d.get ? d : {
                enumerable: !0,
                get: function() {
                    return e[k];
                }
            });
        }
    })), n.default = e, Object.freeze(n);
}

var https__default = _interopDefaultLegacy(https), fs__default = _interopDefaultLegacy(fs);

function setLogger(pluginName) {
    Logger = new LoggerClass(pluginName);
}

class LoggerClass {
    pluginName;
    constructor(pluginName) {
        this.pluginName = pluginName;
    }
    debug(...args) {
        console.debug(this.pluginName, ...args);
    }
    info(...args) {
        console.info(this.pluginName, ...args);
    }
    warn(...args) {
        console.warn(this.pluginName, ...args);
    }
    error(...args) {
        console.error(this.pluginName, ...args);
    }
}

let Logger;

const PLUGIN_CHANGELOG = [ {
    title: "Added",
    type: "added",
    items: [ "It's now possible to add custom emotes directly from your PC instead of entering a URL", "Allow uploading images to channels that don't allow external emotes", "Emotes are now shown as disabled in the reactions menu, as they cannot be used for reacting" ]
}, {
    title: "Fixed",
    type: "fixed",
    items: [ "Custom emote menu no longer shows broken emotes from the standard set", "Custom emotes starting with numbers or containing spaces can now be removed" ]
} ], DEFAULT_SETTINGS = {
    emoteSize: 48,
    autocompleteEmoteSize: 15,
    autocompleteItems: 10,
    customEmotes: {},
    requirePrefix: !0,
    prefix: ";",
    resizeMethod: "smallest",
    showStandardEmotes: !0
};

let Buffer$1;

function urlGetBuffer(url) {
    return url.startsWith("http") ? function httpsGetBuffer(url) {
        return new Promise(((resolve, reject) => {
            https__default.default.get(url, (res => {
                const buffers = [];
                res.on("data", (chunk => {
                    buffers.push(chunk);
                })), res.on("end", (() => {
                    const statusCode = res.statusCode ?? 0;
                    0 !== statusCode && (statusCode < 200 || statusCode >= 400) ? reject(new Error(res.statusMessage)) : resolve(Buffer$1.concat(buffers));
                }));
            })).on("error", (error => {
                reject(error);
            }));
        }));
    }(url) : async function fsGetBuffer(url) {
        const data = fs__default.default.readFileSync(url, "");
        return await Promise.resolve(Buffer$1.from(data));
    }(url);
}

async function loadImagePromise(url, waitForLoad = !0, element) {
    const image = element ?? new Image, loadPromise = new Promise(((resolve, reject) => {
        image.onload = () => {
            resolve();
        }, image.onerror = () => {
            reject(new Error(`Failed to load image for url ${url}`));
        };
    }));
    if (url.startsWith("http") && !waitForLoad) image.src = url; else {
        const buffer = await urlGetBuffer(url);
        image.src = URL.createObjectURL(new Blob([ buffer ]));
    }
    return waitForLoad && await loadPromise, image;
}

function delay(duration) {
    return new Promise((resolve => {
        setTimeout((() => {
            resolve();
        }), duration);
    }));
}

class BaseService {
    plugin;
    zeresPluginLibrary;
    constructor(plugin, zeresPluginLibrary) {
        this.plugin = plugin, this.zeresPluginLibrary = zeresPluginLibrary;
    }
}

class CompletionsService extends BaseService {
    static TAG=CompletionsService.name;
    static TEXTAREA_KEYDOWN_LISTENER="textAreaKeydown";
    static TEXTAREA_WHEEL_LISTENER="textAreaWheel";
    static TEXTAREA_BLUR_LISTENER="textAreaBlur";
    static AUTOCOMPLETE_DIV_WHEEL_LISTENER="autocompleteDivWheel";
    static EMOTE_ROW_MOUSEENTER_LISTENER="emoteRowMouseenter";
    static EMOTE_ROW_MOUSEDOWN_LISTENER="emoteRowMousedown";
    emoteService;
    settingsService;
    modulesService;
    listenersService;
    htmlService;
    draft="";
    cached;
    start(emoteService, settingsService, modulesService, listenersService, htmlService) {
        return this.emoteService = emoteService, this.settingsService = settingsService, 
        this.modulesService = modulesService, this.listenersService = listenersService, 
        this.htmlService = htmlService, this.listenersService.addListenersWatchers[CompletionsService.TAG] = {
            onAddListeners: () => {
                this.addListeners();
            }
        }, this.addListeners(), Promise.resolve();
    }
    addListeners() {
        const textArea = this.htmlService.getTextAreaField();
        if (void 0 === textArea) return;
        this.listenersService.removeListener(CompletionsService.TEXTAREA_KEYDOWN_LISTENER), 
        this.listenersService.removeListener(CompletionsService.TEXTAREA_WHEEL_LISTENER), 
        this.listenersService.removeListener(CompletionsService.TEXTAREA_BLUR_LISTENER);
        const keydownListener = {
            element: textArea,
            name: "keydown",
            callback: evt => {
                this.browseCompletions(evt);
            }
        };
        textArea.addEventListener(keydownListener.name, keydownListener.callback), this.listenersService.addListener(CompletionsService.TEXTAREA_KEYDOWN_LISTENER, keydownListener);
        const wheelListener = {
            element: textArea,
            name: "wheel",
            callback: evt => {
                this.scrollCompletions(evt);
            }
        };
        textArea.addEventListener(wheelListener.name, wheelListener.callback), this.listenersService.addListener(CompletionsService.TEXTAREA_WHEEL_LISTENER, wheelListener);
        const blurListener = {
            element: textArea,
            name: "blur",
            callback: () => {
                this.destroyCompletions();
            }
        };
        textArea.addEventListener(blurListener.name, blurListener.callback), this.listenersService.addListener(CompletionsService.TEXTAREA_BLUR_LISTENER, blurListener);
    }
    browseCompletions(event) {
        if (!this.emoteService.shouldCompleteEmote(this.draft) && !this.emoteService.shouldCompleteCommand(this.draft)) return;
        let options, delta = 0;
        const autocompleteItems = Math.round(this.settingsService.settings.autocompleteItems);
        switch (event.which) {
          case 9:
          case 13:
            if (!this.prepareCompletions()) break;
            event.stopPropagation(), event.preventDefault(), this.insertSelectedCompletion().catch(console.error);
            break;

          case 38:
            delta = -1;
            break;

          case 40:
            delta = 1;
            break;

          case 33:
            delta = -autocompleteItems, options = {
                locked: !0,
                clamped: !0
            };
            break;

          case 34:
            delta = autocompleteItems, options = {
                locked: !0,
                clamped: !0
            };
        }
        0 !== delta && this.prepareCompletions() && (event.stopPropagation(), event.preventDefault(), 
        this.scrollWindow(delta, options));
    }
    prepareCompletions() {
        const candidateText = this.draft, lastText = this.cached?.candidateText;
        if (lastText !== candidateText) if (this.emoteService.shouldCompleteEmote(candidateText)) {
            const {completions, matchText, matchStart} = this.emoteService.getCompletionsEmote(candidateText);
            this.cached = {
                candidateText,
                completions,
                matchText,
                matchStart,
                selectedIndex: 0,
                windowOffset: 0
            };
        } else if (this.emoteService.shouldCompleteCommand(candidateText)) {
            const {completions, matchText, matchStart} = this.emoteService.getCompletionsCommands(candidateText);
            this.cached = {
                candidateText,
                completions,
                matchText,
                matchStart,
                selectedIndex: 0,
                windowOffset: 0
            };
        }
        const {completions} = this.cached ?? {};
        return void 0 !== completions && 0 !== completions.length;
    }
    async insertSelectedCompletion() {
        const {completions, matchText, selectedIndex} = this.cached ?? {}, curDraft = this.draft, matchTextLength = matchText?.length ?? 0;
        if (void 0 === completions || void 0 === selectedIndex) return;
        this.modulesService.draft.clearDraft(this.modulesService.selectedChannelStore.getChannelId(), 0), 
        await delay(0);
        const selectedCompletion = completions[selectedIndex];
        if (!selectedCompletion) return;
        const completionValueArguments = "string" == typeof selectedCompletion.data ? void 0 : selectedCompletion.data.arguments;
        let suffix = " ";
        completionValueArguments && (completionValueArguments.some((argument => "" === argument)) || (suffix = "-")), 
        selectedCompletion.name += suffix;
        const newDraft = curDraft.substring(0, curDraft.length - matchTextLength);
        this.destroyCompletions(), await delay(0), this.modulesService.componentDispatcher.dispatch("INSERT_TEXT", {
            plainText: newDraft + selectedCompletion.name
        });
    }
    destroyCompletions() {
        if (this.htmlService.getTextAreaContainer()) {
            const completions = this.htmlService.getTextAreaContainer()?.querySelectorAll(`.${this.plugin.meta.name}`);
            completions?.forEach((completion => {
                completion.remove();
            }));
        }
        this.cached = void 0, this.renderCompletions.cancel();
    }
    renderCompletions=_.debounce((() => {
        const channelTextArea = this.htmlService.getTextAreaContainer();
        if (!channelTextArea) return;
        const oldAutoComplete = channelTextArea?.querySelectorAll(`.${this.plugin.meta.name}`) ?? [], discordClasses = this.modulesService.classes, isEmote = this.emoteService.shouldCompleteEmote(this.draft);
        for (const autoComplete of oldAutoComplete) autoComplete.remove();
        if (!this.emoteService.shouldCompleteEmote(this.draft) && !this.emoteService.shouldCompleteCommand(this.draft) || !this.prepareCompletions()) return;
        const {completions, matchText, selectedIndex} = this.cached ?? {}, firstIndex = this.cached?.windowOffset ?? 0, matchList = completions?.slice(firstIndex, firstIndex + Math.round(this.settingsService.settings.autocompleteItems)), autocompleteDiv = document.createElement("div");
        this.htmlService.addClasses(autocompleteDiv, discordClasses.Autocomplete.autocomplete, this.plugin.meta.name);
        const autocompleteListener = {
            element: autocompleteDiv,
            name: "wheel",
            callback: evt => {
                this.scrollCompletions(evt, {
                    locked: !0
                });
            }
        };
        autocompleteDiv.addEventListener(autocompleteListener.name, autocompleteListener.callback), 
        this.listenersService.addListener(CompletionsService.AUTOCOMPLETE_DIV_WHEEL_LISTENER, autocompleteListener), 
        channelTextArea.append(autocompleteDiv);
        const autocompleteInnerDiv = document.createElement("div");
        this.htmlService.addClasses(autocompleteInnerDiv, discordClasses.Autocomplete.autocompleteInner), 
        autocompleteDiv.append(autocompleteInnerDiv);
        const titleRow = document.createElement("div");
        this.htmlService.addClasses(titleRow, discordClasses.Autocomplete.autocompleteRowVertical), 
        autocompleteInnerDiv.append(titleRow);
        const selector = document.createElement("div");
        this.htmlService.addClasses(selector, discordClasses.Autocomplete.base), titleRow.append(selector);
        const contentTitle = document.createElement("h3");
        this.htmlService.addClasses(contentTitle, discordClasses.Autocomplete.contentTitle, discordClasses.Wrapper.base, discordClasses.Size.size12), 
        contentTitle.innerText = isEmote ? "Emoji matching " : "Commands ", selector.append(contentTitle);
        const matchTextElement = document.createElement("strong");
        matchTextElement.textContent = matchText ?? "", contentTitle.append(matchTextElement);
        for (const [index, {name, data}] of matchList?.entries() ?? []) {
            const emoteRow = document.createElement("div");
            emoteRow.setAttribute("aria-disabled", "false"), this.htmlService.addClasses(emoteRow, discordClasses.Autocomplete.clickable, discordClasses.Autocomplete.autocompleteRowVertical, discordClasses.Autocomplete.autocompleteRowVerticalSmall);
            const mouseEnterListener = {
                element: emoteRow,
                name: "mouseenter",
                callback: () => {
                    this.cached || (this.cached = {}), this.cached.selectedIndex = index + firstIndex;
                    for (const child of titleRow.parentElement?.children ?? []) {
                        child.setAttribute("aria-selected", "false");
                        for (const nestedChild of child.children) this.htmlService.addClasses(nestedChild, discordClasses.Autocomplete.base);
                    }
                }
            };
            emoteRow.addEventListener(mouseEnterListener.name, mouseEnterListener.callback), 
            this.listenersService.addListener(`${CompletionsService.EMOTE_ROW_MOUSEENTER_LISTENER}${index}`, mouseEnterListener);
            const mouseDownListener = {
                element: emoteRow,
                name: "mousedown",
                callback: evt => {
                    evt.preventDefault(), this.cached || (this.cached = {}), this.cached.selectedIndex = index + firstIndex, 
                    this.insertSelectedCompletion().catch(console.error);
                }
            };
            emoteRow.addEventListener(mouseDownListener.name, mouseDownListener.callback), this.listenersService.addListener(`${CompletionsService.EMOTE_ROW_MOUSEDOWN_LISTENER}${index}`, mouseDownListener), 
            autocompleteInnerDiv.append(emoteRow);
            const emoteSelector = document.createElement("div");
            this.htmlService.addClasses(emoteSelector, discordClasses.Autocomplete.base), emoteRow.append(emoteSelector), 
            index + firstIndex === selectedIndex && emoteRow.setAttribute("aria-selected", "true");
            const emoteContainer = document.createElement("div");
            if (this.htmlService.addClasses(emoteContainer, discordClasses.Autocomplete.autocompleteRowContent), 
            emoteSelector.append(emoteContainer), isEmote) {
                const containerIcon = document.createElement("div");
                this.htmlService.addClasses(containerIcon, discordClasses.Autocomplete.autocompleteRowIcon), 
                emoteContainer.append(containerIcon);
                const settingsAutocompleteEmoteSize = this.settingsService.settings.autocompleteEmoteSize, containerImage = document.createElement("img");
                containerImage.alt = name, containerImage.title = name, containerImage.style.minWidth = `${Math.round(settingsAutocompleteEmoteSize)}px`, 
                containerImage.style.minHeight = `${Math.round(settingsAutocompleteEmoteSize)}px`, 
                containerImage.style.width = `${Math.round(settingsAutocompleteEmoteSize)}px`, containerImage.style.height = `${Math.round(settingsAutocompleteEmoteSize)}px`, 
                this.htmlService.addClasses(containerImage, discordClasses.Autocomplete.emojiImage), 
                containerIcon.append(containerImage), "string" == typeof data && loadImagePromise(data, !1, containerImage).catch(console.error);
            }
            const containerContent = document.createElement("div");
            if (containerContent.style.color = "var(--interactive-active)", this.htmlService.addClasses(containerContent, discordClasses.Autocomplete.autocompleteRowContentPrimary), 
            emoteContainer.append(containerContent), isEmote || "string" == typeof data) containerContent.textContent = name; else {
                containerContent.style.display = "flex", containerContent.style.flexDirection = "column";
                const containerContentName = document.createElement("span");
                containerContentName.style.paddingBottom = "0.5em", containerContentName.textContent = name, 
                containerContent.append(containerContentName);
                const containerContentInfo = document.createElement("span");
                containerContentInfo.style.color = "var(--interactive-normal)", containerContentInfo.textContent = data.info, 
                containerContent.append(containerContentInfo);
            }
        }
    }), 250);
    scrollCompletions(e, options) {
        const delta = Math.sign(e.deltaY);
        this.scrollWindow(delta, options);
    }
    scrollWindow(delta, {locked = !1, clamped = !1} = {}) {
        if (!this.cached) return;
        const {completions, selectedIndex: prevSel, windowOffset} = this.cached, autocompleteItems = Math.round(this.settingsService.settings.autocompleteItems);
        if (!completions) return;
        const num = completions.length;
        let sel = (prevSel ?? 0) + delta;
        sel = clamped ? _.clamp(sel, 0, num - 1) : sel % num + (sel < 0 ? num : 0), this.cached.selectedIndex = sel;
        const boundLower = _.clamp(sel + 2 - (autocompleteItems - 1), 0, num - autocompleteItems), boundUpper = _.clamp(sel - 2, 0, num - autocompleteItems);
        this.cached.windowOffset = _.clamp((windowOffset ?? 0) + (locked ? delta : 0), boundLower, boundUpper), 
        this.renderCompletions(), this.renderCompletions.flush();
    }
    stop() {
        this.draft = "", this.cached = void 0;
    }
}

class EmoteService extends BaseService {
    listenersService;
    settingsService;
    htmlService;
    emoteNames;
    modifiers=[];
    start(listenersService, settingsService, htmlService) {
        return this.listenersService = listenersService, this.settingsService = settingsService, 
        this.htmlService = htmlService, this.initEmotes(), Promise.resolve();
    }
    initEmotes() {
        Promise.all([ this.getEmoteNames(), this.getModifiers() ]).then((([emoteNames, modifiers]) => {
            this.setEmoteNames(emoteNames), this.modifiers = modifiers, this.htmlService.getTextAreaField() && this.listenersService.requestAddListeners(CompletionsService.TAG);
        })).catch((error => {
            Logger.warn("Failed to get emote names and/or modifiers", error);
        }));
    }
    refreshEmotes() {
        this.emoteNames = void 0, BdApi.showToast("Reloading emote database...", {
            type: "info"
        }), this.getEmoteNames().then((names => {
            this.setEmoteNames(names), BdApi.showToast("Emote database reloaded!", {
                type: "success"
            });
        })).catch((error => {
            Logger.warn("Failed to get emote names", error);
        }));
    }
    async getEmoteNames() {
        if (!this.settingsService.settings.showStandardEmotes) return {};
        const data = await urlGetBuffer("https://raw.githubusercontent.com/Yentis/yentis.github.io/master/emotes/emotes.json"), emoteNames = JSON.parse(data.toString());
        return Object.keys(emoteNames).forEach((key => {
            const split = emoteNames[key]?.split("."), [name, extension] = split ?? [];
            delete emoteNames[key], void 0 !== name && void 0 !== extension && (emoteNames[name] = `https://raw.githubusercontent.com/Yentis/yentis.github.io/master/emotes/images/${key}.${extension}`);
        })), emoteNames;
    }
    setEmoteNames(emoteNames) {
        const customEmotes = {};
        Object.entries(this.settingsService.settings.customEmotes).forEach((([name, url]) => {
            customEmotes[this.getPrefixedName(name)] = url;
        }));
        const standardNames = {};
        Object.entries(emoteNames).forEach((([name, url]) => {
            const prefixedName = this.getPrefixedName(name);
            standardNames[prefixedName] = url;
        })), this.emoteNames = {
            ...standardNames,
            ...customEmotes
        };
    }
    async getModifiers() {
        const data = await urlGetBuffer("https://raw.githubusercontent.com/Yentis/betterdiscord-emotereplacer/master/modifiers.json");
        return JSON.parse(data.toString());
    }
    getPrefixedName(name) {
        const settingsPrefix = this.settingsService.settings.prefix;
        return name.toLowerCase().startsWith(settingsPrefix) && (name = name.replace(settingsPrefix, "")), 
        `${settingsPrefix}${name}`;
    }
    shouldCompleteEmote(input) {
        const prefix = this.settingsService.settings.requirePrefix ? this.escapeRegExp(this.settingsService.settings.prefix) : "";
        return new RegExp("(?:^|\\s)" + prefix + "\\w{2,}$").test(input);
    }
    shouldCompleteCommand(input) {
        return this.getRegexCommand().test(input);
    }
    escapeRegExp(input) {
        return input.replace(/[-\\/\\^$*+?.()|[\]{}]/g, "\\$&");
    }
    getRegexCommand() {
        const prefix = this.settingsService.settings.requirePrefix ? this.escapeRegExp(this.settingsService.settings.prefix) : "";
        return new RegExp("((?<!\\/)(?:" + prefix + "|<)[\\w:>]*\\.)([\\w\\.-]*)$");
    }
    getCompletionsEmote(text) {
        const settingsPrefix = this.settingsService.settings.prefix, prefix = this.settingsService.settings.requirePrefix ? this.escapeRegExp(settingsPrefix) : "", match = text.match(new RegExp("(^|\\s)(" + prefix + "\\w{2,})$"));
        if (null === match) return {
            completions: [],
            matchText: void 0,
            matchStart: -1
        };
        const emoteArray = [];
        Object.entries(this.emoteNames ?? {}).forEach((([key, value]) => {
            emoteArray.push({
                name: key,
                data: value
            });
        }));
        const matchText = (match[2] ?? "").toLowerCase(), completions = emoteArray.filter((emote => {
            const matchWithoutPrefix = matchText.startsWith(settingsPrefix) ? matchText.replace(settingsPrefix, "") : matchText;
            return -1 !== emote.name.toLowerCase().search(matchWithoutPrefix) && emote;
        })), matchStart = (match.index ?? 0) + (match[1] ?? "").length;
        return {
            completions,
            matchText,
            matchStart
        };
    }
    getCompletionsCommands(text) {
        const regex = this.getRegexCommand(), match = text.match(regex);
        if (null === match) return {
            completions: [],
            matchText: void 0,
            matchStart: -1
        };
        const commandPart = match[2]?.substring(match[2].lastIndexOf(".") + 1) ?? "", commandArray = [];
        return this.modifiers.forEach((modifier => {
            commandArray.push({
                name: modifier.name,
                data: modifier
            });
        })), {
            completions: commandArray.filter((command => "" === commandPart || -1 !== command.name.toLowerCase().search(commandPart))),
            matchText: commandPart,
            matchStart: (match.index ?? 0) + (match[0] ?? "").length
        };
    }
    stop() {
        this.emoteNames = void 0, this.modifiers = [];
    }
}

class AttachService extends BaseService {
    modulesService;
    canAttach=!1;
    externalEmotes=new Set;
    pendingUpload;
    pendingReply;
    onMessagesLoaded;
    onChannelSelect;
    async start(modulesService) {
        this.modulesService = modulesService;
        const userId = await this.getUserId();
        this.initChannelSubscription(userId);
    }
    getUserId() {
        return new Promise((resolve => {
            const getCurrentUser = this.modulesService.userStore.getCurrentUser;
            let user = getCurrentUser();
            if (user) {
                const userId = user.id;
                return this.setCanAttach(this.modulesService.selectedChannelStore.getChannelId(), userId), 
                void resolve(userId);
            }
            this.onMessagesLoaded = data => {
                user = getCurrentUser();
                const userId = user?.id ?? "";
                this.onMessagesLoaded && (this.modulesService.dispatcher.unsubscribe("LOAD_MESSAGES_SUCCESS", this.onMessagesLoaded), 
                this.onMessagesLoaded = void 0), userId && (this.setCanAttach(data.channelId, userId), 
                resolve(userId));
            }, this.modulesService.dispatcher.subscribe("LOAD_MESSAGES_SUCCESS", this.onMessagesLoaded);
        }));
    }
    setCanAttach(_channelId, userId) {
        this.externalEmotes.clear();
        const channelId = _channelId ?? "";
        if (!channelId) return void (this.canAttach = !0);
        const channel = this.modulesService.channelStore.getChannel(channelId);
        if (!channel) return void (this.canAttach = !0);
        if (!channel.guild_id) return void (this.canAttach = !0);
        const permissions = this.modulesService.discordPermissions;
        this.canAttach = this.modulesService.permissions.can(permissions.ATTACH_FILES, channel, userId);
    }
    initChannelSubscription(userId) {
        this.onChannelSelect = data => {
            this.setCanAttach(data.channelId, userId);
        }, this.modulesService.dispatcher.subscribe("CHANNEL_SELECT", this.onChannelSelect);
    }
    stop() {
        this.onMessagesLoaded && (this.modulesService.dispatcher.unsubscribe("LOAD_MESSAGES_SUCCESS", this.onMessagesLoaded), 
        this.onMessagesLoaded = void 0), this.onChannelSelect && (this.modulesService.dispatcher.unsubscribe("CHANNEL_SELECT", this.onChannelSelect), 
        this.onChannelSelect = void 0), this.canAttach = !1, this.pendingUpload = void 0;
    }
}

class SettingsService extends BaseService {
    static ADD_BUTTON_CLICK_LISTENER="addButtonClick";
    static REFRESH_BUTTON_CLICK_LISTENER="refreshButtonClick";
    static DELETE_BUTTON_CLICK_LISTENER="deleteButtonClick";
    listenersService;
    settings=DEFAULT_SETTINGS;
    start(listenersService) {
        this.listenersService = listenersService;
        const savedSettings = BdApi.loadData(this.plugin.meta.name, "settings");
        return this.settings = Object.assign({}, DEFAULT_SETTINGS, savedSettings), Promise.resolve();
    }
    getSettingsElement() {
        const emoteService = this.plugin.emoteService;
        if (!emoteService) return new HTMLElement;
        const Settings = this.zeresPluginLibrary.Settings, settings = [];
        this.pushRegularSettings(settings, emoteService);
        const emoteFolderPicker = document.createElement("input");
        let emoteName;
        emoteFolderPicker.type = "file", emoteFolderPicker.multiple = !0, emoteFolderPicker.accept = ".png,.gif";
        const emoteNameTextbox = new Settings.Textbox(void 0, "Emote name", void 0, (val => {
            emoteName = val;
        }));
        let imageUrl;
        const imageUrlTextbox = new Settings.Textbox(void 0, "Image URL (must end with .gif or .png, 128px recommended)", void 0, (val => {
            imageUrl = val;
        })), addButton = document.createElement("button");
        addButton.type = "button", addButton.classList.add("bd-button"), addButton.textContent = "Add";
        const addSettingField = new Settings.SettingField(void 0, void 0, void 0, addButton), customEmotesContainer = document.createElement("div"), addListener = {
            element: addButton,
            name: "click",
            callback: () => {
                const files = emoteFolderPicker.files ?? [], addPromises = (files.length > 0 ? Array.from(files).map((file => {
                    const fileName = file.name.substring(0, file.name.lastIndexOf("."));
                    return this.addEmote(fileName, file.path);
                })) : [ this.addEmote(emoteName, imageUrl) ]).map((async promise => {
                    const emoteName = await promise;
                    customEmotesContainer.append(this.createCustomEmoteContainer(emoteName, customEmotesContainer, emoteService));
                }));
                Promise.allSettled(addPromises).then((results => {
                    const errors = [];
                    results.forEach((result => {
                        "fulfilled" !== result.status && (errors.push(result.reason), console.error(result.reason));
                    }));
                    const firstError = errors[0];
                    if (firstError && (BdApi.showToast(`${firstError.message}${errors.length > 1 ? "\nSee console for all errors" : ""}`, {
                        type: "error"
                    }), 1 === addPromises.length)) return;
                    emoteFolderPicker.value = "";
                    const emoteNameTextboxInput = emoteNameTextbox.getElement().querySelector("input");
                    emoteNameTextboxInput && (emoteNameTextboxInput.value = "");
                    const imageUrlTextboxInput = imageUrlTextbox.getElement().querySelector("input");
                    imageUrlTextboxInput && (imageUrlTextboxInput.value = ""), BdApi.saveData(this.plugin.meta.name, "settings", this.settings), 
                    BdApi.showToast("Emote(s) have been saved", {
                        type: "success"
                    });
                })).catch((error => {
                    BdApi.showToast(error.message, {
                        type: "error"
                    });
                }));
            }
        };
        addButton.addEventListener(addListener.name, addListener.callback), this.listenersService.addListener(SettingsService.ADD_BUTTON_CLICK_LISTENER, addListener), 
        Object.keys(this.settings.customEmotes).forEach((key => {
            customEmotesContainer.append(this.createCustomEmoteContainer(key, customEmotesContainer, emoteService));
        }));
        const customEmoteGroup = new Settings.SettingGroup("Custom emotes");
        customEmoteGroup.append(emoteFolderPicker, emoteNameTextbox, imageUrlTextbox, addSettingField, customEmotesContainer), 
        settings.push(customEmoteGroup);
        const refreshButton = document.createElement("button");
        refreshButton.type = "button", refreshButton.classList.add("bd-button"), refreshButton.textContent = "Refresh emote list";
        const refreshSettingField = new Settings.SettingField(void 0, void 0, void 0, refreshButton), refreshListener = {
            element: refreshButton,
            name: "click",
            callback: () => {
                emoteService.refreshEmotes();
            }
        };
        return refreshButton.addEventListener(refreshListener.name, refreshListener.callback), 
        this.listenersService.addListener(SettingsService.REFRESH_BUTTON_CLICK_LISTENER, refreshListener), 
        settings.push(refreshSettingField), Settings.SettingPanel.build((() => {
            BdApi.saveData(this.plugin.meta.name, "settings", this.settings);
        }), ...settings);
    }
    async addEmote(emoteName, imageUrl) {
        if (!emoteName) throw new Error("No emote name entered!");
        if (!imageUrl) throw new Error("No image URL entered!");
        if (!imageUrl.endsWith(".gif") && !imageUrl.endsWith(".png")) throw new Error("Image URL must end with .gif or .png!");
        const emoteService = this.plugin.emoteService;
        if (!emoteService) throw new Error("Emote service not found");
        const emoteNames = emoteService.emoteNames ?? {};
        if (emoteNames[emoteService.getPrefixedName(emoteName)]) throw new Error("Emote name already exists!");
        return this.settings.customEmotes[emoteName] = imageUrl, emoteNames[emoteService.getPrefixedName(emoteName)] = imageUrl, 
        emoteService.emoteNames = emoteNames, await Promise.resolve(emoteName);
    }
    pushRegularSettings(settings, emoteService) {
        const Settings = this.zeresPluginLibrary.Settings;
        settings.push(new Settings.Slider("Emote Size", "The size of emotes. (default 48)", 32, 128, this.settings.emoteSize, (val => {
            this.settings.emoteSize = Math.round(val);
        }), {
            units: "px",
            markers: [ 32, 48, 64, 96, 128 ]
        })), settings.push(new Settings.Slider("Autocomplete Emote Size", "The size of emotes in the autocomplete window. (default 15)", 15, 64, this.settings.autocompleteEmoteSize, (val => {
            this.settings.autocompleteEmoteSize = Math.round(val);
        }), {
            units: "px",
            markers: [ 15, 32, 48, 64 ]
        })), settings.push(new Settings.Slider("Autocomplete Items", "The amount of emotes shown in the autocomplete window. (default 10)", 1, 25, this.settings.autocompleteItems, (val => {
            this.settings.autocompleteItems = Math.round(val);
        }), {
            units: " items",
            markers: [ 1, 5, 10, 15, 20, 25 ]
        })), settings.push(new Settings.Switch("Require prefix", "If this is enabled, the autocomplete list will not be shown unless the prefix is also typed.", this.settings.requirePrefix, (checked => {
            this.settings.requirePrefix = checked;
        }))), settings.push(new Settings.Switch("Show standard custom emotes", "If this is enabled, the standard custom emotes will be visible.", this.settings.showStandardEmotes, (checked => {
            this.settings.showStandardEmotes = checked, emoteService.refreshEmotes();
        }))), settings.push(new Settings.Textbox("Prefix", "The prefix to check against for the above setting. It is recommended to use a single character not in use by other chat functionality, other prefixes may cause issues.", this.settings.prefix, _.debounce((val => {
            if (val === this.settings.prefix) return;
            const previousPrefix = this.settings.prefix;
            this.settings.prefix = val, BdApi.saveData(this.plugin.meta.name, "settings", this.settings);
            const previousEmoteNames = Object.assign({}, emoteService.emoteNames), emoteNames = {};
            Object.entries(previousEmoteNames).forEach((([name, value]) => {
                const prefixedName = emoteService.getPrefixedName(name.replace(previousPrefix, ""));
                emoteNames[prefixedName] = value;
            })), emoteService.emoteNames = emoteNames;
        }), 2000))), settings.push(new Settings.RadioGroup("Resize Method", "How emotes will be scaled down to fit your selected emote size", this.settings.resizeMethod, [ {
            name: "Scale down smallest side",
            value: "smallest"
        }, {
            name: "Scale down largest side",
            value: "largest"
        } ], (val => {
            this.settings.resizeMethod = val;
        })));
    }
    createCustomEmoteContainer(emoteName, container, emoteService) {
        const Settings = this.zeresPluginLibrary.Settings, customEmoteContainer = document.createElement("div");
        customEmoteContainer.style.display = "flex";
        const url = this.settings.customEmotes[emoteName] ?? "", containerImage = document.createElement("img");
        containerImage.alt = emoteName, containerImage.title = emoteName, containerImage.style.minWidth = `${Math.round(this.settings.autocompleteEmoteSize)}px`, 
        containerImage.style.minHeight = `${Math.round(this.settings.autocompleteEmoteSize)}px`, 
        containerImage.style.width = `${Math.round(this.settings.autocompleteEmoteSize)}px`, 
        containerImage.style.height = `${Math.round(this.settings.autocompleteEmoteSize)}px`, 
        containerImage.style.marginRight = "0.5rem", customEmoteContainer.append(containerImage), 
        loadImagePromise(url, !1, containerImage).catch(console.error);
        const deleteButton = document.createElement("button");
        deleteButton.type = "button", deleteButton.classList.add("bd-button", "bd-button-danger"), 
        deleteButton.innerHTML = '<svg class="" fill="#FFFFFF" viewBox="0 0 24 24" style="width: 20px; height: 20px;"><path fill="none" d="M0 0h24v24H0V0z"></path><path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zm2.46-7.12l1.41-1.41L12 12.59l2.12-2.12 1.41 1.41L13.41 14l2.12 2.12-1.41 1.41L12 15.41l-2.12 2.12-1.41-1.41L10.59 14l-2.13-2.12zM15.5 4l-1-1h-5l-1 1H5v2h14V4z"></path><path fill="none" d="M0 0h24v24H0z"></path></svg>', 
        customEmoteContainer.append(deleteButton);
        const deleteListener = {
            element: deleteButton,
            name: "click",
            callback: () => {
                delete this.settings.customEmotes[emoteName], emoteService.emoteNames && delete emoteService.emoteNames[emoteService.getPrefixedName(emoteName)], 
                BdApi.saveData(this.plugin.meta.name, "settings", this.settings), BdApi.showToast(`Emote ${emoteName} has been deleted!`, {
                    type: "success"
                }), document.getElementById(emoteName)?.remove();
            }
        };
        deleteButton.addEventListener(deleteListener.name, deleteListener.callback), this.listenersService.addListener(`${SettingsService.DELETE_BUTTON_CLICK_LISTENER}${emoteName}`, deleteListener);
        const targetEmote = this.settings.customEmotes[emoteName], existingEmote = new Settings.SettingField(emoteName, targetEmote, void 0, customEmoteContainer, {
            noteOnTop: !0
        });
        return existingEmote.getElement().id = emoteName, existingEmote.getElement();
    }
    stop() {}
}

class ListenersService extends BaseService {
    listeners={};
    addListenersWatchers={};
    start() {
        return Promise.resolve();
    }
    addListener(id, listener) {
        this.listeners[id] && this.removeListener(id), this.listeners[id] = listener;
    }
    removeListener(id) {
        const listener = this.listeners[id];
        if (!listener) return;
        const {element, name, callback} = listener;
        element && element.removeEventListener(name, callback), delete this.listeners[id];
    }
    requestAddListeners(targetId) {
        Object.entries(this.addListenersWatchers).forEach((([id, addListenersWatcher]) => {
            id === targetId && addListenersWatcher.onAddListeners();
        }));
    }
    stop() {
        Object.keys(this.listeners).forEach((id => {
            this.removeListener(id);
        }));
    }
}

let gifsicle = {
    tool: {
        workerLocalUrl: 'var gifsicle=function(){Me="undefined"!=typeof document&&document.currentScript?document.currentScript.src:void 0,"undefined"!=typeof __filename&&(Me=Me||__filename);var Me,c=function(e){var j,r,h=void 0!==(e=e||{})?e:{},t=(h.ready=new Promise(function(e,r){j=e}),h.preRun=h.preRun||[],h.preRun.push(function(){if(h.folder&&h.folder.length)for(let e=0;e<h.folder.length;e++){var r=h.folder[e];T.mkdir(r)}T.mkdir("/tem"),T.mkdir("/out");var t=h.input;for(let e=0;e<t.length;e++){var n=t[e];T.writeFile("/"+n.name,new Uint8Array(n.file))}}),h.postRun=h.postRun||[],h.postRun.push(function(){let r=[],t=T.readdir("/out");t.splice(0,2);for(let e=0;e<t.length;e++){var n=t[e],o=T.readFile("/out/"+n);r.push({file:o,name:n})}h.output(r)}),{});for(r in h)h.hasOwnProperty(r)&&(t[r]=h[r]);var n,o,i,O,a=[],C="./this.program",u=function(e,r){throw r},L=!1,c=!1,L="object"==typeof window,c="function"==typeof importScripts,s="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,I=!L&&!s&&!c,f="";s?(f=c?require("path").dirname(f)+"/":__dirname+"/",n=function(e,r){return i=i||require("fs"),e=(O=O||require("path")).normalize(e),i.readFileSync(e,r?null:"utf8")},o=function(e){e=n(e,!0);return H((e=e.buffer?e:new Uint8Array(e)).buffer),e},1<process.argv.length&&(C=process.argv[1].replace(/\\\\/g,"/")),a=process.argv.slice(2),process.on("uncaughtException",function(e){if(!(e instanceof Fe))throw e}),process.on("unhandledRejection",D),u=function(e){process.exit(e)},h.inspect=function(){return"[Emscripten Module object]"}):I?("undefined"!=typeof read&&(n=function(e){return read(e)}),o=function(e){return"function"==typeof readbuffer?new Uint8Array(readbuffer(e)):(H("object"==typeof(e=read(e,"binary"))),e)},"undefined"!=typeof scriptArgs?a=scriptArgs:void 0!==arguments&&(a=arguments),"function"==typeof quit&&(u=function(e){quit(e)}),"undefined"!=typeof print&&((console="undefined"==typeof console?{}:console).log=print,console.warn=console.error="undefined"!=typeof printErr?printErr:print)):(L||c)&&(c?f=self.location.href:document.currentScript&&(f=document.currentScript.src),f=0!==(f=Me?Me:f).indexOf("blob:")?f.substr(0,f.lastIndexOf("/")+1):"",n=function(e){var r=new XMLHttpRequest;return r.open("GET",e,!1),r.send(null),r.responseText},c&&(o=function(e){var r=new XMLHttpRequest;return r.open("GET",e,!1),r.responseType="arraybuffer",r.send(null),new Uint8Array(r.response)}));var l,d,p,m=h.print||console.log.bind(console),w=h.printErr||console.warn.bind(console);for(r in t)t.hasOwnProperty(r)&&(h[r]=t[r]);t=null,h.arguments&&(a=h.arguments),h.thisProgram&&(C=h.thisProgram),h.quit&&(u=h.quit),h.wasmBinary&&(l=h.wasmBinary),h.noExitRuntime&&(d=h.noExitRuntime),"object"!=typeof WebAssembly&&w("no native wasm support detected");var I=new WebAssembly.Table({initial:64,maximum:64,element:"anyfunc"}),U=!1;function H(e,r){e||D("Assertion failed: "+r)}var q="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0;function g(e,r,t){for(var n=r+t,o=r;e[o]&&!(n<=o);)++o;if(16<o-r&&e.subarray&&q)return q.decode(e.subarray(r,o));for(var i="";r<o;){var a,s,u=e[r++];128&u?(s=63&e[r++],192==(224&u)?i+=String.fromCharCode((31&u)<<6|s):(a=63&e[r++],(u=224==(240&u)?(15&u)<<12|s<<6|a:(7&u)<<18|s<<12|a<<6|63&e[r++])<65536?i+=String.fromCharCode(u):(s=u-65536,i+=String.fromCharCode(55296|s>>10,56320|1023&s)))):i+=String.fromCharCode(u)}return i}function W(e,r){return e?g(E,e,r):""}function X(e,r,t,n){if(!(0<n))return 0;for(var o=t,i=t+n-1,a=0;a<e.length;++a){var s=e.charCodeAt(a);if((s=55296<=s&&s<=57343?65536+((1023&s)<<10)|1023&e.charCodeAt(++a):s)<=127){if(i<=t)break;r[t++]=s}else if(s<=2047){if(i<=t+1)break;r[t++]=192|s>>6,r[t++]=128|63&s}else if(s<=65535){if(i<=t+2)break;r[t++]=224|s>>12,r[t++]=128|s>>6&63,r[t++]=128|63&s}else{if(i<=t+3)break;r[t++]=240|s>>18,r[t++]=128|s>>12&63,r[t++]=128|s>>6&63,r[t++]=128|63&s}}return r[t]=0,t-o}function G(e){for(var r=0,t=0;t<e.length;++t){var n=e.charCodeAt(t);(n=55296<=n&&n<=57343?65536+((1023&n)<<10)|1023&e.charCodeAt(++t):n)<=127?++r:r+=n<=2047?2:n<=65535?3:4}return r}function V(e){var r=G(e)+1,t=Se(r);return X(e,y,t,r),t}var v,y,E,K,k;function Y(e){v=e,h.HEAP8=y=new Int8Array(e),h.HEAP16=K=new Int16Array(e),h.HEAP32=k=new Int32Array(e),h.HEAPU8=E=new Uint8Array(e),h.HEAPU16=new Uint16Array(e),h.HEAPU32=new Uint32Array(e),h.HEAPF32=new Float32Array(e),h.HEAPF64=new Float64Array(e)}f=h.INITIAL_MEMORY||16777216;function Z(e){for(;0<e.length;){var r,t=e.shift();"function"==typeof t?t(h):"number"==typeof(r=t.func)?void 0===t.arg?h.dynCall_v(r):h.dynCall_vi(r,t.arg):r(void 0===t.arg?null:t.arg)}}p=h.wasmMemory||new WebAssembly.Memory({initial:f/65536,maximum:32768}),f=(v=p?p.buffer:v).byteLength,Y(v),k[9776]=5282144;var $=[],J=[],Q=[],ee=[];function re(){if(h.preRun)for("function"==typeof h.preRun&&(h.preRun=[h.preRun]);h.preRun.length;)e=h.preRun.shift(),$.unshift(e);var e;Z($)}function te(){if(h.postRun)for("function"==typeof h.postRun&&(h.postRun=[h.postRun]);h.postRun.length;)e=h.postRun.shift(),ee.unshift(e);var e;Z(ee)}var ne=Math.abs,oe=Math.ceil,ie=Math.floor,ae=Math.min,_=0,b=null;function se(){_++,h.monitorRunDependencies&&h.monitorRunDependencies(_)}function ue(){var e;_--,h.monitorRunDependencies&&h.monitorRunDependencies(_),0==_&&b&&(e=b,b=null,e())}function D(e){throw h.onAbort&&h.onAbort(e),m(e+=""),w(e),U=!0,e="abort("+e+"). Build with -s ASSERTIONS=1 for more info.",new WebAssembly.RuntimeError(e)}function ce(e,r){return String.prototype.startsWith?e.startsWith(r):0===e.indexOf(r)}h.preloadedImages={},h.preloadedAudios={};var fe="data:application/octet-stream;base64,";var le="file://";function de(e){return ce(e,le)}var S,F,P="data:application/wasm;base64,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ACABOgABIANBfWogAToAACAAIAE6AAIgAkEHSQ0AIANBfGogAToAACAAIAE6AAMgAkEJSQ0AIABBACAAa0EDcSIEaiIDIAFB/wFxQYGChAhsIgE2AgAgAyACIARrQXxxIgRqIgJBfGogATYCACAEQQlJDQAgAyABNgIIIAMgATYCBCACQXhqIAE2AgAgAkF0aiABNgIAIARBGUkNACADIAE2AhggAyABNgIUIAMgATYCECADIAE2AgwgAkFwaiABNgIAIAJBbGogATYCACACQWhqIAE2AgAgAkFkaiABNgIAIAQgA0EEcUEYciIEayICQSBJDQAgAa0iBUIghiAFhCEFIAMgBGohAQNAIAEgBTcDGCABIAU3AxAgASAFNwMIIAEgBTcDACABQSBqIQEgAkFgaiICQR9LDQALCyAAC5ABAQN/IAAhAQJAAkAgAEEDcUUNACAALQAARQRAQQAPCwNAIAFBAWoiAUEDcUUNASABLQAADQALDAELA0AgASICQQRqIQEgAigCACIDQX9zIANB//37d2pxQYCBgoR4cUUNAAsgA0H/AXFFBEAgAiAAaw8LA0AgAi0AASEDIAJBAWoiASECIAMNAAsLIAEgAGsLSgECfwJAIAAtAAAiAkUgAiABLQAAIgNHcg0AA0AgAS0AASEDIAAtAAEiAkUNASABQQFqIQEgAEEBaiEAIAIgA0YNAAsLIAIgA2sLoggBC38gAEUEQCABEBoPCyABQUBPBEBB3JwCQTA2AgBBAA8LIABBfGoiBygCACIIQXhxIQIgCEEDcSIDQQFGQeCtAigCACILIABBeGoiBktyGkEQIAFBC2pBeHEgAUELSRshBAJAAkAgA0UEQCAEQYACSSACIARBBHJJcg0BIAIgBGtBsLECKAIAQQF0TQ0CDAELIAIgBmohBSACIARPBEAgAiAEayIBQRBJDQIgByAIQQFxIARyQQJyNgIAIAQgBmoiAiABQQNyNgIEIAUgBSgCBEEBcjYCBCACIAEQpQEgAA8LIAVB6K0CKAIARgRAQdytAigCACACaiICIARNDQEgByAIQQFxIARyQQJyNgIAIAQgBmoiASACIARrIgJBAXI2AgRB3K0CIAI2AgBB6K0CIAE2AgAgAA8LIAVB5K0CKAIARgRAQditAigCACACaiICIARJDQECQCACIARrIgFBEE8EQCAHIAhBAXEgBHJBAnI2AgAgBCAGaiIDIAFBAXI2AgQgAiAGaiICIAE2AgAgAiACKAIEQX5xNgIEDAELIAcgCEEBcSACckECcjYCACACIAZqIgEgASgCBEEBcjYCBEEAIQFBACEDC0HkrQIgAzYCAEHYrQIgATYCACAADwsgBSgCBCIDQQJxDQAgA0F4cSACaiIJIARJDQAgCSAEayEMAkAgA0H/AU0EQCAFKAIIIgIgA0EDdiIDQQN0QfitAmpHGiACIAUoAgwiAUYEQEHQrQJB0K0CKAIAQX4gA3dxNgIADAILIAIgATYCDCABIAI2AggMAQsgBSgCGCEKAkAgBSAFKAIMIgJHBEAgCyAFKAIIIgFNBEAgASgCDBoLIAEgAjYCDCACIAE2AggMAQsCQCAFQRRqIgEoAgAiAw0AIAVBEGoiASgCACIDDQBBACECDAELA0AgASELIAMiAkEUaiIBKAIAIgMNACACQRBqIQEgAigCECIDDQALIAtBADYCAAsgCkUNAAJAIAUgBSgCHCIBQQJ0QYCwAmoiAygCAEYEQCADIAI2AgAgAg0BQdStAkHUrQIoAgBBfiABd3E2AgAMAgsgCkEQQRQgCigCECAFRhtqIAI2AgAgAkUNAQsgAiAKNgIYIAUoAhAiAQRAIAIgATYCECABIAI2AhgLIAUoAhQiAUUNACACIAE2AhQgASACNgIYCyAMQQ9NBEAgByAIQQFxIAlyQQJyNgIAIAYgCWoiASABKAIEQQFyNgIEIAAPCyAHIAhBAXEgBHJBAnI2AgAgBCAGaiIBIAxBA3I2AgQgBiAJaiICIAIoAgRBAXI2AgQgASAMEKUBIAAPCyABEBoiAkUEQEEADwsgAiAAQXxBeCAHKAIAIgNBA3EbIANBeHFqIgMgASADIAFJGxAYGiAAEBYgAiEACyAAC8EBAgN/AX4CQAJAIAApA3AiBFBFBEAgACkDeCAEWQ0BCyAAEGsiAkF/Sg0BCyAAQQA2AmhBfw8LIAAoAgghAQJAAkAgACkDcCIEUA0AIAQgACkDeEJ/hXwiBCABIAAoAgQiA2usWQ0AIAAgAyAEp2o2AmgMAQsgACABNgJoCwJAIAFFBEAgACgCBCEADAELIAAgACkDeCABIAAoAgQiAGtBAWqsfDcDeAsgAEF/aiIALQAAIAJHBEAgACACOgAACyACC5gLAgV/D34jAEHgAGsiBSQAIAJCIIYgAUIgiIQhDyAEQi+GIANCEYiEIQ0gBEL///////8/gyIOQg+GIANCMYiEIRAgAiAEhUKAgICAgICAgIB/gyEKIAJC////////P4MiC0IgiCERIA5CEYghEiAEQjCIp0H//wFxIQcCQAJ/IAJCMIinQf//AXEiCUF/akH9/wFNBEBBACAHQX9qQf7/AUkNARoLIAFQIAJC////////////AIMiDEKAgICAgIDA//8AVCAMQoCAgICAgMD//wBRG0UEQCACQoCAgICAgCCEIQoMAgsgA1AgBEL///////////8AgyICQoCAgICAgMD//wBUIAJCgICAgICAwP//AFEbRQRAIARCgICAgICAIIQhCiADIQEMAgsgASAMQoCAgICAgMD//wCFhFAEQCACIAOEUARAQoCAgICAgOD//wAhCkIAIQEMAwsgCkKAgICAgIDA//8AhCEKQgAhAQwCCyADIAJCgICAgICAwP//AIWEUARAIAEgDIQhAkIAIQEgAlAEQEKAgICAgIDg//8AIQoMAwsgCkKAgICAgIDA//8AhCEKDAILIAEgDIRQBEBCACEBDAILIAIgA4RQBEBCACEBDAILIAxC////////P1gEQCAFQdAAaiABIAsgASALIAtQIgYbeSAGQQZ0rXynIgZBcWoQKCAFKQNYIgtCIIYgBSkDUCIBQiCIhCEPIAtCIIghEUEQIAZrIQYLIAYgAkL///////8/Vg0AGiAFQUBrIAMgDiADIA4gDlAiCBt5IAhBBnStfKciCEFxahAoIAUpA0giAkIPhiAFKQNAIgNCMYiEIRAgAkIvhiADQhGIhCENIAJCEYghEiAGIAhrQRBqCyEGIA1C/////w+DIgIgAUL/////D4MiAX4iEyADQg+GQoCA/v8PgyIDIA9C/////w+DIgx+fCIEQiCGIg4gASADfnwiDSAOVK0gAiAMfiIVIAMgC0L/////D4MiC358IhQgEEL/////D4MiDiABfnwiECAEIBNUrUIghiAEQiCIhHwiEyACIAt+IhYgAyARQoCABIQiD358IgMgDCAOfnwiESABIBJC/////weDQoCAgIAIhCIBfnwiEkIghnwiF3whBCAHIAlqIAZqQYGAf2ohBgJAIAsgDn4iGCACIA9+fCICIBhUrSACIAEgDH58Igwg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AAsLAkACQCAAIAhHBEAgBigCECIFIABBBHRqIgcoAgAgAUYNAQsCQEEAIAggCEEHcRtFBEAgBigCECEFDAELIAYoAhAgCEEEdEGAAWoQHiIFRQ0DIAYgBTYCECAGKAIUIQgLIAUgAEEEdCIJaiIHQRBqIAcgCCAAa0EEdBDCASAGIAYoAhRBAWo2AhQgBigCECIFIAlqQQA2AgQMAQsgBygCBEEFRw0AIAUgAEEEdGooAgwiBygCABAWIAcoAgQQFiAHEBYgBigCECEFCyAFIABBBHRqIgAgBDYCDCAAIAI2AgggACADNgIEIAAgATYCAEEAIQoLIAoLaQEBfyMAQYACayIFJAAgBEGAwARxIAIgA0xyRQRAIAUgASACIANrIgJBgAIgAkGAAkkiARsQGxogAUUEQANAIAAgBUGAAhAnIAJBgH5qIgJB/wFLDQALCyAAIAUgAhAnCyAFQYACaiQAC2gBAX8gAEEASCABQQFIckVBAEEAQRRBARAXIgIbRQRAIAIQFkEADwsgAiAANgIAIAIgACABIAAgAUobIgA2AgQgAkEAQQggABAXIgE2AhAgAkIANwIIIAIhACABBH8gAAUgABAWQQALCyUBAX8jAEEQayICJAAgAiABNgIMQQBBAEEDIAAgARBdQQEQAgALwQkCBH8EfiMAQfAAayIFJAAgBEL///////////8AgyEKAkACQCABQn98IgtCf1EgAkL///////////8AgyIJIAsgAVStfEJ/fCILQv///////7///wBWIAtC////////v///AFEbRQRAIANCf3wiC0J/UiAKIAsgA1StfEJ/fCILQv///////7///wBUIAtC////////v///AFEbDQELIAFQIAlCgICAgICAwP//AFQgCUKAgICAgIDA//8AURtFBEAgAkKAgICAgIAghCEEIAEhAwwCCyADUCAKQoCAgICAgMD//wBUIApCgICAgICAwP//AFEbRQRAIARCgICAgICAIIQhBAwCCyABIAlCgICAgICAwP//AIWEUARAQoCAgICAgOD//wAgAiABIAOFIAIgBIVCgICAgICAgICAf4WEUCIGGyEEQgAgASAGGyEDDAILIAMgCkKAgICAgIDA//8AhYRQDQEgASAJhFAEQCADIAqEQgBSDQIgASADgyEDIAIgBIMhBAwCCyADIAqEUEUN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BiAEIAFBAnRqKAIARQ0AC0F/QQEgAEEJSRshBwwFCwsgAEEgIAogByAMayIOIAsgCyAOSBsiE2oiByAPIA8gB0gbIgEgByAJECsgACAQIAoQJyAAQTAgASAHIAlBgIAEcxArIABBMCATIA5BABArIAAgDCAOECcgAEEgIAEgByAJQYDAAHMQKwwBCwtBACEHDAELQX8hBwsgCEHQAGokACAHC20BAn9BAEHMAEEBEBciAAR/IABCADcCACAAQgA3AhggAEEANgI8IABB//8DOwEUIABBADYCSCAAQgA3AkAgAEEGNgIoIABCADcCICAAQgA3AiwgAEIANwIIIABBADYCECAAQgA3AjQgAAVBAAsLEAAgACABIAJBAEEAELoBGgt8AQJ/IAAgAC0ASiIBQX9qIAFyOgBKIAAoAhQgACgCHEsEQCAAQQBBACAAKAIkEQMAGgsgAEEANgIcIABCADcDECAAKAIAIgFBBHEEQCAAIAFBIHI2AgBBfw8LIAAgACgCLCAAKAIwaiICNgIIIAAgAjYCBCABQRt0QR91C2kBAn8CQCAAKAIUIAAoAhxNDQAgAEEAQQAgACgCJBEDABogACgCFA0AQX8PCyAAKAIEIgEgACgCCCICSQRAIAAgASACa6xBASAAKAIoEQ8AGgsgAEEANgIcIABCADcDECAAQgA3AgRBAAtAAQF/IwBBEGsiBSQAIAUgASACIAMgBEKAgICAgICAgIB/hRAuIAAgBSkDADcDACAAIAUpAwg3AwggBUEQaiQACykBAX8jAEEQayICJAAgAiABNgIMQYjoASgCACAAIAEQhQEgAkEQaiQAC7cBAQR/AkAgAigCECIDBH8gAwUgAhDBAQ0BIAIoAhALIAIoAhQiBWsgAUkEQCACIAAgASACKAIkEQMADwsCQCACLABLQQBIDQAgASEEA0AgBCIDRQ0BIAAgA0F/aiIEai0AAEEKRw0ACyACIAAgAyACKAIkEQMAIgQgA0kNASABIANrIQEgACADaiEAIAIoAhQhBSADIQYLIAUgACABEBgaIAIgAigCFCABajYCFCABIAZqIQQLIAQLgwEBA38jAEEQayICJAAgAiABOgAPAkAgACgCECIDRQRAIAAQwQENASAAKAIQIQMLAkAgACgCFCIEIANPDQAgACwASyABQf8BcUYNACAAIARBAWo2AhQg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IAAgBiAEoKKhDwsgAUEDdCIBQcCIAmorAwAgACAGIASgoiABQeCIAmorAwChIAChoSIAmiAAIANCAFMbIQALIAAPCyAARBgtRFT7Ifk/IACmIANC////////////AINCgICAgICAgPj/AFYbC5IBAQN8RAAAAAAAAPA/IAAgAKIiAkQAAAAAAADgP6IiA6EiBEQAAAAAAADwPyAEoSADoSACIAIgAiACRJAVyxmgAfo+okR3UcEWbMFWv6CiRExVVVVVVaU/oKIgAiACoiIDIAOiIAIgAkTUOIi+6fqovaJExLG0vZ7uIT6gokStUpyAT36SvqCioKIgACABoqGgoAtGAQF/IwBBIGsiASQAAn8gACABQQhqEBEiAEUEQEE7IQBBASABLQAIQQJGDQEaC0HcnAIgADYCAEEACyEAIAFBIGokACAAC+EBAQN/IwBBIGsiBEIANwMYIARCADcDECAEQgA3AwggBEIANwMAIAEtAAAiAkUEQEEADwsgAS0AAUUEQCAAIQEDQCABIgNBAWohASADLQAAIAJGDQALIAMgAGsPCwNAIAQgAkEDdkEccWoiAyADKAIAQQEgAkEfcXRyNgIAIAEtAAEhAiABQQFqIQEgAg0ACyAAIQMCQCAALQAAIgJFDQAgACEBA0AgBCACQQN2QRxxaigCACACQR9xdkEBcUUEQCABIQMMAgsgAS0AASECIAFBAWoiAyEBIAINAAsLIAMgAGsLewECfwJAIAAoAgQiAyAAKAIIIgJIBEAgACgCACECDAELIAAgAkEBdEECIAIbIgM2AgggACAAKAIAQQQgAxAXIgI2AgAgAkUEQEEADwsgACgCBCEDCyACIANBAnRqIAE2AgAgACADQQFqNgIEIAEgASgCSEEBajYCSEEBCw4AIAAgABAcQQFqEJICCwkAIAAgARCTAgt7AQF/IwBBkAFrIgQkACAEIAA2AiwgBCAANgIEIARBADYCACAEQX82AkwgBEF/IABB/////wdqIABBAEgbNgIIIARCABA0IAQgAkEBIAMQtwEhAyABBEAgASAAIAQoAgQgBCgCeGogBCgCCGtqNgIACyAEQZABaiQAIAMLpQEBBX8jAEGAAmsiBCQAAkAgAkECSA0AIAEgAkECdGoiByAENgIAIABFDQAgBCEDA0AgAyABKAIAIABBgAIgAEGAAkkbIgUQ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AAsMAgsgAkEDTQ0AA0AgACABKAIANgIAIAFBBGohASAAQQRqIQAgAkF8aiICQQNLDQALCyACRQ0AA0AgACABLQAAOgAAIABBAWohACABQQFqIQEgAkF/aiICDQALCwuhBgIFfwR+IwBBgAFrIgUkAAJAAkACQCADIARCAEIAEEhFDQAgAyAEELoCIQcgAkIwiKciCUH//wFxIgZB//8BRg0AIAcNAQsgBUEQaiABIAIgAyAEECAgBSAFKQMQIgIgBSkDGCIBIAIgARDEASAFKQMIIQIgBSkDACEEDAELIAEgAkL///////8/gyAGrUIwhoQiCiADIARC////////P4MgBEIwiKdB//8BcSIHrUIwhoQiCxBIQQBMBEAgASAKIAMgCxBIBEAgASEEDAILIAVB8ABqIAEgAkIAQgAQICAFKQN4IQIgBSkDcCEEDAELIAYEfiABBSAFQeAAaiABIApCAEKAgICAgIDAu8AAECAgBSkDaCIKQjCIp0GIf2ohBiAFKQNgCyEEIAdFBEAgBUHQAGogAyALQgBCgICAgICAwLvAABAgIAUpA1giC0IwiKdBiH9qIQcgBSkDUCEDCyAKQv///////z+DQoCAgICAgMAAhCIKIAtC////////P4NCgICAgICAwACEIg19IAQgA1StfSIMQn9VIQggBCADfSELIAYgB0oEQANAAn4gCARAIAsgDIRQBEAgBUEgaiABIAJCAEIAECAgBSkDKCECIAUpAyAhBAwFCyALQj+IIQogDEIBhgwBCyAKQgGGIQogBCELIARCP4gLIQwgCiAMhCIKIA19IAtCAYYiBCADVK19IgxCf1UhCCAEIAN9IQsgBkF/aiIGIAdKDQALIAchBgsCQCAIRQ0AIAsiBCAMIgqEQgBSDQAgBUEwaiABIAJCAEIAECAgBSkDOCECIAUpAzAhBAwBCyAKQv///////z9YBEADQCAEQj+IIQEgBkF/aiEGIARCAYYhBCABIApCAYaEIgpCgICAgICAwABUDQALCyAJQYCAAnEhByAGQQBMBEAgBUFAayAEIApC////////P4MgBkH4AGogB3KtQjCGhEIAQoCAgICAgMDDPxAgIAUpA0ghAiAFKQNAIQQMAQsgCkL///////8/gyAGIAdyrUIwhoQhAgsgACAENwMAIAAgAjcDCCAFQYABaiQAC4IRAgV/DH4jAEHAAWsiBSQAIARC////////P4MhEiACQv///////z+DIQwgAiAEhUKAgICAgICAgIB/gyERIARCMIinQf//AXEhBwJAAkACQCACQjCIp0H//wFxIglBf2pB/f8BTQRAIAdBf2pB/v8BSQ0BCyABUCACQv///////////wCDIgpCgICAgICAwP//AFQgCkKAgICAgIDA//8AURtFBEAgAkKAgICAgIAghCERDAILIANQIARC////////////AIMiAkKAgICAgIDA//8AVCACQoCAgICAgMD//wBRG0UEQCAEQoCAgICAgCCEIREgAyEBDAILIAEgCkKAgICAgIDA//8AhYRQBEAgAyACQoCAgICAgMD//wCFhFAEQEIAIQFCgICAgICA4P//ACERDAMLIBFCgICAgICAwP//AIQhEUIAIQEMAgsgAyACQoCAgICAgMD//wCFhFAEQEIAIQEMAgsgASAKhFANAiACIAOEUARAIBFCgICAgICAwP//AIQhEUIAIQEMAgsgCkL///////8/WARAIAVBsAFqIAEgDCABIAwgDFAiBht5IAZBBnStfKciBkFxahAoQRAgBmshBiAFKQO4ASEMIAUpA7ABIQELIAJC////////P1YNACAFQaABaiADIBIgAyASIBJQIggbeSAIQQZ0rXynIghBcWoQKCAGIAhqQXBqIQYgBSkDqAEhEiAFKQOgASEDCyAFQZABaiASQoCAgICAgMAAhCIUQg+GIANCMYiEIgJChMn5zr/mvIL1ACACfSIEEDogBUGAAWpCACAFKQOYAX0gBBA6IAVB8ABqIAUpA4gBQgGGIAUpA4ABQj+IhCIEIAIQOiAFQeAAaiAEQgAgBSkDeH0QOiAFQdAAaiAFKQNoQgGGIAUpA2BCP4iEIgQgAhA6IAVBQGsgBEIAIAUpA1h9EDogBUEwaiAFKQNIQgGGIAUpA0BCP4iEIgQgAhA6IAVBIGogBEIAIAUpAzh9EDogBUEQaiAFKQMoQgGGIAUpAyBCP4iEIgQgAhA6IAUgBEIAIAUpAxh9EDogBiAJIAdraiEGAn5CACAFKQMIQgGGIAUpAwBCP4iEQn98IgpC/////w+DIgQgAkIgiCIOfiIQIApCIIgiCiACQv////8PgyILfnwiAkIghiINIAQgC358IgsgDVStIAogDn4gAiAQVK1CIIYgAkIgiIR8fCALIAQgA0IRiEL/////D4MiDn4iECAKIANCD4ZCgID+/w+DIg1+fCICQiCGIg8gBCANfnwgD1StIAogDn4gAiAQVK1CIIYgAkIgiIR8fHwiAiALVK18IAJCAFKtfH0iC0L/////D4MiDiAEfiIQIAogDn4iDSAEIAtCIIgiD358IgtCIIZ8Ig4gEFStIAogD34gCyANVK1CIIYgC0IgiIR8fCAOQgAgAn0iAkIgiCILIAR+IhAgAkL/////D4MiDSAKfnwiAkIghiIPIAQgDX58IA9UrSAKIAt+IAIgEFStQiCGIAJCIIiEfHx8IgIgDlStfCACQn58IhAgAlStfEJ/fCILQv////8PgyICIAxCAoYgAUI+iIRC/////w+DIgR+Ig4gAUIeiEL/////D4MiCiALQiCIIgt+fCINIA5UrSANIBBCIIgiDiAMQh6IQv//7/8Pg0KAgBCEIgx+fCIPIA1UrXwgCyAMfnwgAiAMfiITIAQgC358Ig0gE1StQiCGIA1CIIiEfCAPIA1CIIZ8Ig0gD1StfCANIAogDn4iEyAQQv////8PgyIQIAR+fCIPIBNUrSAPIAIgAUIChkL8////D4MiE358IhUgD1StfHwiDyANVK18IA8gCyATfiILIAwgEH58IgwgBCAOfnwiBCACIAp+fCICQiCIIAIgBFStIAwgC1StIAQgDFStfHxCIIaEfCIMIA9UrXwgDCAVIA4gE34iBCAKIBB+fCIKQiCIIAogBFStQiCGhHwiBCAVVK0gBCACQiCGfCAEVK18fCIEIAxUrXwiAkL/////////AFgEQCABQjGGIARC/////w+DIgEgA0L/////D4MiCn4iDEIAUq19QgAgDH0iECAEQiCIIgwgCn4iDSABIANCIIgiC358Ig5CIIYiD1StfSACQv////8PgyAKfiABIBJC/////w+DfnwgCyAMfnwgDiANVK1CIIYgDkIgiIR8IAQgFEIgiH4gAyACQiCIfnwgAiALfnwgDCASfnxCIIZ8fSESIAZBf2ohBiAQIA99DAELIARCIYghCyABQjCGIAJCP4YgBEIBiIQiBEL/////D4MiASADQv////8PgyIKfiIMQgBSrX1CACAMfSIOIAEgA0IgiCIMfiIQIAsgAkIfhoQiDUL/////D4MiDyAKfnwiC0Ig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URtFBEAgAUIZiKdB////AXFBgICA/gdyIQIMAQtBgICA/AchAiAFQv///////7+/wABWDQBBACECIAVCMIinIgRBkf4ASQ0AIANBEGogACABQv///////z+DQoCAgICAgMAAhCIFIARB/4F/ahAoIAMgACAFQYH/ACAEaxBTIAMpAwgiAEIZiKchAiADKQMAIAMpAxAgAykDGIRCAFKthCIFUCAAQv///w+DIgBCgICACFQgAEKAgIAIURtFBEAgAkEBaiECDAELIAUgAEKAgIAIhYRCAFINACACQQFxIAJqIQILIANBIGokACACIAFCIIinQYCAgIB4cXK+C8YBAgN/An4jAEEQayIDJAACfiABvCIEQf////8HcSICQYCAgHxqQf////cHTQRAIAKtQhmGQoCAgICAgIDAP3wMAQsgAkGAgID8B08EQCAErUIZhkKAgICAgIDA//8AhAwBCyACRQRAQgAMAQsgAyACrUIAIAJnIgJB0QBqECggAykDACEFIAMpAwhCgICAgICAwACFQYn/ACACa61CMIaECyEGIAAgBTcDACAAIAYgBEGAgICAeHGtQiCGhDcDCCADQRBqJAALEAAjACAAa0FwcSIAJAAgAAuNBQEFfwJAIAAoAjwiAigCmAEiBEF/TARAQdCQAkGSC0EUIgAQGBoMAQsgAi0AnwEEQEHQkAIgAkGAAWoiAEH/ASAAEBwiASABQf8BShsiABAYIQMgAigCfARAIAAgA2ohASAAQX9zQYACaiIAQQFIQf3/A0H9/wMgAigCACAEQRRsaigCBCICIAJBgHBxQYCwA0YbIAJB///DAEsbIgJB/wBKckUEQCABIAI6AAAgAUEBaiADayEADAMLAkAgAEECSCACQf8PSnIEfwJ/IABBA0ggAkH//wNKckUEQEEBIQQgASEAIAJBDHZBYHIMAQsgAEEESA0CIAEgAkESdkHwAXI6AAAgAUEBaiEAQQIhBCACQQx2QT9xQYB/cgshBSAAIAU6AAAgASAEaiEBIAJBBnZBP3FBgH9yBSACQQZ2QUByCyEAIAEgADoAACABIAJBP3FBgAFyOgABIAFBAmohAQsgASADayEADAILQf8BIAFMDQEgACADaiACKAIAIARBFGxqKAIEOgAAIABBAWohAAwBCyACLQCgASEDQdCQAiACQYABaiIAQf8BIAAQHCIAIABB/wFKGyIAEBghASADBEAgACABakGaCSAAQX9zQYACaiIDQQMgA0EDSBsiAxAYGiABIAAgA2oiAGogAigCACAEQRRsaigCACACKAIEIARBDGxqLQACaiIBIABBf3NBgAJqIgIgARAcIgEgASACShsiARAYGiAAIAFqIQAMAQsgACABaiACKAIAIARBFGxqKAIAIAIoAgQgBEEMbGotAAJqIgEgAEF/c0GAAmoiAiABEBwiASABIAJKGyIBEBgaIAAgAWohAAsgAEGAAkgEQCAAQdCQAmpBADoAAAsLgAEBAn8jAEGQAmsiBCQAIAQgBEGMAmo2AgggBCAEQQxqIgU2AgAgBCAFNgIEIAAgBCACIAMQkwEgASAEKAIAIgAgBCgCBCAAayICQf8HIAJBgAhJGyIBEBggAWpBADoAACAAIAVHBEAgABAWIAQoAgQgBCgCAGsaCyAEQZACaiQAC0QCAX8BfiABQv///////z+DIQMCfyABQjCIp0H//wFxIgJB//8BRwRAQQQgAg0BGkECQQMgACADhFAbDwsgACADhFALC7UCAwJ/AX4CfAJAAnwgAL0iA0IgiKdB/////wdxIgFBgOC/hARPBEAgAUGAgMCEBEkgA0IAU3JFBEAgAEQAAAAAAADgf6IPCyABQYCAwP8HTwRARAAAAAAAAPC/IACjDwsgAEQAAAAAAMyQwGVBAXMNAkQAAAAAAAAAACADQn9XDQEaDAILIAFB//+/5ANLDQEgAEQAAAAAAADwP6ALDwsgAEQAAAAAAAC4QqAiBL2nQYABaiIBQQR0QfAfcSICQZC5AWorAwAiBSAFIAAgBEQAAAAAAAC4wqChIAJBCHJBkLkBaisDAKEiAKIgACAAIAAgAER0XIcDgNhVP6JEAAT3iKuygz+gokSmoATXCGusP6CiRHXFgv+9v84/oKJE7zn6/kIu5j+goqAgAUGAfnFBgAJtEEEL2AECAX8BfkF/IQICQCAAQgBSIAFC////////////AIMiA0KAgICAgIDA//8AViADQoCAgICAgMD//wBRGw0AIAAgA0KAgICAgICA/z+EhFAEQEEADwsgAUKAgICAgICA/z+DQgBZBEAgAEIAVCABQoCAgICAgID/P1MgAUKAgICAgICA/z9RGw0BIAAgAUKAgICAgICA/z+FhEIAUg8LIABCAFYg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IAJBoAJqEBkLQcCXAkJ/NwMAQYCVAkGAlQIoAgBBAnI2AgAMOgtBkJcCKAIAKAIEDQACQEH4lAItAABBgAFxRQ0AQdicAi0AAEUEQCACQdSLATYC2AIgAkHUiwE2AtQCIAJB1IsBNgLQAkEAQfGxASACQdACahAZQdicAkEBOgAADAELIAJB1IsBNgLAAkEAQdeyASACQcACahAZC0H4lAJB+JQCKAIAQYABcjYCAEHIlgIoAgAhAUEAQTBBARAXIQACQCABBEAgACABKQIANwIAIAAgASkCKDcCKCAAIAEpAiA3AiAgACABKQIYNwIYIAAgASkCEDcCECAAIAEpAgg3AggMAQsgAEIANwIAIABCADcCKCAAQgA3AiAgAEIANwIYIABCADcCECAAQgA3AggLIABBADYCACAAQfSTAigCADYCCCAAQfiTAigCADYCDCAAQeyTAigCADYCECAAQfCTAigCADYCFEHIlgIgADYCAAw5C0HIlgJBADYCAAw4C0HIlgIoAgAhAEGQlwIoAgAoAgRFBEBBAEEwQQEQFyEBAkAgAARAIAEgACkCADcCACABIAApAig3AiggASAAKQIgNwIgIAEgACkCGDcCGCABIAApAhA3AhAgASAAKQIINwIIDAELIAFCADcCACABQgA3AiggAUIANwIgIAFCADcCGCABQgA3AhAgAUIANwIICyABQQA2AgBByJYCIAE2AgAgAUEBNgIEDDgLIABFDTcgACgCBEUNN0EAQTBBARAXIgEgACkCADcCACABIAApAig3AiggASAAKQIgNwIgIAEgACkCGDcCGCABIAApAhA3AhAgASAAKQIINwIIIAFBADYCAEHIlgIgATYCACABQQA2AgQMNwtB5JYCQQE2AgAMNgtB6JYCQQE2AgAMNQtB5JYCQQA2AgAMNAtB6JYCQQA2AgAMMwsgAkGQlwIoAgAiASgCDCIANgKIDCABQQEQjAEiBEUEQCABQZq0AUEAECIaDAILQfiUAkH4lAIoAgBBgAJyNgIAAkAgACwAACIDQVBqQQpPBEAgAC0AAUUNAQsgACACQYgMakEAECQiA0H/AUsNLyACKAKIDC0AAA0vCyADQQBBABCCASIAIAQ2AgwgACAEEBw2AhAgAEHslgIoAgA2AiBB7JYCIAA2AgAMMgtBkJcCKAIAIgAoAgwhAyAAQQEQ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BCEDIAFBADYCwAEgAUEANgKcASABQQA2AgQgASADNgIAIAFCADcDECABQgA3AzAgAUIANwNIIAEgAy8BEiIGNgIYIAMvARQhBSABIAQ2AlQgASACNgJQIAEgBDYCPCABIAI2AjggASAFNgIcIAFCADcDiAEgASACtyIHIAa4IgijOQNwIAFCADcDgAEgASAIIAejOQNgIAFBgP0ANgLYASABQgA3AwggASAEtyIHIAW4IgijOQN4IAEgCCAHozkDaCABIAAoAhg2AtwBIAAoAgghAgNAIAEgAjYCCCABIAMoAgAgAkECdGooAgA2AgQgASAAKAIcEM8BIAAoAgwiAyADKAIAQQFqIgI2AgAgACACNgIIIAIgACgCBCIDKAIESA0ACyABEM4BIAFB4AFqJABBAAu4AwEMfyABKAIwIgQoAhwgAC8BDiILayIJQQAgCUEAShshByAJIAQoAiQiDGoiBSAALwEKIgMgBSADSBshBQJAIAQoAhggAC8BDCINayIDIAQoAiAiDmoiBiAALwEIIgogBiAKSBsiCiADQQAgA0EASiIDGyIGSgRAIAogBmshCAwBCyAEKAIoIA5Bf2pBACADGyANa2ohBgsCfyAFIAdKBEAgBCgCLCEDIAUgB2sMAQsgBCgCLCIDIAxBf2pBACAJQQBKGyALa2ohB0EACyEFIAQoAighBCABIAM2AjggASAENgI0AkACQCAIQQFIIAVBAUhyDQAgACgCACIERQ0AQQAhAiAAQQBBBCAFQQFqEBciAzYCAANAIAMgAkECdGogBCACIAdqQQJ0aigCACAGajYCACAAKAIAIQMgAkEBaiICIAVIDQALIAMgBUECdGpBADYCACAEEBYgACAFOwEKIAAgCDsBCAwBCyACBEAgABB6DAELIAAoAgAQFiAAQQA2AgAgAEEANgIICyAAIAAvAQwgBiABKAI0a2o7AQwgACAALwEOIAcgASgCOGtqOwEOIAAoAgBBAEcL1QEBCn8gASgCHCACLwEOIglrIgZBACAGQQBKGyEEIAYgASgCJCIKaiIFIAIvAQoiAyAFIANIGyEFAkAgASgCGCACLwEMIgtrIgMgASgCICIMaiIHIAIvAQgiAiAHIAJIGyIHIANBACADQQBKIgMbIgJKBEAgByACayEIDAELIAEoAiggDEF/akEAIAMbIAtraiECCyAA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Qb7QACADECILIQEgA0EQaiQAIAEL5wEBA38jAEEwayIEJAAgABAcIQYgAgR/IAIQHAVBCgshBUHckwIoAgAQFkHckwJBAEEBIAUgBmpBA2oQFyIFNgIAAkAgAgRAIAQgAjYCBCAEIAA2AgAgBUG6zwAgBBA+DAELIANB6QdOBEBBkM4AIQZBBCECIANBkM4ASwRAA0AgAkEBaiECIAZBCmwiBiADSQ0ACwsgBCABNgIoIAQgAjYCJCAEIAA2AiAgBUHIzwAgBEEgahA+DAELIAQgATYCFCAEIAA2AhAgBUHAzwAgBEEQahA+C0HckwIoAgAhACAEQTBqJAAgAAveBAEDfyMAQZABayIEJAACQCABRSACRXINACABIAIQYCEBQdiTAigCAARAQQpBgOgBKAIAIgUQJSAFEEcaQdiTAkEANgIACyAEIAE2AoABIABB3c0AIARBgAFqECEgAigCHCIBBEAgBCABNgJwIABB7M0AIARB8ABqECELIAIvAQghASAEIAIvAQo2AmQgBCABNgJgIABB8c0AIARB4ABqECEgAi8BDCIBIAIvAQ4iBXIEQCAEIAU2AlQgBCABNgJQIABB980AIARB0ABqECELIAItABMEQEGBzgBBC0EBIAAQIxoLIAIuARQiAUEATgRAIAQgAUH//wNxNgJAIABBjc4AIARBQGsQIQtBCiAAECUCQCADQQRxRQ0AIAIoAjRFDQAgBCACKAIsNgIwIABBnc4AIARBMGoQIQsCQCACKAIgIgFFDQAgASgCCEEBSA0AQQAhBQNAQbXOAEEMQQEgABAjGiAFQQJ0IgYgASgCAGooAgAgASgCBCAGaigCACAAEJcBQQogABAlIAVBAWoiBSABKAIISA0ACwsCQCACKAIYIgFFDQAgBCABKAIANgIgIABBws4AIARBIGoQISADQQFxRQ0AIAAgAigCGEHezgAQ2QELIAItABJFBEAgAi8BEEUNAQtB5M4AQQNBASAAECMaIAItABIiAQRAIAQgAUECdEGAzwBqKAIANgIQIABB6M4AIARBEGoQIQsgAi8BECIBBEAgBCABQeQAbiICNgIAIAQgASACQeQAbGtB//8DcTYCBCAAQaDPACAEECELQQogABAlCyAEQZABaiQAC8sEAQR/IwBB4ABrIgQkAAJAIAFFDQBB2JMCKAIABEBBCkGA6AEoAgAiBRAlIAUQRxpB2JMCQQA2AgALIAQgASgCBCIFNgJUIAQgAkHJzAAgAhs2AlAgBEHRzABB0swAIAVBAUYbNgJYIABBuMwAIARB0ABqECEgAS8BEiECIAQgAS8BFDYCRCAEIAI2AkAgAEHUzAAgBEFAaxAhIAEoAgwiAgRAIAQgAigCADYCMCAAQezMACAEQTBqECEgA0EBcQRAIAAgASgCDEGHzQAQ2QELIAQgAS8BEDYCICAAQYvNACAEQSBqECELAkAgASgCHCICRQ0AIAIoAghBAUgNAEEAIQUDQEGczQBBDkEBIAAQIxogBUECdCIGIAIoAgBqKAIAIAIoAgQgBmooAgAgABCXAUEKIAAQJSAFQQFqIgUgAigCCEgNAAsLAkAgASgCGCICRQRAQavNAEEPQQEgABAjGgwBCyACQQFIDQAgBCACNgIQIABBu80AIARBEGoQIQsCQCABKAIEQQFIBEBBACECDAELIANBAnEhB0EAIQZBACECA0AgASgCACAGQQJ0aigCACgCJCIFBEADQCAHBEAgACABIAUgAiAGENgBCyACQQFqIQIgBSgCICIFDQALCyAGQQFqIgYgASgCBEgNAAsLIANBAnEhAyABKAIgIgUEQANAIAMEQCAAIAEgBSACIAEoAgQQ2AELIAJBAWohAiAFKAIgIgUNAAsLIAMgAkVyDQAgBCACNgIAIABBzM0AIAQQIQsgBEHgAGokAAuPAQEBfyMAQSBrIgAkACAAQYCKAigCADYCEEH5yQAgAEEQahCJAUGt2wAQMUH83gAQMUHA4gAQMUH25QAQMUH+6AAQMUHo6wAQMUG57gAQMUHa8QAQMUHO9AAQMUGV9QAQMUHA+AAQMUGF+QAQMUGy/AAQMSAAQYCKAigCADYCAEHlywAgABCJASAAQSBqJAALOAECfyMAQRBrIgAkACAAQYCKAigCACIBNgIAIAAgATYCBEGA6AEoAgBBrckAIAAQISAAQRBqJAALMABBgOgBKAIAIQBB2JMCKAIABEBBCiAAECUgABBHGkHYkwJBADYCAAsgASAAEFIaCzsBAX8gAC0AACIAIAEtAAAiAWtBzJMCKAIAIgIgAEECdGooAgAiACACIAFBAnRqKAIAIgFrIAAgAUYbCysBAX9BxJMCKAIAKAIMIgIgACgCAEEGbGouAQQgAiABKAIAQQZsai4BBGsLKwEBf0HEkwIoAgAoAgwiAiAAKAIAQQZsai4BAiACIAEoAgBBBmxqLgECawsrAQF/QcSTAigCACgCDCICIAAoAgBBBmxqLgEAIAIgASgCAEEGbGouAQBrCz8BAnxBf0EBAn8gACsDCCICIAErAwgiA6GZRHsUrkfheoQ/ZEEBc0UEQCACIANjDAELIAArAxAgASsDEGMLGwu3DgIKfw18IwBBoAJrIgMkACADIABBLBAyIgI2AowCAkAgAkUNACACIABrIgFB/wFNBEAgAyAAIAEQGCIAIAFqQQA6AAALA0AgAi0AAEUNASACLQABQVBqQQlLDQEgA0GQAmogBUECdGogAkEBaiADQYwCakEKECQ2AgAgBUEBaiEFIAMoAowCIgINAAsLQeSXAigCAEEERgRAQeiXAigCABAWC0HklwJBADYCAAJ/AkAgAEGjJBAdRQ0AIABBqCQQHUUNACAAQbIkEB1FBEBB5JcCQQE2AgAMAQsCQCAAQbokEB0EQCAAQcokEB0NAQtB5JcCQQI2AgAMAQsCQAJAIABBzSQQHUUNACAAQdAkEB1FDQAgAEHVJBAdIgJFIAVBAEdxIgFBAUcNASADKAKQAkEDRw0BC0HolwJB1yQ2AgBB5JcCQQM2AgAMAQsCQAJAIABB5CQQHUUNACAAQeckEB1FDQAgAUUNASADKAKQAkEERw0BC0HolwJB8CQ2AgBB5JcCQQM2AgAMAQsCQAJAIABBhCUQHUUNACAAQYclEB1FDQAgAUUNASADKAKQAkEIRw0BC0HolwJBkCU2AgBB5JcCQQM2AgAMAQsCQAJAIABB1CUQHUUNACACRSAAQdklEB1Fcg0AIABB4SUQHQ0BC0HolwJB8CU2AgBB5JcCQQM2AgAMAQsCQCAAQfTFABAdBEAgAEH7xQAQHQ0BC0HolwJBkMYANgIAQeSXAkEDNgIADAELAkACQAJAIABB1MYAEB1FDQAgAEHdxgAQHUUNACAAQeLGABAdRQ0AIABB7sYAEB0NAQsgAygCkAIhACADKAKUAiEBQeSXAkEENgIAQQIgAUECIAFBAkobIAVBAkkbIQpBAEEYAn8gAEEGIABBAEobQQYgBRsiBrciDESqTFjoerb7P6JEAAAAAAAA4D+gIguZRAAAAAAAAOBBYwRAIAuqDAELQYCAgIB4CyIEIAZsIggQFyEHIARFDQFBACECQQAhAQNAIAEhAANAIAYEQEEAIQADQCAHIAJBGGxqIglCgICAgICAgPi/fzcDCCAJIAE2AgQgCSAANgIAIAJBAWohAiAAQQFqIgAgBkcNAAsgAUEBaiIBIARHDQIgDEQAAAAAAADgv6AhESAEt0QAAAAAAADgv6AhEiAEQX9qt0QAAAAAAADgP6IhEyAGQX9qt0QAAAAAAADgP6IhFEEAIQEDQCAHIAFBGGxqIgAoAgC3Ig8gFKEiDiAOoiAAKAIEtyIQIBOhIg0gDaKgIQsCfwJ/An8CfyAAKwMIIgxEAAAAAAAAAABjRUEAIAsgDGNBAXMbRQRAIAAgCzkDCCAAIA0gDhBMOQMQIAshDAsgDEQAAAAAAAAAAGNFC0EAIA9EAAAAAAAA4D+gIg4gDqIiFSAQRAAAAAAAAOA/oCINIA2iIhagIgsgDGNBAXMbRQRAIAAgCzkDCCAAIA0gDhBMOQMQIAshDAsgDEQAAAAAAAAAAGNFC0EAIA8gEaEiDyAPoiIXIBagIgsgDGNBAXMbRQRAIAAgCzkDCCAAIA0gDxBMOQMQIAshDAsgDEQAAAAAAAAAAGNFC0EAIBUgECASoSINIA2iIhCgIgsgDGNBAXMbRQRAIAAgCzkDCCAAIA0gDhBMOQMQIAshDAsgDEQAAAAAAAAAAGNFC0EAIBcgEKAiCyAMY0EBcxtFBEAgACALOQMIIAAgDSAPEEw5AxALIAFBAWoiASAIRw0ACwwECyAAQQFqIgAgBEcNAAsLDAELAkAgAEH2xgAQHUUNACAAQYHHABAdRQ0AQX8gAEGIxwAQHQ0DGgsgAygCkAIhASADKAKUAiEGQeSXAkEENgIAQQAhAEEAQRggAUEGIAFBAEobQQYgBRsiASABbCIHEBchBCABBEADQEEAIQIDQCAEIABBGGxqIghCgICAgICAgPi/fzcDCCAIIAk2AgQgCCACNgIAIABBAWohACACQQFqIgIgAUcNAAsgCUEBaiIJIAFHDQALIAFBf2q3RAAAAAAAAOA/oiEMQQAhAANAIAQgAEEYbGoiAigCALcgDKEiCyALoiACKAIEtyAMoSIOIA6ioCENIAIrAwgiD0QAAAAAAAAAAGNFQQAgDSAPY0EBcxtFBEAgAiANOQMIIAIgDiALEEw5AxALIABBAWoiACAHRw0ACwsgBCAHQRhBGBA5QeiXAiAEIAEgAUECIAZBAiAGQQJKGyAFQQJJGxDbATYCAAwBCyAHIAhBGEEYEDlB6JcCIAcgBiAEIAoQ2wE2AgALQQAgBUECSQ0AGkEAQeSXAigCAEEDRw0AGkEAIAMoApQCIgBBAkgNABpBACAAQeiXAigCACIBLQADRg0AGkEAQQEgAS0AASABLQAAbEEEaiIBEBdB6JcCKAIAIAEQGCIBIAA6AANB5JcCQQQ2AgBB6JcCIAE2AgBBAAshACADQaACaiQAIAALGQBBfyAAKAIEIgAgASgCBCIBRyAAIAFLGws3AQF/IAAgAC4BAkG3AWwgAC4BAEE3bGogAC4BBEETbGpBCHYiATsBBCAAIAE7AQIgACABOwEAC+YLARd/IwBBEGsiByQAIAAuARQhFyAALwEIIRIgAigCAEEBTgRAA0AgAigCECAKQQN0aiIMLQADIRMgDC0AAiEIIAdB8IkCKAIAIgkgDC0AAUEBdGovAQA7AQggByAJIAhBAXRqLwEAOwEKIAcgCSATQQF0ai8BADsBDCADKAIcIgkEQCAHQQhqIAkRBAALIAMgB0EIakEAEFUhCSAMQQE6AAAgDCAJNgIEIApBAWoiCiACKAIASA0ACwtBACEIQQBBDCASQQJqIgwQFyETQQBBDCAMEBchDEHIkwIoAgAiCkUEQEHIkwJBAEEEQYAEEBc2AgADQBCyAiEJQciTAigCACIKIBBBAnRqIAlB/g9vQYF4ajYCACAQQQFqIhBBgARHDQALCyAALwEIQQFqIQYgAC8BDCEQA0AgEyAIQQxsaiIJIAogCCAQakEDbCIOQf8DcUECdGooAgA2AgAgCSAKIA5BAWpB/wNxQQJ0aigCADYCBCAJIAogDkECakH/A3FBAnRqKAIANgIIIAYgCEchCSAIQQFqIQggCQ0ACyADEPECIAAvAQoEQCASQX9qIRggEkEMbEEYaiEZQQAhCANAIBMhCSAAKAIAIBVBAnRqKAIAIQYgDCITQQAgGRAbIQ4gCEUhDCAYQQAgCBsiCiASSQRAIAxBAXQhGiAIQQBHQQF0IRtBf0EBIAgbIRYgBiAKaiEQIAEgEiAVbGogCmohCANAAkAgEC0AACIFIBdGDQAgAigCECIGIAVBA3RqIgUtAAMhDyAFLQACIQsgB0HwiQIoAgAiESAFLQABQQF0ai8BACIFOwEAIAcgESALQQF0ai8BACILOwECIAcgESAPQQF0ai8BACIPOwEEIAMoAhwiEQRAIAcgEREEACAHLgEEIQ8gBy4BAiELIAcuAQAhBSACKAIQIQYLIAcgCSAKQQFqQQxsIhFqIhQoAgBBeHFBCG0gBUEQdEEQdWoiBUH//wEgBUH//wFIGyIFQQAgBUEAShsiDTsBACAHIBQoAgRBeHFBCG0gC0EQdEEQdWoiBUH//wEgBUH//wFIGyIFQQAgBUEAShsiCzsBAiAHIBQoAghBeHFBCG0gD0EQdEEQdWoiBUH//wEgBUH//wFIGyIFQQAgBUEAShsiDzsBBCADKAIMIAYgEC0AAEEDdGooAgQiBkEGbGoiBS4BAiALayILIAtsIAUuAQAgDWsiCyALbGogBS4BBCAPayIFIAVsaiADKAIgIAZBAnRqKAIATwRAIAMgB0EAEFUhBgsgCCAGOgAAIAQgBkH/AXFBAnRqIgYgBigCAEEBajYCACAKIBtqIQsgCiAaaiEPIAcuAQAgAygCDCIUIAgtAAAiBkEGbGouAQBrIgUEQCAJIA9BDGwiBmoiDSANKAIAIAVBOGxBcHFBEG1qNgIAIA4gC0EMbGoiDSANKAIAIAVBGGxBcHFBEG1qNgIAIA4gEWoiDSANKAIAIAVBKGxBcHFBEG1qNgIAIAYgDmoiBiAGKAIAIAVBA3RBcHFBEG1qNgIAIAgtAAAhBgsgBy4BAiAUIAZBBmxqLgECayIFBEAgCSAPQQxsIgZqIg0gDSgCBCAFQThsQXBxQRBtajYCBCAOIAtBDGxqIg0gDSgCBCAFQRhsQXBxQRBtajYCBCAOIBFqIg0gDSgCBCAFQShsQXBxQRBtajYCBCAGIA5qIgYgBigCBCAFQQN0QXBxQRBtajYCBCAILQAAIQYLIAcuAQQgFCAGQQZsai4BBGsiBkUNACAJIA9BDGwiBWoiDyAPKAIIIAZBOGxBcHFBEG1qNgIIIA4gC0EMbGoiCyALKAIIIAZBGGxBcHFBEG1qNgIIIA4gEWoiESARKAIIIAZBKGxBcHFBEG1qNgIIIAUgDmoiBSAFKAIIIAZBA3RBcHFBEG1qNgIICyAIIBZqIQggECAWaiEQIAogFmoiCiASSQ0ACwsgDCEIIAkhDCAVQQFqIhUgAC8BCkkNAAsLIBMQFiAMEBYgB0EQaiQAC4EDAQh/IwBBkAhrIgYkACAALgEUIQkgAigCACIIQQFOBEAgAigCECEKA0AgCiAHQQN0aiICLQADIQsgAi0AAiEMIAZB8IkCKAIAIgUgAi0AAUEBdGovAQA7AYgIIAYgBSAMQQF0ai8BADsBigggBiAFIAtBAXRqLwEAOwGMCCADKAIcIgUEQCAGQYgIaiAFEQQACyACIAMgBkGICGpBABBVIgU2AgQgBiAHQQJ0aiAFNgIAIAJBAToAACAHQQFqIgcgCEcNAAsLIAAvAQoEQEEAIQUgAC8BCCIHIQMDQAJAIANB//8DcUUEQEEAIQMMAQsgACgCACAFQQJ0aigCACECQQAhCANAIAkgAi0AACIDRwRAIAEgBiADQQJ0aigCACIDOgAAIAQgA0H/AXFBAnRqIgMgAygCAEEBajYCACAALwEIIQcLIAFBAWohASACQQFqIQIgCEEBaiIIIAciA0H//wNxSQ0ACwsgBUEBaiIFIAAvAQpJDQALCyAGQZAIaiQAC30BAn8gAEEANgIAQQBBBkGAAhAXIQIgAEEANgIgIABBADYCHCAAQoCAgICAIDcCECAAIAI2AgwgAEF/NgIIIAEoAgBBAU4EQANAIAAgASgCECADQQN0aiICLQABIAItAAIgAi0AAxB0IANBAWoiAyABKAIASA0ACwsgABBzC3wBBX8gAARAIAAoAjwiAigCECEBIAIoAhQiBEEBTgRAA0AgASADQQR0aiIFKAIEQQVGBEAgBSgCDCIBKAIAEBYgASgCBBAWIAEQFiACKAIUIQQgAigCECEBCyADQQFqIgMgBEgNAAsLIAEQFiACKAIEEBYgAhAWIAAQFgsLKAEBf0HEkwIoAgAoAgwiAiAAKAIAQQZsaiACIAEoAgBBBmxqQQYQPQuCAgEKfwJAIAAoAiANACAAQQBBBCAAKAIQEBciBTYCICAAKAIQRQ0AA0AgBSABQQJ0akF/NgIAIAFBAWoiASAAKAIQRw0ACwNAIAEgBCICQQFqIgRHBEAgBSACQQJ0aiEGIAAoAgwiByACQQZsaiIBLgEEIQggAS4BAiEJIAEuAQAhCiAEIQEDQCAJIAcgAUEGbGoiAi4BAmsiAyADbCAKIAIuAQBrIgMgA2xqIAggAi4BBGsiAiACbGpBAnYiAiAGKAIASQRAIAYgAjYCAAsgAiAFIAFBAnRqIgMoAgBJBEAgAyACNgIACyABQQFqIgEgACgCEEcNAAsLIAEgBEcNAAsLCz4BAX8gAEEANgIAQQBBBkGAAhAXIQEgAEEANgIgIABBADYCHCAAQoCAgICAIDcCECAAIAE2AgwgAEF/NgIICwsAIAAgAUEAEOABCwsAIAAgAUEBEOABC9gDAQV/QcAAEBohAkG4ARAaIQNBtAoQGiEEAkACQAJAAkAgAwRAIANBgAEQGiIFNgIQIAJFIARFcg0BIAVFDQIgAiADNgI8QQAhBSACQQA2AjggAkEANgIMIAJCADcCBCACQZQINgIAIANB7wA2AgggA0HQkwE2AgAgA0EANgKQASADQQA2AgwgAyAENgIEQQAhBCAAQQFOBEAgASgCACIEEKwBIgZBAWogBCAGGyEECyADIAA2AhwgAyAENgKMASADQQA7AZwBIAMgATYCGCADQoGAgIBwNwKUAQJAEIgCIgBFDQBBASEFIABB1QgQfw0AIABB2wgQfw0AIABB4AgQf0EARyEFCyADQQA2AnggA0KtgICAEDcCICADIAU2AnwgA0IBNwJwIANBADYCFCACQQFBAEEBQQAQKhogAkECQQFBAUEAECoaIAJBBEEAQQJBABAqGiACQQVBAEECQQEQKhogAkEGQQBBAkECECoaIAJBB0EAQQJBAxAqGiACQQNBAEEDQQAQKhogAkEIQQBBBEEAECoaIAIQ9QEgAg8LIARBAEchACACDQIMAwsgBUUNACAFEBYLIARBAEchACADEBYgAkUNAQsgAhAWCyAABEAgBBAWC0EACwUAEIkCCwv/gAJTAEGACAsCpwUAQZQIC5QSpwUAAAAAAAD/////AAAAAAAAAACnBQAAAAAAAP7///8AAAAAAAAAAKcFAAAAAAAA/f///wAAAAAAAAAATEFORwBVVEYtOABVVEY4AHV0ZjgAQ0xQIGludGVybmFsIGVycm9yOiBvcHRpb24gJWQgaGFzIG5lZ2F0aXZlIG9wdGlvbl9pZABuby0AQ0xQIGludGVybmFsIGVycm9yOiBvcHRpb24gJWQgYmVnaW5zIHdpdGggIm5vLW5vLSIAY2xwLmMALS0Ab3B0aW9uICU8JXMlcyU+IGlzIGFtYmlndW91cwB1bnJlY29nbml6ZWQgb3B0aW9uICU8JXMlQyU+AHVucmVjb2duaXplZCBvcHRpb24gJTwlcyVzJT4AJTwlTyU+IGNhbiUsdCB0YWtlIGFuIGFyZ3VtZW50ACU8JU8lPiByZXF1aXJlcyBhIG5vbi1vcHRpb24gYXJndW1lbnQAJTwlTyU+IHJlcXVpcmVzIGFuIGFyZ3VtZW50AChubyBjdXJyZW50IG9wdGlvbiEpAABDTFAgaW50ZXJuYWwgZXJyb3I6IG1vcmUgdGhhbiAxIG9wdGlvbiBoYXMgc2hvcnQgbmFtZSAlPCVjJT4AQ0xQIGludGVybmFsIGVycm9yOiAxLWNoYXIgbG9uZyBuYW1lIGNvbmZsaWN0cyB3aXRoIHNob3J0IG5hbWUgJTwlYyU+AENMUCBpbnRlcm5hbCBlcnJvcjogZHVwbGljYXRlIGxvbmcgbmFtZSAlPCVzJT4AJTwlTyU+IGV4cGVjdHMgYSBub25uZWdhdGl2ZSBpbnRlZ2VyLCBub3QgJTwlcyU+ACU8JU8lPiBleHBlY3RzIGFuIGludGVnZXIsIG5vdCAlPCVzJT4AJTwlTyU+IGV4cGVjdHMgYSByZWFsIG51bWJlciwgbm90ICU8JXMlPgB5ZXMAdHJ1ZQBubwBmYWxzZQAlPCVPJT4gZXhwZWN0cyBhIHRydWUtb3ItZmFsc2UgdmFsdWUsIG5vdCAlPCVzJT4AbWluX21hdGNoID4gMABhcmdjbXAAYW1iaWd1b3VzAGludmFsaWQAb3B0aW9uICU8JVYlPiBpcyAlcwBhbnkgaW50ZWdlcgAwAG5leHRfYXJndW1lbnQAbl9vcHRpb25fY2hhcnMgPCBDbHBfT3B0aW9uQ2hhcnNTaXplAHNldF9vcHRpb25fdGV4dABsZW4gPiAwAGZpbmRfbG9uZwBjbGktPmNvdWxkX2JlX3Nob3J0AHN3aXRjaF90b19zaG9ydF9hcmd1bWVudAAobnVsbCkAXCUwM28AJWQA4oCYACcA4oCZAG91dCBvZiBtZW1vcnkKAChQb3NzaWJpbGl0aWVzIGFyZQAgYW5kIAAsIGFuZCAALCBhbmQgb3RoZXJzAC4pCgAlczogT3V0IG9mIG1lbW9yeSwgZ2l2aW5nIHVwCgAlczogT3V0IG9mIG1lbW9yeSwgZ2l2aW5nIHVwIChodWdlIGFsbG9jYXRpb24pCgBnaWZmdW5jLmMAZ2lmcmVhZC5jAGltYWdlIGNvcnJ1cHRlZCwgbWluX2NvZGVfc2l6ZSB0b28gYmlnAGltYWdlIGNvcnJ1cHRlZCwgbWluX2NvZGVfc2l6ZSB0b28gc21hbGwAaW1hZ2UgY29ycnVwdGVkLCBjb2RlIG91dCBvZiByYW5nZQAobm90IHJlcG9ydGluZyBtb3JlIGVycm9ycykAbWlzc2luZyAlbGQgJXMgb2YgaW1hZ2UgZGF0YQBwaXhlbABwaXhlbHMAJWxkIHN1cGVyZmx1b3VzIHBpeGVscyBvZiBpbWFnZSBkYXRhAHVua25vd24gYmxvY2sgdHlwZSAlZCBhdCBmaWxlIG9mZnNldCAldQB0cmFpbGluZyBnYXJiYWdlIGFmdGVyIEdJRiBpZ25vcmVkAGltYWdlIGhhcyB6ZXJvIHdpZHRoIGFuZC9vciBoZWlnaHQAaW1hZ2UgcG9zaXRpb24gYW5kL29yIGRpbWVuc2lvbnMgb3V0IG9mIHJhbmdlAGJhZCBncmFwaGljIGV4dGVuc2lvbgBORVRTQ0FQRTIuMABBTklNRVhUUzEuMABiYWQgbG9vcCBleHRlbnNpb24AZ2lmdW5vcHQuYwBtYXB0byA+PSAwICYmIG1hcHRvIDwgbmRlc3Rjb2wAbWVyZ2UuYwBtZXJnZV9jb2xvcm1hcF9pZl9wb3NzaWJsZQBHSUZfQ09MT1JFUSgmZGVzdGNvbFttYXB0b10sICZzcmNjb2xbaV0pAHRvbyBtYW55IGNvbG9ycywgdXNpbmcgbG9jYWwgY29sb3JtYXBzCiAgKFlvdSBtYXkgd2FudCB0byB0cnkgJTwtLWNvbG9ycyAyNTYlPi4pAHRvbyBtYW55IGNvbG9ycywgdXNpbmcgbG9jYWwgY29sb3JtYXBzAGRlc3QtPmdsb2JhbABtZXJnZV9zdHJlYW0Ac29tZSBjb2xvcnMgdW5kZWZpbmVkIGJ5IGNvbG9ybWFwAGMtPmhhc3BpeGVsID09IDIgJiYgZm91bmRfdHJhbnNwYXJlbnQgPCAyNTYAbWVyZ2VfaW1hZ2UAZGVzdGNtLT5uY29sIDw9IDI1NgBvcHRpbWl6ZS5jAC4vb3B0dGVtcGxhdGUuYwAlZCBjb2xvcnMgcmVxdWlyZWQgaW4gYSBmcmFtZSAoMjU2IGlzIG1heCkAYm91bmRzLT50b3AgPCBzY3JlZW5faGVpZ2h0ICYmIGJvdW5kcy0+bGVmdCA8IHNjcmVlbl93aWR0aCAmJiBib3VuZHMtPnRvcCArIGJvdW5kcy0+aGVpZ2h0IDw9IHNjcmVlbl9oZWlnaHQgJiYgYm91bmRzLT5sZWZ0ICsgYm91bmRzLT53aWR0aCA8PSBzY3JlZW5fd2lkdGgAZml4X2RpZmZlcmVuY2VfYm91bmRzADAgJiYgIm9wdGltaXplZCBmcmFtZSBoYXMgc3RyYW5nZSBkaXNwb3NhbCIAY3JlYXRlX25ld19pbWFnZV9kYXRhMzIAY3JlYXRlX25ld19pbWFnZV9kYXRhMTYAQbIaC9ErCgAUAB4AKAAyADwARgBQAFoAYwBuAHgAhACQAJ0AqgC4AMYA1QDlAPYABwEZASsBPwFSAWcBfAGTAakBwQHZAfIBDAInAkICXgJ7ApkCtwLXAvcCGAM5A1wDfwOjA8gD7gMVBD0EZQSPBLkE5AQQBT0FagWZBckF+QUqBl0GkAbEBvkGLwdmB54H1wcRCEsIhwjECAEJQAmACcAJAgpFCogKzQoSC1kLoQvpCzMMfgzJDBYNZA2zDQMOVA6mDvkOTQ+iD/gPUBCoEAIRXBG4ERUScxLSEjITkxP1E1kUvRQjFYoV8hVbFsUWMBedFwoYeRjpGFoZzBlAGrQaKhuhGxkckxwNHYkdBh6EHgMfgx8FIIggDCGRIRginyIoI7MjPiTLJFgl6CV4JgonnCcwKMYoXCn0KY0qKCvEK2As/yyeLT8u4S6ELykwzzB2MR8yyDJ0MyA0zjR9NS023zaSN0Y4/DizOWs6JTvgO5w8Wj0ZPtk+mz9eQCNB6EGvQnhDQkQNRdpFqEZ3R0hIGknuScJKmUtxTEpNJE4AT91PvFCcUX5SYVNFVCtVElb7VuVX0Fi9Watam1uMXH9dc15pX2BgWGFSYk1jSmRIZUhmSWdMaFBpVmpda2VscG17bohvl3Cncbhyy3PgdPV1DXcmeEB5XHp6e5l8uX3bfv9/AABcBtgKIw7VECgTOhUaF9MYbRruG1kdsB74HzEhXiJ+I5UkoiWnJqMnmSiHKXAqUyswLAgt2y2qLnQvOzD9MLwxeDIwM+UzlzRHNfM1nTZFN+o3jDgtOcs5ZzoBO5k7MDzEPFc96D13PgU/kT8cQKVALUGzQTlCvEI/Q8BDQES/RD1FuUU1Rq9GKUehRxlIj0gESXlJ7UlfStFKQkuySyFMkEz+TGtN101CTq1OF0+AT+lPUFC4UB5RhFHpUU5SslIVU3hT2lM8VJ1U/lReVb1VHFZ6VthWNleSV+9XS1imWAFZW1m1WQ9aaFrAWhlbcFvIWx9cdVzLXCFddl3LXR9edF7HXhtfbl/AXxNgZGC2YAdhWGGpYflhSWKYYudiNmOFY9NjIWRuZLxkCWVVZaJl7mU6ZoVm0WYcZ2ZnsWf7Z0VojmjYaCFpammyafppQmqKatJqGWtga6dr7ms0bHpswGwGbUttkG3VbRpuX26jbuduK29vb7Jv9W84cHtwvnAAcUNxhXHHcQhySnKLcsxyDXNOc45zznMPdE90jnTOdA11TXWMdct1CXZIdoZ2xHYCd0B3fne8d/l3NnhzeLB47XgpeWZ5onneeRp6VnqSes16CXtEe397unv1ey98anykfN58GH1SfYx9xn3/fTl+cn6rfuR+HX9Wf45/x39xdWFudGl6ZS5jAAAAAAAA/Q8AAP0/AADx/wAA+/8DAPv/DwD9/z8A/f//APv//wMDAAAQDwAAQGFkYXB0aXZlIHBhbGV0dGUgc2l6ZSBtdXN0IGJlIGJldHdlZW4gMiBhbmQgMjU2AHRyaXZpYWwgYWRhcHRpdmUgcGFsZXR0ZSAob25seSAlZCAlcyBpbiBzb3VyY2UpAGNvbG9yAGNvbG9ycwAha2QzLT50cmVlAGtkM19idWlsZABrZDMtPm1heGRlcHRoIDwgMzIAc3RhY2twb3MgPCAzMgBrZDNfY2xvc2VzdF90cmFuc2Zvcm1lZABub25lAHBvc3Rlcml6ZQBkZWZhdWx0AGZsb3lkLXN0ZWluYmVyZwBmcwBvMwBvM3gzAG8AAwMJCQIGAwUACAEHBG80AG80eDQAAAAAAAQEEBAACAMKDAQOBgILAQkPBw0FbzgAbzh4OAAAAAAACAhAQAAwDDwDMw8/IBAsHCMTLx8IOAQ0CzsHNygYJBQrGycXAjIOPgExDT0iEi4eIREtHQo6BjYJOQU1KhomFikZJRVybzY0AHJvNjR4NjQAb3JkZXJlZAAAAAAAAAAAQEAQEAYPAg8CDgENAg4FDQAOAAkGCgcNBg0DCgUPBAsACwYKBwwHDQAJBg8GCgAPAQ8ACAAPBg8HDwcJAQ8DCAEIAA4JAwoFCgYKBQkGCQIJBA0EDQMIAwoBDQYLAQwDDgUPAwgDCAMMBAsDDQMIBAkGDAQLBgsDCgAMAQsHDAQMBAsFAQ4ACgIJAgsBCAEIAwkEDwcNBw4HDgAKAA4HCQALAQ8ACwALAw8HDgYKBQgACwAIBwsADwAMAQ0GCQAPBAkBCAoFDwYNBg4HDgQMBQ8GCgILAwoDCwMNBgsFDgMOBggFDgUOBwoHCwMNAw0CDgQPBQ8DCAQLBAkFDAMIBQ8CDQUDCgIJBQ8ECQALBwsADgULBQ4HDwYJAAkACAQOBgwACwQPBQgGCgYLBgoDDAUJBgkFDAYMBw4ADgIPBQgCCgMJDgcOBwgBDAIOBA8DCwUMAggACgMMAQ0FDgULAAsDDQcIAQwDDwMOAg8DCwYPAQwBCQMJAwsDCwcLBQwADgYNBgUKBgwDDwMIBwoADwcKBQgBDgUKBw4CDgAOAQgDCAUKBQ8ACAYOAAgCDwQLBgoACAUJBA4BDwMKAQ8ADwUIBw0PAwgACQYMBg8ACwQOAw8DCgUMAwoDCQYJBQ0FDwYOAAkADAQLAw8ECwYPAg8DDgQNAgsBCAUMBwkECAUMAgsAAA0FCwUOBQ8HCQUIAgoDDwYJAwwFCwYOAw0GDQAJAQsDCAMJBAkGDgcIBgwHDQYJBQ0DDwUOAw8EDAQMAg0ADwoHDgEIAgoCDAANAQ0FCwYMAwkGDwEJAQoGCgMPBg8FDwcMBgwACQMMAwsDCAMNAgkDCQYKAgsGCQAJAQkGCgQDCgQJBAkGDQMPAAgECgAOBQ8HDwIMBwoFDwcIAAkACAYOBA8CDwEPAAkFDgAMBwoGCAYLAA0HDgENAgoFCQAODgYNAQwDCAMJBgwEDwIIBQkBCgEIBQ8ACAIMAwwFDAULAgoCCAUKBQwECQMIBA0BDwAMAwgECgMJBQ0FDQMLBAQMAwoGCQAOAAgBCQEJBg8ACgIJBgoHCgIOBAgADQQIAQsGDgcOAAgEDgcOBAkCDAAMAwgFCQYOAAkCDgUKAQ8KAg8GDgMLBg8EDwQNBQsDDAQOBQwADQMIBg8CCgYNAgwGCAMKAw4FCAAKAw0CCQYKBg8EDQIIAw4GCwcNAAoFAg0BCQUKAw8GCgAPBA8EDwYJAA4BCQYMAAsFCQAOBQ4GCQMLBwsBDwEJAw0FDAAJAgkGDQIJBg0HCwcIAA0DCQkGDQYNAAgFDgILBwsCCwIMAwsEDQQKAw8FDQALBgoADQMPBw4DCAQMBgkGCgMOBQ0FCwMNBggCDgMPAwsEDAYECgcLAQoCDgcOAA4EDwAIAA8FDwcLBw4GDAAIAQ8BDgIIAAsECAULAQ8ADAcOAAsECAIIAA4CDgQJBAoHDwUODgANAg4FCwUKAgoGCwMMBQsHCwEMAwsDCQMMBAsGCQUOBQwHDgIMAQgECwcKAw4EDgAOBQsHCwUPAQ4ACgMKAAUMBwoHCwAOBQ4BDgMIAA8ACQUJAQgGDwYPBw0HCQQLAAoGCgcMBw8ACQcOAgsADAcLBw0ACQYOAgsBDwAIAAoKAw8DDwMIBAsDCwYPBgsFDAUNAA8ECAELAwoDDwMOAQ4GDQMLAwsDDQYIAwwFCAQNAwgCDQQIAw4HCAUOBA8FAwkACgAMAwsHCgYIBwwACwEIBQwFDAcLAg4ACgAMAA8CCQUJAA8EDgYJBwsGCgAJAQkADgQMBQkGCgQLBgwFDAwGDwQIBA8HDwMOAAkDDQUOBQsBCQAPAwgHDAcIBQkEDAYMAQoGCQAPAw4ADwMNBQ8FCQYKAA4ADQEPAQgDCAECCAcPAAsBDAEMAA8ACwINAQoFCAcNBgoACwQMBwoBCQEJAAwCCwcPAQsACQIIBAwCDAYOBA4DDQMPAQ4EDwYMDQYLAwwECAQJBAkFDAYKBQ4HDgMKAg0DDgUIAg0BDwYPBAgEDwUKAQ4FDAQNBQsBCQUJAwkACgcKBwsGCgMJAAMPBQgBCQUIBA0GCAQPBgoGDgcLAAkBDAAIBgwGCgMMBw0HCwMIAA0HDAAPBAwFCAQPBQoADwMPAQgBDwQOBg8KBg4ADQQNAQkBDQMLAgwBCAMMAw4GCAQPBAgDDwEJBgsCDgMNBwoECgMIBwsCDAELAQ4DCQYJBw0FCwcKAgkDAQkADgcMBw4FCQYKBg4GDwEOBwoDDAAOBQkGCAEMAA0CCAQJBg8ADgQKBwsFDgIIBA8DCAcNAQkADwAOBQ4ADg8ECgYLAQoCDgMPAQoDCgMIBAwDCgYJBg4CDAMLBAkGDAUPAAoDCAQOAQ4DCwIMBwsCDAYKAQ0ECwQKBQsCCwcACAELBAgECgYLAwoGCgYIAQsBDwcPBgkBCQcIAA4FDAMNBAwADwUMAQwHCQYIAw8ADQYPBw8HDQIPAQ4CDwAIDAUNBQ8BDAEPAQ4GDgIOAg4GCwYLAwwCDQYPAwkFCAIIBQkBCQQJAggEDQENAAsGCwYJAgsDCgEKBgkGCwcPBQUMAAkFCAUJAAoCDQQIBQ4CCQIPBAgCCAAMBgwACgUPBAkDDQAJBA8BDgEJAAkCDgYMAA8HCQIJAA8GCgMPAw0JAQ8FDAMOAA8HCAUOAQsBDQYKBw0ADgUKBwsDDwYLAQwCCAQNBQoCCgYNBQ0ECgUJAwgEDAEMBQsGDgMLBwsHAgsEDAcIAw8DCwQLBwoBCgIKAAsEDAAKAQgHCwEKAQ8HCgILAQkGDgILAQ4EDAINAQkFCAcLBwoHDwQNAwoBCw0FCAAPAwsGDAcPAw8BDwQOBQ0GCAEPBg0FDAIPBAkEDwMOBg4FCQMMBgsFCAIJBQwFDwENAw4CCAAIAAwHDwUADgEIAggCDwIJBgwADAcMBw0ADwYOBQsBDAUIBQgBDgAKBAwGCQYIAAkADwQPBQ0BDwUMBwoGDgQJBg8ADwcNCgQNBQ0FCwUMBQkDCQQIAwkDCgYLAQ8CCAUPAQ0CCwYOBggCDwMOAw0GCQYJAAoCCgcLAQ8DCQMNAwoDCQQKAQQLBwoCDgQPAw8CDwcKAg4BCAAPAggBDAINAQgHDAYLAQoECwIPAA0ADAcLBQwHCAYPBAwHCgYKAAoACwQMBwoNAg4CCgcLAQsHCwcMAwsHDQQLBgwFCwYKBw0ECwMPAw4EDwMIBQoHCgYPAwkDDwELAwkADwEPAw8EDQUIAw8DAwkBDAQOAAsHDwELAw4ACwUKAgoCCAYOBwsACgcOBw8GCQYJAQwHCQQIBw0ADQYMBggBCQEPBAwADAQKAA0ADA0FCgYJAQ0GCwAOBwsHDgUPAg0FDwQJAg0DDgcKAwoDDAMMAggFDwMNAwsDCgQJAw8BDgQLBgoDCAQNAAoECAUFCAMNBA4BDQcJAg4EDgQMBwoGCgUMAgsGDAcNBAsCCwMIBQ8CCgEJAgwADAAKAQwACQcKAA8ECQAIAQ4EDgQNDAIIBgoACAUNAwgFCgMLAg8ADQMIAg8GCQEIAw4BDwUOBwgADAYPBQgFCQQPBQgFDwQMAwkGDAMNBQsHCgEIAwQPAgsCCgYLAw4HDwAKAA4DDAQIBwkDCwANAgwCDQUIBQgCCwQMAgoHCAYKBwwHCwAPBwgHDwAJAgwGDQAJBAkIAwwFDwUNAQgHCAMMBQkFCQYOAQwDDwcKBwgFCAUPAA0BDgcJAQ4HDQIMAwgBDQMIBAwACwMMBQsFCQMMBg4CBQ0CCAYMBwoFDgQLAgsCDQINBQoFCQAKBw0EDwIJAQkFCQYKBAwFDAQKAw4DDwEIBAwFCAUOBwsHDwULAg0BCQoADQYKAg8DCAEMAg4GCAUKBw0BDQEMBwkBCQIMBQwEDAMMAgkACAEPAQoHCgYMBAsBDgILAA4BCQIMAggFDQUGCgcLAAkDCQULAAgADQINBA0FCQQIAggACgAOBgkGCQQOBwkACwcKBwsHDgQOBQ8ECAQLBQ4ACAEOBw4CCwcNDAMNAw4FDwYMAA8ECwUJBQkCDgEMAQ0FDwQLBwwBDQIIAQwADwYOAg4DCgELAwsADAEPAgsBDAQJBAoCDQYKAgIIBAgECQAJAg8FCQYLBw4ACQIMAggACgEJBwgCCQELAgsCCAEJAQsHDQYLAQsACQINBA4BDwIIBw8ADQYJBA0NBQ0BDgAMBgkGDAANAAsDDQYLBwwFDgYOBQ8DDQYOBw8GDwUNBA4FCAIOAw4GDgUKBgoCCQUPBQsBCAUNAwsCAggGCAAJAQ8ACwQPBwgECAENBwsBDQUPAQ8CCQANBQwDDAIIAQoBDQUPAwkDCQIMBQ4GDQEJBgkBCAQPBwoHDw4FDgMMBAoHDAcIAgwBDQILBA0DCAUIAQoHDAYJBQgACAcOBQ0GCAQIAgwGDQUIBwgDCgMNBAwBDQQLAQ4DCAECDQYKAAkBDwAMBAsCCQAJAA0BCAALBQkGDQIPAgwHDAYPAg4BDQEOBAsCDgEJAA8BDAUOBg0CDwMJAQ8HCAEOCwcNAw8GCAQIBA4CDgYNBgsEDgQPBA4DCgIKBQkGCQMJAQsGCQQIBA8ACAQNBAkECQUJAwoCCQUMBggEDAALBAQKBA0BDAcIAA0EDAINAQ4HDwMIBwwDCgQJBAsHCAILAgoADAEOBg4HDQcLAwoACgQJAw0ADQcIBwkHCwIIAQ4PAAsBCQYPAwoHCQEJBwoHCgEMBQgBDwcNAwwCDQIOBw4FCgQIBAsBCgMOAA4GDgUNAggHCgcNAg4CDQIOBQsGBwsFDQELBwgFDgQNAQ4FCgIPBA0HCwcKAQgFCQQMBwoBDQcNBwsADgUOAg4EDAQNBw0HCAIOAg0FCQUJAggBCgwACAINBAwBCwEKAQoEDAILBQgBDwMOAQ0EDgIJAgwCCAQIAgwDCgYLAAsHCgEJAgoADQELBwoGDQEMAQwGDgcCDgQPBw4FCAQNAgoEDQANAQsBDAcMBg0EDQQNAgwCDQENBwoCCwIKBw8HCwUNAggCDgQJAg4ACAEIBwoFDwYOCwcKAgsBDQALAQ8HCAEJBA0ECAQIAwoACQAJAgkHCQYKBw0BDQcOBgsDDAIIAgwFCwUMAgoFDgQMBA0CCQEKAAIMAA0HDQIMBAgBDAQNBgsHDQcNAQkHCgIKAQkCCgELBgkEDQIKAAoCDgANBwoHCgAMAAkADQINAQkADwIOAg0LBwgECgIKBwwBCwcIAg0BCgAKAg0GDgAOBw0GDgUNBA8BCgINBw0HCQQJBg0DDQMIBA0ECgYKBQwECgcLBgkGBA4GCwcNBgoECAQLBggFDQcOBw4BCQAMAQkBDAQOBwoEDQcNBwsECgELBw0EDAEKBAwCCAIMAgoCDAEMBAwCDAgCDQIIAQ0BDAEMAgwCCwEJAgsDDAQIBAwECgYKAQ0CCwIKAQwADgIOBAkCCAENBAgADAQLBgwGCwcKBwsCCgdkaWFnNDUAZGlhZ29uYWwAQZDGAAvkCAgIQAIQIDA4KBgIACQ0PCwcDAQUMTkpGQkBESE9LR0NBRUlNSoaCgISIjI6Hg4GFiY2Pi4LAxMjMzsrGwcXJzc/Lx8PaGFsZnRvbmUAaGFsZgB0cmloYWxmdG9uZQB0cmloYWxmAHNxaGFsZnRvbmUAc3FoYWxmAHNxdWFyZWhhbGZ0b25lAHRyaXZpYWwgYWRhcHRpdmUgcGFsZXR0ZSAob25seSAlZCBjb2xvcnMgaW4gc291cmNlKQAAGQAAABoAAAAbAAAAcGxhbnBvcyA9PSBucGxhbgBwbGFuX2Zyb21fY3BsYW4AKm5ld19uY29sIDwgbmV3X2NtLT5jYXBhY2l0eQB0cnlfYXNzaWduX3RyYW5zcGFyZW5jeQAqbmV3X25jb2wgPT0gMjU2ACh1bnNpZ25lZCkgaSA8ICh1bnNpZ25lZCkga2QzLT5uaXRlbXMALi9rY29sb3IuaABrZDNfZGlzYWJsZQBrZDMtPmRpc2FibGVkIDwgMCB8fCBrZDMtPmRpc2FibGVkID09IGkAZ2lmc2ljbGUAVXNhZ2U6ICVzIFtPUFRJT04gfCBGSUxFIHwgRlJBTUVdLi4uClRyeSAnJXMgLS1oZWxwJyBmb3IgbW9yZSBpbmZvcm1hdGlvbi4KACdHaWZzaWNsZScgbWFuaXB1bGF0ZXMgR0lGIGltYWdlcy4gSXRzIG1vc3QgY29tbW9uIHVzZXMgaW5jbHVkZSBjb21iaW5pbmcKc2luZ2xlIGltYWdlcyBpbnRvIGFuaW1hdGlvbnMsIGFkZGluZyB0cmFuc3BhcmVuY3ksIG9wdGltaXppbmcgYW5pbWF0aW9ucyBmb3IKc3BhY2UsIGFuZCBwcmludGluZyBpbmZvcm1hdGlvbiBhYm91dCBHSUZzLgoKVXNhZ2U6ICVzIFtPUFRJT04gfCBGSUxFIHwgRlJBTUVdLi4uCgoAUmVwb3J0IGJ1Z3MgdG8gPGVrb2hsZXJAZ21haWwuY29tPi4KVG9vIG11Y2ggaW5mb3JtYXRpb24/IFRyeSAnJXMgLS1oZWxwIHwgbW9yZScuCgAqICVzICVkIGltYWdlJXMKADxzdGRpbj4AAHMAICBsb2dpY2FsIHNjcmVlbiAlZHglZAoAICBnbG9iYWwgY29sb3IgdGFibGUgWyVkXQoAICB8ACAgYmFja2dyb3VuZCAlZAoAICBlbmQgY29tbWVudCAAICBsb29wIGZvcmV2ZXIKACAgbG9vcCBjb3VudCAldQoAICBleHRlbnNpb25zICVkCgAgICsgaW1hZ2UgIyVkIAAjJXMgACVkeCVkACBhdCAlZCwlZAAgaW50ZXJsYWNlZAAgdHJhbnNwYXJlbnQgJWQAICAgIGNvbXByZXNzZWQgc2l6ZSAldQoAICAgIGNvbW1lbnQgACAgICBsb2NhbCBjb2xvciB0YWJsZSBbJWRdCgAgICAgfAAgICAAIGRpc3Bvc2FsICVzAEGAzwALwUQ2KwAAOysAAEArAABLKwAAVCsAAFYrAABYKwAAWisAACBkZWxheSAlZC4lMDJkcwBzdXBwb3J0LmMAJXMuJXMAJXMuJTAzZAAlcy4lMCpkAGZyYW1lIHNwZWNpZmljYXRpb25zIG11c3Qgc3RhcnQgd2l0aCAjAG5vIGZyYW1lIG5hbWVkICU8IyVzJT4AZnJhbWUgJTwjJXMlPiBvdXQgb2YgcmFuZ2UsIGltYWdlIGhhcyAlZCBmcmFtZXMAaW52YWxpZCBkaW1lbnNpb25zICU8JXMlPiAod2FudCBXeEgpAGludmFsaWQgcG9zaXRpb24gJTwlcyU+ICh3YW50ICdYLFknKQBpbnZhbGlkIHNjYWxlIGZhY3RvciAlPCVzJT4gKHdhbnQgWHhZKQBpbnZhbGlkIHJlY3RhbmdsZSAlPCVzJT4gKHdhbnQgWDEsWTEtWDIsWTIgb3IgWDEsWTErV3hIADAxMjM0NTY3ODlBQkNERUZhYmNkZWYAaW52YWxpZCBjb2xvciAlPCVzJT4gKHdhbnQgI1JHQiBvciAjUlJHR0JCKQBpbnZhbGlkIGNvbG9yICU8JXMlPgAlPCVPJT4gdGFrZXMgdHdvIGNvbG9yIGFyZ3VtZW50cwAtAHJiACVzAGZpbGUgbm90IGluIEdJRiBmb3JtYXQAY2FuJSx0IHVzZSBhcyBwYWxldHRlIChubyBnbG9iYWwgY29sb3IgdGFibGUpAHRoZXJlIHdlcmUgZXJyb3JzIHJlYWRpbmcgdGhpcyBHSUYAZW1wdHkgb3V0cHV0IEdJRiBub3Qgd3JpdHRlbgBodWdlIEdJRiwgY29uc2VydmluZyBtZW1vcnkgKHByb2Nlc3NpbmcgbWF5IHRha2UgYSB3aGlsZSkAc3JjaS0+cmVmY291bnQgPiAxAG1lcmdlX2ZyYW1lX2ludGVydmFsACVzOiVzJXMgZmF0YWwgZXJyb3I6IAAlczolcyVzIHdhcm5pbmc6IAAlczolcyVzIAA6ACUuKnMlLipzACAgICAAICUzZDogIyUwMlglMDJYJTAyWABcYQBcYgBcZgBcbgBccgBcdABcdgBcXABcMDAwAFwlMDNvACAgZXh0ZW5zaW9uICVkOiAAYXBwICcAJyVjJyAoMHglMDJYKQAweCUwMlgAIGF0IGVuZAAgYmVmb3JlICMlZAAgcGFja2V0aXplZAAgICAgJTA4eDogACUwMnggICAAJTAyeCUwMnggACAgICAgAG5vbmUAYXNpcwBiYWNrZ3JvdW5kAHByZXZpb3VzADQANQA2ADcAJWcgJWcgJWcAMDEyMzQ1Njc4OWFiY2RlZkFCQ0RFRgAlMXglMXglMXgAJTJ4JTJ4JTJ4AG1heGltdW0gMjU2IGNvbG9ycyBhbGxvd2VkIGluIGNvbG9ybWFwAGZpbGUgbm90IGluIGNvbG9ybWFwIGZvcm1hdABmMSA+PSAwICYmIGYyIDwgZnNldC0+Y291bnQAbWVyZ2VyX2ZsYXR0ZW4AY3JvcHBpbmcgZGltZW5zaW9ucyBkb24lLHQgZml0IGltYWdlAHRyYW5zcGFyZW50ACVzIGNvbG9yIG91dCBvZiByYW5nZQAlcyBjb2xvciBub3QgaW4gY29sb3JtYXAAZGVzdC0+bmltYWdlcyA+IDAAZml4X3RvdGFsX2Nyb3AAaXJyZWxldmFudCBiYWNrZ3JvdW5kIGNvbG9yCiAgKFRoZSBiYWNrZ3JvdW5kIHdpbGwgYXBwZWFyIHRyYW5zcGFyZW50IGJlY2F1c2UgIHRoZSBmaXJzdCBpbWFnZSBjb250YWlucyB0cmFuc3BhcmVuY3kuKQBpcnJlbGV2YW50IGJhY2tncm91bmQgY29sb3IAaW5wdXQgaW1hZ2VzIGhhdmUgY29uZmxpY3RpbmcgYmFja2dyb3VuZCBjb2xvcnMKICAoVGhpcyBtZWFucyBzb21lIGFuaW1hdGlvbiBmcmFtZXMgbWF5IGFwcGVhciBpbmNvcnJlY3QuKQBpbnB1dCBpbWFnZXMgaGF2ZSBjb25mbGljdGluZyBiYWNrZ3JvdW5kIGNvbG9ycwBNb2RlIG9wdGlvbnM6IGF0IG1vc3Qgb25lLCBiZWZvcmUgYW55IGZpbGVuYW1lcy4KICAtbSwgLS1tZXJnZSAgICAgICAgICAgICAgICAgICBNZXJnZSBtb2RlOiBjb21iaW5lIGlucHV0cywgd3JpdGUgc3Rkb3V0LgogIC1iLCAtLWJhdGNoICAgICAgICAgICAgICAgICAgIEJhdGNoIG1vZGU6IG1vZGlmeSBpbnB1dHMsIHdyaXRlIGJhY2sgdG8KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzYW1lIGZpbGVuYW1lcy4KICAtZSwgLS1leHBsb2RlICAgICAgICAgICAgICAgICBFeHBsb2RlIG1vZGU6IHdyaXRlIE4gZmlsZXMgZm9yIGVhY2ggaW5wdXQsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25lIHBlciBmcmFtZSwgdG8gJ2lucHV0LmZyYW1lLW51bWJlcicuCiAgLUUsIC0tZXhwbG9kZS1ieS1uYW1lICAgICAgICAgRXhwbG9kZSBtb2RlLCBidXQgd3JpdGUgJ2lucHV0Lm5hbWUnLgoAR2VuZXJhbCBvcHRpb25zOiBBbHNvIC0tbm8tT1BUSU9OIGZvciBpbmZvIGFuZCB2ZXJib3NlLgogIC1JLCAtLWluZm8gICAgICAgICAgICAgICAgICAgIFByaW50IGluZm8gYWJvdXQgaW5wdXQgR0lGcy4gVHdvIC1JJ3MgbWVhbnMKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3JtYWwgb3V0cHV0IGlzIG5vdCBzdXBwcmVzc2VkLgogICAgICAtLWNvbG9yLWluZm8sIC0tY2luZm8gICAgIC0taW5mbyBwbHVzIGNvbG9ybWFwIGRldGFpbHMuCiAgICAgIC0tZXh0ZW5zaW9uLWluZm8sIC0teGluZm8gLS1pbmZvIHBsdXMgZXh0ZW5zaW9uIGRldGFpbHMuCiAgICAgIC0tc2l6ZS1pbmZvLCAtLXNpbmZvICAgICAgLS1pbmZvIHBsdXMgY29tcHJlc3Npb24gaW5mb3JtYXRpb24uCiAgLVYsIC0tdmVyYm9zZSAgICAgICAgICAgICAgICAgUHJpbnRzIHByb2dyZXNzIGluZm9ybWF0aW9uLgAgIC1oLCAtLWhlbHAgICAgICAgICAgICAgICAgICAgIFByaW50IHRoaXMgbWVzc2FnZSBhbmQgZXhpdC4KICAgICAgLS12ZXJzaW9uICAgICAgICAgICAgICAgICBQcmludCB2ZXJzaW9uIG51bWJlciBhbmQgZXhpdC4KICAtbywgLS1vdXRwdXQgRklMRSAgICAgICAgICAgICBXcml0ZSBvdXRwdXQgdG8gRklMRS4KICAtdywgLS1uby13YXJuaW5ncyAgICAgICAgICAgICBEb24ndCByZXBvcnQgd2FybmluZ3MuCiAgICAgIC0tbm8taWdub3JlLWVycm9ycyAgICAgICAgUXVpdCBvbiB2ZXJ5IGVycm9uZW91cyBpbnB1dCBHSUZzLgogICAgICAtLWNvbnNlcnZlLW1lbW9yeSAgICAgICAgIENvbnNlcnZlIG1lbW9yeSBhdCB0aGUgZXhwZW5zZSBvZiBzcGVlZC4KICAgICAgLS1tdWx0aWZpbGUgICAgICAgICAgICAgICBTdXBwb3J0IGNvbmNhdGVuYXRlZCBHSUYgZmlsZXMuCgBGcmFtZSBzZWxlY3Rpb25zOiAgICAgICAgICAgICAgICNudW0sICNudW0xLW51bTIsICNudW0xLSwgI25hbWUKCkZyYW1lIGNoYW5nZSBvcHRpb25zOgogIC0tZGVsZXRlIEZSQU1FUyAgICAgICAgICAgICAgIERlbGV0ZSBGUkFNRVMgZnJvbSBpbnB1dC4KICAtLWluc2VydC1iZWZvcmUgRlJBTUUgR0lGUyAgICBJbnNlcnQgR0lGUyBiZWZvcmUgRlJBTUVTIGluIGlucHV0LgogIC0tYXBwZW5kIEdJRlMgICAgICAgICAgICAgICAgIEFwcGVuZCBHSUZTIHRvIGlucHV0LgogIC0tcmVwbGFjZSBGUkFNRVMgR0lGUyAgICAgICAgIFJlcGxhY2UgRlJBTUVTIHdpdGggR0lGUyBpbiBpbnB1dC4KICAtLWRvbmUgICAgICAgICAgICAgICAgICAgICAgICBEb25lIHdpdGggZnJhbWUgY2hhbmdlcy4KAEltYWdlIG9wdGlvbnM6IEFsc28gLS1uby1PUFRJT04gYW5kIC0tc2FtZS1PUFRJT04uCiAgLUIsIC0tYmFja2dyb3VuZCBDT0wgICAgICAgICAgTWFrZSBDT0wgdGhlIGJhY2tncm91bmQgY29sb3IuCiAgICAgIC0tY3JvcCBYLFkrV3hILCAtLWNyb3AgWCxZLVgyLFkyCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQ3JvcCB0aGUgaW1hZ2UuCiAgICAgIC0tY3JvcC10cmFuc3BhcmVuY3kgICAgICAgQ3JvcCB0cmFuc3BhcmVudCBib3JkZXJzIG9mZiB0aGUgaW1hZ2UuCiAgICAgIC0tZmxpcC1ob3Jpem9udGFsLCAtLWZsaXAtdmVydGljYWwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBGbGlwIHRoZSBpbWFnZS4AICAtaSwgLS1pbnRlcmxhY2UgICAgICAgICAgICAgICBUdXJuIG9uIGludGVybGFjaW5nLgogIC1TLCAtLWxvZ2ljYWwtc2NyZWVuIFd4SCAgICAgIFNldCBsb2dpY2FsIHNjcmVlbiB0byBXeEguCiAgLXAsIC0tcG9zaXRpb24gWCxZICAgICAgICAgICAgU2V0IGZyYW1lIHBvc2l0aW9uIHRvIChYLFkpLgogICAgICAtLXJvdGF0ZS05MCwgLS1yb3RhdGUtMTgwLCAtLXJvdGF0ZS0yNzAsIC0tbm8tcm90YXRlCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUm90YXRlIHRoZSBpbWFnZS4KICAtdCwgLS10cmFuc3BhcmVudCBDT0wgICAgICAgICBNYWtlIENPTCB0cmFuc3BhcmVudC4KAEV4dGVuc2lvbiBvcHRpb25zOgogICAgICAtLWFwcC1leHRlbnNpb24gTiBEICAgICAgIEFkZCBhbiBhcHAgZXh0ZW5zaW9uIG5hbWVkIE4gd2l0aCBkYXRhIEQuCiAgLWMsIC0tY29tbWVudCBURVhUICAgICAgICAgICAgQWRkIGEgY29tbWVudCBiZWZvcmUgdGhlIG5leHQgZnJhbWUuCiAgICAgIC0tZXh0ZW5zaW9uIE4gRCAgICAgICAgICAgQWRkIGFuIGV4dGVuc2lvbiBudW1iZXIgTiB3aXRoIGRhdGEgRC4KICAtbiwgLS1uYW1lIFRFWFQgICAgICAgICAgICAgICBTZXQgbmV4dCBmcmFtZSdzIG5hbWUuCiAgICAgIC0tbm8tY29tbWVudHMsIC0tbm8tbmFtZXMsIC0tbm8tZXh0ZW5zaW9ucwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFJlbW92ZSBjb21tZW50cyAobmFtZXMsIGV4dGVuc2lvbnMpIGZyb20gaW5wdXQuAEFuaW1hdGlvbiBvcHRpb25zOiBBbHNvIC0tbm8tT1BUSU9OIGFuZCAtLXNhbWUtT1BUSU9OLgogIC1kLCAtLWRlbGF5IFRJTUUgICAgICAgICAgICAgIFNldCBmcmFtZSBkZWxheSB0byBUSU1FIChpbiAxLzEwMHNlYykuCiAgLUQsIC0tZGlzcG9zYWwgTUVUSE9EICAgICAgICAgU2V0IGZyYW1lIGRpc3Bvc2FsIHRvIE1FVEhPRC4KICAtbCwgLS1sb29wY291bnRbPU5dICAgICAgICAgICBTZXQgbG9vcCBleHRlbnNpb24gdG8gTiAoZGVmYXVsdCBmb3JldmVyKS4KICAtTywgLS1vcHRpbWl6ZVs9TEVWRUxdICAgICAgICBPcHRpbWl6ZSBvdXRwdXQgR0lGcy4KICAtVSwgLS11bm9wdGltaXplICAgICAgICAgICAgICBVbm9wdGltaXplIGlucHV0IEdJRnMuACAgLWosIC0tdGhyZWFkc1s9VEhSRUFEU10gICAgICAgVXNlIG11bHRpcGxlIHRocmVhZHMgdG8gaW1wcm92ZSBzcGVlZC4ACldob2xlLUdJRiBvcHRpb25zOiBBbHNvIC0tbm8tT1BUSU9OLgogICAgICAtLWNhcmVmdWwgICAgICAgICAgICAgICAgIFdyaXRlIGxhcmdlciBHSUZzIHRoYXQgYXZvaWQgYnVncyBpbiBvdGhlcgogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb2dyYW1zLgogICAgICAtLWNoYW5nZS1jb2xvciBDT0wxIENPTDIgIENoYW5nZSBDT0wxIHRvIENPTDIgdGhyb3VnaG91dC4KICAtaywgLS1jb2xvcnMgTiAgICAgICAgICAgICAgICBSZWR1Y2UgdGhlIG51bWJlciBvZiBjb2xvcnMgdG8gTi4KICAgICAgLS1jb2xvci1tZXRob2QgTUVUSE9EICAgICBTZXQgbWV0aG9kIGZvciBjaG9vc2luZyByZWR1Y2VkIGNvbG9ycy4KICAtZiwgLS1kaXRoZXIgICAgICAgICAgICAgICAgICBEaXRoZXIgaW1hZ2UgYWZ0ZXIgY2hhbmdpbmcgY29sb3JtYXAuACAgICAgIC0tZ2FtbWEgRyAgICAgICAgICAgICAgICAgU2V0IGdhbW1hIGZvciBjb2xvciByZWR1Y3Rpb24gWzIuMl0uACAgICAgIC0tbG9zc3lbPUxPU1NJTkVTU10gICAgICAgQWx0ZXIgaW1hZ2UgY29sb3JzIHRvIHNocmluayBvdXRwdXQgZmlsZSBzaXplCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXQgdGhlIGNvc3Qgb2YgYXJ0aWZhY3RzIGFuZCBub2lzZS4KICAgICAgLS1yZXNpemUgV3hIICAgICAgICAgICAgICBSZXNpemUgdGhlIG91dHB1dCBHSUYgdG8gV3hILgogICAgICAtLXJlc2l6ZS13aWR0aCBXICAgICAgICAgIFJlc2l6ZSB0byB3aWR0aCBXIGFuZCBwcm9wb3J0aW9uYWwgaGVpZ2h0LgogICAgICAtLXJlc2l6ZS1oZWlnaHQgSCAgICAgICAgIFJlc2l6ZSB0byBoZWlnaHQgSCBhbmQgcHJvcG9ydGlvbmFsIHdpZHRoLgogICAgICAtLXJlc2l6ZS1maXQgV3hIICAgICAgICAgIFJlc2l6ZSBpZiBuZWNlc3NhcnkgdG8gZml0IHdpdGhpbiBXeEguACAgICAgIC0tc2NhbGUgWEZBQ1RPUlt4WUZBQ1RPUl0gU2NhbGUgdGhlIG91dHB1dCBHSUYgYnkgWEZBQ1RPUnhZRkFDVE9SLgogICAgICAtLXJlc2l6ZS1tZXRob2QgTUVUSE9EICAgIFNldCByZXNpemluZyBtZXRob2QuCiAgICAgIC0tcmVzaXplLWNvbG9ycyBOICAgICAgICAgUmVzaXplIGNhbiBhZGQgbmV3IGNvbG9ycyB1cCB0byBOLgogICAgICAtLXRyYW5zZm9ybS1jb2xvcm1hcCBDTUQgIFRyYW5zZm9ybSBlYWNoIG91dHB1dCBjb2xvcm1hcCBieSBzaGVsbCBDTUQuCiAgICAgIC0tdXNlLWNvbG9ybWFwIENNQVAgICAgICAgU2V0IG91dHB1dCBHSUYncyBjb2xvcm1hcCB0byBDTUFQLCB3aGljaCBjYW4KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZSAnd2ViJywgJ2dyYXknLCAnYncnLCBvciBhIEdJRiBmaWxlLgoAAAAAAAAAAAEAAAACAAAAAwAAAAQAAAAFAAAABgAAAAcAAAAIAAAACQAAAP////////////////////////////////////8KAAAACwAAAAwAAAANAAAADgAAAA8AAAD//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////woAAAALAAAADAAAAA0AAAAOAAAADwAAAHhmb3JtLmMAAAAAAC90bXAvZ2lmc2ljbGUuWFhYWFhYAGNhbiUsdCBjcmVhdGUgdGVtcG9yYXJ5IGZpbGUhACVzICA+JXMAdwBjYW4lLHQgcnVuIGNvbG9yIHRyYW5zZm9ybWF0aW9uIGNvbW1hbmQ6ICVzACVkICVkICVkCgBjb2xvciB0cmFuc2Zvcm1hdGlvbiBlcnJvcjogJXMAY29sb3IgdHJhbnNmb3JtYXRpb24gY29tbWFuZCBmYWlsZWQAcgBjb2xvciB0cmFuc2Zvcm1hdGlvbiBjb21tYW5kIGdlbmVyYXRlZCBubyBvdXRwdXQAPGNvbG9yIHRyYW5zZm9ybWF0aW9uPgB0b28gZmV3IGNvbG9ycyBpbiBjb2xvciB0cmFuc2Zvcm1hdGlvbiByZXN1bHRzAHRvbyBtYW55IGNvbG9ycyBpbiBjb2xvciB0cmFuc2Zvcm1hdGlvbiByZXN1bHRzAHJvdGF0aW9uID09IDEgfHwgcm90YXRpb24gPT0gMwByb3RhdGVfaW1hZ2UAbmV3IGltYWdlIGlzIHRvbyBsYXJnZSAobWF4IHNpemUgNjU1MzV4NjU1MzUpAGdmcy0+bmltYWdlcyA+IDAAcmVzaXplX3N0cmVhbQBpbWFnZSB0b28gY29tcGxleCBmb3IgbXVsdGl0aHJlYWRlZCByZXNpemUsIHVzaW5nIDEgdGhyZWFkCiAgKFRyeSBydW5uaW5nIHRoZSBHSUYgdGhyb3VnaCAlPGdpZnNpY2xlIC1VJT4uKQBzY3R4LT5rZDMgPT0gJnNjdHgtPmdsb2JhbF9rZDMAc2NhbGVfaW1hZ2VfdXBkYXRlX2dsb2JhbF9rZDMAKHVuc2lnbmVkKSBpIDwgKHVuc2lnbmVkKSBrZDMtPm5pdGVtcwAuL2tjb2xvci5oAGtkM19kaXNhYmxlAGtkMy0+ZGlzYWJsZWQgPCAwIHx8IGtkMy0+ZGlzYWJsZWQgPT0gaQAha3NzLT5kYXRhICYmICFrc3MtPnNjcmF0Y2gAa3NzY3JlZW5faW5pdAAha2NzLT5kYXRhICYmICFrY3MtPnNjcmF0Y2gAa2NzY3JlZW5faW5pdAAodW5zaWduZWQpIGdmaS0+bGVmdCArIGdmaS0+d2lkdGggPD0ga3NzLT53aWR0aABrc3NjcmVlbl9hcHBseQAodW5zaWduZWQpIGdmaS0+dG9wICsgZ2ZpLT5oZWlnaHQgPD0ga3NzLT5oZWlnaHQAa3NzY3JlZW5fZGlzcG9zZQAodW5zaWduZWQpIGdmaS0+bGVmdCArIGdmaS0+d2lkdGggPD0ga2NzLT53aWR0aABrY3NjcmVlbl9kaXNwb3NlACh1bnNpZ25lZCkgZ2ZpLT50b3AgKyBnZmktPmhlaWdodCA8PSBrY3MtPmhlaWdodABrY3NjcmVlbl9hcHBseQB3LT5pcG9zID49IHlpMCAmJiB3LT5pcG9zIDwgeWkxAHNjYWxlX2ltYWdlX2RhdGFfd2VpZ2h0ZWQAYXBwZW5kAGFwcC1leHRlbnNpb24Abm8tYXBwLWV4dGVuc2lvbnMAYmFja2dyb3VuZABiYXRjaABiZwBjYXJlZnVsAGNoYW5nZS1jb2xvcgBjaW5mbwBjbGlwAGNvbG9ycwBjb2xvci1tZXRob2QAY29sb3ItaW5mbwBjb21tZW50AG5vLWNvbW1lbnRzAGNvbnNlcnZlLW1lbW9yeQBjcm9wAGNyb3AtdHJhbnNwYXJlbmN5AGRlbGF5AGRlbGV0ZQBkaXNwb3NhbABkaXRoZXIAZG9uZQBleHBsb2RlAGV4cGxvZGUtYnktbmFtZQBleHRlbnNpb24Abm8tZXh0ZW5zaW9uAG5vLWV4dGVuc2lvbnMAZXh0ZW5zaW9uLWluZm8AZmxpcC1ob3Jpem9udGFsAGZsaXAtdmVydGljYWwAbm8tZmxpcABnYW1tYQBncmF5AGhlbHAAaWdub3JlLWVycm9ycwBpbmZvAGluc2VydC1iZWZvcmUAaW50ZXJsYWNlAGxvZ2ljYWwtc2NyZWVuAGxvb3Bjb3VudABsb3NzeQBtZXJnZQBtZXRob2QAbXVsdGlmaWxlAG5hbWUAbmV4dGZpbGUAbm8tbmFtZXMAb3B0aW1pemUAb3V0cHV0AHBvc2l0aW9uAHJlcGxhY2UAcmVzaXplAHJlc2l6ZS13aWR0aAByZXNpemUtaGVpZ2h0AHJlc2l6AHJlc2kAcmVzAHJlc2l6ZS1maXQAcmVzaXplLWZpdC13aWR0aAByZXNpemUtZml0LWhlaWdodAByZXNpemUtZmkAcmVzaXplLWYAcmVzaXplLXRvdWNoAHJlc2l6ZS10b3VjaC13aWR0aAByZXNpemUtdG91Y2gtaGVpZ2h0AHJlc2l6ZS10b3VjAHJlc2l6ZS10b3UAcmVzaXplLXRvAHJlc2l6ZS10AHJlc2l6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ZQB0cmFpbGluZyBnYXJiYWdlIGlnbm9yZWQAZmlsZSBub3QgaW4gR0lGIGZvcm1hdAAlczogJTwtLW11bHRpZmlsZSU+IGlzIHVzZWZ1bCBvbmx5IGluIG1lcmdlIG1vZGUAI3N0ZGluIwBHSUYgdG9vIGNvbXBsZXggdG8gdW5vcHRpbWl6ZQogIChUaGUgcmVhc29uIHdhcyBsb2NhbCBjb2xvciB0YWJsZXMgb3IgY29tcGxleCB0cmFuc3BhcmVuY3kuCiAgVHJ5IHJ1bm5pbmcgdGhlIEdJRiB0aHJvdWdoICU8Z2lmc2ljbGUgLS1jb2xvcnM9MjU1JT4gZmlyc3QuKQBHSUYgdG9vIGNvbXBsZXggdG8gdW5vcHRpbWl6ZQAtAGluZmluaXRlAGZvcmV2ZXIAbm9uZQBhc2lzAHByZXZpb3VzAGRpdmVyc2l0eQBibGVuZC1kaXZlcnNpdHkAbWVkaWFuLWN1dABrZWVwLWVtcHR5AG5vLWtlZXAtZW1wdHkAZHJvcC1lbXB0eQBuby1kcm9wLWVtcHR5AHBvaW50AHNhbXBsZQBtaXgAYm94AGNhdHJvbQBsYW5jem9zAGxhbmN6b3MyAGxhbmN6b3MzAG1pdGNoZWxsAGZhc3QAZ29vZAAAAAAAALBGAAD4RQAA60UAAGtZAACwRQAA8EYAABdHAADURQAAJUYAAHhZAAB9WQAAAAAAAMlGAACGWQAAlVkAAKJZAACuWQAAAUYAALxZAADFWQAAXUUAANVZAAAoRwAA6lkAAH9GAAD+WQAADFoAAGRpc3Bvc2FsIG11c3QgYmUgYmV0d2VlbiAwIGFuZCA3AENPTE9SMiBtdXN0IGJlIGluIFJHQiBmb3JtYXQgaW4gJTwtLWNoYW5nZS1jb2xvciBDT0xPUjEgQ09MT1IyJT4AYXJndW1lbnQgdG8gJU8gbXVzdCBiZSBiZXR3ZWVuIDIgYW5kIDI1NgBkZWZhdWx0AHBvc3Rlcml6ZQAlPCVzJT4gaXMgbm90IGEgdmFsaWQgZGl0aGVyAHNSR0IAc3JnYgAlTyBzaG91bGQgYmUgYSBudW1iZXIgb3IgJTxzcmdiJT4Ab25lIG9mIFcgYW5kIEggbXVzdCBiZSBwb3NpdGl2ZSBpbiAlPCVzIFd4SCU+ACVzIGFyZ3VtZW50IG11c3QgYmUgcG9zaXRpdmUAJXMgWCBhbmQgWSBmYWN0b3JzIG11c3QgYmUgcG9zaXRpdmUAJXMgY2FuIGJlIGF0IG1vc3QgMjU2AExDREYgR2lmc2ljbGUgJXMKADEuOTIAZnJhbWUAaW5wdXQAAAAFWwAAFFsAACU8LS1pbmZvJT4gc3VwcHJlc3NlcyBub3JtYWwgb3V0cHV0LCBjYW4lLHQgdXNlIHdpdGggYW4KICBvdXRwdXQgbW9kZSBsaWtlICU8LS1tZXJnZSU+IG9yICU8LS1iYXRjaCU+LgogIChUcnkgJTwtSUklPiwgd2hpY2ggZG9lc24lLHQgc3VwcHJlc3Mgbm9ybWFsIG91dHB1dC4pAHRvbyBsYXRlIHRvIGNoYW5nZSBtb2RlcwBJcyBhIHRlcm1pbmFsAHJiACVzADx1bmtub3duPgAlczojJWQAcmVhZCBlcnJvcjogAAAlcyVzACVzJXMgKCVkIHRpbWVzKQAocGx1cyBtb3JlIGVycm9yczsgaXMgdGhpcyBHSUYgY29ycnVwdD8pAG1pc3NpbmcgJWx1IHBpeGVsAGZhdGFsIGVycm9yOiB0b28gbWFueSBtaXNzaW5nIHBpeGVscywgZ2l2aW5nIHVwAHcAbWVyZ2VfYW5kX3dyaXRlX2ZyYW1lcwAjc3Rkb3V0IwB0cml2aWFsIGFkYXB0aXZlIHBhbGV0dGUgKG9ubHkgJWQgY29sb3JzIGluIHNvdXJjZSkAY2FuJ3QgaGFwcGVuAHdiADxzdGRvdXQ+AElzIGEgdGVybWluYWw6IHRyeSBgLW8gT1VUUFVURklMRWAAcmVkdW5kYW50ICVzIG9wdGlvbgogIChUaGUgJXMgb3B0aW9uIHdhcyBvdmVycmlkZGVuIGJ5IGFub3RoZXIgJXMgb3B0aW9uCiAgYmVmb3JlIGl0IGhhZCBhbnkgZWZmZWN0LikAcmVkdW5kYW50ICVzIG9wdGlvbgB0cmFuc3BhcmVuY3kAZmxpcAByb3RhdGlvbgBsb2dpY2FsIHNjcmVlbgBvcHRpbWl6YXRpb24Ab3V0cHV0IGZpbGUAY29sb3JtYXAgc2l6ZQBjb2xvcm1hcABjb2xvcm1hcCBtZXRob2QAY29sb3IgdHJhbnNmb3JtYXRpb24AbWVtb3J5IGNvbnNlcnZhdGlvbgByZXNpemUgbWV0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c3VjaCBkZXZpY2UATm90IGEgZGlyZWN0b3J5AElzIGEgZGlyZWN0b3J5AFRleHQgZmlsZSBidXN5AEV4ZWMgZm9ybWF0IGVycm9yAEludmFsaWQgYXJndW1lbnQAQXJndW1lbnQgbGlzdCB0b28gbG9uZwBTeW1ib2xpYyBsaW5rIGxvb3AARmlsZW5hbWUgdG9vIGxvbmcAVG9vIG1hbnkgb3BlbiBmaWxlcyBpbiBzeXN0ZW0ATm8gZmlsZSBkZXNjcmlwdG9ycyBhdmFpbGFibGUAQmFkIGZpbGUgZGVzY3JpcHRvcgBObyBjaGlsZCBwcm9jZXNzAEJhZCBhZGRyZXNzAEZpbGUgdG9vIGxhcmdlAFRvbyBtYW55IGxpbmtzAE5vIGxvY2tzIGF2YWlsYWJsZQBSZXNvdXJjZSBkZWFkbG9jayB3b3VsZCBvY2N1cgBTdGF0ZSBub3QgcmVjb3ZlcmFibGUAUHJldmlvdXMgb3duZXIgZGllZABPcGVyYXRpb24gY2FuY2VsZWQARnVuY3Rpb24gbm90IGltcGxlbWVudGVkAE5vIG1lc3NhZ2Ugb2YgZGVzaXJlZCB0eXBlAElkZW50aWZpZXIgcmVtb3ZlZABEZXZpY2Ugbm90IGEgc3RyZWFtAE5vIGRhdGEgYXZhaWxhYmxlAERldmljZSB0aW1lb3V0AE91dCBvZiBzdHJlYW1zIHJlc291cmNlcwBMaW5rIGhhcyBiZWVuIHNldmVyZWQAUHJvdG9jb2wgZXJyb3IAQmFkIG1lc3NhZ2UARmlsZSBkZXNjcmlwdG9yIGluIGJhZCBzdGF0ZQBOb3QgYSBzb2NrZXQARGVzdGluYXRpb24gYWRkcmVzcyByZXF1aXJlZABNZXNzYWdlIHRvbyBsYXJnZQBQcm90b2NvbCB3cm9uZyB0eXBlIGZvciBzb2NrZXQAUHJvdG9jb2wgbm90IGF2YWlsYWJsZQBQcm90b2NvbCBub3Qgc3VwcG9ydGVkAFNvY2tldCB0eXBlIG5vdCBzdXBwb3J0ZWQATm90IHN1cHBvcnRlZABQcm90b2NvbCBmYW1pbHkgbm90IHN1cHBvcnRlZABBZGRyZXNzIGZhbWlseSBub3Qgc3VwcG9ydGVkIGJ5IHByb3RvY29sAEFkZHJlc3Mgbm90IGF2YWlsYWJsZQBOZXR3b3JrIGlzIGRvd24ATmV0d29yayB1bnJlYWNoYWJsZQBDb25uZWN0aW9uIHJlc2V0IGJ5IG5ldHdvcmsAQ29ubmVjdGlvbiBhYm9ydGVkAE5vIGJ1ZmZlciBzcGFjZSBhdmFpbGFibGUAU29ja2V0IGlzIGNvbm5lY3RlZABTb2NrZXQgbm90IGNvbm5lY3RlZABDYW5ub3Qgc2VuZCBhZnRlciBzb2NrZXQgc2h1dGRvd24AT3BlcmF0aW9uIGFscmVhZHkgaW4gcHJvZ3Jlc3MAT3BlcmF0aW9uIGluIHByb2dyZXNzAFN0YWxlIGZpbGUgaGFuZGxlAFJlbW90ZSBJL08gZXJyb3IAUXVvdGEgZXhjZWVkZWQATm8gbWVkaXVtIGZvdW5kAFdyb25nIG1lZGl1bSB0eXBlAE5vIGVycm9yIGluZm9ybWF0aW9uAAByd2EAgIYAABCHAACghwAAAAAAABEACgAREREAAAAABQAAAAAAAAkAAAAACwAAAAAAAAAAEQAPChEREQMKBwABAAkLCwAACQYLAAALAAYRAAAAERERAEHh6AELIQsAAAAAAAAAABEACgoREREACgAAAgAJCwAAAAkACwAACwBBm+kBCwEMAEGn6QELFQwAAAAADAAAAAAJDAAAAAAADAAADABB1ekBCwEOAEHh6QELFQ0AAAAEDQAAAAAJDgAAAAAADgAADgBBj+oBCwEQAEGb6gELHg8AAAAADwAAAAAJEAAAAAAAEAAAEAAAEgAAABISEgBB0uoBCw4SAAAAEhISAAAAAAAACQBBg+sBCwELAEGP6wELFQoAAAAACgAAAAAJCwAAAAAACwAACwBBvesBCwEMAEHJ6wELJwwAAAAADAAAAAAJDAAAAAAADAAADAAALSsgICAwWDB4AChudWxsKQBBgOwBCzAwMTIzNDU2Nzg5QUJDREVGLTBYKzBYIDBYLTB4KzB4IDB4AGluZgBJTkYATkFOAC4AQdzsAQsBPwBBg+0BCwX//////wBB0O0BC4AEAgAAwAMAAMAEAADABQAAwAYAAMAHAADACAAAwAkAAMAKAADACwAAwAwAAMANAADADgAAwA8AAMAQAADAEQAAwBIAAMATAADAFAAAwBUAAMAWAADAFwAAwBgAAMAZAADAGgAAwBsAAMAcAADAHQAAwB4AAMAfAADAAAAAswEAAMMCAADDAwAAwwQAAMMFAADDBgAAwwcAAMMIAADDCQAAwwoAAMMLAADDDAAAww0AANMOAADDDwAAwwAADLsBAAzDAgAMwwMADMMEAAzTAAAAAP////////////////////////////////////////////////////////////////8AAQIDBAUGBwgJ/////////woLDA0ODxAREhMUFRYXGBkaGxwdHh8gISIj////////CgsMDQ4PEBESExQVFhcYGRobHB0eHyAhIiP/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////AAECBAcDBgUAAAAYAAAANQAAAHEAAABr////zvv//5K///9pbmZpbml0eQBuYW4AQeDxAQs2CgAAAGQAAADoAwAAECcAAKCGAQBAQg8AgJaYAADh9QXRdJ4AV529KoBwUg///z4nWFhYWFhYAEGg8gEL1xUDAAAABAAAAAQAAAAGAAAAg/miAERObgD8KRUA0VcnAN009QBi28AAPJmVAEGQQwBjUf4Au96rALdhxQA6biQA0k1CAEkG4AAJ6i4AHJLRAOsd/gApsRwA6D6nAPU1ggBEuy4AnOmEALQmcABBfl8A1pE5AFODOQCc9DkAi1+EACj5vQD4HzsA3v+XAA+YBQARL+8AClqLAG0fbQDPfjYACcsnAEZPtwCeZj8ALepfALondQDl68cAPXvxAPc5BwCSUooA+2vqAB+xXwAIXY0AMANWAHv8RgDwq2sAILzPADb0mgDjqR0AXmGRAAgb5gCFmWUAoBRfAI1AaACA2P8AJ3NNAAYGMQDKVhUAyahzAHviYABrjMAAGcRHAM1nwwAJ6NwAWYMqAIt2xACmHJYARK/dABlX0QClPgUABQf/ADN+PwDCMugAmE/eALt9MgAmPcMAHmvvAJ/4XgA1HzoAf/LKAPGHHQB8kCEAaiR8ANVu+gAwLXcAFTtDALUUxgDDGZ0ArcTCACxNQQAMAF0Ahn1GAONxLQCbxpoAM2IAALTSfAC0p5cAN1XVANc+9gCjEBgATXb8AGSd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";function pe(){try{if(l)return new Uint8Array(l);if(o)return o(P);throw"both async and sync fetching of the wasm failed"}catch(e){D(e)}}function he(){var e=function(){var r=new Error;if(!r.stack){try{throw new Error}catch(e){r=e}if(!r.stack)return"(no stack trace available)"}return r.stack.toString()}();return h.extraStackTrace&&(e+="\\n"+h.extraStackTrace()),e.replace(/\\b_Z[\\w\\d_]+/g,function(e){return e===e?e:e+" ["+e+"]"})}J.push({func:function(){_e()}});var me=s?function(){var e=process.hrtime();return 1e3*e[0]+e[1]/1e6}:"undefined"!=typeof dateNow?dateNow:function(){return performance.now()},we=!0;function A(e){return k[De()>>2]=e}var x={splitPath:function(e){return/^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/.exec(e).slice(1)},normalizeArray:function(e,r){for(var t=0,n=e.length-1;0<=n;n--){var o=e[n];"."===o?e.splice(n,1):".."===o?(e.splice(n,1),t++):t&&(e.splice(n,1),t--)}if(r)for(;t;t--)e.unshift("..");return e},normalize:function(e){var r="/"===e.charAt(0),t="/"===e.substr(-1);return(e=(e=x.normalizeArray(e.split("/").filter(function(e){return!!e}),!r).join("/"))||r?e:".")&&t&&(e+="/"),(r?"/":"")+e},dirname:function(e){var e=x.splitPath(e),r=e[0],e=e[1];return r||e?r+(e=e&&e.substr(0,e.length-1)):"."},basename:function(e){if("/"===e)return"/";var r=e.lastIndexOf("/");return-1===r?e:e.substr(r+1)},extname:function(e){return x.splitPath(e)[3]},join:function(){var e=Array.prototype.slice.call(arguments,0);return x.normalize(e.join("/"))},join2:function(e,r){return x.normalize(e+"/"+r)}},R={resolve:function(){for(var e="",r=!1,t=arguments.length-1;-1<=t&&!r;t--){var n=0<=t?arguments[t]:T.cwd();if("string"!=typeof n)throw new TypeError("Arguments to path.resolve must be strings");if(!n)return"";e=n+"/"+e,r="/"===n.charAt(0)}return(r?"/":"")+(e=x.normalizeArray(e.split("/").filter(function(e){return!!e}),!r).join("/"))||"."},relative:function(e,r){function t(e){for(var r=0;r<e.length&&""===e[r];r++);for(var t=e.length-1;0<=t&&""===e[t];t--);return t<r?[]:e.slice(r,t-r+1)}e=R.resolve(e).substr(1),r=R.resolve(r).substr(1);for(var n=t(e.split("/")),o=t(r.split("/")),i=Math.min(n.length,o.length),a=i,s=0;s<i;s++)if(n[s]!==o[s]){a=s;break}for(var u=[],s=a;s<n.length;s++)u.push("..");return(u=u.concat(o.slice(a))).join("/")}},M={ttys:[],init:function(){},shutdown:function(){},register:function(e,r){M.ttys[e]={input:[],output:[],ops:r},T.registerDevice(e,M.stream_ops)},stream_ops:{open:function(e){var r=M.ttys[e.node.rdev];if(!r)throw new T.ErrnoError(43);e.tty=r,e.seekable=!1},close:function(e){e.tty.ops.flush(e.tty)},flush:function(e){e.tty.ops.flush(e.tty)},read:function(e,r,t,n,o){if(!e.tty||!e.tty.ops.get_char)throw new T.ErrnoError(60);for(var i,a=0,s=0;s<n;s++){try{i=e.tty.ops.get_char(e.tty)}catch(e){throw new T.ErrnoError(29)}if(void 0===i&&0===a)throw new T.ErrnoError(6);if(null==i)break;a++,r[t+s]=i}return a&&(e.node.timestamp=Date.now()),a},write:function(e,r,t,n,o){if(!e.tty||!e.tty.ops.put_char)throw new T.ErrnoError(60);try{for(var i=0;i<n;i++)e.tty.ops.put_char(e.tty,r[t+i])}catch(e){throw new T.ErrnoError(29)}return n&&(e.node.timestamp=Date.now()),i}},default_tty_ops:{get_char:function(e){if(!e.input.length){var r=null;if(s){var t=Buffer.alloc?Buffer.alloc(256):new Buffer(256),n=0;try{n=i.readSync(process.stdin.fd,t,0,256,null)}catch(e){if(-1==e.toString().indexOf("EOF"))throw e;n=0}r=0<n?t.slice(0,n).toString("utf-8"):null}else"undefined"!=typeof window&&"function"==typeof window.prompt?null!==(r=window.prompt("Input: "))&&(r+="\\n"):"function"==typeof readline&&null!==(r=readline())&&(r+="\\n");if(!r)return null;e.input=ye(r,!0)}return e.input.shift()},put_char:function(e,r){null===r||10===r?(m(g(e.output,0)),e.output=[]):0!=r&&e.output.push(r)},flush:function(e){e.output&&0<e.output.length&&(m(g(e.output,0)),e.output=[])}},default_tty1_ops:{put_char:function(e,r){null===r||10===r?(w(g(e.output,0)),e.output=[]):0!=r&&e.output.push(r)},flush:function(e){e.output&&0<e.output.length&&(w(g(e.output,0)),e.output=[])}}},B={ops_table:null,mount:function(e){return B.createNode(null,"/",16895,0)},createNode:function(e,r,t,n){if(T.isBlkdev(t)||T.isFIFO(t))throw new T.ErrnoError(63);B.ops_table||(B.ops_table={dir:{node:{getattr:B.node_ops.getattr,setattr:B.node_ops.setattr,lookup:B.node_ops.lookup,mknod:B.node_ops.mknod,rename:B.node_ops.rename,unlink:B.node_ops.unlink,rmdir:B.node_ops.rmdir,readdir:B.node_ops.readdir,symlink:B.node_ops.symlink},stream:{llseek:B.stream_ops.llseek}},file:{node:{getattr:B.node_ops.getattr,setattr:B.node_ops.setattr},stream:{llseek:B.stream_ops.llseek,read:B.stream_ops.read,write:B.stream_ops.write,allocate:B.stream_ops.allocate,mmap:B.stream_ops.mmap,msync:B.stream_ops.msync}},link:{node:{getattr:B.node_ops.getattr,setattr:B.node_ops.setattr,readlink:B.node_ops.readlink},stream:{}},chrdev:{node:{getattr:B.node_ops.getattr,setattr:B.node_ops.setattr},stream:T.chrdev_stream_ops}});t=T.createNode(e,r,t,n);return T.isDir(t.mode)?(t.node_ops=B.ops_table.dir.node,t.stream_ops=B.ops_table.dir.stream,t.contents={}):T.isFile(t.mode)?(t.node_ops=B.ops_table.file.node,t.stream_ops=B.ops_table.file.stream,t.usedBytes=0,t.contents=null):T.isLink(t.mode)?(t.node_ops=B.ops_table.link.node,t.stream_ops=B.ops_table.link.stream):T.isChrdev(t.mode)&&(t.node_ops=B.ops_table.chrdev.node,t.stream_ops=B.ops_table.chrdev.stream),t.timestamp=Date.now(),e&&(e.contents[r]=t),t},getFileDataAsRegularArray:function(e){if(e.contents&&e.contents.subarray){for(var r=[],t=0;t<e.usedBytes;++t)r.push(e.contents[t]);return r}return e.contents},getFileDataAsTypedArray:function(e){return e.contents?e.contents.subarray?e.contents.subarray(0,e.usedBytes):new Uint8Array(e.contents):new Uint8Array(0)},expandFileStorage:function(e,r){var t=e.contents?e.contents.length:0;r<=t||(r=Math.max(r,t*(t<1048576?2:1.125)>>>0),0!=t&&(r=Math.max(r,256)),t=e.contents,e.contents=new Uint8Array(r),0<e.usedBytes&&e.contents.set(t.subarray(0,e.usedBytes),0))},resizeFileStorage:function(e,r){if(e.usedBytes!=r){if(0==r)return e.contents=null,void(e.usedBytes=0);var t;if(!e.contents||e.contents.subarray)return t=e.contents,e.contents=new Uint8Array(r),t&&e.contents.set(t.subarray(0,Math.min(r,e.usedBytes))),void(e.usedBytes=r);if(e.contents||(e.contents=[]),e.contents.length>r)e.contents.length=r;else for(;e.contents.length<r;)e.contents.push(0);e.usedBytes=r}},node_ops:{getattr:function(e){var r={};return r.dev=T.isChrdev(e.mode)?e.id:1,r.ino=e.id,r.mode=e.mode,r.nlink=1,r.uid=0,r.gid=0,r.rdev=e.rdev,T.isDir(e.mode)?r.size=4096:T.isFile(e.mode)?r.size=e.usedBytes:T.isLink(e.mode)?r.size=e.link.length:r.size=0,r.atime=new Date(e.timestamp),r.mtime=new Date(e.timestamp),r.ctime=new Date(e.timestamp),r.blksize=4096,r.blocks=Math.ceil(r.size/r.blksize),r},setattr:function(e,r){void 0!==r.mode&&(e.mode=r.mode),void 0!==r.timestamp&&(e.timestamp=r.timestamp),void 0!==r.size&&B.resizeFileStorage(e,r.size)},lookup:function(e,r){throw T.genericErrors[44]},mknod:function(e,r,t,n){return B.createNode(e,r,t,n)},rename:function(e,r,t){if(T.isDir(e.mode)){var n;try{n=T.lookupNode(r,t)}catch(e){}if(n)for(var o in n.contents)throw new T.ErrnoError(55)}delete e.parent.contents[e.name],e.name=t,(r.contents[t]=e).parent=r},unlink:function(e,r){delete e.contents[r]},rmdir:function(e,r){for(var t in T.lookupNode(e,r).contents)throw new T.ErrnoError(55);delete e.contents[r]},readdir:function(e){var r,t=[".",".."];for(r in e.contents)e.contents.hasOwnProperty(r)&&t.push(r);return t},symlink:function(e,r,t){e=B.createNode(e,r,41471,0);return e.link=t,e},readlink:function(e){if(T.isLink(e.mode))return e.link;throw new T.ErrnoError(28)}},stream_ops:{read:function(e,r,t,n,o){var i=e.node.contents;if(o>=e.node.usedBytes)return 0;var a=Math.min(e.node.usedBytes-o,n);if(8<a&&i.subarray)r.set(i.subarray(o,o+a),t);else for(var s=0;s<a;s++)r[t+s]=i[o+s];return a},write:function(e,r,t,n,o,i){if(r.buffer===y.buffer&&(i=!1),!n)return 0;var a=e.node;if(a.timestamp=Date.now(),r.subarray&&(!a.contents||a.contents.subarray)){if(i)return a.contents=r.subarray(t,t+n),a.usedBytes=n;if(0===a.usedBytes&&0===o)return a.contents=r.slice(t,t+n),a.usedBytes=n;if(o+n<=a.usedBytes)return a.contents.set(r.subarray(t,t+n),o),n}if(B.expandFileStorage(a,o+n),a.contents.subarray&&r.subarray)a.contents.set(r.subarray(t,t+n),o);else for(var s=0;s<n;s++)a.contents[o+s]=r[t+s];return a.usedBytes=Math.max(a.usedBytes,o+n),n},llseek:function(e,r,t){if(1===t?r+=e.position:2===t&&T.isFile(e.node.mode)&&(r+=e.node.usedBytes),r<0)throw new T.ErrnoError(28);return r},allocate:function(e,r,t){B.expandFileStorage(e.node,r+t),e.node.usedBytes=Math.max(e.node.usedBytes,r+t)},mmap:function(e,r,t,n,o,i){if(H(0===r),!T.isFile(e.node.mode))throw new T.ErrnoError(43);var a,s,r=e.node.contents;if(2&i||r.buffer!==v){if((0<n||n+t<r.length)&&(r=r.subarray?r.subarray(n,n+t):Array.prototype.slice.call(r,n,n+t)),s=!0,!(a=be(t)))throw new T.ErrnoError(48);y.set(r,a)}else s=!1,a=r.byteOffset;return{ptr:a,allocated:s}},msync:function(e,r,t,n,o){if(T.isFile(e.node.mode))return 2&o||B.stream_ops.write(e,r,0,n,t,!1),0;throw new T.ErrnoError(43)}}},T={root:null,mounts:[],devices:{},streams:[],nextInode:1,nameTable:null,currentPath:"/",initialized:!1,ignorePermissions:!0,trackingDelegate:{},tracking:{openFlags:{READ:1,WRITE:2}},ErrnoError:null,genericErrors:{},filesystems:null,syncFSRequests:0,handleFSError:function(e){if(e instanceof T.ErrnoError)return A(e.errno);throw e+" : "+he()},lookupPath:function(e,r){if(r=r||{},!(e=R.resolve(T.cwd(),e)))return{path:"",node:null};var t,n={follow_mount:!0,recurse_count:0};for(t in n)void 0===r[t]&&(r[t]=n[t]);if(8<r.recurse_count)throw new T.ErrnoError(32);for(var o=x.normalizeArray(e.split("/").filter(function(e){return!!e}),!1),i=T.root,a="/",s=0;s<o.length;s++){var u=s===o.length-1;if(u&&r.parent)break;if(i=T.lookupNode(i,o[s]),a=x.join2(a,o[s]),!T.isMountpoint(i)||u&&!r.follow_mount||(i=i.mounted.root),!u||r.follow)for(var c=0;T.isLink(i.mode);){var f=T.readlink(a),a=R.resolve(x.dirname(a),f),i=T.lookupPath(a,{recurse_count:r.recurse_count}).node;if(40<c++)throw new T.ErrnoError(32)}}return{path:a,node:i}},getPath:function(e){for(var r,t;;){if(T.isRoot(e))return t=e.mount.mountpoint,r?"/"!==t[t.length-1]?t+"/"+r:t+r:t;r=r?e.name+"/"+r:e.name,e=e.parent}},hashName:function(e,r){for(var t=0,n=0;n<r.length;n++)t=(t<<5)-t+r.charCodeAt(n)|0;return(e+t>>>0)%T.nameTable.length},hashAddNode:function(e){var r=T.hashName(e.parent.id,e.name);e.name_next=T.nameTable[r],T.nameTable[r]=e},hashRemoveNode:function(e){var r=T.hashName(e.parent.id,e.name);if(T.nameTable[r]===e)T.nameTable[r]=e.name_next;else for(var t=T.nameTable[r];t;){if(t.name_next===e){t.name_next=e.name_next;break}t=t.name_next}},lookupNode:function(e,r){var t=T.mayLookup(e);if(t)throw new T.ErrnoError(t,e);for(var t=T.hashName(e.id,r),n=T.nameTable[t];n;n=n.name_next){var o=n.name;if(n.parent.id===e.id&&o===r)return n}return T.lookup(e,r)},createNode:function(e,r,t,n){e=new T.FSNode(e,r,t,n);return T.hashAddNode(e),e},destroyNode:function(e){T.hashRemoveNode(e)},isRoot:function(e){return e===e.parent},isMountpoint:function(e){return!!e.mounted},isFile:function(e){return 32768==(61440&e)},isDir:function(e){return 16384==(61440&e)},isLink:function(e){return 40960==(61440&e)},isChrdev:function(e){return 8192==(61440&e)},isBlkdev:function(e){return 24576==(61440&e)},isFIFO:function(e){return 4096==(61440&e)},isSocket:function(e){return 49152==(49152&e)},flagModes:{r:0,rs:1052672,"r+":2,w:577,wx:705,xw:705,"w+":578,"wx+":706,"xw+":706,a:1089,ax:1217,xa:1217,"a+":1090,"ax+":1218,"xa+":1218},modeStringToFlags:function(e){var r=T.flagModes[e];if(void 0===r)throw new Error("Unknown file open mode: "+e);return r},flagsToPermissionString:function(e){var r=["r","w","rw"][3&e];return 512&e&&(r+="w"),r},nodePermissions:function(e,r){return T.ignorePermissions||(-1===r.indexOf("r")||292&e.mode)&&(-1===r.indexOf("w")||146&e.mode)&&(-1===r.indexOf("x")||73&e.mode)?0:2},mayLookup:function(e){var r=T.nodePermissions(e,"x");return r||(e.node_ops.lookup?0:2)},mayCreate:function(e,r){try{T.lookupNode(e,r);return 20}catch(e){}return T.nodePermissions(e,"wx")},mayDelete:function(e,r,t){var n;try{n=T.lookupNode(e,r)}catch(e){return e.errno}r=T.nodePermissions(e,"wx");if(r)return r;if(t){if(!T.isDir(n.mode))return 54;if(T.isRoot(n)||T.getPath(n)===T.cwd())return 10}else if(T.isDir(n.mode))return 31;return 0},mayOpen:function(e,r){return e?T.isLink(e.mode)?32:T.isDir(e.mode)&&("r"!==T.flagsToPermissionString(r)||512&r)?31:T.nodePermissions(e,T.flagsToPermissionString(r)):44},MAX_OPEN_FDS:4096,nextfd:function(e,r){r=r||T.MAX_OPEN_FDS;for(var t=e=e||0;t<=r;t++)if(!T.streams[t])return t;throw new T.ErrnoError(33)},getStream:function(e){return T.streams[e]},createStream:function(e,r,t){T.FSStream||(T.FSStream=function(){},T.FSStream.prototype={object:{get:function(){return this.node},set:function(e){this.node=e}},isRead:{get:function(){return 1!=(2097155&this.flags)}},isWrite:{get:function(){return 0!=(2097155&this.flags)}},isAppend:{get:function(){return 1024&this.flags}}});var n,o=new T.FSStream;for(n in e)o[n]=e[n];e=o;r=T.nextfd(r,t);return e.fd=r,T.streams[r]=e},closeStream:function(e){T.streams[e]=null},chrdev_stream_ops:{open:function(e){var r=T.getDevice(e.node.rdev);e.stream_ops=r.stream_ops,e.stream_ops.open&&e.stream_ops.open(e)},llseek:function(){throw new T.ErrnoError(70)}},major:function(e){return e>>8},minor:function(e){return 255&e},makedev:function(e,r){return e<<8|r},registerDevice:function(e,r){T.devices[e]={stream_ops:r}},getDevice:function(e){return T.devices[e]},getMounts:function(e){for(var r=[],t=[e];t.length;){var n=t.pop();r.push(n),t.push.apply(t,n.mounts)}return r},syncfs:function(r,t){"function"==typeof r&&(t=r,r=!1),T.syncFSRequests++,1<T.syncFSRequests&&w("warning: "+T.syncFSRequests+" FS.syncfs operations in flight at once, probably just doing extra work");var n=T.getMounts(T.root.mount),o=0;function i(e){return T.syncFSRequests--,t(e)}function a(e){if(e)return a.errored?void 0:(a.errored=!0,i(e));++o>=n.length&&i(null)}n.forEach(function(e){if(!e.type.syncfs)return a(null);e.type.syncfs(e,r,a)})},mount:function(e,r,t){var n,o="/"===t,i=!t;if(o&&T.root)throw new T.ErrnoError(10);if(!o&&!i){i=T.lookupPath(t,{follow_mount:!1});if(t=i.path,n=i.node,T.isMountpoint(n))throw new T.ErrnoError(10);if(!T.isDir(n.mode))throw new T.ErrnoError(54)}i={type:e,opts:r,mountpoint:t,mounts:[]},r=e.mount(i);return(r.mount=i).root=r,o?T.root=r:n&&(n.mounted=i,n.mount&&n.mount.mounts.push(i)),r},unmount:function(e){e=T.lookupPath(e,{follow_mount:!1});if(!T.isMountpoint(e.node))throw new T.ErrnoError(28);var e=e.node,r=e.mounted,n=T.getMounts(r),r=(Object.keys(T.nameTable).forEach(function(e){for(var r=T.nameTable[e];r;){var t=r.name_next;-1!==n.indexOf(r.mount)&&T.destroyNode(r),r=t}}),e.mounted=null,e.mount.mounts.indexOf(r));e.mount.mounts.splice(r,1)},lookup:function(e,r){return e.node_ops.lookup(e,r)},mknod:function(e,r,t){var n=T.lookupPath(e,{parent:!0}).node,e=x.basename(e);if(!e||"."===e||".."===e)throw new T.ErrnoError(28);var o=T.mayCreate(n,e);if(o)throw new T.ErrnoError(o);if(n.node_ops.mknod)return n.node_ops.mknod(n,e,r,t);throw new T.ErrnoError(63)},create:function(e,r){return T.mknod(e,r=(r=void 0!==r?r:438)&4095|32768,0)},mkdir:function(e,r){return T.mknod(e,r=(r=void 0!==r?r:511)&1023|16384,0)},mkdirTree:function(e,r){for(var t=e.split("/"),n="",o=0;o<t.length;++o)if(t[o]){n+="/"+t[o];try{T.mkdir(n,r)}catch(e){if(20!=e.errno)throw e}}},mkdev:function(e,r,t){return void 0===t&&(t=r,r=438),T.mknod(e,r|=8192,t)},symlink:function(e,r){if(!R.resolve(e))throw new T.ErrnoError(44);var t=T.lookupPath(r,{parent:!0}).node;if(!t)throw new T.ErrnoError(44);var r=x.basename(r),n=T.mayCreate(t,r);if(n)throw new T.ErrnoError(n);if(t.node_ops.symlink)return t.node_ops.symlink(t,r,e);throw new T.ErrnoError(63)},rename:function(r,t){var e,n,o=x.dirname(r),i=x.dirname(t),a=x.basename(r),s=x.basename(t);try{e=T.lookupPath(r,{parent:!0}).node,n=T.lookupPath(t,{parent:!0}).node}catch(e){throw new T.ErrnoError(10)}if(!e||!n)throw new T.ErrnoError(44);if(e.mount!==n.mount)throw new T.ErrnoError(75);var u,c=T.lookupNode(e,a),i=R.relative(r,i);if("."!==i.charAt(0))throw new T.ErrnoError(28);if("."!==(i=R.relative(t,o)).charAt(0))throw new T.ErrnoError(55);try{u=T.lookupNode(n,s)}catch(e){}if(c!==u){o=T.isDir(c.mode),i=T.mayDelete(e,a,o);if(i)throw new T.ErrnoError(i);if(i=u?T.mayDelete(n,s,o):T.mayCreate(n,s))throw new T.ErrnoError(i);if(!e.node_ops.rename)throw new T.ErrnoError(63);if(T.isMountpoint(c)||u&&T.isMountpoint(u))throw new T.ErrnoError(10);if(n!==e&&(i=T.nodePermissions(e,"w")))throw new T.ErrnoError(i);try{T.trackingDelegate.willMovePath}catch(e){w("FS.trackingDelegate[\'willMovePath\'](\'"+r+"\', \'"+t+"\') threw an exception: "+e.message)}T.hashRemoveNode(c);try{e.node_ops.rename(c,n,s)}catch(e){throw e}finally{T.hashAddNode(c)}try{T.trackingDelegate.onMovePath}catch(e){w("FS.trackingDelegate[\'onMovePath\'](\'"+r+"\', \'"+t+"\') threw an exception: "+e.message)}}},rmdir:function(r){var e=T.lookupPath(r,{parent:!0}).node,t=x.basename(r),n=T.lookupNode(e,t),o=T.mayDelete(e,t,!0);if(o)throw new T.ErrnoError(o);if(!e.node_ops.rmdir)throw new T.ErrnoError(63);if(T.isMountpoint(n))throw new T.ErrnoError(10);try{T.trackingDelegate.willDeletePath}catch(e){w("FS.trackingDelegate[\'willDeletePath\'](\'"+r+"\') threw an exception: "+e.message)}e.node_ops.rmdir(e,t),T.destroyNode(n);try{T.trackingDelegate.onDeletePath}catch(e){w("FS.trackingDelegate[\'onDeletePath\'](\'"+r+"\') threw an exception: "+e.message)}},readdir:function(e){e=T.lookupPath(e,{follow:!0}).node;if(e.node_ops.readdir)return e.node_ops.readdir(e);throw new T.ErrnoError(54)},unlink:function(r){var e=T.lookupPath(r,{parent:!0}).node,t=x.basename(r),n=T.lookupNode(e,t),o=T.mayDelete(e,t,!1);if(o)throw new T.ErrnoError(o);if(!e.node_ops.unlink)throw new T.ErrnoError(63);if(T.isMountpoint(n))throw new T.ErrnoError(10);try{T.trackingDelegate.willDeletePath}catch(e){w("FS.trackingDelegate[\'willDeletePath\'](\'"+r+"\') threw an exception: "+e.message)}e.node_ops.unlink(e,t),T.destroyNode(n);try{T.trackingDelegate.onDeletePath}catch(e){w("FS.trackingDelegate[\'onDeletePath\'](\'"+r+"\') threw an exception: "+e.message)}},readlink:function(e){e=T.lookupPath(e).node;if(!e)throw new T.ErrnoError(44);if(e.node_ops.readlink)return R.resolve(T.getPath(e.parent),e.node_ops.readlink(e));throw new T.ErrnoError(28)},stat:function(e,r){e=T.lookupPath(e,{follow:!r}).node;if(!e)throw new T.ErrnoError(44);if(e.node_ops.getattr)return e.node_ops.getattr(e);throw new T.ErrnoError(63)},lstat:function(e){return T.stat(e,!0)},chmod:function(e,r,t){if(!(t="string"==typeof e?T.lookupPath(e,{follow:!t}).node:e).node_ops.setattr)throw new T.ErrnoError(63);t.node_ops.setattr(t,{mode:4095&r|-4096&t.mode,timestamp:Date.now()})},lchmod:function(e,r){T.chmod(e,r,!0)},fchmod:function(e,r){e=T.getStream(e);if(!e)throw new T.ErrnoError(8);T.chmod(e.node,r)},chown:function(e,r,t,n){if(!(n="string"==typeof e?T.lookupPath(e,{follow:!n}).node:e).node_ops.setattr)throw new T.ErrnoError(63);n.node_ops.setattr(n,{timestamp:Date.now()})},lchown:function(e,r,t){T.chown(e,r,t,!0)},fchown:function(e,r,t){e=T.getStream(e);if(!e)throw new T.ErrnoError(8);T.chown(e.node,r,t)},truncate:function(e,r){if(r<0)throw new T.ErrnoError(28);if(!(e="string"==typeof e?T.lookupPath(e,{follow:!0}).node:e).node_ops.setattr)throw new T.ErrnoError(63);if(T.isDir(e.mode))throw new T.ErrnoError(31);if(!T.isFile(e.mode))throw new T.ErrnoError(28);var t=T.nodePermissions(e,"w");if(t)throw new T.ErrnoError(t);e.node_ops.setattr(e,{size:r,timestamp:Date.now()})},ftruncate:function(e,r){e=T.getStream(e);if(!e)throw new T.ErrnoError(8);if(0==(2097155&e.flags))throw new T.ErrnoError(28);T.truncate(e.node,r)},utime:function(e,r,t){e=T.lookupPath(e,{follow:!0}).node;e.node_ops.setattr(e,{timestamp:Math.max(r,t)})},open:function(r,e,t,n,o){if(""===r)throw new T.ErrnoError(44);if(t=void 0===t?438:t,t=64&(e="string"==typeof e?T.modeStringToFlags(e):e)?4095&t|32768:0,"object"==typeof r)i=r;else{r=x.normalize(r);try{var i=T.lookupPath(r,{follow:!(131072&e)}).node}catch(e){}}var a=!1;if(64&e)if(i){if(128&e)throw new T.ErrnoError(20)}else i=T.mknod(r,t,0),a=!0;if(!i)throw new T.ErrnoError(44);if(T.isChrdev(i.mode)&&(e&=-513),65536&e&&!T.isDir(i.mode))throw new T.ErrnoError(54);if(!a){t=T.mayOpen(i,e);if(t)throw new T.ErrnoError(t)}512&e&&T.truncate(i,0),e&=-131713;a=T.createStream({node:i,path:T.getPath(i),flags:e,seekable:!0,position:0,stream_ops:i.stream_ops,ungotten:[],error:!1},n,o);a.stream_ops.open&&a.stream_ops.open(a),!h.logReadFiles||1&e||(T.readFiles||(T.readFiles={}),r in T.readFiles||(T.readFiles[r]=1,w("FS.trackingDelegate error on read file: "+r)));try{T.trackingDelegate.onOpenFile}catch(e){w("FS.trackingDelegate[\'onOpenFile\'](\'"+r+"\', flags) threw an exception: "+e.message)}return a},close:function(e){if(T.isClosed(e))throw new T.ErrnoError(8);e.getdents&&(e.getdents=null);try{e.stream_ops.close&&e.stream_ops.close(e)}catch(e){throw e}finally{T.closeStream(e.fd)}e.fd=null},isClosed:function(e){return null===e.fd},llseek:function(e,r,t){if(T.isClosed(e))throw new T.ErrnoError(8);if(!e.seekable||!e.stream_ops.llseek)throw new T.ErrnoError(70);if(0!=t&&1!=t&&2!=t)throw new T.ErrnoError(28);return e.position=e.stream_ops.llseek(e,r,t),e.ungotten=[],e.position},read:function(e,r,t,n,o){if(n<0||o<0)throw new T.ErrnoError(28);if(T.isClosed(e))throw new T.ErrnoError(8);if(1==(2097155&e.flags))throw new T.ErrnoError(8);if(T.isDir(e.node.mode))throw new T.ErrnoError(31);if(!e.stream_ops.read)throw new T.ErrnoError(28);var i=void 0!==o;if(i){if(!e.seekable)throw new T.ErrnoError(70)}else o=e.position;r=e.stream_ops.read(e,r,t,n,o);return i||(e.position+=r),r},write:function(r,e,t,n,o,i){if(n<0||o<0)throw new T.ErrnoError(28);if(T.isClosed(r))throw new T.ErrnoError(8);if(0==(2097155&r.flags))throw new T.ErrnoError(8);if(T.isDir(r.node.mode))throw new T.ErrnoError(31);if(!r.stream_ops.write)throw new T.ErrnoError(28);r.seekable&&1024&r.flags&&T.llseek(r,0,2);var a=void 0!==o;if(a){if(!r.seekable)throw new T.ErrnoError(70)}else o=r.position;e=r.stream_ops.write(r,e,t,n,o,i);a||(r.position+=e);try{r.path&&T.trackingDelegate.onWriteToFile&&T.trackingDelegate.onWriteToFile(r.path)}catch(e){w("FS.trackingDelegate[\'onWriteToFile\'](\'"+r.path+"\') threw an exception: "+e.message)}return e},allocate:function(e,r,t){if(T.isClosed(e))throw new T.ErrnoError(8);if(r<0||t<=0)throw new T.ErrnoError(28);if(0==(2097155&e.flags))throw new T.ErrnoError(8);if(!T.isFile(e.node.mode)&&!T.isDir(e.node.mode))throw new T.ErrnoError(43);if(!e.stream_ops.allocate)throw new T.ErrnoError(138);e.stream_ops.allocate(e,r,t)},mmap:function(e,r,t,n,o,i){if(0!=(2&o)&&0==(2&i)&&2!=(2097155&e.flags))throw new T.ErrnoError(2);if(1==(2097155&e.flags))throw new T.ErrnoError(2);if(e.stream_ops.mmap)return e.stream_ops.mmap(e,r,t,n,o,i);throw new T.ErrnoError(43)},msync:function(e,r,t,n,o){return e&&e.stream_ops.msync?e.stream_ops.msync(e,r,t,n,o):0},munmap:function(e){return 0},ioctl:function(e,r,t){if(e.stream_ops.ioctl)return e.stream_ops.ioctl(e,r,t);throw new T.ErrnoError(59)},readFile:function(e,r){if((r=r||{}).flags=r.flags||"r",r.encoding=r.encoding||"binary","utf8"!==r.encoding&&"binary"!==r.encoding)throw new Error(\'Invalid encoding type "\'+r.encoding+\'"\');var t,n=T.open(e,r.flags),e=T.stat(e).size,o=new Uint8Array(e);return T.read(n,o,0,e,0),"utf8"===r.encoding?t=g(o,0):"binary"===r.encoding&&(t=o),T.close(n),t},writeFile:function(e,r,t){(t=t||{}).flags=t.flags||"w";e=T.open(e,t.flags,t.mode);if("string"==typeof r){var n=new Uint8Array(G(r)+1),o=X(r,n,0,n.length);T.write(e,n,0,o,void 0,t.canOwn)}else{if(!ArrayBuffer.isView(r))throw new Error("Unsupported data type");T.write(e,r,0,r.byteLength,void 0,t.canOwn)}T.close(e)},cwd:function(){return T.currentPath},chdir:function(e){e=T.lookupPath(e,{follow:!0});if(null===e.node)throw new T.ErrnoError(44);if(!T.isDir(e.node.mode))throw new T.ErrnoError(54);var r=T.nodePermissions(e.node,"x");if(r)throw new T.ErrnoError(r);T.currentPath=e.path},createDefaultDirectories:function(){T.mkdir("/tmp"),T.mkdir("/home"),T.mkdir("/home/web_user")},createDefaultDevices:function(){if(T.mkdir("/dev"),T.registerDevice(T.makedev(1,3),{read:function(){return 0},write:function(e,r,t,n,o){return n}}),T.mkdev("/dev/null",T.makedev(1,3)),M.register(T.makedev(5,0),M.default_tty_ops),M.register(T.makedev(6,0),M.default_tty1_ops),T.mkdev("/dev/tty",T.makedev(5,0)),T.mkdev("/dev/tty1",T.makedev(6,0)),"object"==typeof crypto&&"function"==typeof crypto.getRandomValues)var e=new Uint8Array(1),r=function(){return crypto.getRandomValues(e),e[0]};else if(s)try{var t=require("crypto");r=function(){return t.randomBytes(1)[0]}}catch(e){}T.createDevice("/dev","random",r=r||function(){D("random_device")}),T.createDevice("/dev","urandom",r),T.mkdir("/dev/shm"),T.mkdir("/dev/shm/tmp")},createSpecialDirectories:function(){T.mkdir("/proc"),T.mkdir("/proc/self"),T.mkdir("/proc/self/fd"),T.mount({mount:function(){var e=T.createNode("/proc/self","fd",16895,73);return e.node_ops={lookup:function(e,r){var t=T.getStream(+r);if(!t)throw new T.ErrnoError(8);r={parent:null,mount:{mountpoint:"fake"},node_ops:{readlink:function(){return t.path}}};return r.parent=r}},e}},{},"/proc/self/fd")},createStandardStreams:function(){h.stdin?T.createDevice("/dev","stdin",h.stdin):T.symlink("/dev/tty","/dev/stdin"),h.stdout?T.createDevice("/dev","stdout",null,h.stdout):T.symlink("/dev/tty","/dev/stdout"),h.stderr?T.createDevice("/dev","stderr",null,h.stderr):T.symlink("/dev/tty1","/dev/stderr"),T.open("/dev/stdin","r"),T.open("/dev/stdout","w"),T.open("/dev/stderr","w")},ensureErrnoError:function(){T.ErrnoError||(T.ErrnoError=function(e,r){this.node=r,this.setErrno=function(e){this.errno=e},this.setErrno(e),this.message="FS error"},T.ErrnoError.prototype=new Error,T.ErrnoError.prototype.constructor=T.ErrnoError,[44].forEach(function(e){T.genericErrors[e]=new T.ErrnoError(e),T.genericErrors[e].stack="<generic error, no stack>"}))},staticInit:function(){T.ensureErrnoError(),T.nameTable=new Array(4096),T.mount(B,{},"/"),T.createDefaultDirectories(),T.createDefaultDevices(),T.createSpecialDirectories(),T.filesystems={MEMFS:B}},init:function(e,r,t){T.init.initialized=!0,T.ensureErrnoError(),h.stdin=e||h.stdin,h.stdout=r||h.stdout,h.stderr=t||h.stderr,T.createStandardStreams()},quit:function(){T.init.initialized=!1;var e=h._fflush;e&&e(0);for(var r=0;r<T.streams.length;r++){var t=T.streams[r];t&&T.close(t)}},getMode:function(e,r){var t=0;return e&&(t|=365),r&&(t|=146),t},joinPath:function(e,r){e=x.join.apply(null,e);return e=r&&"/"==e[0]?e.substr(1):e},absolutePath:function(e,r){return R.resolve(r,e)},standardizePath:function(e){return x.normalize(e)},findObject:function(e,r){e=T.analyzePath(e,r);return e.exists?e.object:(A(e.error),null)},analyzePath:function(e,r){try{e=(n=T.lookupPath(e,{follow:!r})).path}catch(e){}var t={isRoot:!1,exists:!1,error:0,name:null,path:null,object:null,parentExists:!1,parentPath:null,parentObject:null};try{var n=T.lookupPath(e,{parent:!0});t.parentExists=!0,t.parentPath=n.path,t.parentObject=n.node,t.name=x.basename(e),n=T.lookupPath(e,{follow:!r}),t.exists=!0,t.path=n.path,t.object=n.node,t.name=n.node.name,t.isRoot="/"===n.path}catch(e){t.error=e.errno}return t},createFolder:function(e,r,t,n){e=x.join2("string"==typeof e?e:T.getPath(e),r),r=T.getMode(t,n);return T.mkdir(e,r)},createPath:function(e,r,t,n){e="string"==typeof e?e:T.getPath(e);for(var o=r.split("/").reverse();o.length;){var i=o.pop();if(i){var a=x.join2(e,i);try{T.mkdir(a)}catch(e){}e=a}}return a},createFile:function(e,r,t,n,o){e=x.join2("string"==typeof e?e:T.getPath(e),r),r=T.getMode(n,o);return T.create(e,r)},createDataFile:function(e,r,t,n,o,i){r=r?x.join2("string"==typeof e?e:T.getPath(e),r):e,e=T.getMode(n,o),n=T.create(r,e);if(t){if("string"==typeof t){for(var a=new Array(t.length),s=0,u=t.length;s<u;++s)a[s]=t.charCodeAt(s);t=a}T.chmod(n,146|e);o=T.open(n,"w");T.write(o,t,0,t.length,0,i),T.close(o),T.chmod(n,e)}return n},createDevice:function(e,r,u,a){var e=x.join2("string"==typeof e?e:T.getPath(e),r),r=T.getMode(!!u,!!a),t=(T.createDevice.major||(T.createDevice.major=64),T.makedev(T.createDevice.major++,0));return T.registerDevice(t,{open:function(e){e.seekable=!1},close:function(e){a&&a.buffer&&a.buffer.length&&a(10)},read:function(e,r,t,n,o){for(var i,a=0,s=0;s<n;s++){try{i=u()}catch(e){throw new T.ErrnoError(29)}if(void 0===i&&0===a)throw new T.ErrnoError(6);if(null==i)break;a++,r[t+s]=i}return a&&(e.node.timestamp=Date.now()),a},write:function(e,r,t,n,o){for(var i=0;i<n;i++)try{a(r[t+i])}catch(e){throw new T.ErrnoError(29)}return n&&(e.node.timestamp=Date.now()),i}}),T.mkdev(e,r,t)},createLink:function(e,r,t,n,o){e=x.join2("string"==typeof e?e:T.getPath(e),r);return T.symlink(t,e)},forceLoadFile:function(e){if(e.isDevice||e.isFolder||e.link||e.contents)return!0;var r=!0;if("undefined"!=typeof XMLHttpRequest)throw new Error("Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.");if(!n)throw new Error("Cannot load without read() or XMLHttpRequest.");try{e.contents=ye(n(e.url),!0),e.usedBytes=e.contents.length}catch(e){r=!1}return r||A(29),r},createLazyFile:function(e,r,a,t,n){function o(){this.lengthKnown=!1,this.chunks=[]}if(o.prototype.get=function(e){var r;if(!(e>this.length-1||e<0))return r=e%this.chunkSize,e=e/this.chunkSize|0,this.getter(e)[r]},o.prototype.setDataGetter=function(e){this.getter=e},o.prototype.cacheLength=function(){var e=new XMLHttpRequest;if(e.open("HEAD",a,!1),e.send(null),!(200<=e.status&&e.status<300||304===e.status))throw new Error("Couldn\'t load "+a+". Status: "+e.status);var r,n=Number(e.getResponseHeader("Content-length")),t=(r=e.getResponseHeader("Accept-Ranges"))&&"bytes"===r,e=(r=e.getResponseHeader("Content-Encoding"))&&"gzip"===r,o=1048576,i=(t||(o=n),this);i.setDataGetter(function(e){var r=e*o,t=(e+1)*o-1,t=Math.min(t,n-1);if(void 0===i.chunks[e]&&(i.chunks[e]=function(e,r){if(r<e)throw new Error("invalid range ("+e+", "+r+") or no bytes requested!");if(n-1<r)throw new Error("only "+n+" bytes available! programmer error!");var t=new XMLHttpRequest;if(t.open("GET",a,!1),n!==o&&t.setRequestHeader("Range","bytes="+e+"-"+r),"undefined"!=typeof Uint8Array&&(t.responseType="arraybuffer"),t.overrideMimeType&&t.overrideMimeType("text/plain; charset=x-user-defined"),t.send(null),200<=t.status&&t.status<300||304===t.status)return void 0!==t.response?new Uint8Array(t.response||[]):ye(t.responseText||"",!0);throw new Error("Couldn\'t load "+a+". Status: "+t.status)}(r,t)),void 0===i.chunks[e])throw new Error("doXHR failed!");return i.chunks[e]}),!e&&n||(o=n=1,n=this.getter(0).length,o=n,m("LazyFiles on gzip forces download of the whole file when length is accessed")),this._length=n,this._chunkSize=o,this.lengthKnown=!0},"undefined"!=typeof XMLHttpRequest){if(!c)throw"Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc";var i=new o,i=(Object.defineProperties(i,{length:{get:function(){return this.lengthKnown||this.cacheLength(),this._length}},chunkSize:{get:function(){return this.lengthKnown||this.cacheLength(),this._chunkSize}}}),{isDevice:!1,contents:i})}else i={isDevice:!1,url:a};var u=T.createFile(e,r,i,t,n),s=(i.contents?u.contents=i.contents:i.url&&(u.contents=null,u.url=i.url),Object.defineProperties(u,{usedBytes:{get:function(){return this.contents.length}}}),{});return Object.keys(u.stream_ops).forEach(function(e){var r=u.stream_ops[e];s[e]=function(){if(T.forceLoadFile(u))return r.apply(null,arguments);throw new T.ErrnoError(29)}}),s.read=function(e,r,t,n,o){if(!T.forceLoadFile(u))throw new T.ErrnoError(29);var i=e.node.contents;if(o>=i.length)return 0;var a=Math.min(i.length-o,n);if(i.slice)for(var s=0;s<a;s++)r[t+s]=i[o+s];else for(s=0;s<a;s++)r[t+s]=i.get(o+s);return a},u.stream_ops=s,u},createPreloadedFile:function(o,i,e,a,s,u,c,f,l,d){Browser.init();var p=i?R.resolve(x.join2(o,i)):o;function r(r){function t(e){d&&d(),f||T.createDataFile(o,i,e,a,s,l),u&&u(),ue()}var n=!1;h.preloadPlugins.forEach(function(e){n||e.canHandle(p)&&(e.handle(r,p,t,function(){c&&c(),ue()}),n=!0)}),n||t(r)}se(),"string"==typeof e?Browser.asyncLoad(e,function(e){r(e)},c):r(e)},indexedDB:function(){return window.indexedDB||window.mozIndexedDB||window.webkitIndexedDB||window.msIndexedDB},DB_NAME:function(){return"EM_FS_"+window.location.pathname},DB_VERSION:20,DB_STORE_NAME:"FILE_DATA",saveFilesToDB:function(a,s,u){s=s||function(){},u=u||function(){};var e=T.indexedDB();try{var c=e.open(T.DB_NAME(),T.DB_VERSION)}catch(e){return u(e)}c.onupgradeneeded=function(){m("creating db"),c.result.createObjectStore(T.DB_STORE_NAME)},c.onsuccess=function(){var e=c.result.transaction([T.DB_STORE_NAME],"readwrite"),r=e.objectStore(T.DB_STORE_NAME),t=0,n=0,o=a.length;function i(){(0==n?s:u)()}a.forEach(function(e){e=r.put(T.analyzePath(e).object.contents,e);e.onsuccess=function(){++t+n==o&&i()},e.onerror=function(){t+ ++n==o&&i()}}),e.onerror=u},c.onerror=u},loadFilesFromDB:function(s,u,c){u=u||function(){},c=c||function(){};var e=T.indexedDB();try{var f=e.open(T.DB_NAME(),T.DB_VERSION)}catch(e){return c(e)}f.onupgradeneeded=c,f.onsuccess=function(){var e=f.result;try{var r=e.transaction([T.DB_STORE_NAME],"readonly")}catch(e){return void c(e)}var t=r.objectStore(T.DB_STORE_NAME),n=0,o=0,i=s.length;function a(){(0==o?u:c)()}s.forEach(function(e){var r=t.get(e);r.onsuccess=function(){T.analyzePath(e).exists&&T.unlink(e),T.createDataFile(x.dirname(e),x.basename(e),r.result,!0,!0,!0),++n+o==i&&a()},r.onerror=function(){n+ ++o==i&&a()}}),r.onerror=c},f.onerror=c}},N={mappings:{},DEFAULT_POLLMASK:5,umask:511,calculateAt:function(e,r){if("/"!==r[0]){var t;if(-100===e)t=T.cwd();else{e=T.getStream(e);if(!e)throw new T.ErrnoError(8);t=e.path}r=x.join2(t,r)}return r},doStat:function(e,r,t){try{var n=e(r)}catch(e){if(e&&e.node&&x.normalize(r)!==x.normalize(T.getPath(e.node)))return-54;throw e}return k[t>>2]=n.dev,k[t+4>>2]=0,k[t+8>>2]=n.ino,k[t+12>>2]=n.mode,k[t+16>>2]=n.nlink,k[t+20>>2]=n.uid,k[t+24>>2]=n.gid,k[t+28>>2]=n.rdev,k[t+32>>2]=0,F=[n.size>>>0,(S=n.size,1<=+ne(S)?0<S?(0|ae(+ie(S/4294967296),4294967295))>>>0:~~+oe((S-(~~S>>>0))/4294967296)>>>0:0)],k[t+40>>2]=F[0],k[t+44>>2]=F[1],k[t+48>>2]=4096,k[t+52>>2]=n.blocks,k[t+56>>2]=n.atime.getTime()/1e3|0,k[t+60>>2]=0,k[t+64>>2]=n.mtime.getTime()/1e3|0,k[t+68>>2]=0,k[t+72>>2]=n.ctime.getTime()/1e3|0,k[t+76>>2]=0,F=[n.ino>>>0,(S=n.ino,1<=+ne(S)?0<S?(0|ae(+ie(S/4294967296),4294967295))>>>0:~~+oe((S-(~~S>>>0))/4294967296)>>>0:0)],k[t+80>>2]=F[0],k[t+84>>2]=F[1],0},doMsync:function(e,r,t,n,o){e=E.slice(e,e+t);T.msync(r,e,o,t,n)},doMkdir:function(e,r){return"/"===(e=x.normalize(e))[e.length-1]&&(e=e.substr(0,e.length-1)),T.mkdir(e,r,0),0},doMknod:function(e,r,t){switch(61440&r){case 32768:case 8192:case 24576:case 4096:case 49152:break;default:return-28}return T.mknod(e,r,t),0},doReadlink:function(e,r,t){if(t<=0)return-28;var e=T.readlink(e),n=Math.min(t,G(e)),o=y[r+n];return X(e,E,r,t+1),y[r+n]=o,n},doAccess:function(e,r){if(-8&r)return-28;e=T.lookupPath(e,{follow:!0}).node;if(!e)return-44;var t="";return 4&r&&(t+="r"),2&r&&(t+="w"),1&r&&(t+="x"),t&&T.nodePermissions(e,t)?-2:0},doDup:function(e,r,t){var n=T.getStream(t);return n&&T.close(n),T.open(e,r,0,t,t).fd},doReadv:function(e,r,t,n){for(var o=0,i=0;i<t;i++){var a=k[r+8*i>>2],s=k[r+(8*i+4)>>2],a=T.read(e,y,a,s,n);if(a<0)return-1;if(o+=a,a<s)break}return o},doWritev:function(e,r,t,n){for(var o=0,i=0;i<t;i++){var a=k[r+8*i>>2],s=k[r+(8*i+4)>>2],a=T.write(e,y,a,s,n);if(a<0)return-1;o+=a}return o},varargs:void 0,get:function(){return N.varargs+=4,k[N.varargs-4>>2]},getStr:function(e){return W(e)},getStreamFromFD:function(e){e=T.getStream(e);if(e)return e;throw new T.ErrnoError(8)},get64:function(e,r){return e}};var ge={};function z(){if(!z.strings){var e={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:("object"==typeof navigator&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:C||"./this.program"};for(r in ge)e[r]=ge[r];var r,t=[];for(r in e)t.push(r+"="+e[r]);z.strings=t}return z.strings}function ve(e,r,t,n){this.parent=e=e||this,this.mount=e.mount,this.mounted=null,this.id=T.nextInode++,this.name=r,this.mode=t,this.node_ops={},this.stream_ops={},this.rdev=n}function ye(e,r,t){t=0<t?t:G(e)+1,t=new Array(t),e=X(e,t,0,t.length);return r&&(t.length=e),t}Object.defineProperties(ve.prototype,{read:{get:function(){return 365==(365&this.mode)},set:function(e){e?this.mode|=365:this.mode&=-366}},write:{get:function(){return 146==(146&this.mode)},set:function(e){e?this.mode|=146:this.mode&=-147}},isFolder:{get:function(){return T.isDir(this.mode)}},isDevice:{get:function(){return T.isChrdev(this.mode)}}}),T.FSNode=ve,T.staticInit();var Ee,ke={a:function(e,r,t,n){D("Assertion failed: "+W(e)+", at: "+[r?W(r):"unknown filename",t,n?W(n):"unknown function"])},s:function(e,r){var t;if(0===e)t=Date.now();else{if(1!==e&&4!==e||!we)return A(28),-1;t=me()}return k[r>>2]=t/1e3|0,k[r+4>>2]=t%1e3*1e3*1e3|0,0},d:function(e,r,t){N.varargs=t;try{var n=N.getStreamFromFD(e);switch(r){case 0:return(o=N.get())<0?-28:T.open(n.path,n.flags,0,o).fd;case 1:case 2:return 0;case 3:return n.flags;case 4:var o=N.get();return n.flags|=o,0;case 12:o=N.get();return K[o+0>>1]=2,0;case 13:case 14:return 0;case 16:case 8:return-28;case 9:return A(28),-1;default:return-28}}catch(e){return void 0!==T&&e instanceof T.ErrnoError||D(e),-e.errno}},i:function(e,r,t){N.varargs=t;try{var n=N.getStreamFromFD(e);switch(r){case 21509:case 21505:return n.tty?0:-59;case 21510:case 21511:case 21512:case 21506:case 21507:case 21508:return n.tty?0:-59;case 21519:if(!n.tty)return-59;var o=N.get();return k[o>>2]=0;case 21520:return n.tty?-28:-59;case 21531:o=N.get();return T.ioctl(n,r,o);case 21523:case 21524:return n.tty?0:-59;default:D("bad ioctl syscall "+r)}}catch(e){return void 0!==T&&e instanceof T.ErrnoError||D(e),-e.errno}},e:function(e,r,t){N.varargs=t;try{var n=N.getStr(e),o=N.get();return T.open(n,r,o).fd}catch(e){return void 0!==T&&e instanceof T.ErrnoError||D(e),-e.errno}},t:function(e){try{return e=N.getStr(e),T.rmdir(e),0}catch(e){return void 0!==T&&e instanceof T.ErrnoError||D(e),-e.errno}},j:function(e){try{var r=N.umask;return N.umask=e,r}catch(e){return void 0!==T&&e instanceof T.ErrnoError||D(e),-e.errno}},u:function(e){try{return e=N.getStr(e),T.unlink(e),0}catch(e){return void 0!==T&&e instanceof T.ErrnoError||D(e),-e.errno}},v:function(e,r,t,n){try{D("cannot wait on child processes")}catch(e){return void 0!==T&&e instanceof T.ErrnoError||D(e),-e.errno}},n:function(e,r,t){E.copyWithin(e,r,r+t)},b:function(e){var r=E.length,t=2147483648;if(t<(e>>>=0))return!1;for(var n,o=1;o<=4;o*=2){var i=r*(1+.2/o),i=Math.min(i,e+100663296);if(function(e){try{return p.grow(e-v.byteLength+65535>>>16),Y(p.buffer),1}catch(e){}}(Math.min(t,(0<(i=Math.max(16777216,e,i))%(n=65536)&&(i+=n-i%n),i))))return!0}return!1},p:function(a,s){var u=0;return z().forEach(function(e,r){for(var t=s+u,n=(k[a+4*r>>2]=t,e),o=t,r=void 0,i=0;i<n.length;++i)y[o++>>0]=n.charCodeAt(i);r||(y[o>>0]=0),u+=e.length+1}),0},q:function(e,r){var t=z(),n=(k[e>>2]=t.length,0);return t.forEach(function(e){n+=e.length+1}),k[r>>2]=n,0},c:function(e){xe(e)},f:function(e){try{var r=N.getStreamFromFD(e);return T.close(r),0}catch(e){return void 0!==T&&e instanceof T.ErrnoError||D(e),e.errno}},r:function(e,r){try{var t=N.getStreamFromFD(e),n=t.tty?2:T.isDir(t.mode)?3:T.isLink(t.mode)?7:4;return y[r>>0]=n,0}catch(e){return void 0!==T&&e instanceof T.ErrnoError||D(e),e.errno}},h:function(e,r,t,n){try{var o=N.getStreamFromFD(e),i=N.doReadv(o,r,t);return k[n>>2]=i,0}catch(e){return void 0!==T&&e instanceof T.ErrnoError||D(e),e.errno}},m:function(e,r,t,n,o){try{var i=N.getStreamFromFD(e),a=4294967296*t+(r>>>0),s=9007199254740992;return a<=-s||s<=a?-61:(T.llseek(i,a,n),F=[i.position>>>0,(S=i.position,1<=+ne(S)?0<S?(0|ae(+ie(S/4294967296),4294967295))>>>0:~~+oe((S-(~~S>>>0))/4294967296)>>>0:0)],k[o>>2]=F[0],k[o+4>>2]=F[1],i.getdents&&0==a&&0===n&&(i.getdents=null),0)}catch(e){return void 0!==T&&e instanceof T.ErrnoError||D(e),e.errno}},g:function(e,r,t,n){try{var o=N.getStreamFromFD(e),i=N.doWritev(o,r,t);return k[n>>2]=i,0}catch(e){return void 0!==T&&e instanceof T.ErrnoError||D(e),e.errno}},memory:p,o:function(){w("missing function: popen"),D(-1)},l:function(){return 6},k:function(){},table:I},_e=(!function(){var r={a:ke};function t(e,r){e=e.exports;h.asm=e,ue()}function n(e){t(e.instance)}function o(e){return(l||!L&&!c||"function"!=typeof fetch||de(P)?new Promise(function(e,r){e(pe())}):fetch(P,{credentials:"same-origin"}).then(function(e){if(e.ok)return e.arrayBuffer();throw"failed to load wasm binary file at \'"+P+"\'"}).catch(pe)).then(function(e){return WebAssembly.instantiate(e,r)}).then(e,function(e){w("failed to asynchronously prepare wasm: "+e),D(e)})}if(se(),h.instantiateWasm)try{h.instantiateWasm(r,t);return}catch(e){return w("Module.instantiateWasm callback failed with error: "+e)}l||"function"!=typeof WebAssembly.instantiateStreaming||ce(P,fe)||de(P)||"function"!=typeof fetch?o(n):fetch(P,{credentials:"same-origin"}).then(function(e){return WebAssembly.instantiateStreaming(e,r).then(n,function(e){return w("wasm streaming compile failed: "+e),w("falling back to ArrayBuffer instantiation"),o(n)})})}(),h.___wasm_call_ctors=function(){return(_e=h.___wasm_call_ctors=h.asm.w).apply(null,arguments)}),be=h._malloc=function(){return(be=h._malloc=h.asm.x).apply(null,arguments)},De=h.___errno_location=function(){return(De=h.___errno_location=h.asm.y).apply(null,arguments)},Se=(h._main=function(){return(h._main=h.asm.z).apply(null,arguments)},h.stackAlloc=function(){return(Se=h.stackAlloc=h.asm.A).apply(null,arguments)});function Fe(e){this.name="ExitStatus",this.message="Program terminated with exit("+e+")",this.status=e}function Pe(r){var t=h._main;r=r||[];try{for(let e=0;e<r.length;e++){const s=r[e];var n,{argc:o,argv:i}=function(e){var r=e.length+1,t=Se(4*(r+1));k[t>>2]=V(C);for(var n=1;n<r;n++)k[(t>>2)+n]=V(e[n-1]);return k[(t>>2)+r]=0,{argc:r,argv:t}}(s.split(" ").filter(e=>Boolean(e)));if(0!==(n=t(o,i)))break}xe(n,!0)}catch(e){if(e instanceof Fe)return;if("unwind"==e)return void(d=!0);var a=e;e&&"object"==typeof e&&e.stack&&(a=[e,e.stack]),w("exception thrown: "+a),u(1,e)}}function Ae(e){function r(){Ee||(Ee=!0,h.calledRun=!0,U||(h.noFSInit||T.init.initialized||T.init(),Z(J),T.ignorePermissions=!1,Z(Q),j(h),h.onRuntimeInitialized&&h.onRuntimeInitialized(),Re&&Pe(e),te()))}e=e||a,0<_||(re(),0<_||(h.setStatus?(h.setStatus("Running..."),setTimeout(function(){setTimeout(function(){h.setStatus("")},1),r()},1)):r()))}function xe(e,r){r&&d&&0===e||(d||(U=!0,h.onExit&&h.onExit(e)),u(e,new Fe(e)))}if(h.dynCall_vi=function(){return(h.dynCall_vi=h.asm.B).apply(null,arguments)},b=function e(){Ee||Ae(),Ee||(b=e)},h.run=Ae,h.preInit)for("function"==typeof h.preInit&&(h.preInit=[h.preInit]);0<h.preInit.length;)h.preInit.pop()();var Re=!0;return h.noInitialRun&&(Re=!1),d=!0,Ae(),e.ready};let r="";let t="";var f={flush:()=>{0<r.length&&(console.log(r),r=""),0<t.length&&(console.error(t),t="")},stderr:e=>{t+=String.fromCharCode(e),10===e&&(console.error(t),t="")},stdout:e=>{r+=String.fromCharCode(e),10===e&&(console.log(r),r="")}};const l=[];return async(e={})=>{let{data:i=null,command:a=[],folder:s=[],isStrict:u=!1}=e;return await new Promise(e=>{l.push(e),1===l.length&&l[0]()}),new Promise((r,t)=>{let n=!1,o="";c({stdout:f.stdout,stderr:e=>{o+=String.fromCharCode(e),10===e&&(console.error(o),u&&t(o))},arguments:a,input:i,folder:s,output:e=>{r(e),n=!0}}).then(()=>{(0,f.flush)(),n||t(),0<l.length&&(l.shift(),0<l.length&&l[0]())})})}}();onmessage=function(r){(async()=>{var e=await gifsicle(r.data).catch(e=>{postMessage(e)});postMessage(e)})().catch(e=>{postMessage(null)})};',
        workerBlobUrl: "",
        worker() {
            return this.workerBlobUrl || (this.workerLocalUrl ? this.workerBlobUrl = URL.createObjectURL(new Blob([ this.workerLocalUrl ])) : this.workerBlobUrl = "../src/worker.js", 
            this.workerBlobUrl);
        },
        errorLink: () => " \n Check: https://github.com/renzhezhilu/gifsicle-wasm-browser",
        testType: A => A instanceof Element ? "element" : Object.prototype.toString.call(A).replace(/\[object\s(.+)\]/, "$1").toLowerCase(),
        async textToUrl(A) {
            return this.worker();
        },
        loadCommand(A) {
            var I = this.testType(A);
            if (0 === A.length) throw "<command> the content can not be blank" + this.errorLink();
            if ("array" === I) return A.map((A => A.replace(/\n/gi, " ")));
            throw "<command> types:" + I + ", must be an array" + this.errorLink();
        },
        loadOne(B) {
            return new Promise((async (I, A) => {
                var g = this.testType(B);
                if ([ "string" ].includes(g)) fetch(B).then((A => {
                    if (200 !== A.status) throw "<" + B + "> Url error!!!" + this.errorLink();
                    return A.arrayBuffer();
                })).then((A => I(A))); else if ([ "blob", "file" ].includes(g)) new Response(B).arrayBuffer().then((A => I(A))); else {
                    if (![ "arraybuffer" ].includes(g)) throw "<input.file> types:" + g + ", only supports Url, blob, file, arraybuffer" + this.errorLink();
                    I(B);
                }
            }));
        },
        loadFile(B) {
            return new Promise((async (I, A) => {
                var g = this.testType(B);
                if ("array" !== g) throw "<input> types:" + g + ", only supports Array" + this.errorLink();
                if (0 === B.length) throw "<input> the content can not be blank" + this.errorLink();
                g = B.map((A => this.loadOne(A.file))), Promise.all(g).then((function(g) {
                    var A = B.map(((A, I) => (A.file = g[I], A)));
                    I(A);
                })).catch((function(A) {}));
            }));
        },
        loadFolder(B) {
            return new Promise((async (A, I) => {
                var g = this.testType(B);
                if (![ "array" ].includes(g)) throw "<folder> types:" + g + ", only supports Array" + this.errorLink();
                A(B);
            }));
        }
    },
    run(t = {}) {
        return new Promise((async (Q, A) => {
            let {input: I = [], command: g = "", folder: B = [], isStrict: C = !1, start: E = (A => {})} = t;
            var i = await this.tool.textToUrl();
            let o = new Worker(i);
            var D = this.tool.loadCommand(g), w = await this.tool.loadFile(I), e = (E(w), await this.tool.loadFolder(B));
            console.log(D), console.log(w), console.log(i), o.postMessage({
                data: w,
                command: D,
                folder: e,
                isStrict: C
            }), o.onmessage = async function(I) {
                if (!I.data || "string" == typeof I.data) return o.terminate(), void A(I.data);
                let g = [];
                for (let A = 0; A < I.data.length; A++) {
                    const C = I.data[A];
                    var B;
                    C.name.includes(".txt") ? (B = new File([ C.file ], C.name, {
                        type: "text/plain"
                    }), g.push(B)) : (B = new File([ C.file ], C.name, {
                        type: "image/gif"
                    }), g.push(B));
                }
                o.terminate(), Q(g);
            }, o.onerror = function(A) {
                console.error(A), o.terminate(), Q(null);
            };
        }));
    }
};

class NeuQuant$1 {
    network=[];
    netindex=new Int32Array(256);
    bias=new Int32Array(256);
    freq=new Int32Array(256);
    radpower=new Int32Array(32);
    pixels;
    samplefac;
    constructor(pixels, samplefac) {
        this.pixels = pixels, this.samplefac = samplefac;
    }
    init() {
        this.network = [], this.netindex = new Int32Array(256), this.bias = new Int32Array(256), 
        this.freq = new Int32Array(256), this.radpower = new Int32Array(32);
        for (let i = 0; i < 256; i++) {
            const v = (i << 12) / 256;
            this.network[i] = new Float64Array([ v, v, v, 0 ]), this.freq[i] = 256, this.bias[i] = 0;
        }
    }
    unbiasnet() {
        for (let i = 0; i < 256; i++) this.network[i][0] >>= 4, this.network[i][1] >>= 4, 
        this.network[i][2] >>= 4, this.network[i][3] = i;
    }
    altersingle(alpha, i, b, g, r) {
        this.network[i][0] -= alpha * (this.network[i][0] - b) / 1024, this.network[i][1] -= alpha * (this.network[i][1] - g) / 1024, 
        this.network[i][2] -= alpha * (this.network[i][2] - r) / 1024;
    }
    alterneigh(radius, i, b, g, r) {
        const lo = Math.abs(i - radius), hi = Math.min(i + radius, 256);
        let j = i + 1, k = i - 1, m = 1;
        for (;j < hi || k > lo; ) {
            const a = this.radpower[m++];
            let p;
            j < hi && (p = this.network[j++], p[0] -= a * (p[0] - b) / 262144, p[1] -= a * (p[1] - g) / 262144, 
            p[2] -= a * (p[2] - r) / 262144), k > lo && (p = this.network[k--], p[0] -= a * (p[0] - b) / 262144, 
            p[1] -= a * (p[1] - g) / 262144, p[2] -= a * (p[2] - r) / 262144);
        }
    }
    contest(b, g, r) {
        let bestd = ~(1 << 31), bestbiasd = bestd, bestpos = -1, bestbiaspos = bestpos;
        for (let i = 0; i < 256; i++) {
            const n = this.network[i], dist = Math.abs(n[0] - b) + Math.abs(n[1] - g) + Math.abs(n[2] - r);
            dist < bestd && (bestd = dist, bestpos = i);
            const biasdist = dist - (this.bias[i] >> 12);
            biasdist < bestbiasd && (bestbiasd = biasdist, bestbiaspos = i);
            const betafreq = this.freq[i] >> 10;
            this.freq[i] -= betafreq, this.bias[i] += betafreq << 10;
        }
        return this.freq[bestpos] += 64, this.bias[bestpos] -= 65536, bestbiaspos;
    }
    inxbuild() {
        let j, previouscol = 0, startpos = 0;
        for (let i = 0; i < 256; i++) {
            const p = this.network[i];
            let q, smallpos = i, smallval = p[1];
            for (j = i + 1; j < 256; j++) q = this.network[j], q[1] < smallval && (smallpos = j, 
            smallval = q[1]);
            if (q = this.network[smallpos], i !== smallpos && (j = q[0], q[0] = p[0], p[0] = j, 
            j = q[1], q[1] = p[1], p[1] = j, j = q[2], q[2] = p[2], p[2] = j, j = q[3], q[3] = p[3], 
            p[3] = j), smallval !== previouscol) {
                for (this.netindex[previouscol] = startpos + i >> 1, j = previouscol + 1; j < smallval; j++) this.netindex[j] = i;
                previouscol = smallval, startpos = i;
            }
        }
        for (this.netindex[previouscol] = startpos + 255 >> 1, j = previouscol + 1; j < 256; j++) this.netindex[j] = 255;
    }
    lookupRGB(b, g, r) {
        let a, p, dist, bestd = 1000, best = -1, i = this.netindex[g], j = i - 1;
        for (;i < 256 || j >= 0; ) i < 256 && (p = this.network[i], dist = p[1] - g, dist >= bestd ? i = 256 : (i++, 
        dist < 0 && (dist = -dist), a = p[0] - b, a < 0 && (a = -a), dist += a, dist < bestd && (a = p[2] - r, 
        a < 0 && (a = -a), dist += a, dist < bestd && (bestd = dist, best = p[3])))), j >= 0 && (p = this.network[j], 
        dist = g - p[1], dist >= bestd ? j = -1 : (j--, dist < 0 && (dist = -dist), a = p[0] - b, 
        a < 0 && (a = -a), dist += a, dist < bestd && (a = p[2] - r, a < 0 && (a = -a), 
        dist += a, dist < bestd && (bestd = dist, best = p[3]))));
        return best;
    }
    learn() {
        let i;
        const lengthcount = this.pixels.length, alphadec = 30 + (this.samplefac - 1) / 3, samplepixels = lengthcount / (3 * this.samplefac);
        let step, b, g, r, j, delta = ~~(samplepixels / 100), alpha = 1024, radius = 2048, rad = radius >> 6;
        for (rad <= 1 && (rad = 0), i = 0; i < rad; i++) this.radpower[i] = alpha * (256 * (rad * rad - i * i) / (rad * rad));
        lengthcount < 1509 ? (this.samplefac = 1, step = 3) : step = lengthcount % 499 != 0 ? 1497 : lengthcount % 491 != 0 ? 1473 : lengthcount % 487 != 0 ? 1461 : 1509;
        let pix = 0;
        for (i = 0; i < samplepixels; ) if (b = (0xff & this.pixels[pix]) << 4, g = (0xff & this.pixels[pix + 1]) << 4, 
        r = (0xff & this.pixels[pix + 2]) << 4, j = this.contest(b, g, r), this.altersingle(alpha, j, b, g, r), 
        0 !== rad && this.alterneigh(rad, j, b, g, r), pix += step, pix >= lengthcount && (pix -= lengthcount), 
        i++, 0 === delta && (delta = 1), i % delta == 0) for (alpha -= alpha / alphadec, 
        radius -= radius / 30, rad = radius >> 6, rad <= 1 && (rad = 0), j = 0; j < rad; j++) this.radpower[j] = alpha * (256 * (rad * rad - j * j) / (rad * rad));
    }
    buildColormap() {
        this.init(), this.learn(), this.unbiasnet(), this.inxbuild();
    }
    getColormap() {
        const map = [], index = [];
        for (let i = 0; i < 256; i++) index[this.network[i][3]] = i;
        let k = 0;
        for (let l = 0; l < 256; l++) {
            const j = index[l];
            map[k++] = this.network[j][0], map[k++] = this.network[j][1], map[k++] = this.network[j][2];
        }
        return map;
    }
}

const masks = [ 0x0000, 0x0001, 0x0003, 0x0007, 0x000F, 0x001F, 0x003F, 0x007F, 0x00FF, 0x01FF, 0x03FF, 0x07FF, 0x0FFF, 0x1FFF, 0x3FFF, 0x7FFF, 0xFFFF ];

class LZWEncoder {
    width;
    height;
    pixels;
    colorDepth;
    initCodeSize;
    accum=new Uint8Array(256);
    htab=new Int32Array(5003);
    codetab=new Int32Array(5003);
    curAccum=0;
    curBits=0;
    aCount=0;
    freeEnt=0;
    maxcode=0;
    clearFlg=!1;
    gInitBits=0;
    nBits=0;
    ClearCode=0;
    EOFCode;
    remaining=0;
    curPixel=0;
    constructor(width, height, pixels, colorDepth) {
        this.width = width, this.height = height, this.pixels = pixels, this.colorDepth = colorDepth, 
        this.initCodeSize = Math.max(2, colorDepth);
    }
    flushChar(outs) {
        this.aCount > 0 && (outs.writeByte(this.aCount), outs.writeBytes(this.accum, 0, this.aCount), 
        this.aCount = 0);
    }
    charOut(c, outs) {
        this.accum[this.aCount++] = c, this.aCount >= 254 && this.flushChar(outs);
    }
    clHash(hsize) {
        for (let i = 0; i < hsize; ++i) this.htab[i] = -1;
    }
    static MAXCODE(nBits) {
        return (1 << nBits) - 1;
    }
    output(code, outs) {
        for (this.curAccum &= masks[this.curBits], this.curBits > 0 ? this.curAccum |= code << this.curBits : this.curAccum = code, 
        this.curBits += this.nBits; this.curBits >= 8; ) this.charOut(0xff & this.curAccum, outs), 
        this.curAccum >>= 8, this.curBits -= 8;
        if ((this.freeEnt > this.maxcode || this.clearFlg) && (this.clearFlg ? (this.maxcode = LZWEncoder.MAXCODE(this.nBits = this.gInitBits), 
        this.clearFlg = !1) : (++this.nBits, 12 === this.nBits ? this.maxcode = 4096 : this.maxcode = LZWEncoder.MAXCODE(this.nBits))), 
        code === this.EOFCode) {
            for (;this.curBits > 0; ) this.charOut(0xff & this.curAccum, outs), this.curAccum >>= 8, 
            this.curBits -= 8;
            this.flushChar(outs);
        }
    }
    clBlock(outs) {
        this.clHash(5003), this.freeEnt = this.ClearCode + 2, this.clearFlg = !0, this.output(this.ClearCode, outs);
    }
    nextPixel() {
        return 0 === this.remaining ? -1 : (--this.remaining, 0xff & this.pixels[this.curPixel++]);
    }
    compress(initBits, outs) {
        this.gInitBits = initBits, this.clearFlg = !1, this.nBits = this.gInitBits, this.maxcode = LZWEncoder.MAXCODE(this.nBits), 
        this.ClearCode = 1 << initBits - 1, this.EOFCode = this.ClearCode + 1, this.freeEnt = this.ClearCode + 2, 
        this.aCount = 0;
        let fcode, c, ent = this.nextPixel(), hshift = 0;
        for (fcode = 5003; fcode < 65536; fcode *= 2) ++hshift;
        hshift = 8 - hshift, this.clHash(5003), this.output(this.ClearCode, outs);
        outerLoop: do {
            c = this.nextPixel(), fcode = (c << 12) + ent;
            let i = c << hshift ^ ent;
            if (this.htab[i] !== fcode) {
                if (this.htab[i] >= 0) {
                    let disp = 5003 - i;
                    0 === i && (disp = 1);
                    do {
                        if (i -= disp, i < 0 && (i += 5003), this.htab[i] === fcode) {
                            ent = this.codetab[i];
                            continue outerLoop;
                        }
                    } while (this.htab[i] >= 0);
                }
                this.output(ent, outs), ent = c, this.freeEnt < 4096 ? (this.codetab[i] = this.freeEnt++, 
                this.htab[i] = fcode) : this.clBlock(outs);
            } else ent = this.codetab[i];
        } while (-1 !== c);
        this.output(ent, outs), this.output(this.EOFCode, outs);
    }
    encode(outs) {
        outs.writeByte(this.initCodeSize), this.remaining = this.width * this.height, this.curPixel = 0, 
        this.compress(this.initCodeSize + 1, outs), outs.writeByte(0);
    }
}

class ByteArray {
    data=[];
    getData() {
        return Buffer.from(this.data);
    }
    writeByte(val) {
        this.data.push(val);
    }
    writeUTFBytes(text) {
        for (let l = text.length, i = 0; i < l; i++) this.writeByte(text.charCodeAt(i));
    }
    writeBytes(array, offset, length) {
        for (let l = length || array.length, i = offset || 0; i < l; i++) this.writeByte(array[i]);
    }
}

class GIFEncoder {
    width;
    height;
    transparent;
    transIndex=0;
    repeat=-1;
    delay=0;
    image;
    pixels;
    indexedPixels;
    colorDepth;
    colorTab;
    usedEntry=[];
    palSize=7;
    dispose=-1;
    firstFrame=!0;
    sample=10;
    started=!1;
    buffers=[];
    out=new ByteArray;
    constructor(width, height) {
        this.width = ~~width, this.height = ~~height;
    }
    getAndResetBuffer() {
        const buffer = Buffer$1.concat(this.buffers);
        return this.buffers = [], buffer;
    }
    emit() {
        this.out.data.length && (this.buffers.push(Uint8Array.from(this.out.data)), this.out.data = []);
    }
    start() {
        this.out.writeUTFBytes("GIF89a"), this.started = !0, this.emit();
    }
    getImagePixels() {
        const data = this.image;
        if (void 0 === data) return;
        const w = this.width, h = this.height;
        this.pixels = new Uint8Array(w * h * 3);
        let count = 0;
        for (let i = 0; i < h; i++) for (let j = 0; j < w; j++) {
            const b = i * w * 4 + 4 * j;
            this.pixels[count++] = data[b], this.pixels[count++] = data[b + 1], this.pixels[count++] = data[b + 2];
        }
    }
    findClosest(c) {
        if (void 0 === this.colorTab) return -1;
        const r = (0xFF0000 & c) >> 16, g = (0x00FF00 & c) >> 8, b = 0x0000FF & c;
        let minpos = 0, dmin = 16777216;
        const len = this.colorTab.length;
        for (let i = 0; i < len; ) {
            const index = i / 3, dr = r - (0xff & this.colorTab[i++]), dg = g - (0xff & this.colorTab[i++]), db = b - (0xff & this.colorTab[i++]), d = dr * dr + dg * dg + db * db;
            this.usedEntry[index] && d < dmin && (dmin = d, minpos = index);
        }
        return minpos;
    }
    analyzePixels() {
        if (void 0 === this.pixels || void 0 === this.image) return;
        const nPix = this.pixels.length / 3;
        this.indexedPixels = new Uint8Array(nPix);
        const imgq = new NeuQuant$1(this.pixels, this.sample);
        imgq.buildColormap(), this.colorTab = imgq.getColormap();
        let k = 0;
        for (let j = 0; j < nPix; j++) {
            const index = imgq.lookupRGB(0xff & this.pixels[k++], 0xff & this.pixels[k++], 0xff & this.pixels[k++]);
            this.usedEntry[index] = !0, this.indexedPixels[j] = index;
        }
        if (this.pixels = void 0, this.colorDepth = 8, this.palSize = 7, void 0 !== this.transparent) {
            this.transIndex = this.findClosest(this.transparent);
            for (let pixelIndex = 0; pixelIndex < nPix; pixelIndex++) 0 === this.image[4 * pixelIndex + 3] && (this.indexedPixels[pixelIndex] = this.transIndex);
        }
    }
    writeShort(pValue) {
        this.out.writeByte(0xFF & pValue), this.out.writeByte(pValue >> 8 & 0xFF);
    }
    writeLSD() {
        this.writeShort(this.width), this.writeShort(this.height), this.out.writeByte(240 | this.palSize), 
        this.out.writeByte(0), this.out.writeByte(0);
    }
    writePalette() {
        if (void 0 === this.colorTab) return;
        this.out.writeBytes(this.colorTab);
        const n = 768 - this.colorTab.length;
        for (let i = 0; i < n; i++) this.out.writeByte(0);
    }
    writeNetscapeExt() {
        this.out.writeByte(0x21), this.out.writeByte(0xff), this.out.writeByte(11), this.out.writeUTFBytes("NETSCAPE2.0"), 
        this.out.writeByte(3), this.out.writeByte(1), this.writeShort(this.repeat), this.out.writeByte(0);
    }
    writeGraphicCtrlExt() {
        let transp, disp;
        this.out.writeByte(0x21), this.out.writeByte(0xf9), this.out.writeByte(4), void 0 === this.transparent ? (transp = 0, 
        disp = 0) : (transp = 1, disp = 2), this.dispose >= 0 && (disp = 7 & this.dispose), 
        disp <<= 2, this.out.writeByte(0 | disp | transp), this.writeShort(this.delay), 
        this.out.writeByte(this.transIndex), this.out.writeByte(0);
    }
    writeImageDesc() {
        this.out.writeByte(0x2c), this.writeShort(0), this.writeShort(0), this.writeShort(this.width), 
        this.writeShort(this.height), this.firstFrame ? this.out.writeByte(0) : this.out.writeByte(128 | this.palSize);
    }
    writePixels() {
        void 0 !== this.indexedPixels && void 0 !== this.colorDepth && new LZWEncoder(this.width, this.height, this.indexedPixels, this.colorDepth).encode(this.out);
    }
    addFrame(imageData) {
        this.image = imageData, this.getImagePixels(), this.analyzePixels(), this.firstFrame && (this.writeLSD(), 
        this.writePalette(), this.repeat >= 0 && this.writeNetscapeExt()), this.writeGraphicCtrlExt(), 
        this.writeImageDesc(), this.firstFrame || this.writePalette(), this.writePixels(), 
        this.firstFrame = !1, this.emit();
    }
    setDelay(milliseconds) {
        void 0 !== milliseconds && (this.delay = Math.round(milliseconds / 10));
    }
    setFrameRate(fps) {
        void 0 !== fps && (this.delay = Math.round(100 / fps));
    }
    setDispose(disposalCode) {
        void 0 !== disposalCode ? disposalCode >= 0 && (this.dispose = disposalCode) : this.dispose = void 0 === this.transparent ? 0 : 2;
    }
    setRepeat(repeat = -1) {
        this.repeat = repeat;
    }
    setTransparent(color) {
        this.transparent = color;
    }
    end() {
        null !== this.buffers.length && this.emit();
    }
    finish() {
        this.out.writeByte(0x3b), this.end();
    }
    setQuality(_quality = 10) {
        let quality = _quality;
        quality < 1 && (quality = 1), this.sample = quality;
    }
}

module.exports = GIFEncoder;

var commonjsGlobal = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {};

function getDefaultExportFromCjs(x) {
    return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x.default : x;
}

function commonjsRequire(path) {
    throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}

class BitmapImage$2 {
    constructor(...args) {
        if (0 === args.length) throw new Error("constructor requires parameters");
        const firstArg = args[0];
        if (null !== firstArg && "object" == typeof firstArg) if (firstArg instanceof BitmapImage$2) {
            const sourceBitmap = firstArg.bitmap;
            this.bitmap = {
                width: sourceBitmap.width,
                height: sourceBitmap.height,
                data: new Buffer(sourceBitmap.width * sourceBitmap.height * 4)
            }, sourceBitmap.data.copy(this.bitmap.data);
        } else {
            if (!(firstArg.width && firstArg.height && firstArg.data)) throw new Error("unrecognized constructor parameters");
            this.bitmap = firstArg;
        } else {
            if ("number" != typeof firstArg || "number" != typeof args[1]) throw new Error("unrecognized constructor parameters");
            {
                const width = firstArg, height = args[1], thirdArg = args[2];
                this.bitmap = {
                    width,
                    height
                }, Buffer.isBuffer(thirdArg) ? this.bitmap.data = thirdArg : (this.bitmap.data = new Buffer(width * height * 4), 
                "number" == typeof thirdArg && this.fillRGBA(thirdArg));
            }
        }
    }
    blit(toImage, toX, toY, fromX, fromY, fromWidth, fromHeight) {
        if (fromX + fromWidth > this.bitmap.width) throw new Error("copy exceeds width of source bitmap");
        if (toX + fromWidth > toImage.bitmap.width) throw new Error("copy exceeds width of target bitmap");
        if (fromY + fromHeight > this.bitmap.height) throw new Error("copy exceeds height of source bitmap");
        if (toY + fromHeight > toImage.bitmap.height) throw new Erro("copy exceeds height of target bitmap");
        const sourceBuf = this.bitmap.data, targetBuf = toImage.bitmap.data, sourceByteWidth = 4 * this.bitmap.width, targetByteWidth = 4 * toImage.bitmap.width, copyByteWidth = 4 * fromWidth;
        let si = fromY * sourceByteWidth + 4 * fromX, ti = toY * targetByteWidth + 4 * toX;
        for (;--fromHeight >= 0; ) sourceBuf.copy(targetBuf, ti, si, si + copyByteWidth), 
        si += sourceByteWidth, ti += targetByteWidth;
        return this;
    }
    fillRGBA(rgba) {
        const buf = this.bitmap.data, bufByteWidth = 4 * this.bitmap.height;
        let bi = 0;
        for (;bi < bufByteWidth; ) buf.writeUInt32BE(rgba, bi), bi += 4;
        for (;bi < buf.length; ) buf.copy(buf, bi, 0, bufByteWidth), bi += bufByteWidth;
        return this;
    }
    getRGBA(x, y) {
        const bi = 4 * (y * this.bitmap.width + x);
        return this.bitmap.data.readUInt32BE(bi);
    }
    getRGBASet() {
        const rgbaSet = new Set, buf = this.bitmap.data;
        for (let bi = 0; bi < buf.length; bi += 4) rgbaSet.add(buf.readUInt32BE(bi, !0));
        return rgbaSet;
    }
    greyscale() {
        const buf = this.bitmap.data;
        return this.scan(0, 0, this.bitmap.width, this.bitmap.height, ((x, y, idx) => {
            const grey = Math.round(0.299 * buf[idx] + 0.587 * buf[idx + 1] + 0.114 * buf[idx + 2]);
            buf[idx] = grey, buf[idx + 1] = grey, buf[idx + 2] = grey;
        })), this;
    }
    reframe(xOffset, yOffset, width, height, fillRGBA) {
        const cropX = xOffset < 0 ? 0 : xOffset, cropY = yOffset < 0 ? 0 : yOffset, cropWidth = width + cropX > this.bitmap.width ? this.bitmap.width - cropX : width, cropHeight = height + cropY > this.bitmap.height ? this.bitmap.height - cropY : height, newX = xOffset < 0 ? -xOffset : 0, newY = yOffset < 0 ? -yOffset : 0;
        let image;
        if (void 0 === fillRGBA) {
            if (cropX !== xOffset || cropY != yOffset || cropWidth !== width || cropHeight !== height) throw new GifError("fillRGBA required for this reframing");
            image = new BitmapImage$2(width, height);
        } else image = new BitmapImage$2(width, height, fillRGBA);
        return this.blit(image, newX, newY, cropX, cropY, cropWidth, cropHeight), this.bitmap = image.bitmap, 
        this;
    }
    scale(factor) {
        if (1 === factor) return;
        if (!Number.isInteger(factor) || factor < 1) throw new Error("the scale must be an integer >= 1");
        const sourceWidth = this.bitmap.width, sourceHeight = this.bitmap.height, destByteWidth = sourceWidth * factor * 4, sourceBuf = this.bitmap.data, destBuf = new Buffer(sourceHeight * destByteWidth * factor);
        let priorDestRowIndex, sourceIndex = 0, destIndex = 0;
        for (let y = 0; y < sourceHeight; ++y) {
            priorDestRowIndex = destIndex;
            for (let x = 0; x < sourceWidth; ++x) {
                const color = sourceBuf.readUInt32BE(sourceIndex, !0);
                for (let cx = 0; cx < factor; ++cx) destBuf.writeUInt32BE(color, destIndex), destIndex += 4;
                sourceIndex += 4;
            }
            for (let cy = 1; cy < factor; ++cy) destBuf.copy(destBuf, destIndex, priorDestRowIndex, destIndex), 
            destIndex += destByteWidth, priorDestRowIndex += destByteWidth;
        }
        return this.bitmap = {
            width: sourceWidth * factor,
            height: sourceHeight * factor,
            data: destBuf
        }, this;
    }
    scanAllCoords(scanHandler) {
        const width = this.bitmap.width, bufferLength = this.bitmap.data.length;
        let x = 0, y = 0;
        for (let bi = 0; bi < bufferLength; bi += 4) scanHandler(x, y, bi), ++x === width && (x = 0, 
        ++y);
    }
    scanAllIndexes(scanHandler) {
        const bufferLength = this.bitmap.data.length;
        for (let bi = 0; bi < bufferLength; bi += 4) scanHandler(bi);
    }
}

var bitmapimage = BitmapImage$2, gif = {};

class Gif$2 {
    constructor(buffer, frames, spec) {
        this.width = spec.width, this.height = spec.height, this.loops = spec.loops, this.usesTransparency = spec.usesTransparency, 
        this.colorScope = spec.colorScope, this.frames = frames, this.buffer = buffer;
    }
}

Gif$2.GlobalColorsPreferred = 0, Gif$2.GlobalColorsOnly = 1, Gif$2.LocalColorsOnly = 2;

class GifError$3 extends Error {
    constructor(messageOrError) {
        super(messageOrError), messageOrError instanceof Error && (this.stack = "Gif" + messageOrError.stack);
    }
}

gif.Gif = Gif$2, gif.GifError = GifError$3;

var gifcodec = {}, omggif = {};

function GifReaderLZWOutputIndexStream(code_stream, p, output, output_length) {
    for (var min_code_size = code_stream[p++], clear_code = 1 << min_code_size, eoi_code = clear_code + 1, next_code = eoi_code + 1, cur_code_size = min_code_size + 1, code_mask = (1 << cur_code_size) - 1, cur_shift = 0, cur = 0, op = 0, subblock_size = code_stream[p++], code_table = new Int32Array(4096), prev_code = null; ;) {
        for (;cur_shift < 16 && 0 !== subblock_size; ) cur |= code_stream[p++] << cur_shift, 
        cur_shift += 8, 1 === subblock_size ? subblock_size = code_stream[p++] : --subblock_size;
        if (cur_shift < cur_code_size) break;
        var code = cur & code_mask;
        if (cur >>= cur_code_size, cur_shift -= cur_code_size, code !== clear_code) {
            if (code === eoi_code) break;
            for (var chase_code = code < next_code ? code : prev_code, chase_length = 0, chase = chase_code; chase > clear_code; ) chase = code_table[chase] >> 8, 
            ++chase_length;
            var k = chase;
            if (op + chase_length + (chase_code !== code ? 1 : 0) > output_length) return void console.log("Warning, gif stream longer than expected.");
            output[op++] = k;
            var b = op += chase_length;
            for (chase_code !== code && (output[op++] = k), chase = chase_code; chase_length--; ) chase = code_table[chase], 
            output[--b] = 0xff & chase, chase >>= 8;
            null !== prev_code && next_code < 4096 && (code_table[next_code++] = prev_code << 8 | k, 
            next_code >= code_mask + 1 && cur_code_size < 12 && (++cur_code_size, code_mask = code_mask << 1 | 1)), 
            prev_code = code;
        } else next_code = eoi_code + 1, code_mask = (1 << (cur_code_size = min_code_size + 1)) - 1, 
        prev_code = null;
    }
    return op !== output_length && console.log("Warning, gif stream shorter than expected."), 
    output;
}

try {
    omggif.GifWriter = function GifWriter(buf, width, height, gopts) {
        var p = 0, loop_count = void 0 === (gopts = void 0 === gopts ? {} : gopts).loop ? null : gopts.loop, global_palette = void 0 === gopts.palette ? null : gopts.palette;
        if (width <= 0 || height <= 0 || width > 65535 || height > 65535) throw new Error("Width/Height invalid.");
        function check_palette_and_num_colors(palette) {
            var num_colors = palette.length;
            if (num_colors < 2 || num_colors > 256 || num_colors & num_colors - 1) throw new Error("Invalid code/color length, must be power of 2 and 2 .. 256.");
            return num_colors;
        }
        buf[p++] = 0x47, buf[p++] = 0x49, buf[p++] = 0x46, buf[p++] = 0x38, buf[p++] = 0x39, 
        buf[p++] = 0x61;
        var gp_num_colors_pow2 = 0, background = 0;
        if (null !== global_palette) {
            for (var gp_num_colors = check_palette_and_num_colors(global_palette); gp_num_colors >>= 1; ) ++gp_num_colors_pow2;
            if (gp_num_colors = 1 << gp_num_colors_pow2, --gp_num_colors_pow2, void 0 !== gopts.background) {
                if ((background = gopts.background) >= gp_num_colors) throw new Error("Background index out of range.");
                if (0 === background) throw new Error("Background index explicitly passed as 0.");
            }
        }
        if (buf[p++] = 0xff & width, buf[p++] = width >> 8 & 0xff, buf[p++] = 0xff & height, 
        buf[p++] = height >> 8 & 0xff, buf[p++] = (null !== global_palette ? 0x80 : 0) | gp_num_colors_pow2, 
        buf[p++] = background, buf[p++] = 0, null !== global_palette) for (var i = 0, il = global_palette.length; i < il; ++i) {
            var rgb = global_palette[i];
            buf[p++] = rgb >> 16 & 0xff, buf[p++] = rgb >> 8 & 0xff, buf[p++] = 0xff & rgb;
        }
        if (null !== loop_count) {
            if (loop_count < 0 || loop_count > 65535) throw new Error("Loop count invalid.");
            buf[p++] = 0x21, buf[p++] = 0xff, buf[p++] = 0x0b, buf[p++] = 0x4e, buf[p++] = 0x45, 
            buf[p++] = 0x54, buf[p++] = 0x53, buf[p++] = 0x43, buf[p++] = 0x41, buf[p++] = 0x50, 
            buf[p++] = 0x45, buf[p++] = 0x32, buf[p++] = 0x2e, buf[p++] = 0x30, buf[p++] = 0x03, 
            buf[p++] = 0x01, buf[p++] = 0xff & loop_count, buf[p++] = loop_count >> 8 & 0xff, 
            buf[p++] = 0x00;
        }
        var ended = !1;
        this.addFrame = function(x, y, w, h, indexed_pixels, opts) {
            if (!0 === ended && (--p, ended = !1), opts = void 0 === opts ? {} : opts, x < 0 || y < 0 || x > 65535 || y > 65535) throw new Error("x/y invalid.");
            if (w <= 0 || h <= 0 || w > 65535 || h > 65535) throw new Error("Width/Height invalid.");
            if (indexed_pixels.length < w * h) throw new Error("Not enough pixels for the frame size.");
            var using_local_palette = !0, palette = opts.palette;
            if (null == palette && (using_local_palette = !1, palette = global_palette), null == palette) throw new Error("Must supply either a local or global palette.");
            for (var num_colors = check_palette_and_num_colors(palette), min_code_size = 0; num_colors >>= 1; ) ++min_code_size;
            num_colors = 1 << min_code_size;
            var delay = void 0 === opts.delay ? 0 : opts.delay, disposal = void 0 === opts.disposal ? 0 : opts.disposal;
            if (disposal < 0 || disposal > 3) throw new Error("Disposal out of range.");
            var use_transparency = !1, transparent_index = 0;
            if (void 0 !== opts.transparent && null !== opts.transparent && (use_transparency = !0, 
            (transparent_index = opts.transparent) < 0 || transparent_index >= num_colors)) throw new Error("Transparent color index.");
            if ((0 !== disposal || use_transparency || 0 !== delay) && (buf[p++] = 0x21, buf[p++] = 0xf9, 
            buf[p++] = 4, buf[p++] = disposal << 2 | (!0 === use_transparency ? 1 : 0), buf[p++] = 0xff & delay, 
            buf[p++] = delay >> 8 & 0xff, buf[p++] = transparent_index, buf[p++] = 0), buf[p++] = 0x2c, 
            buf[p++] = 0xff & x, buf[p++] = x >> 8 & 0xff, buf[p++] = 0xff & y, buf[p++] = y >> 8 & 0xff, 
            buf[p++] = 0xff & w, buf[p++] = w >> 8 & 0xff, buf[p++] = 0xff & h, buf[p++] = h >> 8 & 0xff, 
            buf[p++] = !0 === using_local_palette ? 0x80 | min_code_size - 1 : 0, !0 === using_local_palette) for (var i = 0, il = palette.length; i < il; ++i) {
                var rgb = palette[i];
                buf[p++] = rgb >> 16 & 0xff, buf[p++] = rgb >> 8 & 0xff, buf[p++] = 0xff & rgb;
            }
            return p = function GifWriterOutputLZWCodeStream(buf, p, min_code_size, index_stream) {
                buf[p++] = min_code_size;
                var cur_subblock = p++, clear_code = 1 << min_code_size, code_mask = clear_code - 1, eoi_code = clear_code + 1, next_code = eoi_code + 1, cur_code_size = min_code_size + 1, cur_shift = 0, cur = 0;
                function emit_bytes_to_buffer(bit_block_size) {
                    for (;cur_shift >= bit_block_size; ) buf[p++] = 0xff & cur, cur >>= 8, cur_shift -= 8, 
                    p === cur_subblock + 256 && (buf[cur_subblock] = 255, cur_subblock = p++);
                }
                function emit_code(c) {
                    cur |= c << cur_shift, cur_shift += cur_code_size, emit_bytes_to_buffer(8);
                }
                var ib_code = index_stream[0] & code_mask, code_table = {};
                emit_code(clear_code);
                for (var i = 1, il = index_stream.length; i < il; ++i) {
                    var k = index_stream[i] & code_mask, cur_key = ib_code << 8 | k, cur_code = code_table[cur_key];
                    if (void 0 === cur_code) {
                        for (cur |= ib_code << cur_shift, cur_shift += cur_code_size; cur_shift >= 8; ) buf[p++] = 0xff & cur, 
                        cur >>= 8, cur_shift -= 8, p === cur_subblock + 256 && (buf[cur_subblock] = 255, 
                        cur_subblock = p++);
                        4096 === next_code ? (emit_code(clear_code), next_code = eoi_code + 1, cur_code_size = min_code_size + 1, 
                        code_table = {}) : (next_code >= 1 << cur_code_size && ++cur_code_size, code_table[cur_key] = next_code++), 
                        ib_code = k;
                    } else ib_code = cur_code;
                }
                return emit_code(ib_code), emit_code(eoi_code), emit_bytes_to_buffer(1), cur_subblock + 1 === p ? buf[cur_subblock] = 0 : (buf[cur_subblock] = p - cur_subblock - 1, 
                buf[p++] = 0), p;
            }(buf, p, min_code_size < 2 ? 2 : min_code_size, indexed_pixels), p;
        }, this.end = function() {
            return !1 === ended && (buf[p++] = 0x3b, ended = !0), p;
        }, this.getOutputBuffer = function() {
            return buf;
        }, this.setOutputBuffer = function(v) {
            buf = v;
        }, this.getOutputBufferPosition = function() {
            return p;
        }, this.setOutputBufferPosition = function(v) {
            p = v;
        };
    }, omggif.GifReader = function GifReader(buf) {
        var p = 0;
        if (0x47 !== buf[p++] || 0x49 !== buf[p++] || 0x46 !== buf[p++] || 0x38 !== buf[p++] || 0x38 != (buf[p++] + 1 & 0xfd) || 0x61 !== buf[p++]) throw new Error("Invalid GIF 87a/89a header.");
        var width = buf[p++] | buf[p++] << 8, height = buf[p++] | buf[p++] << 8, pf0 = buf[p++], global_palette_flag = pf0 >> 7, num_global_colors = 1 << 1 + (0x7 & pf0);
        buf[p++], buf[p++];
        var global_palette_offset = null, global_palette_size = null;
        global_palette_flag && (global_palette_offset = p, global_palette_size = num_global_colors, 
        p += 3 * num_global_colors);
        var no_eof = !0, frames = [], delay = 0, transparent_index = null, disposal = 0, loop_count = null;
        for (this.width = width, this.height = height; no_eof && p < buf.length; ) switch (buf[p++]) {
          case 0x21:
            switch (buf[p++]) {
              case 0xff:
                if (0x0b !== buf[p] || 0x4e == buf[p + 1] && 0x45 == buf[p + 2] && 0x54 == buf[p + 3] && 0x53 == buf[p + 4] && 0x43 == buf[p + 5] && 0x41 == buf[p + 6] && 0x50 == buf[p + 7] && 0x45 == buf[p + 8] && 0x32 == buf[p + 9] && 0x2e == buf[p + 10] && 0x30 == buf[p + 11] && 0x03 == buf[p + 12] && 0x01 == buf[p + 13] && 0 == buf[p + 16]) p += 14, 
                loop_count = buf[p++] | buf[p++] << 8, p++; else for (p += 12; ;) {
                    if (!((block_size = buf[p++]) >= 0)) throw Error("Invalid block size");
                    if (0 === block_size) break;
                    p += block_size;
                }
                break;

              case 0xf9:
                if (0x4 !== buf[p++] || 0 !== buf[p + 4]) throw new Error("Invalid graphics extension block.");
                var pf1 = buf[p++];
                delay = buf[p++] | buf[p++] << 8, transparent_index = buf[p++], 0 == (1 & pf1) && (transparent_index = null), 
                disposal = pf1 >> 2 & 0x7, p++;
                break;

              case 0xfe:
                for (;;) {
                    if (!((block_size = buf[p++]) >= 0)) throw Error("Invalid block size");
                    if (0 === block_size) break;
                    p += block_size;
                }
                break;

              default:
                throw new Error("Unknown graphic control label: 0x" + buf[p - 1].toString(16));
            }
            break;

          case 0x2c:
            var x = buf[p++] | buf[p++] << 8, y = buf[p++] | buf[p++] << 8, w = buf[p++] | buf[p++] << 8, h = buf[p++] | buf[p++] << 8, pf2 = buf[p++], interlace_flag = pf2 >> 6 & 1, num_local_colors = 1 << 1 + (0x7 & pf2), palette_offset = global_palette_offset, palette_size = global_palette_size, has_local_palette = !1;
            pf2 >> 7 && (has_local_palette = !0, palette_offset = p, palette_size = num_local_colors, 
            p += 3 * num_local_colors);
            var data_offset = p;
            for (p++; ;) {
                var block_size;
                if (!((block_size = buf[p++]) >= 0)) throw Error("Invalid block size");
                if (0 === block_size) break;
                p += block_size;
            }
            frames.push({
                x,
                y,
                width: w,
                height: h,
                has_local_palette,
                palette_offset,
                palette_size,
                data_offset,
                data_length: p - data_offset,
                transparent_index,
                interlaced: !!interlace_flag,
                delay,
                disposal
            });
            break;

          case 0x3b:
            no_eof = !1;
            break;

          default:
            throw new Error("Unknown gif block: 0x" + buf[p - 1].toString(16));
        }
        this.numFrames = function() {
            return frames.length;
        }, this.loopCount = function() {
            return loop_count;
        }, this.frameInfo = function(frame_num) {
            if (frame_num < 0 || frame_num >= frames.length) throw new Error("Frame index out of range.");
            return frames[frame_num];
        }, this.decodeAndBlitFrameBGRA = function(frame_num, pixels) {
            var frame = this.frameInfo(frame_num), num_pixels = frame.width * frame.height, index_stream = new Uint8Array(num_pixels);
            GifReaderLZWOutputIndexStream(buf, frame.data_offset, index_stream, num_pixels);
            var palette_offset = frame.palette_offset, trans = frame.transparent_index;
            null === trans && (trans = 256);
            var framewidth = frame.width, framestride = width - framewidth, xleft = framewidth, opbeg = 4 * (frame.y * width + frame.x), opend = 4 * ((frame.y + frame.height) * width + frame.x), op = opbeg, scanstride = 4 * framestride;
            !0 === frame.interlaced && (scanstride += 4 * width * 7);
            for (var interlaceskip = 8, i = 0, il = index_stream.length; i < il; ++i) {
                var index = index_stream[i];
                if (0 === xleft && (xleft = framewidth, (op += scanstride) >= opend && (scanstride = 4 * framestride + 4 * width * (interlaceskip - 1), 
                op = opbeg + (framewidth + framestride) * (interlaceskip << 1), interlaceskip >>= 1)), 
                index === trans) op += 4; else {
                    var r = buf[palette_offset + 3 * index], g = buf[palette_offset + 3 * index + 1], b = buf[palette_offset + 3 * index + 2];
                    pixels[op++] = b, pixels[op++] = g, pixels[op++] = r, pixels[op++] = 255;
                }
                --xleft;
            }
        }, this.decodeAndBlitFrameRGBA = function(frame_num, pixels) {
            var frame = this.frameInfo(frame_num), num_pixels = frame.width * frame.height, index_stream = new Uint8Array(num_pixels);
            GifReaderLZWOutputIndexStream(buf, frame.data_offset, index_stream, num_pixels);
            var palette_offset = frame.palette_offset, trans = frame.transparent_index;
            null === trans && (trans = 256);
            var framewidth = frame.width, framestride = width - framewidth, xleft = framewidth, opbeg = 4 * (frame.y * width + frame.x), opend = 4 * ((frame.y + frame.height) * width + frame.x), op = opbeg, scanstride = 4 * framestride;
            !0 === frame.interlaced && (scanstride += 4 * width * 7);
            for (var interlaceskip = 8, i = 0, il = index_stream.length; i < il; ++i) {
                var index = index_stream[i];
                if (0 === xleft && (xleft = framewidth, (op += scanstride) >= opend && (scanstride = 4 * framestride + 4 * width * (interlaceskip - 1), 
                op = opbeg + (framewidth + framestride) * (interlaceskip << 1), interlaceskip >>= 1)), 
                index === trans) op += 4; else {
                    var r = buf[palette_offset + 3 * index], g = buf[palette_offset + 3 * index + 1], b = buf[palette_offset + 3 * index + 2];
                    pixels[op++] = r, pixels[op++] = g, pixels[op++] = b, pixels[op++] = 255;
                }
                --xleft;
            }
        };
    };
} catch (e) {}

var gifutil = {}, __defProp = Object.defineProperty, __getOwnPropDesc = Object.getOwnPropertyDescriptor, __getOwnPropNames = Object.getOwnPropertyNames, __hasOwnProp = Object.prototype.hasOwnProperty, __export = (target, all) => {
    for (var name in all) __defProp(target, name, {
        get: all[name],
        enumerable: !0
    });
}, __toCommonJS = (cache => (module2, temp) => cache && cache.get(module2) || (temp = ((target, module2, copyDefault, desc) => {
    if (module2 && "object" == typeof module2 || "function" == typeof module2) for (let key of __getOwnPropNames(module2)) __hasOwnProp.call(target, key) || __defProp(target, key, {
        get: () => module2[key],
        enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable
    });
    return target;
})(__defProp({}, "__esModule", {
    value: !0
}), module2), cache && cache.set(module2, temp), temp))("undefined" != typeof WeakMap ? new WeakMap : 0), __publicField = (obj, key, value) => (((obj, key, value) => {
    key in obj ? __defProp(obj, key, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value
    }) : obj[key] = value;
})(obj, "symbol" != typeof key ? key + "" : key, value), value), src_exports = {};

__export(src_exports, {
    applyPalette: () => applyPalette,
    applyPaletteSync: () => applyPaletteSync,
    buildPalette: () => buildPalette,
    buildPaletteSync: () => buildPaletteSync,
    constants: () => constants_exports,
    conversion: () => conversion_exports,
    distance: () => distance_exports,
    image: () => image_exports,
    palette: () => palette_exports,
    quality: () => quality_exports,
    utils: () => utils_exports
});

var constants_exports = {};

__export(constants_exports, {
    bt709: () => bt709_exports
});

var bt709_exports = {};

__export(bt709_exports, {
    Y: () => Y,
    x: () => x,
    y: () => y
});

var Y = (Y2 => (Y2[Y2.RED = 0.2126] = "RED", Y2[Y2.GREEN = 0.7152] = "GREEN", Y2[Y2.BLUE = 0.0722] = "BLUE", 
Y2[Y2.WHITE = 1] = "WHITE", Y2))(Y || {}), x = (x2 => (x2[x2.RED = 0.64] = "RED", 
x2[x2.GREEN = 0.3] = "GREEN", x2[x2.BLUE = 0.15] = "BLUE", x2[x2.WHITE = 0.3127] = "WHITE", 
x2))(x || {}), y = (y2 => (y2[y2.RED = 0.33] = "RED", y2[y2.GREEN = 0.6] = "GREEN", 
y2[y2.BLUE = 0.06] = "BLUE", y2[y2.WHITE = 0.329] = "WHITE", y2))(y || {}), conversion_exports = {};

function correctGamma(n) {
    return n > 0.04045 ? ((n + 0.055) / 1.055) ** 2.4 : n / 12.92;
}

function rgb2xyz(r, g, b) {
    return {
        x: 0.4124 * (r = correctGamma(r / 255)) + 0.3576 * (g = correctGamma(g / 255)) + 0.1805 * (b = correctGamma(b / 255)),
        y: 0.2126 * r + 0.7152 * g + 0.0722 * b,
        z: 0.0193 * r + 0.1192 * g + 0.9505 * b
    };
}

__export(conversion_exports, {
    lab2rgb: () => lab2rgb,
    lab2xyz: () => lab2xyz,
    rgb2hsl: () => rgb2hsl$1,
    rgb2lab: () => rgb2lab,
    rgb2xyz: () => rgb2xyz,
    xyz2lab: () => xyz2lab,
    xyz2rgb: () => xyz2rgb
});

var arithmetic_exports = {};

function degrees2radians(n) {
    return n * (Math.PI / 180);
}

function max3(a, b, c) {
    let m = a;
    return m < b && (m = b), m < c && (m = c), m;
}

function min3(a, b, c) {
    let m = a;
    return m > b && (m = b), m > c && (m = c), m;
}

function intInRange(value, low, high) {
    return value > high && (value = high), value < low && (value = low), 0 | value;
}

function inRange0to255Rounded(n) {
    return (n = Math.round(n)) > 255 ? n = 255 : n < 0 && (n = 0), n;
}

function inRange0to255(n) {
    return n > 255 ? n = 255 : n < 0 && (n = 0), n;
}

function stableSort(arrayToSort, callback) {
    const type = typeof arrayToSort[0];
    let sorted;
    if ("number" === type || "string" === type) {
        const ord = Object.create(null);
        for (let i = 0, l = arrayToSort.length; i < l; i++) {
            const val = arrayToSort[i];
            ord[val] || 0 === ord[val] || (ord[val] = i);
        }
        sorted = arrayToSort.sort(((a, b) => callback(a, b) || ord[a] - ord[b]));
    } else {
        const ord2 = arrayToSort.slice(0);
        sorted = arrayToSort.sort(((a, b) => callback(a, b) || ord2.indexOf(a) - ord2.indexOf(b)));
    }
    return sorted;
}

function rgb2hsl$1(r, g, b) {
    const min = min3(r, g, b), max = max3(r, g, b), delta = max - min, l = (min + max) / 510;
    let s = 0;
    l > 0 && l < 1 && (s = delta / (l < 0.5 ? max + min : 510 - max - min));
    let h = 0;
    return delta > 0 && (h = max === r ? (g - b) / delta : max === g ? 2 + (b - r) / delta : 4 + (r - g) / delta, 
    h *= 60, h < 0 && (h += 360)), {
        h,
        s,
        l
    };
}

function pivot(n) {
    return n > 8856e-6 ? n ** (1 / 3) : 7.787 * n + 16 / 116;
}

function xyz2lab(x2, y2, z) {
    if (x2 = pivot(x2 / .95047), y2 = pivot(y2 / 1), z = pivot(z / 1.08883), 116 * y2 - 16 < 0) throw new Error("xxx");
    return {
        L: Math.max(0, 116 * y2 - 16),
        a: 500 * (x2 - y2),
        b: 200 * (y2 - z)
    };
}

function rgb2lab(r, g, b) {
    const xyz = rgb2xyz(r, g, b);
    return xyz2lab(xyz.x, xyz.y, xyz.z);
}

function pivot2(n) {
    return n > 0.206893034 ? n ** 3 : (n - 16 / 116) / 7.787;
}

function lab2xyz(L, a, b) {
    const y2 = (L + 16) / 116, z = y2 - b / 200;
    return {
        x: .95047 * pivot2(a / 500 + y2),
        y: 1 * pivot2(y2),
        z: 1.08883 * pivot2(z)
    };
}

function correctGamma2(n) {
    return n > 31308e-7 ? 1.055 * n ** (1 / 2.4) - 0.055 : 12.92 * n;
}

function xyz2rgb(x2, y2, z) {
    const r = correctGamma2(3.2406 * x2 + -1.5372 * y2 + -0.4986 * z), g = correctGamma2(-0.9689 * x2 + 1.8758 * y2 + 0.0415 * z), b = correctGamma2(0.0557 * x2 + -0.204 * y2 + 1.057 * z);
    return {
        r: inRange0to255Rounded(255 * r),
        g: inRange0to255Rounded(255 * g),
        b: inRange0to255Rounded(255 * b)
    };
}

function lab2rgb(L, a, b) {
    const xyz = lab2xyz(L, a, b);
    return xyz2rgb(xyz.x, xyz.y, xyz.z);
}

__export(arithmetic_exports, {
    degrees2radians: () => degrees2radians,
    inRange0to255: () => inRange0to255,
    inRange0to255Rounded: () => inRange0to255Rounded,
    intInRange: () => intInRange,
    max3: () => max3,
    min3: () => min3,
    stableSort: () => stableSort
});

var distance_exports = {};

__export(distance_exports, {
    AbstractDistanceCalculator: () => AbstractDistanceCalculator,
    AbstractEuclidean: () => AbstractEuclidean,
    AbstractManhattan: () => AbstractManhattan,
    CIE94GraphicArts: () => CIE94GraphicArts,
    CIE94Textiles: () => CIE94Textiles,
    CIEDE2000: () => CIEDE2000,
    CMetric: () => CMetric,
    Euclidean: () => Euclidean,
    EuclideanBT709: () => EuclideanBT709,
    EuclideanBT709NoAlpha: () => EuclideanBT709NoAlpha,
    Manhattan: () => Manhattan,
    ManhattanBT709: () => ManhattanBT709,
    ManhattanNommyde: () => ManhattanNommyde,
    PNGQuant: () => PNGQuant
});

var AbstractDistanceCalculator = class {
    constructor() {
        __publicField(this, "_maxDistance"), __publicField(this, "_whitePoint"), this._setDefaults(), 
        this.setWhitePoint(255, 255, 255, 255);
    }
    setWhitePoint(r, g, b, a) {
        this._whitePoint = {
            r: r > 0 ? 255 / r : 0,
            g: g > 0 ? 255 / g : 0,
            b: b > 0 ? 255 / b : 0,
            a: a > 0 ? 255 / a : 0
        }, this._maxDistance = this.calculateRaw(r, g, b, a, 0, 0, 0, 0);
    }
    calculateNormalized(colorA, colorB) {
        return this.calculateRaw(colorA.r, colorA.g, colorA.b, colorA.a, colorB.r, colorB.g, colorB.b, colorB.a) / this._maxDistance;
    }
}, AbstractCIE94 = class extends AbstractDistanceCalculator {
    calculateRaw(r1, g1, b1, a1, r2, g2, b2, a2) {
        const lab1 = rgb2lab(inRange0to255(r1 * this._whitePoint.r), inRange0to255(g1 * this._whitePoint.g), inRange0to255(b1 * this._whitePoint.b)), lab2 = rgb2lab(inRange0to255(r2 * this._whitePoint.r), inRange0to255(g2 * this._whitePoint.g), inRange0to255(b2 * this._whitePoint.b)), dL = lab1.L - lab2.L, dA = lab1.a - lab2.a, dB = lab1.b - lab2.b, c1 = Math.sqrt(lab1.a * lab1.a + lab1.b * lab1.b), dC = c1 - Math.sqrt(lab2.a * lab2.a + lab2.b * lab2.b);
        let deltaH = dA * dA + dB * dB - dC * dC;
        deltaH = deltaH < 0 ? 0 : Math.sqrt(deltaH);
        const dAlpha = (a2 - a1) * this._whitePoint.a * this._kA;
        return Math.sqrt((dL / this._Kl) ** 2 + (dC / (1 + this._K1 * c1)) ** 2 + (deltaH / (1 + this._K2 * c1)) ** 2 + dAlpha ** 2);
    }
}, CIE94Textiles = class extends AbstractCIE94 {
    _setDefaults() {
        this._Kl = 2, this._K1 = 0.048, this._K2 = 0.014, this._kA = 12.5 / 255;
    }
}, CIE94GraphicArts = class extends AbstractCIE94 {
    _setDefaults() {
        this._Kl = 1, this._K1 = 0.045, this._K2 = 0.015, this._kA = 25 / 255;
    }
}, _CIEDE2000 = class extends AbstractDistanceCalculator {
    _setDefaults() {}
    static _calculatehp(b, ap) {
        const hp = Math.atan2(b, ap);
        return hp >= 0 ? hp : hp + _CIEDE2000._deg360InRad;
    }
    static _calculateRT(ahp, aCp) {
        const aCp_to_7 = aCp ** 7, R_C = 2 * Math.sqrt(aCp_to_7 / (aCp_to_7 + _CIEDE2000._pow25to7)), delta_theta = _CIEDE2000._deg30InRad * Math.exp(-(((ahp - _CIEDE2000._deg275InRad) / _CIEDE2000._deg25InRad) ** 2));
        return -Math.sin(2 * delta_theta) * R_C;
    }
    static _calculateT(ahp) {
        return 1 - 0.17 * Math.cos(ahp - _CIEDE2000._deg30InRad) + 0.24 * Math.cos(2 * ahp) + 0.32 * Math.cos(3 * ahp + _CIEDE2000._deg6InRad) - 0.2 * Math.cos(4 * ahp - _CIEDE2000._deg63InRad);
    }
    static _calculate_ahp(C1pC2p, h_bar, h1p, h2p) {
        const hpSum = h1p + h2p;
        return 0 === C1pC2p ? hpSum : h_bar <= _CIEDE2000._deg180InRad ? hpSum / 2 : hpSum < _CIEDE2000._deg360InRad ? (hpSum + _CIEDE2000._deg360InRad) / 2 : (hpSum - _CIEDE2000._deg360InRad) / 2;
    }
    static _calculate_dHp(C1pC2p, h_bar, h2p, h1p) {
        let dhp;
        return dhp = 0 === C1pC2p ? 0 : h_bar <= _CIEDE2000._deg180InRad ? h2p - h1p : h2p <= h1p ? h2p - h1p + _CIEDE2000._deg360InRad : h2p - h1p - _CIEDE2000._deg360InRad, 
        2 * Math.sqrt(C1pC2p) * Math.sin(dhp / 2);
    }
    calculateRaw(r1, g1, b1, a1, r2, g2, b2, a2) {
        const lab1 = rgb2lab(inRange0to255(r1 * this._whitePoint.r), inRange0to255(g1 * this._whitePoint.g), inRange0to255(b1 * this._whitePoint.b)), lab2 = rgb2lab(inRange0to255(r2 * this._whitePoint.r), inRange0to255(g2 * this._whitePoint.g), inRange0to255(b2 * this._whitePoint.b)), dA = (a2 - a1) * this._whitePoint.a * _CIEDE2000._kA, dE2 = this.calculateRawInLab(lab1, lab2);
        return Math.sqrt(dE2 + dA * dA);
    }
    calculateRawInLab(Lab1, Lab2) {
        const L1 = Lab1.L, a1 = Lab1.a, b1 = Lab1.b, L2 = Lab2.L, a2 = Lab2.a, b2 = Lab2.b, pow_a_C1_C2_to_7 = ((Math.sqrt(a1 * a1 + b1 * b1) + Math.sqrt(a2 * a2 + b2 * b2)) / 2) ** 7, G = 0.5 * (1 - Math.sqrt(pow_a_C1_C2_to_7 / (pow_a_C1_C2_to_7 + _CIEDE2000._pow25to7))), a1p = (1 + G) * a1, a2p = (1 + G) * a2, C1p = Math.sqrt(a1p * a1p + b1 * b1), C2p = Math.sqrt(a2p * a2p + b2 * b2), C1pC2p = C1p * C2p, h1p = _CIEDE2000._calculatehp(b1, a1p), h2p = _CIEDE2000._calculatehp(b2, a2p), h_bar = Math.abs(h1p - h2p), dLp = L2 - L1, dCp = C2p - C1p, dHp = _CIEDE2000._calculate_dHp(C1pC2p, h_bar, h2p, h1p), ahp = _CIEDE2000._calculate_ahp(C1pC2p, h_bar, h1p, h2p), aCp = (C1p + C2p) / 2, aLp_minus_50_square = ((L1 + L2) / 2 - 50) ** 2, dCpSC = dCp / (1 + 0.045 * aCp), dHpSH = dHp / (1 + 0.015 * _CIEDE2000._calculateT(ahp) * aCp);
        return (dLp / (1 + 0.015 * aLp_minus_50_square / Math.sqrt(20 + aLp_minus_50_square))) ** 2 + dCpSC ** 2 + dHpSH ** 2 + _CIEDE2000._calculateRT(ahp, aCp) * dCpSC * dHpSH;
    }
}, CIEDE2000 = _CIEDE2000;

__publicField(CIEDE2000, "_kA", 25 / 255), __publicField(CIEDE2000, "_pow25to7", 25 ** 7), 
__publicField(CIEDE2000, "_deg360InRad", degrees2radians(360)), __publicField(CIEDE2000, "_deg180InRad", degrees2radians(180)), 
__publicField(CIEDE2000, "_deg30InRad", degrees2radians(30)), __publicField(CIEDE2000, "_deg6InRad", degrees2radians(6)), 
__publicField(CIEDE2000, "_deg63InRad", degrees2radians(63)), __publicField(CIEDE2000, "_deg275InRad", degrees2radians(275)), 
__publicField(CIEDE2000, "_deg25InRad", degrees2radians(25));

var CMetric = class extends AbstractDistanceCalculator {
    calculateRaw(r1, g1, b1, a1, r2, g2, b2, a2) {
        const rmean = (r1 + r2) / 2 * this._whitePoint.r, r = (r1 - r2) * this._whitePoint.r, g = (g1 - g2) * this._whitePoint.g, b = (b1 - b2) * this._whitePoint.b, dE = ((512 + rmean) * r * r >> 8) + 4 * g * g + ((767 - rmean) * b * b >> 8), dA = (a2 - a1) * this._whitePoint.a;
        return Math.sqrt(dE + dA * dA);
    }
    _setDefaults() {}
}, AbstractEuclidean = class extends AbstractDistanceCalculator {
    calculateRaw(r1, g1, b1, a1, r2, g2, b2, a2) {
        const dR = r2 - r1, dG = g2 - g1, dB = b2 - b1, dA = a2 - a1;
        return Math.sqrt(this._kR * dR * dR + this._kG * dG * dG + this._kB * dB * dB + this._kA * dA * dA);
    }
}, Euclidean = class extends AbstractEuclidean {
    _setDefaults() {
        this._kR = 1, this._kG = 1, this._kB = 1, this._kA = 1;
    }
}, EuclideanBT709 = class extends AbstractEuclidean {
    _setDefaults() {
        this._kR = 0.2126, this._kG = 0.7152, this._kB = 0.0722, this._kA = 1;
    }
}, EuclideanBT709NoAlpha = class extends AbstractEuclidean {
    _setDefaults() {
        this._kR = 0.2126, this._kG = 0.7152, this._kB = 0.0722, this._kA = 0;
    }
}, AbstractManhattan = class extends AbstractDistanceCalculator {
    calculateRaw(r1, g1, b1, a1, r2, g2, b2, a2) {
        let dR = r2 - r1, dG = g2 - g1, dB = b2 - b1, dA = a2 - a1;
        return dR < 0 && (dR = 0 - dR), dG < 0 && (dG = 0 - dG), dB < 0 && (dB = 0 - dB), 
        dA < 0 && (dA = 0 - dA), this._kR * dR + this._kG * dG + this._kB * dB + this._kA * dA;
    }
}, Manhattan = class extends AbstractManhattan {
    _setDefaults() {
        this._kR = 1, this._kG = 1, this._kB = 1, this._kA = 1;
    }
}, ManhattanNommyde = class extends AbstractManhattan {
    _setDefaults() {
        this._kR = 0.4984, this._kG = 0.8625, this._kB = 0.2979, this._kA = 1;
    }
}, ManhattanBT709 = class extends AbstractManhattan {
    _setDefaults() {
        this._kR = 0.2126, this._kG = 0.7152, this._kB = 0.0722, this._kA = 1;
    }
}, PNGQuant = class extends AbstractDistanceCalculator {
    calculateRaw(r1, g1, b1, a1, r2, g2, b2, a2) {
        const alphas = (a2 - a1) * this._whitePoint.a;
        return this._colordifferenceCh(r1 * this._whitePoint.r, r2 * this._whitePoint.r, alphas) + this._colordifferenceCh(g1 * this._whitePoint.g, g2 * this._whitePoint.g, alphas) + this._colordifferenceCh(b1 * this._whitePoint.b, b2 * this._whitePoint.b, alphas);
    }
    _colordifferenceCh(x2, y2, alphas) {
        const black = x2 - y2, white = black + alphas;
        return black * black + white * white;
    }
    _setDefaults() {}
}, palette_exports = {};

__export(palette_exports, {
    AbstractPaletteQuantizer: () => AbstractPaletteQuantizer,
    ColorHistogram: () => ColorHistogram,
    NeuQuant: () => NeuQuant,
    NeuQuantFloat: () => NeuQuantFloat,
    RGBQuant: () => RGBQuant,
    WuColorCube: () => WuColorCube,
    WuQuant: () => WuQuant
});

var AbstractPaletteQuantizer = class {
    quantizeSync() {
        for (const value of this.quantize()) if (value.palette) return value.palette;
        throw new Error("unreachable");
    }
}, Point = class {
    constructor() {
        __publicField(this, "r"), __publicField(this, "g"), __publicField(this, "b"), __publicField(this, "a"), 
        __publicField(this, "uint32"), __publicField(this, "rgba"), this.uint32 = -1 >>> 0, 
        this.r = this.g = this.b = this.a = 0, this.rgba = new Array(4), this.rgba[0] = 0, 
        this.rgba[1] = 0, this.rgba[2] = 0, this.rgba[3] = 0;
    }
    static createByQuadruplet(quadruplet) {
        const point = new Point;
        return point.r = 0 | quadruplet[0], point.g = 0 | quadruplet[1], point.b = 0 | quadruplet[2], 
        point.a = 0 | quadruplet[3], point._loadUINT32(), point._loadQuadruplet(), point;
    }
    static createByRGBA(red, green, blue, alpha) {
        const point = new Point;
        return point.r = 0 | red, point.g = 0 | green, point.b = 0 | blue, point.a = 0 | alpha, 
        point._loadUINT32(), point._loadQuadruplet(), point;
    }
    static createByUint32(uint32) {
        const point = new Point;
        return point.uint32 = uint32 >>> 0, point._loadRGBA(), point._loadQuadruplet(), 
        point;
    }
    from(point) {
        this.r = point.r, this.g = point.g, this.b = point.b, this.a = point.a, this.uint32 = point.uint32, 
        this.rgba[0] = point.r, this.rgba[1] = point.g, this.rgba[2] = point.b, this.rgba[3] = point.a;
    }
    getLuminosity(useAlphaChannel) {
        let r = this.r, g = this.g, b = this.b;
        return useAlphaChannel && (r = Math.min(255, 255 - this.a + this.a * r / 255), g = Math.min(255, 255 - this.a + this.a * g / 255), 
        b = Math.min(255, 255 - this.a + this.a * b / 255)), 0.2126 * r + 0.7152 * g + 0.0722 * b;
    }
    _loadUINT32() {
        this.uint32 = (this.a << 24 | this.b << 16 | this.g << 8 | this.r) >>> 0;
    }
    _loadRGBA() {
        this.r = 255 & this.uint32, this.g = this.uint32 >>> 8 & 255, this.b = this.uint32 >>> 16 & 255, 
        this.a = this.uint32 >>> 24 & 255;
    }
    _loadQuadruplet() {
        this.rgba[0] = this.r, this.rgba[1] = this.g, this.rgba[2] = this.b, this.rgba[3] = this.a;
    }
}, PointContainer = class {
    constructor() {
        __publicField(this, "_pointArray"), __publicField(this, "_width"), __publicField(this, "_height"), 
        this._width = 0, this._height = 0, this._pointArray = [];
    }
    getWidth() {
        return this._width;
    }
    getHeight() {
        return this._height;
    }
    setWidth(width) {
        this._width = width;
    }
    setHeight(height) {
        this._height = height;
    }
    getPointArray() {
        return this._pointArray;
    }
    clone() {
        const clone = new PointContainer;
        clone._width = this._width, clone._height = this._height;
        for (let i = 0, l = this._pointArray.length; i < l; i++) clone._pointArray[i] = Point.createByUint32(0 | this._pointArray[i].uint32);
        return clone;
    }
    toUint32Array() {
        const l = this._pointArray.length, uint32Array = new Uint32Array(l);
        for (let i = 0; i < l; i++) uint32Array[i] = this._pointArray[i].uint32;
        return uint32Array;
    }
    toUint8Array() {
        return new Uint8Array(this.toUint32Array().buffer);
    }
    static fromHTMLImageElement(img) {
        const width = img.naturalWidth, height = img.naturalHeight, canvas = document.createElement("canvas");
        return canvas.width = width, canvas.height = height, canvas.getContext("2d").drawImage(img, 0, 0, width, height, 0, 0, width, height), 
        PointContainer.fromHTMLCanvasElement(canvas);
    }
    static fromHTMLCanvasElement(canvas) {
        const width = canvas.width, height = canvas.height, imgData = canvas.getContext("2d").getImageData(0, 0, width, height);
        return PointContainer.fromImageData(imgData);
    }
    static fromImageData(imageData) {
        const width = imageData.width, height = imageData.height;
        return PointContainer.fromUint8Array(imageData.data, width, height);
    }
    static fromUint8Array(uint8Array, width, height) {
        switch (Object.prototype.toString.call(uint8Array)) {
          case "[object Uint8ClampedArray]":
          case "[object Uint8Array]":
            break;

          default:
            uint8Array = new Uint8Array(uint8Array);
        }
        const uint32Array = new Uint32Array(uint8Array.buffer);
        return PointContainer.fromUint32Array(uint32Array, width, height);
    }
    static fromUint32Array(uint32Array, width, height) {
        const container = new PointContainer;
        container._width = width, container._height = height;
        for (let i = 0, l = uint32Array.length; i < l; i++) container._pointArray[i] = Point.createByUint32(0 | uint32Array[i]);
        return container;
    }
    static fromBuffer(buffer, width, height) {
        const uint32Array = new Uint32Array(buffer.buffer, buffer.byteOffset, buffer.byteLength / Uint32Array.BYTES_PER_ELEMENT);
        return PointContainer.fromUint32Array(uint32Array, width, height);
    }
};

function hueGroup(hue, segmentsNumber) {
    const seg = 360 / segmentsNumber;
    for (let i = 1, mid = seg - seg / 2; i < segmentsNumber; i++, mid += seg) if (hue >= mid && hue < mid + seg) return i;
    return 0;
}

var Palette = class {
    constructor() {
        __publicField(this, "_pointContainer"), __publicField(this, "_pointArray", []), 
        __publicField(this, "_i32idx", {}), this._pointContainer = new PointContainer, this._pointContainer.setHeight(1), 
        this._pointArray = this._pointContainer.getPointArray();
    }
    add(color) {
        this._pointArray.push(color), this._pointContainer.setWidth(this._pointArray.length);
    }
    has(color) {
        for (let i = this._pointArray.length - 1; i >= 0; i--) if (color.uint32 === this._pointArray[i].uint32) return !0;
        return !1;
    }
    getNearestColor(colorDistanceCalculator, color) {
        return this._pointArray[0 | this._getNearestIndex(colorDistanceCalculator, color)];
    }
    getPointContainer() {
        return this._pointContainer;
    }
    _nearestPointFromCache(key) {
        return "number" == typeof this._i32idx[key] ? this._i32idx[key] : -1;
    }
    _getNearestIndex(colorDistanceCalculator, point) {
        let idx = this._nearestPointFromCache("" + point.uint32);
        if (idx >= 0) return idx;
        let minimalDistance = Number.MAX_VALUE;
        idx = 0;
        for (let i = 0, l = this._pointArray.length; i < l; i++) {
            const p = this._pointArray[i], distance = colorDistanceCalculator.calculateRaw(point.r, point.g, point.b, point.a, p.r, p.g, p.b, p.a);
            distance < minimalDistance && (minimalDistance = distance, idx = i);
        }
        return this._i32idx[point.uint32] = idx, idx;
    }
    sort() {
        this._i32idx = {}, this._pointArray.sort(((a, b) => {
            const hslA = rgb2hsl$1(a.r, a.g, a.b), hslB = rgb2hsl$1(b.r, b.g, b.b), hueA = a.r === a.g && a.g === a.b ? 0 : 1 + hueGroup(hslA.h, 10), hueDiff = (b.r === b.g && b.g === b.b ? 0 : 1 + hueGroup(hslB.h, 10)) - hueA;
            if (hueDiff) return -hueDiff;
            const lA = a.getLuminosity(!0), lB = b.getLuminosity(!0);
            if (lB - lA != 0) return lB - lA;
            const satDiff = (100 * hslB.s | 0) - (100 * hslA.s | 0);
            return satDiff ? -satDiff : 0;
        }));
    }
}, utils_exports = {};

__export(utils_exports, {
    HueStatistics: () => HueStatistics,
    Palette: () => Palette,
    Point: () => Point,
    PointContainer: () => PointContainer,
    ProgressTracker: () => ProgressTracker,
    arithmetic: () => arithmetic_exports
});

var HueGroup = class {
    constructor() {
        __publicField(this, "num", 0), __publicField(this, "cols", []);
    }
}, HueStatistics = class {
    constructor(numGroups, minCols) {
        __publicField(this, "_numGroups"), __publicField(this, "_minCols"), __publicField(this, "_stats"), 
        __publicField(this, "_groupsFull"), this._numGroups = numGroups, this._minCols = minCols, 
        this._stats = [];
        for (let i = 0; i <= numGroups; i++) this._stats[i] = new HueGroup;
        this._groupsFull = 0;
    }
    check(i32) {
        this._groupsFull === this._numGroups + 1 && (this.check = () => {});
        const r = 255 & i32, g = i32 >>> 8 & 255, b = i32 >>> 16 & 255, hg = r === g && g === b ? 0 : 1 + hueGroup(rgb2hsl$1(r, g, b).h, this._numGroups), gr = this._stats[hg], min = this._minCols;
        gr.num++, gr.num > min || (gr.num === min && this._groupsFull++, gr.num <= min && this._stats[hg].cols.push(i32));
    }
    injectIntoDictionary(histG) {
        for (let i = 0; i <= this._numGroups; i++) this._stats[i].num <= this._minCols && this._stats[i].cols.forEach((col => {
            histG[col] ? histG[col]++ : histG[col] = 1;
        }));
    }
    injectIntoArray(histG) {
        for (let i = 0; i <= this._numGroups; i++) this._stats[i].num <= this._minCols && this._stats[i].cols.forEach((col => {
            -1 === histG.indexOf(col) && histG.push(col);
        }));
    }
}, _ProgressTracker = class {
    constructor(valueRange, progressRange) {
        __publicField(this, "progress"), __publicField(this, "_step"), __publicField(this, "_range"), 
        __publicField(this, "_last"), __publicField(this, "_progressRange"), this._range = valueRange, 
        this._progressRange = progressRange, this._step = Math.max(1, this._range / (_ProgressTracker.steps + 1) | 0), 
        this._last = -this._step, this.progress = 0;
    }
    shouldNotify(current) {
        return current - this._last >= this._step && (this._last = current, this.progress = Math.min(this._progressRange * this._last / this._range, this._progressRange), 
        !0);
    }
}, ProgressTracker = _ProgressTracker;

__publicField(ProgressTracker, "steps", 100);

var Neuron = class {
    constructor(defaultValue) {
        __publicField(this, "r"), __publicField(this, "g"), __publicField(this, "b"), __publicField(this, "a"), 
        this.r = this.g = this.b = this.a = defaultValue;
    }
    toPoint() {
        return Point.createByRGBA(this.r >> 3, this.g >> 3, this.b >> 3, this.a >> 3);
    }
    subtract(r, g, b, a) {
        this.r -= 0 | r, this.g -= 0 | g, this.b -= 0 | b, this.a -= 0 | a;
    }
}, _NeuQuant = class extends AbstractPaletteQuantizer {
    constructor(colorDistanceCalculator, colors = 256) {
        super(), __publicField(this, "_pointArray"), __publicField(this, "_networkSize"), 
        __publicField(this, "_network"), __publicField(this, "_sampleFactor"), __publicField(this, "_radPower"), 
        __publicField(this, "_freq"), __publicField(this, "_bias"), __publicField(this, "_distance"), 
        this._distance = colorDistanceCalculator, this._pointArray = [], this._sampleFactor = 1, 
        this._networkSize = colors, this._distance.setWhitePoint(2040, 2040, 2040, 2040);
    }
    sample(pointContainer) {
        this._pointArray = this._pointArray.concat(pointContainer.getPointArray());
    }
    * quantize() {
        this._init(), yield* this._learn(), yield {
            palette: this._buildPalette(),
            progress: 100
        };
    }
    _init() {
        this._freq = [], this._bias = [], this._radPower = [], this._network = [];
        for (let i = 0; i < this._networkSize; i++) this._network[i] = new Neuron((i << 11) / this._networkSize | 0), 
        this._freq[i] = _NeuQuant._initialBias / this._networkSize | 0, this._bias[i] = 0;
    }
    * _learn() {
        let sampleFactor = this._sampleFactor;
        const pointsNumber = this._pointArray.length;
        pointsNumber < _NeuQuant._minpicturebytes && (sampleFactor = 1);
        const alphadec = 30 + (sampleFactor - 1) / 3 | 0, pointsToSample = pointsNumber / sampleFactor | 0;
        let step, delta = pointsToSample / _NeuQuant._nCycles | 0, alpha = _NeuQuant._initAlpha, radius = (this._networkSize >> 3) * _NeuQuant._radiusBias, rad = radius >> _NeuQuant._radiusBiasShift;
        rad <= 1 && (rad = 0);
        for (let i = 0; i < rad; i++) this._radPower[i] = alpha * ((rad * rad - i * i) * _NeuQuant._radBias / (rad * rad)) >>> 0;
        step = pointsNumber < _NeuQuant._minpicturebytes ? 1 : pointsNumber % _NeuQuant._prime1 != 0 ? _NeuQuant._prime1 : pointsNumber % _NeuQuant._prime2 != 0 ? _NeuQuant._prime2 : pointsNumber % _NeuQuant._prime3 != 0 ? _NeuQuant._prime3 : _NeuQuant._prime4;
        const tracker = new ProgressTracker(pointsToSample, 99);
        for (let i = 0, pointIndex = 0; i < pointsToSample; ) {
            tracker.shouldNotify(i) && (yield {
                progress: tracker.progress
            });
            const point = this._pointArray[pointIndex], b = point.b << 3, g = point.g << 3, r = point.r << 3, a = point.a << 3, neuronIndex = this._contest(b, g, r, a);
            if (this._alterSingle(alpha, neuronIndex, b, g, r, a), 0 !== rad && this._alterNeighbour(rad, neuronIndex, b, g, r, a), 
            pointIndex += step, pointIndex >= pointsNumber && (pointIndex -= pointsNumber), 
            i++, 0 === delta && (delta = 1), i % delta == 0) {
                alpha -= alpha / alphadec | 0, radius -= radius / _NeuQuant._radiusDecrease | 0, 
                rad = radius >> _NeuQuant._radiusBiasShift, rad <= 1 && (rad = 0);
                for (let j = 0; j < rad; j++) this._radPower[j] = alpha * ((rad * rad - j * j) * _NeuQuant._radBias / (rad * rad)) >>> 0;
            }
        }
    }
    _buildPalette() {
        const palette = new Palette;
        return this._network.forEach((neuron => {
            palette.add(neuron.toPoint());
        })), palette.sort(), palette;
    }
    _alterNeighbour(rad, i, b, g, r, al) {
        let lo = i - rad;
        lo < -1 && (lo = -1);
        let hi = i + rad;
        hi > this._networkSize && (hi = this._networkSize);
        let j = i + 1, k = i - 1, m = 1;
        for (;j < hi || k > lo; ) {
            const a = this._radPower[m++] / _NeuQuant._alphaRadBias;
            if (j < hi) {
                const p = this._network[j++];
                p.subtract(a * (p.r - r), a * (p.g - g), a * (p.b - b), a * (p.a - al));
            }
            if (k > lo) {
                const p = this._network[k--];
                p.subtract(a * (p.r - r), a * (p.g - g), a * (p.b - b), a * (p.a - al));
            }
        }
    }
    _alterSingle(alpha, i, b, g, r, a) {
        alpha /= _NeuQuant._initAlpha;
        const n = this._network[i];
        n.subtract(alpha * (n.r - r), alpha * (n.g - g), alpha * (n.b - b), alpha * (n.a - a));
    }
    _contest(b, g, r, a) {
        let bestd = ~(1 << 31), bestbiasd = bestd, bestpos = -1, bestbiaspos = bestpos;
        for (let i = 0; i < this._networkSize; i++) {
            const n = this._network[i], dist = 8160 * this._distance.calculateNormalized(n, {
                r,
                g,
                b,
                a
            }) | 0;
            dist < bestd && (bestd = dist, bestpos = i);
            const biasdist = dist - (this._bias[i] >> _NeuQuant._initialBiasShift - 3);
            biasdist < bestbiasd && (bestbiasd = biasdist, bestbiaspos = i);
            const betafreq = this._freq[i] >> _NeuQuant._betaShift;
            this._freq[i] -= betafreq, this._bias[i] += betafreq << _NeuQuant._gammaShift;
        }
        return this._freq[bestpos] += _NeuQuant._beta, this._bias[bestpos] -= _NeuQuant._betaGamma, 
        bestbiaspos;
    }
}, NeuQuant = _NeuQuant;

__publicField(NeuQuant, "_prime1", 499), __publicField(NeuQuant, "_prime2", 491), 
__publicField(NeuQuant, "_prime3", 487), __publicField(NeuQuant, "_prime4", 503), 
__publicField(NeuQuant, "_minpicturebytes", _NeuQuant._prime4), __publicField(NeuQuant, "_nCycles", 100), 
__publicField(NeuQuant, "_initialBiasShift", 16), __publicField(NeuQuant, "_initialBias", 1 << _NeuQuant._initialBiasShift), 
__publicField(NeuQuant, "_gammaShift", 10), __publicField(NeuQuant, "_betaShift", 10), 
__publicField(NeuQuant, "_beta", _NeuQuant._initialBias >> _NeuQuant._betaShift), 
__publicField(NeuQuant, "_betaGamma", _NeuQuant._initialBias << _NeuQuant._gammaShift - _NeuQuant._betaShift), 
__publicField(NeuQuant, "_radiusBiasShift", 6), __publicField(NeuQuant, "_radiusBias", 1 << _NeuQuant._radiusBiasShift), 
__publicField(NeuQuant, "_radiusDecrease", 30), __publicField(NeuQuant, "_alphaBiasShift", 10), 
__publicField(NeuQuant, "_initAlpha", 1 << _NeuQuant._alphaBiasShift), __publicField(NeuQuant, "_radBiasShift", 8), 
__publicField(NeuQuant, "_radBias", 1 << _NeuQuant._radBiasShift), __publicField(NeuQuant, "_alphaRadBiasShift", _NeuQuant._alphaBiasShift + _NeuQuant._radBiasShift), 
__publicField(NeuQuant, "_alphaRadBias", 1 << _NeuQuant._alphaRadBiasShift);

var NeuronFloat = class {
    constructor(defaultValue) {
        __publicField(this, "r"), __publicField(this, "g"), __publicField(this, "b"), __publicField(this, "a"), 
        this.r = this.g = this.b = this.a = defaultValue;
    }
    toPoint() {
        return Point.createByRGBA(this.r >> 3, this.g >> 3, this.b >> 3, this.a >> 3);
    }
    subtract(r, g, b, a) {
        this.r -= r, this.g -= g, this.b -= b, this.a -= a;
    }
}, _NeuQuantFloat = class extends AbstractPaletteQuantizer {
    constructor(colorDistanceCalculator, colors = 256) {
        super(), __publicField(this, "_pointArray"), __publicField(this, "_networkSize"), 
        __publicField(this, "_network"), __publicField(this, "_sampleFactor"), __publicField(this, "_radPower"), 
        __publicField(this, "_freq"), __publicField(this, "_bias"), __publicField(this, "_distance"), 
        this._distance = colorDistanceCalculator, this._pointArray = [], this._sampleFactor = 1, 
        this._networkSize = colors, this._distance.setWhitePoint(2040, 2040, 2040, 2040);
    }
    sample(pointContainer) {
        this._pointArray = this._pointArray.concat(pointContainer.getPointArray());
    }
    * quantize() {
        this._init(), yield* this._learn(), yield {
            palette: this._buildPalette(),
            progress: 100
        };
    }
    _init() {
        this._freq = [], this._bias = [], this._radPower = [], this._network = [];
        for (let i = 0; i < this._networkSize; i++) this._network[i] = new NeuronFloat((i << 11) / this._networkSize), 
        this._freq[i] = _NeuQuantFloat._initialBias / this._networkSize, this._bias[i] = 0;
    }
    * _learn() {
        let sampleFactor = this._sampleFactor;
        const pointsNumber = this._pointArray.length;
        pointsNumber < _NeuQuantFloat._minpicturebytes && (sampleFactor = 1);
        const alphadec = 30 + (sampleFactor - 1) / 3, pointsToSample = pointsNumber / sampleFactor;
        let step, delta = pointsToSample / _NeuQuantFloat._nCycles | 0, alpha = _NeuQuantFloat._initAlpha, radius = (this._networkSize >> 3) * _NeuQuantFloat._radiusBias, rad = radius >> _NeuQuantFloat._radiusBiasShift;
        rad <= 1 && (rad = 0);
        for (let i = 0; i < rad; i++) this._radPower[i] = alpha * ((rad * rad - i * i) * _NeuQuantFloat._radBias / (rad * rad));
        step = pointsNumber < _NeuQuantFloat._minpicturebytes ? 1 : pointsNumber % _NeuQuantFloat._prime1 != 0 ? _NeuQuantFloat._prime1 : pointsNumber % _NeuQuantFloat._prime2 != 0 ? _NeuQuantFloat._prime2 : pointsNumber % _NeuQuantFloat._prime3 != 0 ? _NeuQuantFloat._prime3 : _NeuQuantFloat._prime4;
        const tracker = new ProgressTracker(pointsToSample, 99);
        for (let i = 0, pointIndex = 0; i < pointsToSample; ) {
            tracker.shouldNotify(i) && (yield {
                progress: tracker.progress
            });
            const point = this._pointArray[pointIndex], b = point.b << 3, g = point.g << 3, r = point.r << 3, a = point.a << 3, neuronIndex = this._contest(b, g, r, a);
            if (this._alterSingle(alpha, neuronIndex, b, g, r, a), 0 !== rad && this._alterNeighbour(rad, neuronIndex, b, g, r, a), 
            pointIndex += step, pointIndex >= pointsNumber && (pointIndex -= pointsNumber), 
            i++, 0 === delta && (delta = 1), i % delta == 0) {
                alpha -= alpha / alphadec, radius -= radius / _NeuQuantFloat._radiusDecrease, rad = radius >> _NeuQuantFloat._radiusBiasShift, 
                rad <= 1 && (rad = 0);
                for (let j = 0; j < rad; j++) this._radPower[j] = alpha * ((rad * rad - j * j) * _NeuQuantFloat._radBias / (rad * rad));
            }
        }
    }
    _buildPalette() {
        const palette = new Palette;
        return this._network.forEach((neuron => {
            palette.add(neuron.toPoint());
        })), palette.sort(), palette;
    }
    _alterNeighbour(rad, i, b, g, r, al) {
        let lo = i - rad;
        lo < -1 && (lo = -1);
        let hi = i + rad;
        hi > this._networkSize && (hi = this._networkSize);
        let j = i + 1, k = i - 1, m = 1;
        for (;j < hi || k > lo; ) {
            const a = this._radPower[m++] / _NeuQuantFloat._alphaRadBias;
            if (j < hi) {
                const p = this._network[j++];
                p.subtract(a * (p.r - r), a * (p.g - g), a * (p.b - b), a * (p.a - al));
            }
            if (k > lo) {
                const p = this._network[k--];
                p.subtract(a * (p.r - r), a * (p.g - g), a * (p.b - b), a * (p.a - al));
            }
        }
    }
    _alterSingle(alpha, i, b, g, r, a) {
        alpha /= _NeuQuantFloat._initAlpha;
        const n = this._network[i];
        n.subtract(alpha * (n.r - r), alpha * (n.g - g), alpha * (n.b - b), alpha * (n.a - a));
    }
    _contest(b, g, r, al) {
        let bestd = ~(1 << 31), bestbiasd = bestd, bestpos = -1, bestbiaspos = bestpos;
        for (let i = 0; i < this._networkSize; i++) {
            const n = this._network[i], dist = 8160 * this._distance.calculateNormalized(n, {
                r,
                g,
                b,
                a: al
            });
            dist < bestd && (bestd = dist, bestpos = i);
            const biasdist = dist - (this._bias[i] >> _NeuQuantFloat._initialBiasShift - 3);
            biasdist < bestbiasd && (bestbiasd = biasdist, bestbiaspos = i);
            const betafreq = this._freq[i] >> _NeuQuantFloat._betaShift;
            this._freq[i] -= betafreq, this._bias[i] += betafreq << _NeuQuantFloat._gammaShift;
        }
        return this._freq[bestpos] += _NeuQuantFloat._beta, this._bias[bestpos] -= _NeuQuantFloat._betaGamma, 
        bestbiaspos;
    }
}, NeuQuantFloat = _NeuQuantFloat;

__publicField(NeuQuantFloat, "_prime1", 499), __publicField(NeuQuantFloat, "_prime2", 491), 
__publicField(NeuQuantFloat, "_prime3", 487), __publicField(NeuQuantFloat, "_prime4", 503), 
__publicField(NeuQuantFloat, "_minpicturebytes", _NeuQuantFloat._prime4), __publicField(NeuQuantFloat, "_nCycles", 100), 
__publicField(NeuQuantFloat, "_initialBiasShift", 16), __publicField(NeuQuantFloat, "_initialBias", 1 << _NeuQuantFloat._initialBiasShift), 
__publicField(NeuQuantFloat, "_gammaShift", 10), __publicField(NeuQuantFloat, "_betaShift", 10), 
__publicField(NeuQuantFloat, "_beta", _NeuQuantFloat._initialBias >> _NeuQuantFloat._betaShift), 
__publicField(NeuQuantFloat, "_betaGamma", _NeuQuantFloat._initialBias << _NeuQuantFloat._gammaShift - _NeuQuantFloat._betaShift), 
__publicField(NeuQuantFloat, "_radiusBiasShift", 6), __publicField(NeuQuantFloat, "_radiusBias", 1 << _NeuQuantFloat._radiusBiasShift), 
__publicField(NeuQuantFloat, "_radiusDecrease", 30), __publicField(NeuQuantFloat, "_alphaBiasShift", 10), 
__publicField(NeuQuantFloat, "_initAlpha", 1 << _NeuQuantFloat._alphaBiasShift), 
__publicField(NeuQuantFloat, "_radBiasShift", 8), __publicField(NeuQuantFloat, "_radBias", 1 << _NeuQuantFloat._radBiasShift), 
__publicField(NeuQuantFloat, "_alphaRadBiasShift", _NeuQuantFloat._alphaBiasShift + _NeuQuantFloat._radBiasShift), 
__publicField(NeuQuantFloat, "_alphaRadBias", 1 << _NeuQuantFloat._alphaRadBiasShift);

var _ColorHistogram = class {
    constructor(method, colors) {
        __publicField(this, "_method"), __publicField(this, "_hueStats"), __publicField(this, "_histogram"), 
        __publicField(this, "_initColors"), __publicField(this, "_minHueCols"), this._method = method, 
        this._minHueCols = colors << 2, this._initColors = colors << 2, this._hueStats = new HueStatistics(_ColorHistogram._hueGroups, this._minHueCols), 
        this._histogram = Object.create(null);
    }
    sample(pointContainer) {
        switch (this._method) {
          case 1:
            this._colorStats1D(pointContainer);
            break;

          case 2:
            this._colorStats2D(pointContainer);
        }
    }
    getImportanceSortedColorsIDXI32() {
        const sorted = stableSort(Object.keys(this._histogram), ((a, b) => this._histogram[b] - this._histogram[a]));
        if (0 === sorted.length) return [];
        let idxi32;
        switch (this._method) {
          case 1:
            const initialColorsLimit = Math.min(sorted.length, this._initColors), last = sorted[initialColorsLimit - 1], freq = this._histogram[last];
            idxi32 = sorted.slice(0, initialColorsLimit);
            let pos = initialColorsLimit;
            const len = sorted.length;
            for (;pos < len && this._histogram[sorted[pos]] === freq; ) idxi32.push(sorted[pos++]);
            this._hueStats.injectIntoArray(idxi32);
            break;

          case 2:
            idxi32 = sorted;
            break;

          default:
            throw new Error("Incorrect method");
        }
        return idxi32.map((v => +v));
    }
    _colorStats1D(pointContainer) {
        const histG = this._histogram, pointArray = pointContainer.getPointArray(), len = pointArray.length;
        for (let i = 0; i < len; i++) {
            const col = pointArray[i].uint32;
            this._hueStats.check(col), col in histG ? histG[col]++ : histG[col] = 1;
        }
    }
    _colorStats2D(pointContainer) {
        const width = pointContainer.getWidth(), height = pointContainer.getHeight(), pointArray = pointContainer.getPointArray(), boxW = _ColorHistogram._boxSize[0], boxH = _ColorHistogram._boxSize[1], area = boxW * boxH, boxes = this._makeBoxes(width, height, boxW, boxH), histG = this._histogram;
        boxes.forEach((box => {
            let effc = Math.round(box.w * box.h / area) * _ColorHistogram._boxPixels;
            effc < 2 && (effc = 2);
            const histL = {};
            this._iterateBox(box, width, (i => {
                const col = pointArray[i].uint32;
                this._hueStats.check(col), col in histG ? histG[col]++ : col in histL ? ++histL[col] >= effc && (histG[col] = histL[col]) : histL[col] = 1;
            }));
        })), this._hueStats.injectIntoDictionary(histG);
    }
    _iterateBox(bbox, wid, fn) {
        const b = bbox, i0 = b.y * wid + b.x, i1 = (b.y + b.h - 1) * wid + (b.x + b.w - 1), incr = wid - b.w + 1;
        let cnt = 0, i = i0;
        do {
            fn.call(this, i), i += ++cnt % b.w == 0 ? incr : 1;
        } while (i <= i1);
    }
    _makeBoxes(width, height, stepX, stepY) {
        const wrem = width % stepX, hrem = height % stepY, xend = width - wrem, yend = height - hrem, boxesArray = [];
        for (let y2 = 0; y2 < height; y2 += stepY) for (let x2 = 0; x2 < width; x2 += stepX) boxesArray.push({
            x: x2,
            y: y2,
            w: x2 === xend ? wrem : stepX,
            h: y2 === yend ? hrem : stepY
        });
        return boxesArray;
    }
}, ColorHistogram = _ColorHistogram;

__publicField(ColorHistogram, "_boxSize", [ 64, 64 ]), __publicField(ColorHistogram, "_boxPixels", 2), 
__publicField(ColorHistogram, "_hueGroups", 10);

var RemovedColor = class {
    constructor(index, color, distance) {
        __publicField(this, "index"), __publicField(this, "color"), __publicField(this, "distance"), 
        this.index = index, this.color = color, this.distance = distance;
    }
}, RGBQuant = class extends AbstractPaletteQuantizer {
    constructor(colorDistanceCalculator, colors = 256, method = 2) {
        super(), __publicField(this, "_colors"), __publicField(this, "_initialDistance"), 
        __publicField(this, "_distanceIncrement"), __publicField(this, "_histogram"), __publicField(this, "_distance"), 
        this._distance = colorDistanceCalculator, this._colors = colors, this._histogram = new ColorHistogram(method, colors), 
        this._initialDistance = 0.01, this._distanceIncrement = 5e-3;
    }
    sample(image) {
        this._histogram.sample(image);
    }
    * quantize() {
        const idxi32 = this._histogram.getImportanceSortedColorsIDXI32();
        if (0 === idxi32.length) throw new Error("No colors in image");
        yield* this._buildPalette(idxi32);
    }
    * _buildPalette(idxi32) {
        const palette = new Palette, colorArray = palette.getPointContainer().getPointArray(), usageArray = new Array(idxi32.length);
        for (let i = 0; i < idxi32.length; i++) colorArray.push(Point.createByUint32(idxi32[i])), 
        usageArray[i] = 1;
        const len = colorArray.length, memDist = [];
        let palLen = len, thold = this._initialDistance;
        const tracker = new ProgressTracker(palLen - this._colors, 99);
        for (;palLen > this._colors; ) {
            memDist.length = 0;
            for (let i = 0; i < len; i++) {
                if (tracker.shouldNotify(len - palLen) && (yield {
                    progress: tracker.progress
                }), 0 === usageArray[i]) continue;
                const pxi = colorArray[i];
                for (let j = i + 1; j < len; j++) {
                    if (0 === usageArray[j]) continue;
                    const pxj = colorArray[j], dist = this._distance.calculateNormalized(pxi, pxj);
                    dist < thold && (memDist.push(new RemovedColor(j, pxj, dist)), usageArray[j] = 0, 
                    palLen--);
                }
            }
            thold += palLen > 3 * this._colors ? this._initialDistance : this._distanceIncrement;
        }
        if (palLen < this._colors) {
            stableSort(memDist, ((a, b) => b.distance - a.distance));
            let k = 0;
            for (;palLen < this._colors && k < memDist.length; ) usageArray[memDist[k].index] = 1, 
            palLen++, k++;
        }
        let colors = colorArray.length;
        for (let colorIndex = colors - 1; colorIndex >= 0; colorIndex--) 0 === usageArray[colorIndex] && (colorIndex !== colors - 1 && (colorArray[colorIndex] = colorArray[colors - 1]), 
        --colors);
        colorArray.length = colors, palette.sort(), yield {
            palette,
            progress: 100
        };
    }
};

function createArray1D(dimension1) {
    const a = [];
    for (let k = 0; k < dimension1; k++) a[k] = 0;
    return a;
}

function createArray4D(dimension1, dimension2, dimension3, dimension4) {
    const a = new Array(dimension1);
    for (let i = 0; i < dimension1; i++) {
        a[i] = new Array(dimension2);
        for (let j = 0; j < dimension2; j++) {
            a[i][j] = new Array(dimension3);
            for (let k = 0; k < dimension3; k++) {
                a[i][j][k] = new Array(dimension4);
                for (let l = 0; l < dimension4; l++) a[i][j][k][l] = 0;
            }
        }
    }
    return a;
}

function createArray3D(dimension1, dimension2, dimension3) {
    const a = new Array(dimension1);
    for (let i = 0; i < dimension1; i++) {
        a[i] = new Array(dimension2);
        for (let j = 0; j < dimension2; j++) {
            a[i][j] = new Array(dimension3);
            for (let k = 0; k < dimension3; k++) a[i][j][k] = 0;
        }
    }
    return a;
}

function fillArray3D(a, dimension1, dimension2, dimension3, value) {
    for (let i = 0; i < dimension1; i++) {
        a[i] = [];
        for (let j = 0; j < dimension2; j++) {
            a[i][j] = [];
            for (let k = 0; k < dimension3; k++) a[i][j][k] = value;
        }
    }
}

function fillArray1D(a, dimension1, value) {
    for (let i = 0; i < dimension1; i++) a[i] = value;
}

var WuColorCube = class {
    constructor() {
        __publicField(this, "redMinimum"), __publicField(this, "redMaximum"), __publicField(this, "greenMinimum"), 
        __publicField(this, "greenMaximum"), __publicField(this, "blueMinimum"), __publicField(this, "blueMaximum"), 
        __publicField(this, "volume"), __publicField(this, "alphaMinimum"), __publicField(this, "alphaMaximum");
    }
}, _WuQuant = class extends AbstractPaletteQuantizer {
    constructor(colorDistanceCalculator, colors = 256, significantBitsPerChannel = 5) {
        super(), __publicField(this, "_reds"), __publicField(this, "_greens"), __publicField(this, "_blues"), 
        __publicField(this, "_alphas"), __publicField(this, "_sums"), __publicField(this, "_weights"), 
        __publicField(this, "_momentsRed"), __publicField(this, "_momentsGreen"), __publicField(this, "_momentsBlue"), 
        __publicField(this, "_momentsAlpha"), __publicField(this, "_moments"), __publicField(this, "_table"), 
        __publicField(this, "_pixels"), __publicField(this, "_cubes"), __publicField(this, "_colors"), 
        __publicField(this, "_significantBitsPerChannel"), __publicField(this, "_maxSideIndex"), 
        __publicField(this, "_alphaMaxSideIndex"), __publicField(this, "_sideSize"), __publicField(this, "_alphaSideSize"), 
        __publicField(this, "_distance"), this._distance = colorDistanceCalculator, this._setQuality(significantBitsPerChannel), 
        this._initialize(colors);
    }
    sample(image) {
        const pointArray = image.getPointArray();
        for (let i = 0, l = pointArray.length; i < l; i++) this._addColor(pointArray[i]);
        this._pixels = this._pixels.concat(pointArray);
    }
    * quantize() {
        yield* this._preparePalette();
        const palette = new Palette;
        for (let paletteIndex = 0; paletteIndex < this._colors; paletteIndex++) if (this._sums[paletteIndex] > 0) {
            const sum = this._sums[paletteIndex], r = this._reds[paletteIndex] / sum, g = this._greens[paletteIndex] / sum, b = this._blues[paletteIndex] / sum, a = this._alphas[paletteIndex] / sum, color = Point.createByRGBA(0 | r, 0 | g, 0 | b, 0 | a);
            palette.add(color);
        }
        palette.sort(), yield {
            palette,
            progress: 100
        };
    }
    * _preparePalette() {
        yield* this._calculateMoments();
        let next = 0;
        const volumeVariance = createArray1D(this._colors);
        for (let cubeIndex = 1; cubeIndex < this._colors; ++cubeIndex) {
            this._cut(this._cubes[next], this._cubes[cubeIndex]) ? (volumeVariance[next] = this._cubes[next].volume > 1 ? this._calculateVariance(this._cubes[next]) : 0, 
            volumeVariance[cubeIndex] = this._cubes[cubeIndex].volume > 1 ? this._calculateVariance(this._cubes[cubeIndex]) : 0) : (volumeVariance[next] = 0, 
            cubeIndex--), next = 0;
            let temp = volumeVariance[0];
            for (let index = 1; index <= cubeIndex; ++index) volumeVariance[index] > temp && (temp = volumeVariance[index], 
            next = index);
            if (temp <= 0) {
                this._colors = cubeIndex + 1;
                break;
            }
        }
        const lookupRed = [], lookupGreen = [], lookupBlue = [], lookupAlpha = [];
        for (let k = 0; k < this._colors; ++k) {
            const weight = _WuQuant._volume(this._cubes[k], this._weights);
            weight > 0 ? (lookupRed[k] = _WuQuant._volume(this._cubes[k], this._momentsRed) / weight | 0, 
            lookupGreen[k] = _WuQuant._volume(this._cubes[k], this._momentsGreen) / weight | 0, 
            lookupBlue[k] = _WuQuant._volume(this._cubes[k], this._momentsBlue) / weight | 0, 
            lookupAlpha[k] = _WuQuant._volume(this._cubes[k], this._momentsAlpha) / weight | 0) : (lookupRed[k] = 0, 
            lookupGreen[k] = 0, lookupBlue[k] = 0, lookupAlpha[k] = 0);
        }
        this._reds = createArray1D(this._colors + 1), this._greens = createArray1D(this._colors + 1), 
        this._blues = createArray1D(this._colors + 1), this._alphas = createArray1D(this._colors + 1), 
        this._sums = createArray1D(this._colors + 1);
        for (let index = 0, l = this._pixels.length; index < l; index++) {
            const color = this._pixels[index];
            let bestMatch = -1, bestDistance = Number.MAX_VALUE;
            for (let lookup = 0; lookup < this._colors; lookup++) {
                const foundRed = lookupRed[lookup], foundGreen = lookupGreen[lookup], foundBlue = lookupBlue[lookup], foundAlpha = lookupAlpha[lookup], distance = this._distance.calculateRaw(foundRed, foundGreen, foundBlue, foundAlpha, color.r, color.g, color.b, color.a);
                distance < bestDistance && (bestDistance = distance, bestMatch = lookup);
            }
            this._reds[bestMatch] += color.r, this._greens[bestMatch] += color.g, this._blues[bestMatch] += color.b, 
            this._alphas[bestMatch] += color.a, this._sums[bestMatch]++;
        }
    }
    _addColor(color) {
        const bitsToRemove = 8 - this._significantBitsPerChannel, indexRed = 1 + (color.r >> bitsToRemove), indexGreen = 1 + (color.g >> bitsToRemove), indexBlue = 1 + (color.b >> bitsToRemove), indexAlpha = 1 + (color.a >> bitsToRemove);
        this._weights[indexAlpha][indexRed][indexGreen][indexBlue]++, this._momentsRed[indexAlpha][indexRed][indexGreen][indexBlue] += color.r, 
        this._momentsGreen[indexAlpha][indexRed][indexGreen][indexBlue] += color.g, this._momentsBlue[indexAlpha][indexRed][indexGreen][indexBlue] += color.b, 
        this._momentsAlpha[indexAlpha][indexRed][indexGreen][indexBlue] += color.a, this._moments[indexAlpha][indexRed][indexGreen][indexBlue] += this._table[color.r] + this._table[color.g] + this._table[color.b] + this._table[color.a];
    }
    * _calculateMoments() {
        const area = [], areaRed = [], areaGreen = [], areaBlue = [], areaAlpha = [], area2 = [], xarea = createArray3D(this._sideSize, this._sideSize, this._sideSize), xareaRed = createArray3D(this._sideSize, this._sideSize, this._sideSize), xareaGreen = createArray3D(this._sideSize, this._sideSize, this._sideSize), xareaBlue = createArray3D(this._sideSize, this._sideSize, this._sideSize), xareaAlpha = createArray3D(this._sideSize, this._sideSize, this._sideSize), xarea2 = createArray3D(this._sideSize, this._sideSize, this._sideSize);
        let trackerProgress = 0;
        const tracker = new ProgressTracker(this._alphaMaxSideIndex * this._maxSideIndex, 99);
        for (let alphaIndex = 1; alphaIndex <= this._alphaMaxSideIndex; ++alphaIndex) {
            fillArray3D(xarea, this._sideSize, this._sideSize, this._sideSize, 0), fillArray3D(xareaRed, this._sideSize, this._sideSize, this._sideSize, 0), 
            fillArray3D(xareaGreen, this._sideSize, this._sideSize, this._sideSize, 0), fillArray3D(xareaBlue, this._sideSize, this._sideSize, this._sideSize, 0), 
            fillArray3D(xareaAlpha, this._sideSize, this._sideSize, this._sideSize, 0), fillArray3D(xarea2, this._sideSize, this._sideSize, this._sideSize, 0);
            for (let redIndex = 1; redIndex <= this._maxSideIndex; ++redIndex, ++trackerProgress) {
                tracker.shouldNotify(trackerProgress) && (yield {
                    progress: tracker.progress
                }), fillArray1D(area, this._sideSize, 0), fillArray1D(areaRed, this._sideSize, 0), 
                fillArray1D(areaGreen, this._sideSize, 0), fillArray1D(areaBlue, this._sideSize, 0), 
                fillArray1D(areaAlpha, this._sideSize, 0), fillArray1D(area2, this._sideSize, 0);
                for (let greenIndex = 1; greenIndex <= this._maxSideIndex; ++greenIndex) {
                    let line = 0, lineRed = 0, lineGreen = 0, lineBlue = 0, lineAlpha = 0, line2 = 0;
                    for (let blueIndex = 1; blueIndex <= this._maxSideIndex; ++blueIndex) line += this._weights[alphaIndex][redIndex][greenIndex][blueIndex], 
                    lineRed += this._momentsRed[alphaIndex][redIndex][greenIndex][blueIndex], lineGreen += this._momentsGreen[alphaIndex][redIndex][greenIndex][blueIndex], 
                    lineBlue += this._momentsBlue[alphaIndex][redIndex][greenIndex][blueIndex], lineAlpha += this._momentsAlpha[alphaIndex][redIndex][greenIndex][blueIndex], 
                    line2 += this._moments[alphaIndex][redIndex][greenIndex][blueIndex], area[blueIndex] += line, 
                    areaRed[blueIndex] += lineRed, areaGreen[blueIndex] += lineGreen, areaBlue[blueIndex] += lineBlue, 
                    areaAlpha[blueIndex] += lineAlpha, area2[blueIndex] += line2, xarea[redIndex][greenIndex][blueIndex] = xarea[redIndex - 1][greenIndex][blueIndex] + area[blueIndex], 
                    xareaRed[redIndex][greenIndex][blueIndex] = xareaRed[redIndex - 1][greenIndex][blueIndex] + areaRed[blueIndex], 
                    xareaGreen[redIndex][greenIndex][blueIndex] = xareaGreen[redIndex - 1][greenIndex][blueIndex] + areaGreen[blueIndex], 
                    xareaBlue[redIndex][greenIndex][blueIndex] = xareaBlue[redIndex - 1][greenIndex][blueIndex] + areaBlue[blueIndex], 
                    xareaAlpha[redIndex][greenIndex][blueIndex] = xareaAlpha[redIndex - 1][greenIndex][blueIndex] + areaAlpha[blueIndex], 
                    xarea2[redIndex][greenIndex][blueIndex] = xarea2[redIndex - 1][greenIndex][blueIndex] + area2[blueIndex], 
                    this._weights[alphaIndex][redIndex][greenIndex][blueIndex] = this._weights[alphaIndex - 1][redIndex][greenIndex][blueIndex] + xarea[redIndex][greenIndex][blueIndex], 
                    this._momentsRed[alphaIndex][redIndex][greenIndex][blueIndex] = this._momentsRed[alphaIndex - 1][redIndex][greenIndex][blueIndex] + xareaRed[redIndex][greenIndex][blueIndex], 
                    this._momentsGreen[alphaIndex][redIndex][greenIndex][blueIndex] = this._momentsGreen[alphaIndex - 1][redIndex][greenIndex][blueIndex] + xareaGreen[redIndex][greenIndex][blueIndex], 
                    this._momentsBlue[alphaIndex][redIndex][greenIndex][blueIndex] = this._momentsBlue[alphaIndex - 1][redIndex][greenIndex][blueIndex] + xareaBlue[redIndex][greenIndex][blueIndex], 
                    this._momentsAlpha[alphaIndex][redIndex][greenIndex][blueIndex] = this._momentsAlpha[alphaIndex - 1][redIndex][greenIndex][blueIndex] + xareaAlpha[redIndex][greenIndex][blueIndex], 
                    this._moments[alphaIndex][redIndex][greenIndex][blueIndex] = this._moments[alphaIndex - 1][redIndex][greenIndex][blueIndex] + xarea2[redIndex][greenIndex][blueIndex];
                }
            }
        }
    }
    static _volumeFloat(cube, moment) {
        return moment[cube.alphaMaximum][cube.redMaximum][cube.greenMaximum][cube.blueMaximum] - moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][cube.blueMaximum] - moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][cube.blueMaximum] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] - moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][cube.blueMaximum] + moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMaximum] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMaximum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] - (moment[cube.alphaMaximum][cube.redMaximum][cube.greenMaximum][cube.blueMinimum] - moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][cube.blueMinimum] - moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] - moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum]);
    }
    static _volume(cube, moment) {
        return 0 | _WuQuant._volumeFloat(cube, moment);
    }
    static _top(cube, direction, position, moment) {
        let result;
        switch (direction) {
          case _WuQuant._alpha:
            result = moment[position][cube.redMaximum][cube.greenMaximum][cube.blueMaximum] - moment[position][cube.redMaximum][cube.greenMinimum][cube.blueMaximum] - moment[position][cube.redMinimum][cube.greenMaximum][cube.blueMaximum] + moment[position][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] - (moment[position][cube.redMaximum][cube.greenMaximum][cube.blueMinimum] - moment[position][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] - moment[position][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] + moment[position][cube.redMinimum][cube.greenMinimum][cube.blueMinimum]);
            break;

          case _WuQuant._red:
            result = moment[cube.alphaMaximum][position][cube.greenMaximum][cube.blueMaximum] - moment[cube.alphaMaximum][position][cube.greenMinimum][cube.blueMaximum] - moment[cube.alphaMinimum][position][cube.greenMaximum][cube.blueMaximum] + moment[cube.alphaMinimum][position][cube.greenMinimum][cube.blueMaximum] - (moment[cube.alphaMaximum][position][cube.greenMaximum][cube.blueMinimum] - moment[cube.alphaMaximum][position][cube.greenMinimum][cube.blueMinimum] - moment[cube.alphaMinimum][position][cube.greenMaximum][cube.blueMinimum] + moment[cube.alphaMinimum][position][cube.greenMinimum][cube.blueMinimum]);
            break;

          case _WuQuant._green:
            result = moment[cube.alphaMaximum][cube.redMaximum][position][cube.blueMaximum] - moment[cube.alphaMaximum][cube.redMinimum][position][cube.blueMaximum] - moment[cube.alphaMinimum][cube.redMaximum][position][cube.blueMaximum] + moment[cube.alphaMinimum][cube.redMinimum][position][cube.blueMaximum] - (moment[cube.alphaMaximum][cube.redMaximum][position][cube.blueMinimum] - moment[cube.alphaMaximum][cube.redMinimum][position][cube.blueMinimum] - moment[cube.alphaMinimum][cube.redMaximum][position][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMinimum][position][cube.blueMinimum]);
            break;

          case _WuQuant._blue:
            result = moment[cube.alphaMaximum][cube.redMaximum][cube.greenMaximum][position] - moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][position] - moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][position] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][position] - (moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][position] - moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][position] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][position] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][position]);
            break;

          default:
            throw new Error("impossible");
        }
        return 0 | result;
    }
    static _bottom(cube, direction, moment) {
        switch (direction) {
          case _WuQuant._alpha:
            return -moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][cube.blueMaximum] + moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMaximum] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMaximum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] - (-moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum]);

          case _WuQuant._red:
            return -moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][cube.blueMaximum] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMaximum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] - (-moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum]);

          case _WuQuant._green:
            return -moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][cube.blueMaximum] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] + moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMaximum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] - (-moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum]);

          case _WuQuant._blue:
            return -moment[cube.alphaMaximum][cube.redMaximum][cube.greenMaximum][cube.blueMinimum] + moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] - moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum] - (-moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum]);

          default:
            return 0;
        }
    }
    _calculateVariance(cube) {
        const volumeRed = _WuQuant._volume(cube, this._momentsRed), volumeGreen = _WuQuant._volume(cube, this._momentsGreen), volumeBlue = _WuQuant._volume(cube, this._momentsBlue), volumeAlpha = _WuQuant._volume(cube, this._momentsAlpha);
        return _WuQuant._volumeFloat(cube, this._moments) - (volumeRed * volumeRed + volumeGreen * volumeGreen + volumeBlue * volumeBlue + volumeAlpha * volumeAlpha) / _WuQuant._volume(cube, this._weights);
    }
    _maximize(cube, direction, first, last, wholeRed, wholeGreen, wholeBlue, wholeAlpha, wholeWeight) {
        const bottomRed = 0 | _WuQuant._bottom(cube, direction, this._momentsRed), bottomGreen = 0 | _WuQuant._bottom(cube, direction, this._momentsGreen), bottomBlue = 0 | _WuQuant._bottom(cube, direction, this._momentsBlue), bottomAlpha = 0 | _WuQuant._bottom(cube, direction, this._momentsAlpha), bottomWeight = 0 | _WuQuant._bottom(cube, direction, this._weights);
        let result = 0, cutPosition = -1;
        for (let position = first; position < last; ++position) {
            let halfRed = bottomRed + _WuQuant._top(cube, direction, position, this._momentsRed), halfGreen = bottomGreen + _WuQuant._top(cube, direction, position, this._momentsGreen), halfBlue = bottomBlue + _WuQuant._top(cube, direction, position, this._momentsBlue), halfAlpha = bottomAlpha + _WuQuant._top(cube, direction, position, this._momentsAlpha), halfWeight = bottomWeight + _WuQuant._top(cube, direction, position, this._weights);
            if (0 !== halfWeight) {
                let halfDistance = halfRed * halfRed + halfGreen * halfGreen + halfBlue * halfBlue + halfAlpha * halfAlpha, temp = halfDistance / halfWeight;
                halfRed = wholeRed - halfRed, halfGreen = wholeGreen - halfGreen, halfBlue = wholeBlue - halfBlue, 
                halfAlpha = wholeAlpha - halfAlpha, halfWeight = wholeWeight - halfWeight, 0 !== halfWeight && (halfDistance = halfRed * halfRed + halfGreen * halfGreen + halfBlue * halfBlue + halfAlpha * halfAlpha, 
                temp += halfDistance / halfWeight, temp > result && (result = temp, cutPosition = position));
            }
        }
        return {
            max: result,
            position: cutPosition
        };
    }
    _cut(first, second) {
        let direction;
        const wholeRed = _WuQuant._volume(first, this._momentsRed), wholeGreen = _WuQuant._volume(first, this._momentsGreen), wholeBlue = _WuQuant._volume(first, this._momentsBlue), wholeAlpha = _WuQuant._volume(first, this._momentsAlpha), wholeWeight = _WuQuant._volume(first, this._weights), red = this._maximize(first, _WuQuant._red, first.redMinimum + 1, first.redMaximum, wholeRed, wholeGreen, wholeBlue, wholeAlpha, wholeWeight), green = this._maximize(first, _WuQuant._green, first.greenMinimum + 1, first.greenMaximum, wholeRed, wholeGreen, wholeBlue, wholeAlpha, wholeWeight), blue = this._maximize(first, _WuQuant._blue, first.blueMinimum + 1, first.blueMaximum, wholeRed, wholeGreen, wholeBlue, wholeAlpha, wholeWeight), alpha = this._maximize(first, _WuQuant._alpha, first.alphaMinimum + 1, first.alphaMaximum, wholeRed, wholeGreen, wholeBlue, wholeAlpha, wholeWeight);
        if (alpha.max >= red.max && alpha.max >= green.max && alpha.max >= blue.max) {
            if (direction = _WuQuant._alpha, alpha.position < 0) return !1;
        } else direction = red.max >= alpha.max && red.max >= green.max && red.max >= blue.max ? _WuQuant._red : green.max >= alpha.max && green.max >= red.max && green.max >= blue.max ? _WuQuant._green : _WuQuant._blue;
        switch (second.redMaximum = first.redMaximum, second.greenMaximum = first.greenMaximum, 
        second.blueMaximum = first.blueMaximum, second.alphaMaximum = first.alphaMaximum, 
        direction) {
          case _WuQuant._red:
            second.redMinimum = first.redMaximum = red.position, second.greenMinimum = first.greenMinimum, 
            second.blueMinimum = first.blueMinimum, second.alphaMinimum = first.alphaMinimum;
            break;

          case _WuQuant._green:
            second.greenMinimum = first.greenMaximum = green.position, second.redMinimum = first.redMinimum, 
            second.blueMinimum = first.blueMinimum, second.alphaMinimum = first.alphaMinimum;
            break;

          case _WuQuant._blue:
            second.blueMinimum = first.blueMaximum = blue.position, second.redMinimum = first.redMinimum, 
            second.greenMinimum = first.greenMinimum, second.alphaMinimum = first.alphaMinimum;
            break;

          case _WuQuant._alpha:
            second.alphaMinimum = first.alphaMaximum = alpha.position, second.blueMinimum = first.blueMinimum, 
            second.redMinimum = first.redMinimum, second.greenMinimum = first.greenMinimum;
        }
        return first.volume = (first.redMaximum - first.redMinimum) * (first.greenMaximum - first.greenMinimum) * (first.blueMaximum - first.blueMinimum) * (first.alphaMaximum - first.alphaMinimum), 
        second.volume = (second.redMaximum - second.redMinimum) * (second.greenMaximum - second.greenMinimum) * (second.blueMaximum - second.blueMinimum) * (second.alphaMaximum - second.alphaMinimum), 
        !0;
    }
    _initialize(colors) {
        this._colors = colors, this._cubes = [];
        for (let cubeIndex = 0; cubeIndex < colors; cubeIndex++) this._cubes[cubeIndex] = new WuColorCube;
        this._cubes[0].redMinimum = 0, this._cubes[0].greenMinimum = 0, this._cubes[0].blueMinimum = 0, 
        this._cubes[0].alphaMinimum = 0, this._cubes[0].redMaximum = this._maxSideIndex, 
        this._cubes[0].greenMaximum = this._maxSideIndex, this._cubes[0].blueMaximum = this._maxSideIndex, 
        this._cubes[0].alphaMaximum = this._alphaMaxSideIndex, this._weights = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize), 
        this._momentsRed = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize), 
        this._momentsGreen = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize), 
        this._momentsBlue = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize), 
        this._momentsAlpha = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize), 
        this._moments = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize), 
        this._table = [];
        for (let tableIndex = 0; tableIndex < 256; ++tableIndex) this._table[tableIndex] = tableIndex * tableIndex;
        this._pixels = [];
    }
    _setQuality(significantBitsPerChannel = 5) {
        this._significantBitsPerChannel = significantBitsPerChannel, this._maxSideIndex = 1 << this._significantBitsPerChannel, 
        this._alphaMaxSideIndex = this._maxSideIndex, this._sideSize = this._maxSideIndex + 1, 
        this._alphaSideSize = this._alphaMaxSideIndex + 1;
    }
}, WuQuant = _WuQuant;

__publicField(WuQuant, "_alpha", 3), __publicField(WuQuant, "_red", 2), __publicField(WuQuant, "_green", 1), 
__publicField(WuQuant, "_blue", 0);

var image_exports = {};

__export(image_exports, {
    AbstractImageQuantizer: () => AbstractImageQuantizer,
    ErrorDiffusionArray: () => ErrorDiffusionArray,
    ErrorDiffusionArrayKernel: () => ErrorDiffusionArrayKernel,
    ErrorDiffusionRiemersma: () => ErrorDiffusionRiemersma,
    NearestColor: () => NearestColor
});

var AbstractImageQuantizer = class {
    quantizeSync(pointContainer, palette) {
        for (const value of this.quantize(pointContainer, palette)) if (value.pointContainer) return value.pointContainer;
        throw new Error("unreachable");
    }
}, NearestColor = class extends AbstractImageQuantizer {
    constructor(colorDistanceCalculator) {
        super(), __publicField(this, "_distance"), this._distance = colorDistanceCalculator;
    }
    * quantize(pointContainer, palette) {
        const pointArray = pointContainer.getPointArray(), width = pointContainer.getWidth(), height = pointContainer.getHeight(), tracker = new ProgressTracker(height, 99);
        for (let y2 = 0; y2 < height; y2++) {
            tracker.shouldNotify(y2) && (yield {
                progress: tracker.progress
            });
            for (let x2 = 0, idx = y2 * width; x2 < width; x2++, idx++) {
                const point = pointArray[idx];
                point.from(palette.getNearestColor(this._distance, point));
            }
        }
        yield {
            pointContainer,
            progress: 100
        };
    }
}, ErrorDiffusionArrayKernel = (ErrorDiffusionArrayKernel2 => (ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2.FloydSteinberg = 0] = "FloydSteinberg", 
ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2.FalseFloydSteinberg = 1] = "FalseFloydSteinberg", 
ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2.Stucki = 2] = "Stucki", ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2.Atkinson = 3] = "Atkinson", 
ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2.Jarvis = 4] = "Jarvis", ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2.Burkes = 5] = "Burkes", 
ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2.Sierra = 6] = "Sierra", ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2.TwoSierra = 7] = "TwoSierra", 
ErrorDiffusionArrayKernel2[ErrorDiffusionArrayKernel2.SierraLite = 8] = "SierraLite", 
ErrorDiffusionArrayKernel2))(ErrorDiffusionArrayKernel || {}), ErrorDiffusionArray = class extends AbstractImageQuantizer {
    constructor(colorDistanceCalculator, kernel, serpentine = !0, minimumColorDistanceToDither = 0, calculateErrorLikeGIMP = !1) {
        super(), __publicField(this, "_minColorDistance"), __publicField(this, "_serpentine"), 
        __publicField(this, "_kernel"), __publicField(this, "_calculateErrorLikeGIMP"), 
        __publicField(this, "_distance"), this._setKernel(kernel), this._distance = colorDistanceCalculator, 
        this._minColorDistance = minimumColorDistanceToDither, this._serpentine = serpentine, 
        this._calculateErrorLikeGIMP = calculateErrorLikeGIMP;
    }
    * quantize(pointContainer, palette) {
        const pointArray = pointContainer.getPointArray(), originalPoint = new Point, width = pointContainer.getWidth(), height = pointContainer.getHeight(), errorLines = [];
        let dir = 1, maxErrorLines = 1;
        for (const kernel of this._kernel) {
            const kernelErrorLines = kernel[2] + 1;
            maxErrorLines < kernelErrorLines && (maxErrorLines = kernelErrorLines);
        }
        for (let i = 0; i < maxErrorLines; i++) this._fillErrorLine(errorLines[i] = [], width);
        const tracker = new ProgressTracker(height, 99);
        for (let y2 = 0; y2 < height; y2++) {
            tracker.shouldNotify(y2) && (yield {
                progress: tracker.progress
            }), this._serpentine && (dir *= -1);
            const lni = y2 * width, xStart = 1 === dir ? 0 : width - 1, xEnd = 1 === dir ? width : -1;
            this._fillErrorLine(errorLines[0], width), errorLines.push(errorLines.shift());
            const errorLine = errorLines[0];
            for (let x2 = xStart, idx = lni + xStart; x2 !== xEnd; x2 += dir, idx += dir) {
                const point = pointArray[idx], error = errorLine[x2];
                originalPoint.from(point);
                const correctedPoint = Point.createByRGBA(inRange0to255Rounded(point.r + error[0]), inRange0to255Rounded(point.g + error[1]), inRange0to255Rounded(point.b + error[2]), inRange0to255Rounded(point.a + error[3])), palettePoint = palette.getNearestColor(this._distance, correctedPoint);
                if (point.from(palettePoint), this._minColorDistance && this._distance.calculateNormalized(originalPoint, palettePoint) < this._minColorDistance) continue;
                let er, eg, eb, ea;
                this._calculateErrorLikeGIMP ? (er = correctedPoint.r - palettePoint.r, eg = correctedPoint.g - palettePoint.g, 
                eb = correctedPoint.b - palettePoint.b, ea = correctedPoint.a - palettePoint.a) : (er = originalPoint.r - palettePoint.r, 
                eg = originalPoint.g - palettePoint.g, eb = originalPoint.b - palettePoint.b, ea = originalPoint.a - palettePoint.a);
                const dStart = 1 === dir ? 0 : this._kernel.length - 1, dEnd = 1 === dir ? this._kernel.length : -1;
                for (let i = dStart; i !== dEnd; i += dir) {
                    const x1 = this._kernel[i][1] * dir, y1 = this._kernel[i][2];
                    if (x1 + x2 >= 0 && x1 + x2 < width && y1 + y2 >= 0 && y1 + y2 < height) {
                        const d = this._kernel[i][0], e = errorLines[y1][x1 + x2];
                        e[0] += er * d, e[1] += eg * d, e[2] += eb * d, e[3] += ea * d;
                    }
                }
            }
        }
        yield {
            pointContainer,
            progress: 100
        };
    }
    _fillErrorLine(errorLine, width) {
        errorLine.length > width && (errorLine.length = width);
        const l = errorLine.length;
        for (let i = 0; i < l; i++) {
            const error = errorLine[i];
            error[0] = error[1] = error[2] = error[3] = 0;
        }
        for (let i = l; i < width; i++) errorLine[i] = [ 0, 0, 0, 0 ];
    }
    _setKernel(kernel) {
        switch (kernel) {
          case 0:
            this._kernel = [ [ 7 / 16, 1, 0 ], [ 3 / 16, -1, 1 ], [ 5 / 16, 0, 1 ], [ 1 / 16, 1, 1 ] ];
            break;

          case 1:
            this._kernel = [ [ 3 / 8, 1, 0 ], [ 3 / 8, 0, 1 ], [ 2 / 8, 1, 1 ] ];
            break;

          case 2:
            this._kernel = [ [ 8 / 42, 1, 0 ], [ 4 / 42, 2, 0 ], [ 2 / 42, -2, 1 ], [ 4 / 42, -1, 1 ], [ 8 / 42, 0, 1 ], [ 4 / 42, 1, 1 ], [ 2 / 42, 2, 1 ], [ 1 / 42, -2, 2 ], [ 2 / 42, -1, 2 ], [ 4 / 42, 0, 2 ], [ 2 / 42, 1, 2 ], [ 1 / 42, 2, 2 ] ];
            break;

          case 3:
            this._kernel = [ [ 1 / 8, 1, 0 ], [ 1 / 8, 2, 0 ], [ 1 / 8, -1, 1 ], [ 1 / 8, 0, 1 ], [ 1 / 8, 1, 1 ], [ 1 / 8, 0, 2 ] ];
            break;

          case 4:
            this._kernel = [ [ 7 / 48, 1, 0 ], [ 5 / 48, 2, 0 ], [ 3 / 48, -2, 1 ], [ 5 / 48, -1, 1 ], [ 7 / 48, 0, 1 ], [ 5 / 48, 1, 1 ], [ 3 / 48, 2, 1 ], [ 1 / 48, -2, 2 ], [ 3 / 48, -1, 2 ], [ 5 / 48, 0, 2 ], [ 3 / 48, 1, 2 ], [ 1 / 48, 2, 2 ] ];
            break;

          case 5:
            this._kernel = [ [ .25, 1, 0 ], [ 4 / 32, 2, 0 ], [ 2 / 32, -2, 1 ], [ 4 / 32, -1, 1 ], [ .25, 0, 1 ], [ 4 / 32, 1, 1 ], [ 2 / 32, 2, 1 ] ];
            break;

          case 6:
            this._kernel = [ [ 5 / 32, 1, 0 ], [ 3 / 32, 2, 0 ], [ 2 / 32, -2, 1 ], [ 4 / 32, -1, 1 ], [ 5 / 32, 0, 1 ], [ 4 / 32, 1, 1 ], [ 2 / 32, 2, 1 ], [ 2 / 32, -1, 2 ], [ 3 / 32, 0, 2 ], [ 2 / 32, 1, 2 ] ];
            break;

          case 7:
            this._kernel = [ [ .25, 1, 0 ], [ 3 / 16, 2, 0 ], [ 1 / 16, -2, 1 ], [ 2 / 16, -1, 1 ], [ 3 / 16, 0, 1 ], [ 2 / 16, 1, 1 ], [ 1 / 16, 2, 1 ] ];
            break;

          case 8:
            this._kernel = [ [ .5, 1, 0 ], [ 1 / 4, -1, 1 ], [ 1 / 4, 0, 1 ] ];
            break;

          default:
            throw new Error(`ErrorDiffusionArray: unknown kernel = ${kernel}`);
        }
    }
};

function* hilbertCurve(width, height, callback) {
    const maxBound = Math.max(width, height), data = {
        width,
        height,
        level: Math.floor(Math.log(maxBound) / Math.log(2) + 1),
        callback,
        tracker: new ProgressTracker(width * height, 99),
        index: 0,
        x: 0,
        y: 0
    };
    yield* walkHilbert(data, 1), visit(data, 0);
}

function* walkHilbert(data, direction) {
    if (!(data.level < 1)) {
        switch (data.tracker.shouldNotify(data.index) && (yield {
            progress: data.tracker.progress
        }), data.level--, direction) {
          case 2:
            yield* walkHilbert(data, 1), visit(data, 3), yield* walkHilbert(data, 2), visit(data, 4), 
            yield* walkHilbert(data, 2), visit(data, 2), yield* walkHilbert(data, 4);
            break;

          case 3:
            yield* walkHilbert(data, 4), visit(data, 2), yield* walkHilbert(data, 3), visit(data, 1), 
            yield* walkHilbert(data, 3), visit(data, 3), yield* walkHilbert(data, 1);
            break;

          case 1:
            yield* walkHilbert(data, 2), visit(data, 4), yield* walkHilbert(data, 1), visit(data, 3), 
            yield* walkHilbert(data, 1), visit(data, 1), yield* walkHilbert(data, 3);
            break;

          case 4:
            yield* walkHilbert(data, 3), visit(data, 1), yield* walkHilbert(data, 4), visit(data, 2), 
            yield* walkHilbert(data, 4), visit(data, 4), yield* walkHilbert(data, 2);
        }
        data.level++;
    }
}

function visit(data, direction) {
    switch (data.x >= 0 && data.x < data.width && data.y >= 0 && data.y < data.height && (data.callback(data.x, data.y), 
    data.index++), direction) {
      case 2:
        data.x--;
        break;

      case 3:
        data.x++;
        break;

      case 1:
        data.y--;
        break;

      case 4:
        data.y++;
    }
}

var ErrorDiffusionRiemersma = class extends AbstractImageQuantizer {
    constructor(colorDistanceCalculator, errorQueueSize = 16, errorPropagation = 1) {
        super(), __publicField(this, "_distance"), __publicField(this, "_weights"), __publicField(this, "_errorQueueSize"), 
        this._distance = colorDistanceCalculator, this._errorQueueSize = errorQueueSize, 
        this._weights = ErrorDiffusionRiemersma._createWeights(errorPropagation, errorQueueSize);
    }
    * quantize(pointContainer, palette) {
        const pointArray = pointContainer.getPointArray(), width = pointContainer.getWidth(), height = pointContainer.getHeight(), errorQueue = [];
        let head = 0;
        for (let i = 0; i < this._errorQueueSize; i++) errorQueue[i] = {
            r: 0,
            g: 0,
            b: 0,
            a: 0
        };
        yield* hilbertCurve(width, height, ((x2, y2) => {
            const p = pointArray[x2 + y2 * width];
            let {r, g, b, a} = p;
            for (let i = 0; i < this._errorQueueSize; i++) {
                const weight = this._weights[i], e = errorQueue[(i + head) % this._errorQueueSize];
                r += e.r * weight, g += e.g * weight, b += e.b * weight, a += e.a * weight;
            }
            const correctedPoint = Point.createByRGBA(inRange0to255Rounded(r), inRange0to255Rounded(g), inRange0to255Rounded(b), inRange0to255Rounded(a)), quantizedPoint = palette.getNearestColor(this._distance, correctedPoint);
            head = (head + 1) % this._errorQueueSize;
            const tail = (head + this._errorQueueSize - 1) % this._errorQueueSize;
            errorQueue[tail].r = p.r - quantizedPoint.r, errorQueue[tail].g = p.g - quantizedPoint.g, 
            errorQueue[tail].b = p.b - quantizedPoint.b, errorQueue[tail].a = p.a - quantizedPoint.a, 
            p.from(quantizedPoint);
        })), yield {
            pointContainer,
            progress: 100
        };
    }
    static _createWeights(errorPropagation, errorQueueSize) {
        const weights = [], multiplier = Math.exp(Math.log(errorQueueSize) / (errorQueueSize - 1));
        for (let i = 0, next = 1; i < errorQueueSize; i++) weights[i] = (next + 0.5 | 0) / errorQueueSize * errorPropagation, 
        next *= multiplier;
        return weights;
    }
}, quality_exports = {};

function ssim(image1, image2) {
    if (image1.getHeight() !== image2.getHeight() || image1.getWidth() !== image2.getWidth()) throw new Error("Images have different sizes!");
    const c1 = (.01 * 255) ** 2, c2 = (.03 * 255) ** 2;
    let numWindows = 0, mssim = 0;
    return function iterate(image1, image2, callback) {
        const width = image1.getWidth(), height = image1.getHeight();
        for (let y2 = 0; y2 < height; y2 += 8) for (let x2 = 0; x2 < width; x2 += 8) {
            const windowWidth = Math.min(8, width - x2), windowHeight = Math.min(8, height - y2), lumaValues1 = calculateLumaValuesForWindow(image1, x2, y2, windowWidth, windowHeight), lumaValues2 = calculateLumaValuesForWindow(image2, x2, y2, windowWidth, windowHeight);
            callback(lumaValues1, lumaValues2, calculateAverageLuma(lumaValues1), calculateAverageLuma(lumaValues2));
        }
    }(image1, image2, ((lumaValues1, lumaValues2, averageLumaValue1, averageLumaValue2) => {
        let sigxy = 0, sigsqx = 0, sigsqy = 0;
        for (let i = 0; i < lumaValues1.length; i++) sigsqx += (lumaValues1[i] - averageLumaValue1) ** 2, 
        sigsqy += (lumaValues2[i] - averageLumaValue2) ** 2, sigxy += (lumaValues1[i] - averageLumaValue1) * (lumaValues2[i] - averageLumaValue2);
        const numPixelsInWin = lumaValues1.length - 1;
        sigsqx /= numPixelsInWin, sigsqy /= numPixelsInWin, sigxy /= numPixelsInWin, mssim += (2 * averageLumaValue1 * averageLumaValue2 + c1) * (2 * sigxy + c2) / ((averageLumaValue1 ** 2 + averageLumaValue2 ** 2 + c1) * (sigsqx + sigsqy + c2)), 
        numWindows++;
    })), mssim / numWindows;
}

function calculateLumaValuesForWindow(image, x2, y2, width, height) {
    const pointArray = image.getPointArray(), lumaValues = [];
    let counter = 0;
    for (let j = y2; j < y2 + height; j++) {
        const offset = j * image.getWidth();
        for (let i = x2; i < x2 + width; i++) {
            const point = pointArray[offset + i];
            lumaValues[counter] = 0.2126 * point.r + 0.7152 * point.g + 0.0722 * point.b, counter++;
        }
    }
    return lumaValues;
}

function calculateAverageLuma(lumaValues) {
    let sumLuma = 0;
    for (const luma of lumaValues) sumLuma += luma;
    return sumLuma / lumaValues.length;
}

__export(quality_exports, {
    ssim: () => ssim
});

var setImmediateImpl = "function" == typeof setImmediate ? setImmediate : "undefined" != typeof process && "function" == typeof (null == process ? void 0 : process.nextTick) ? callback => process.nextTick(callback) : callback => setTimeout(callback, 0);

function buildPaletteSync(images, {colorDistanceFormula, paletteQuantization, colors} = {}) {
    const paletteQuantizer = paletteQuantizationToPaletteQuantizer(colorDistanceFormulaToColorDistance(colorDistanceFormula), paletteQuantization, colors);
    return images.forEach((image => paletteQuantizer.sample(image))), paletteQuantizer.quantizeSync();
}

async function buildPalette(images, {colorDistanceFormula, paletteQuantization, colors, onProgress} = {}) {
    return new Promise(((resolve, reject) => {
        const paletteQuantizer = paletteQuantizationToPaletteQuantizer(colorDistanceFormulaToColorDistance(colorDistanceFormula), paletteQuantization, colors);
        let palette;
        images.forEach((image => paletteQuantizer.sample(image)));
        const iterator = paletteQuantizer.quantize(), next = () => {
            try {
                const result = iterator.next();
                result.done ? resolve(palette) : (result.value.palette && (palette = result.value.palette), 
                onProgress && onProgress(result.value.progress), setImmediateImpl(next));
            } catch (error) {
                reject(error);
            }
        };
        setImmediateImpl(next);
    }));
}

function applyPaletteSync(image, palette, {colorDistanceFormula, imageQuantization} = {}) {
    return imageQuantizationToImageQuantizer(colorDistanceFormulaToColorDistance(colorDistanceFormula), imageQuantization).quantizeSync(image, palette);
}

async function applyPalette(image, palette, {colorDistanceFormula, imageQuantization, onProgress} = {}) {
    return new Promise(((resolve, reject) => {
        let outPointContainer;
        const iterator = imageQuantizationToImageQuantizer(colorDistanceFormulaToColorDistance(colorDistanceFormula), imageQuantization).quantize(image, palette), next = () => {
            try {
                const result = iterator.next();
                result.done ? resolve(outPointContainer) : (result.value.pointContainer && (outPointContainer = result.value.pointContainer), 
                onProgress && onProgress(result.value.progress), setImmediateImpl(next));
            } catch (error) {
                reject(error);
            }
        };
        setImmediateImpl(next);
    }));
}

function colorDistanceFormulaToColorDistance(colorDistanceFormula = "euclidean-bt709") {
    switch (colorDistanceFormula) {
      case "cie94-graphic-arts":
        return new CIE94GraphicArts;

      case "cie94-textiles":
        return new CIE94Textiles;

      case "ciede2000":
        return new CIEDE2000;

      case "color-metric":
        return new CMetric;

      case "euclidean":
        return new Euclidean;

      case "euclidean-bt709":
        return new EuclideanBT709;

      case "euclidean-bt709-noalpha":
        return new EuclideanBT709NoAlpha;

      case "manhattan":
        return new Manhattan;

      case "manhattan-bt709":
        return new ManhattanBT709;

      case "manhattan-nommyde":
        return new ManhattanNommyde;

      case "pngquant":
        return new PNGQuant;

      default:
        throw new Error(`Unknown colorDistanceFormula ${colorDistanceFormula}`);
    }
}

function imageQuantizationToImageQuantizer(distanceCalculator, imageQuantization = "floyd-steinberg") {
    switch (imageQuantization) {
      case "nearest":
        return new NearestColor(distanceCalculator);

      case "riemersma":
        return new ErrorDiffusionRiemersma(distanceCalculator);

      case "floyd-steinberg":
        return new ErrorDiffusionArray(distanceCalculator, 0);

      case "false-floyd-steinberg":
        return new ErrorDiffusionArray(distanceCalculator, 1);

      case "stucki":
        return new ErrorDiffusionArray(distanceCalculator, 2);

      case "atkinson":
        return new ErrorDiffusionArray(distanceCalculator, 3);

      case "jarvis":
        return new ErrorDiffusionArray(distanceCalculator, 4);

      case "burkes":
        return new ErrorDiffusionArray(distanceCalculator, 5);

      case "sierra":
        return new ErrorDiffusionArray(distanceCalculator, 6);

      case "two-sierra":
        return new ErrorDiffusionArray(distanceCalculator, 7);

      case "sierra-lite":
        return new ErrorDiffusionArray(distanceCalculator, 8);

      default:
        throw new Error(`Unknown imageQuantization ${imageQuantization}`);
    }
}

function paletteQuantizationToPaletteQuantizer(distanceCalculator, paletteQuantization = "wuquant", colors = 256) {
    switch (paletteQuantization) {
      case "neuquant":
        return new NeuQuant(distanceCalculator, colors);

      case "rgbquant":
        return new RGBQuant(distanceCalculator, colors);

      case "wuquant":
        return new WuQuant(distanceCalculator, colors);

      case "neuquant-float":
        return new NeuQuantFloat(distanceCalculator, colors);

      default:
        throw new Error(`Unknown paletteQuantization ${paletteQuantization}`);
    }
}

var imageQ = __toCommonJS(src_exports), gifframe = {};

const BitmapImage$1 = bitmapimage;

class GifFrame$2 extends BitmapImage$1 {
    constructor(...args) {
        if (super(...args), args[0] instanceof GifFrame$2) {
            const source = args[0];
            this.xOffset = source.xOffset, this.yOffset = source.yOffset, this.disposalMethod = source.disposalMethod, 
            this.delayCentisecs = source.delayCentisecs, this.interlaced = source.interlaced;
        } else {
            const lastArg = args[args.length - 1];
            let options = {};
            "object" != typeof lastArg || lastArg instanceof BitmapImage$1 || (options = lastArg), 
            this.xOffset = options.xOffset || 0, this.yOffset = options.yOffset || 0, this.disposalMethod = void 0 !== options.disposalMethod ? options.disposalMethod : GifFrame$2.DisposeToBackgroundColor, 
            this.delayCentisecs = options.delayCentisecs || 8, this.interlaced = options.interlaced || !1;
        }
    }
    getPalette() {
        const colorSet = new Set, buf = this.bitmap.data;
        let i = 0, usesTransparency = !1;
        for (;i < buf.length; ) {
            if (0 === buf[i + 3]) usesTransparency = !0; else {
                const color = buf.readUInt32BE(i, !0) >> 8 & 0xFFFFFF;
                colorSet.add(color);
            }
            i += 4;
        }
        const colors = new Array(colorSet.size), iter = colorSet.values();
        for (i = 0; i < colors.length; ++i) colors[i] = iter.next().value;
        colors.sort(((a, b) => a - b));
        let indexCount = colors.length;
        return usesTransparency && ++indexCount, {
            colors,
            usesTransparency,
            indexCount
        };
    }
}

GifFrame$2.DisposeToAnything = 0, GifFrame$2.DisposeNothing = 1, GifFrame$2.DisposeToBackgroundColor = 2, 
GifFrame$2.DisposeToPrevious = 3, gifframe.GifFrame = GifFrame$2, function(exports) {
    const fs = fs__default.default, ImageQ = imageQ, BitmapImage = bitmapimage, {GifFrame} = gifframe, {GifError} = gif, INVALID_SUFFIXES = [ ".jpg", ".jpeg", ".png", ".bmp" ];
    function _quantize(imageOrImages, method, maxColorIndexes, modifier, dither) {
        const images = Array.isArray(imageOrImages) ? imageOrImages : [ imageOrImages ];
        if (dither) {
            if ([ "FloydSteinberg", "FalseFloydSteinberg", "Stucki", "Atkinson", "Jarvis", "Burkes", "Sierra", "TwoSierra", "SierraLite" ].indexOf(dither.ditherAlgorithm) < 0) throw new Error(`Invalid ditherAlgorithm '${dither.ditherAlgorithm}'`);
            void 0 === dither.serpentine && (dither.serpentine = !0), void 0 === dither.minimumColorDistanceToDither && (dither.minimumColorDistanceToDither = 0), 
            void 0 === dither.calculateErrorLikeGIMP && (dither.calculateErrorLikeGIMP = !1);
        }
        const distCalculator = new ImageQ.distance.Euclidean, quantizer = new ImageQ.palette[method](distCalculator, maxColorIndexes, modifier);
        let imageMaker;
        imageMaker = dither ? new ImageQ.image.ErrorDiffusionArray(distCalculator, ImageQ.image.ErrorDiffusionArrayKernel[dither.ditherAlgorithm], dither.serpentine, dither.minimumColorDistanceToDither, dither.calculateErrorLikeGIMP) : new ImageQ.image.NearestColor(distCalculator);
        const inputContainers = [];
        images.forEach((image => {
            const imageBuf = image.bitmap.data, inputBuf = new ArrayBuffer(imageBuf.length), inputArray = new Uint32Array(inputBuf);
            for (let bi = 0, ai = 0; bi < imageBuf.length; bi += 4, ++ai) inputArray[ai] = imageBuf.readUInt32LE(bi, !0);
            const inputContainer = ImageQ.utils.PointContainer.fromUint32Array(inputArray, image.bitmap.width, image.bitmap.height);
            quantizer.sample(inputContainer), inputContainers.push(inputContainer);
        }));
        const limitedPalette = quantizer.quantizeSync();
        for (let i = 0; i < images.length; ++i) {
            const imageBuf = images[i].bitmap.data, outputArray = imageMaker.quantizeSync(inputContainers[i], limitedPalette).toUint32Array();
            for (let bi = 0, ai = 0; bi < imageBuf.length; bi += 4, ++ai) imageBuf.writeUInt32LE(outputArray[ai], bi);
        }
    }
    exports.cloneFrames = function(frames) {
        let clones = [];
        return frames.forEach((frame => {
            clones.push(new GifFrame(frame));
        })), clones;
    }, exports.getColorInfo = function(frames, maxGlobalIndex) {
        let usesTransparency = !1;
        const palettes = [];
        for (let i = 0; i < frames.length; ++i) {
            let palette = frames[i].getPalette();
            if (palette.usesTransparency && (usesTransparency = !0), palette.indexCount > 256) throw new GifError(`Frame ${i} uses more than 256 color indexes`);
            palettes.push(palette);
        }
        if (0 === maxGlobalIndex) return {
            usesTransparency,
            palettes
        };
        const globalColorSet = new Set;
        palettes.forEach((palette => {
            palette.colors.forEach((color => {
                globalColorSet.add(color);
            }));
        }));
        let indexCount = globalColorSet.size;
        if (usesTransparency && ++indexCount, maxGlobalIndex && indexCount > maxGlobalIndex) return {
            usesTransparency,
            palettes
        };
        const colors = new Array(globalColorSet.size), iter = globalColorSet.values();
        for (let i = 0; i < colors.length; ++i) colors[i] = iter.next().value;
        return colors.sort(((a, b) => a - b)), {
            colors,
            indexCount,
            usesTransparency,
            palettes
        };
    }, exports.copyAsJimp = function(jimp, bitmapImageToCopy) {
        return exports.shareAsJimp(jimp, new BitmapImage(bitmapImageToCopy));
    }, exports.getMaxDimensions = function(frames) {
        let maxWidth = 0, maxHeight = 0;
        return frames.forEach((frame => {
            const width = frame.xOffset + frame.bitmap.width;
            width > maxWidth && (maxWidth = width);
            const height = frame.yOffset + frame.bitmap.height;
            height > maxHeight && (maxHeight = height);
        })), {
            maxWidth,
            maxHeight
        };
    }, exports.quantizeDekker = function(imageOrImages, maxColorIndexes, dither) {
        _quantize(imageOrImages, "NeuQuantFloat", maxColorIndexes = maxColorIndexes || 256, 0, dither);
    }, exports.quantizeSorokin = function(imageOrImages, maxColorIndexes, histogram, dither) {
        let histogramID;
        switch (maxColorIndexes = maxColorIndexes || 256, histogram = histogram || "min-pop") {
          case "min-pop":
            histogramID = 2;
            break;

          case "top-pop":
            histogramID = 1;
            break;

          default:
            throw new Error(`Invalid quantizeSorokin histogram '${histogram}'`);
        }
        _quantize(imageOrImages, "RGBQuant", maxColorIndexes, histogramID, dither);
    }, exports.quantizeWu = function(imageOrImages, maxColorIndexes, significantBits, dither) {
        if (maxColorIndexes = maxColorIndexes || 256, (significantBits = significantBits || 5) < 1 || significantBits > 8) throw new Error("Invalid quantization quality");
        _quantize(imageOrImages, "WuQuant", maxColorIndexes, significantBits, dither);
    }, exports.read = function(source, decoder) {
        return Buffer.isBuffer(source) ? decoder.decodeGif(source) : function _readBinary(path) {
            return new Promise(((resolve, reject) => {
                fs.readFile(path, ((err, buffer) => err ? reject(err) : resolve(buffer)));
            }));
        }(source).then((buffer => decoder.decodeGif(buffer)));
    }, exports.shareAsJimp = function(jimp, bitmapImageToShare) {
        const jimpImage = new jimp(bitmapImageToShare.bitmap.width, bitmapImageToShare.bitmap.height, 0);
        return jimpImage.bitmap.data = bitmapImageToShare.bitmap.data, jimpImage;
    }, exports.write = function(path, frames, spec, encoder) {
        const matches = path.match(/\.[a-zA-Z]+$/);
        if (null !== matches && INVALID_SUFFIXES.includes(matches[0].toLowerCase())) throw new Error(`GIF '${path}' has an unexpected suffix`);
        return encoder.encodeGif(frames, spec).then((gif => function _writeBinary(path, buffer) {
            return new Promise(((resolve, reject) => {
                fs.writeFile(path, buffer, (err => err ? reject(err) : resolve()));
            }));
        }(path, gif.buffer).then((() => gif))));
    };
}(gifutil);

const Omggif = omggif, {Gif: Gif$1, GifError: GifError$2} = gif, GifUtil$1 = gifutil, {GifFrame: GifFrame$1} = gifframe;

function _colorLookupLinear(colors, color) {
    const index = colors.indexOf(color);
    return -1 === index ? null : index;
}

function _colorLookupBinary(colors, color) {
    for (var mid, lo = 0, hi = colors.length - 1; lo <= hi; ) if (colors[mid = Math.floor((lo + hi) / 2)] > color) hi = mid - 1; else {
        if (!(colors[mid] < color)) return mid;
        lo = mid + 1;
    }
    return null;
}

function _extendPaletteToPowerOf2(palette) {
    const colors = palette.colors;
    palette.usesTransparency && colors.push(0);
    const colorCount = colors.length;
    let powerOf2 = 2;
    for (;colorCount > powerOf2; ) powerOf2 <<= 1;
    colors.length = powerOf2, colors.fill(0, colorCount);
}

function _getFrameSizeEst(frame, pixelBitWidth) {
    let byteLength = frame.bitmap.width * frame.bitmap.height;
    return byteLength = Math.ceil(byteLength * pixelBitWidth / 8), byteLength += Math.ceil(byteLength / 255), 
    100 + byteLength + 768;
}

function _getPixelBitWidth(palette) {
    let indexCount = palette.indexCount, pixelBitWidth = 0;
    for (--indexCount; indexCount; ) ++pixelBitWidth, indexCount >>= 1;
    return pixelBitWidth > 0 ? pixelBitWidth : 1;
}

function _writeFrame(gifWriter, frameIndex, frame, palette, isLocalPalette) {
    if (frame.interlaced) throw new GifError$2("writing interlaced GIFs is not supported");
    const frameInfo = function _getIndexedImage(frameIndex, frame, palette) {
        const colors = palette.colors, colorToIndexFunc = colors.length <= 8 ? _colorLookupLinear : _colorLookupBinary, colorBuffer = frame.bitmap.data, indexBuffer = new Buffer(colorBuffer.length / 4);
        let transparentIndex = colors.length, i = 0, j = 0;
        for (;i < colorBuffer.length; ) {
            if (0 !== colorBuffer[i + 3]) {
                const color = colorBuffer.readUInt32BE(i, !0) >> 8 & 0xFFFFFF;
                indexBuffer[j] = colorToIndexFunc(colors, color);
            } else indexBuffer[j] = transparentIndex;
            i += 4, ++j;
        }
        if (palette.usesTransparency) {
            if (256 === transparentIndex) throw new GifError$2(`Frame ${frameIndex} already has 256 colorsand so can't use transparency`);
        } else transparentIndex = null;
        return {
            buffer: indexBuffer,
            transparentIndex
        };
    }(frameIndex, frame, palette), options = {
        delay: frame.delayCentisecs,
        disposal: frame.disposalMethod,
        transparent: frameInfo.transparentIndex
    };
    isLocalPalette && (_extendPaletteToPowerOf2(palette), options.palette = palette.colors);
    try {
        let endOfFrame, buffer = gifWriter.getOutputBuffer(), startOfFrame = gifWriter.getOutputBufferPosition(), tryAgain = !0;
        for (;tryAgain; ) if (endOfFrame = gifWriter.addFrame(frame.xOffset, frame.yOffset, frame.bitmap.width, frame.bitmap.height, frameInfo.buffer, options), 
        tryAgain = !1, endOfFrame >= buffer.length - 1) {
            const biggerBuffer = new Buffer(1.5 * buffer.length);
            buffer.copy(biggerBuffer), gifWriter.setOutputBuffer(biggerBuffer), gifWriter.setOutputBufferPosition(startOfFrame), 
            buffer = biggerBuffer, tryAgain = !0;
        }
        return buffer;
    } catch (err) {
        throw new GifError$2(err);
    }
}

gifcodec.GifCodec = class GifCodec$1 {
    constructor(options = {}) {
        this._transparentRGB = null, "number" == typeof options.transparentRGB && 0 !== options.transparentRGB && (this._transparentRGBA = 256 * options.transparentRGB), 
        this._testInitialBufferSize = 0;
    }
    decodeGif(buffer) {
        try {
            let reader;
            try {
                reader = new Omggif.GifReader(buffer);
            } catch (err) {
                throw new GifError$2(err);
            }
            const frameCount = reader.numFrames(), frames = [], spec = {
                width: reader.width,
                height: reader.height,
                loops: reader.loopCount(),
                usesTransparency: !1
            };
            for (let i = 0; i < frameCount; ++i) {
                const frameInfo = this._decodeFrame(reader, i, spec.usesTransparency);
                frames.push(frameInfo.frame), frameInfo.usesTransparency && (spec.usesTransparency = !0);
            }
            return Promise.resolve(new Gif$1(buffer, frames, spec));
        } catch (err) {
            return Promise.reject(err);
        }
    }
    encodeGif(frames, spec = {}) {
        try {
            if (null === frames || 0 === frames.length) throw new GifError$2("there are no frames");
            const dims = GifUtil$1.getMaxDimensions(frames);
            return (spec = Object.assign({}, spec)).width = dims.maxWidth, spec.height = dims.maxHeight, 
            spec.loops = spec.loops || 0, spec.colorScope = spec.colorScope || Gif$1.GlobalColorsPreferred, 
            Promise.resolve(this._encodeGif(frames, spec));
        } catch (err) {
            return Promise.reject(err);
        }
    }
    _decodeFrame(reader, frameIndex, alreadyUsedTransparency) {
        let info, buffer;
        try {
            if (info = reader.frameInfo(frameIndex), buffer = new Buffer(reader.width * reader.height * 4), 
            reader.decodeAndBlitFrameRGBA(frameIndex, buffer), info.width !== reader.width || info.height !== reader.height) {
                if (info.y && (buffer = buffer.slice(info.y * reader.width * 4)), reader.width > info.width) for (let ii = 0; ii < info.height; ++ii) buffer.copy(buffer, ii * info.width * 4, 4 * (info.x + ii * reader.width), 4 * (info.x + ii * reader.width) + 4 * info.width);
                buffer = buffer.slice(0, info.width * info.height * 4);
            }
        } catch (err) {
            throw new GifError$2(err);
        }
        let usesTransparency = !1;
        if (null === this._transparentRGBA) {
            if (!alreadyUsedTransparency) for (let i = 3; i < buffer.length; i += 4) 0 === buffer[i] && (usesTransparency = !0, 
            i = buffer.length);
        } else for (let i = 3; i < buffer.length; i += 4) 0 === buffer[i] && (buffer.writeUInt32BE(this._transparentRGBA, i - 3), 
        usesTransparency = !0);
        return {
            frame: new GifFrame$1(info.width, info.height, buffer, {
                xOffset: info.x,
                yOffset: info.y,
                disposalMethod: info.disposal,
                interlaced: info.interlaced,
                delayCentisecs: info.delay
            }),
            usesTransparency
        };
    }
    _encodeGif(frames, spec) {
        let colorInfo;
        if (spec.colorScope === Gif$1.LocalColorsOnly) colorInfo = GifUtil$1.getColorInfo(frames, 0); else if (colorInfo = GifUtil$1.getColorInfo(frames, 256), 
        !colorInfo.colors) {
            if (spec.colorScope === Gif$1.GlobalColorsOnly) throw new GifError$2("Too many color indexes for global color table");
            spec.colorScope = Gif$1.LocalColorsOnly;
        }
        spec.usesTransparency = colorInfo.usesTransparency;
        const localPalettes = colorInfo.palettes;
        return spec.colorScope === Gif$1.LocalColorsOnly ? function _encodeLocal(frames, spec, bufferSizeEst, localPalettes) {
            const options = {
                loop: spec.loops
            };
            let gifWriter, buffer = new Buffer(bufferSizeEst);
            try {
                gifWriter = new Omggif.GifWriter(buffer, spec.width, spec.height, options);
            } catch (err) {
                throw new GifError$2(err);
            }
            for (let i = 0; i < frames.length; ++i) buffer = _writeFrame(gifWriter, i, frames[i], localPalettes[i], !0);
            return new Gif$1(buffer.slice(0, gifWriter.end()), frames, spec);
        }(frames, spec, 2000, localPalettes) : function _encodeGlobal(frames, spec, bufferSizeEst, globalPalette) {
            const extendedGlobalPalette = {
                colors: globalPalette.colors.slice(),
                usesTransparency: globalPalette.usesTransparency
            };
            _extendPaletteToPowerOf2(extendedGlobalPalette);
            const options = {
                palette: extendedGlobalPalette.colors,
                loop: spec.loops
            };
            let gifWriter, buffer = new Buffer(bufferSizeEst);
            try {
                gifWriter = new Omggif.GifWriter(buffer, spec.width, spec.height, options);
            } catch (err) {
                throw new GifError$2(err);
            }
            for (let i = 0; i < frames.length; ++i) buffer = _writeFrame(gifWriter, i, frames[i], globalPalette, !1);
            return new Gif$1(buffer.slice(0, gifWriter.end()), frames, spec);
        }(frames, spec, 2000, colorInfo);
    }
    _getSizeEstimateGlobal(globalPalette, frames) {
        if (this._testInitialBufferSize > 0) return this._testInitialBufferSize;
        let sizeEst = 968;
        const pixelBitWidth = _getPixelBitWidth(globalPalette);
        return frames.forEach((frame => {
            sizeEst += _getFrameSizeEst(frame, pixelBitWidth);
        })), sizeEst;
    }
    _getSizeEstimateLocal(palettes, frames) {
        if (this._testInitialBufferSize > 0) return this._testInitialBufferSize;
        let sizeEst = 200;
        for (let i = 0; i < frames.length; ++i) {
            const pixelBitWidth = _getPixelBitWidth(palettes[i]);
            sizeEst += _getFrameSizeEst(frames[i], pixelBitWidth);
        }
        return sizeEst;
    }
};

const BitmapImage = bitmapimage, {Gif, GifError: GifError$1} = gif, {GifCodec} = gifcodec, {GifFrame} = gifframe;

var src = {
    BitmapImage,
    Gif,
    GifCodec,
    GifFrame,
    GifUtil: gifutil,
    GifError: GifError$1
};

async function getGifFromBuffer(data) {
    const buffer = data, gif = await (new src.GifCodec).decodeGif(buffer);
    if (gif.frames.length > 200) throw Error("Image too large, advanced modifiers not supported!");
    return gif;
}

function alignGif(frames, interval) {
    let alignedFrames = src.GifUtil.cloneFrames(frames);
    for (;alignedFrames.length < interval; ) alignedFrames = alignedFrames.concat(src.GifUtil.cloneFrames(frames));
    let framesToDelete = alignedFrames.length % interval;
    for (;framesToDelete / alignedFrames.length > 0.2; ) alignedFrames = alignedFrames.concat(src.GifUtil.cloneFrames(frames)), 
    framesToDelete = alignedFrames.length % interval;
    const amountCopies = alignedFrames.length / frames.length;
    let currentCopy = 0;
    for (let i = 0; i < framesToDelete; i++) {
        const frameToDelete = Math.floor(Math.random() * frames.length - 1) + 1;
        alignedFrames.splice(frameToDelete + currentCopy * frames.length, 1), currentCopy = (currentCopy + 1) % amountCopies;
    }
    return alignedFrames;
}

function setEncoderProperties(encoder, delay) {
    encoder.start(), encoder.setRepeat(0), encoder.setQuality(5), void 0 !== delay && encoder.setDelay(delay), 
    encoder.setTransparent(0x00000000);
}

function preparePNGVariables(options, image) {
    const {widthModifier, heightModifier} = function getSizeFromOptions(options) {
        let widthModifier = 1, heightModifier = 1;
        if (!options.isResized) {
            const {size} = options;
            if (size.includes("x")) {
                const split = size.split("x");
                widthModifier = parseFloat(split[0] ?? "1"), heightModifier = parseFloat(split[1] ?? "1");
            } else widthModifier = parseFloat(size), heightModifier = parseFloat(size);
        }
        return {
            widthModifier,
            heightModifier
        };
    }(options), width = Math.floor(widthModifier * image.width), height = Math.floor(heightModifier * image.height);
    return {
        width,
        height,
        encoder: new GIFEncoder(width, height)
    };
}

var jimp = {
    exports: {}
};

!function(module, exports) {
    if ((void 0 === window || !window) && "undefined" != typeof self) var window = self;
    jimp.exports = function r(e, n, t) {
        function o(i, f) {
            if (!n[i]) {
                if (!e[i]) {
                    if (!f && commonjsRequire) return commonjsRequire(i);
                    if (u) return u(i, !0);
                    var a = new Error("Cannot find module '" + i + "'");
                    throw a.code = "MODULE_NOT_FOUND", a;
                }
                var p = n[i] = {
                    exports: {}
                };
                e[i][0].call(p.exports, (function(r) {
                    return o(e[i][1][r] || r);
                }), p, p.exports, r, e, n, t);
            }
            return n[i].exports;
        }
        for (var u = commonjsRequire, i = 0; i < t.length; i++) o(t[i]);
        return o;
    }({
        1: [ function(require, module, exports) {
            module.exports = function _arrayWithHoles(arr) {
                if (Array.isArray(arr)) return arr;
            };
        }, {} ],
        2: [ function(require, module, exports) {
            module.exports = function _arrayWithoutHoles(arr) {
                if (Array.isArray(arr)) {
                    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];
                    return arr2;
                }
            };
        }, {} ],
        3: [ function(require, module, exports) {
            module.exports = function _assertThisInitialized(self) {
                if (void 0 === self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                return self;
            };
        }, {} ],
        4: [ function(require, module, exports) {
            module.exports = function _classCallCheck(instance, Constructor) {
                if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
            };
        }, {} ],
        5: [ function(require, module, exports) {
            var setPrototypeOf = require("./setPrototypeOf");
            function isNativeReflectConstruct() {
                if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
                if (Reflect.construct.sham) return !1;
                if ("function" == typeof Proxy) return !0;
                try {
                    return Date.prototype.toString.call(Reflect.construct(Date, [], (function() {}))), 
                    !0;
                } catch (e) {
                    return !1;
                }
            }
            function _construct(Parent, args, Class) {
                return isNativeReflectConstruct() ? module.exports = _construct = Reflect.construct : module.exports = _construct = function _construct(Parent, args, Class) {
                    var a = [ null ];
                    a.push.apply(a, args);
                    var instance = new (Function.bind.apply(Parent, a));
                    return Class && setPrototypeOf(instance, Class.prototype), instance;
                }, _construct.apply(null, arguments);
            }
            module.exports = _construct;
        }, {
            "./setPrototypeOf": 18
        } ],
        6: [ function(require, module, exports) {
            function _defineProperties(target, props) {
                for (var i = 0; i < props.length; i++) {
                    var descriptor = props[i];
                    descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, 
                    "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor);
                }
            }
            module.exports = function _createClass(Constructor, protoProps, staticProps) {
                return protoProps && _defineProperties(Constructor.prototype, protoProps), staticProps && _defineProperties(Constructor, staticProps), 
                Constructor;
            };
        }, {} ],
        7: [ function(require, module, exports) {
            module.exports = function _defineProperty(obj, key, value) {
                return key in obj ? Object.defineProperty(obj, key, {
                    value,
                    enumerable: !0,
                    configurable: !0,
                    writable: !0
                }) : obj[key] = value, obj;
            };
        }, {} ],
        8: [ function(require, module, exports) {
            function _extends() {
                return module.exports = _extends = Object.assign || function(target) {
                    for (var i = 1; i < arguments.length; i++) {
                        var source = arguments[i];
                        for (var key in source) Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
                    }
                    return target;
                }, _extends.apply(this, arguments);
            }
            module.exports = _extends;
        }, {} ],
        9: [ function(require, module, exports) {
            function _getPrototypeOf(o) {
                return module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
                    return o.__proto__ || Object.getPrototypeOf(o);
                }, _getPrototypeOf(o);
            }
            module.exports = _getPrototypeOf;
        }, {} ],
        10: [ function(require, module, exports) {
            var setPrototypeOf = require("./setPrototypeOf");
            module.exports = function _inherits(subClass, superClass) {
                if ("function" != typeof superClass && null !== superClass) throw new TypeError("Super expression must either be null or a function");
                subClass.prototype = Object.create(superClass && superClass.prototype, {
                    constructor: {
                        value: subClass,
                        writable: !0,
                        configurable: !0
                    }
                }), superClass && setPrototypeOf(subClass, superClass);
            };
        }, {
            "./setPrototypeOf": 18
        } ],
        11: [ function(require, module, exports) {
            module.exports = function _interopRequireDefault(obj) {
                return obj && obj.__esModule ? obj : {
                    default: obj
                };
            };
        }, {} ],
        12: [ function(require, module, exports) {
            var _typeof = require("../helpers/typeof");
            function _getRequireWildcardCache() {
                if ("function" != typeof WeakMap) return null;
                var cache = new WeakMap;
                return _getRequireWildcardCache = function _getRequireWildcardCache() {
                    return cache;
                }, cache;
            }
            module.exports = function _interopRequireWildcard(obj) {
                if (obj && obj.__esModule) return obj;
                if (null === obj || "object" !== _typeof(obj) && "function" != typeof obj) return {
                    default: obj
                };
                var cache = _getRequireWildcardCache();
                if (cache && cache.has(obj)) return cache.get(obj);
                var newObj = {}, hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
                for (var key in obj) if (Object.prototype.hasOwnProperty.call(obj, key)) {
                    var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
                    desc && (desc.get || desc.set) ? Object.defineProperty(newObj, key, desc) : newObj[key] = obj[key];
                }
                return newObj.default = obj, cache && cache.set(obj, newObj), newObj;
            };
        }, {
            "../helpers/typeof": 21
        } ],
        13: [ function(require, module, exports) {
            module.exports = function _iterableToArray(iter) {
                if (Symbol.iterator in Object(iter) || "[object Arguments]" === Object.prototype.toString.call(iter)) return Array.from(iter);
            };
        }, {} ],
        14: [ function(require, module, exports) {
            module.exports = function _iterableToArrayLimit(arr, i) {
                if (Symbol.iterator in Object(arr) || "[object Arguments]" === Object.prototype.toString.call(arr)) {
                    var _arr = [], _n = !0, _d = !1, _e = void 0;
                    try {
                        for (var _s, _i = arr[Symbol.iterator](); !(_n = (_s = _i.next()).done) && (_arr.push(_s.value), 
                        !i || _arr.length !== i); _n = !0) ;
                    } catch (err) {
                        _d = !0, _e = err;
                    } finally {
                        try {
                            _n || null == _i.return || _i.return();
                        } finally {
                            if (_d) throw _e;
                        }
                    }
                    return _arr;
                }
            };
        }, {} ],
        15: [ function(require, module, exports) {
            module.exports = function _nonIterableRest() {
                throw new TypeError("Invalid attempt to destructure non-iterable instance");
            };
        }, {} ],
        16: [ function(require, module, exports) {
            module.exports = function _nonIterableSpread() {
                throw new TypeError("Invalid attempt to spread non-iterable instance");
            };
        }, {} ],
        17: [ function(require, module, exports) {
            var _typeof = require("../helpers/typeof"), assertThisInitialized = require("./assertThisInitialized");
            module.exports = function _possibleConstructorReturn(self, call) {
                return !call || "object" !== _typeof(call) && "function" != typeof call ? assertThisInitialized(self) : call;
            };
        }, {
            "../helpers/typeof": 21,
            "./assertThisInitialized": 3
        } ],
        18: [ function(require, module, exports) {
            function _setPrototypeOf(o, p) {
                return module.exports = _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
                    return o.__proto__ = p, o;
                }, _setPrototypeOf(o, p);
            }
            module.exports = _setPrototypeOf;
        }, {} ],
        19: [ function(require, module, exports) {
            var arrayWithHoles = require("./arrayWithHoles"), iterableToArrayLimit = require("./iterableToArrayLimit"), nonIterableRest = require("./nonIterableRest");
            module.exports = function _slicedToArray(arr, i) {
                return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || nonIterableRest();
            };
        }, {
            "./arrayWithHoles": 1,
            "./iterableToArrayLimit": 14,
            "./nonIterableRest": 15
        } ],
        20: [ function(require, module, exports) {
            var arrayWithoutHoles = require("./arrayWithoutHoles"), iterableToArray = require("./iterableToArray"), nonIterableSpread = require("./nonIterableSpread");
            module.exports = function _toConsumableArray(arr) {
                return arrayWithoutHoles(arr) || iterableToArray(arr) || nonIterableSpread();
            };
        }, {
            "./arrayWithoutHoles": 2,
            "./iterableToArray": 13,
            "./nonIterableSpread": 16
        } ],
        21: [ function(require, module, exports) {
            function _typeof2(obj) {
                return _typeof2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function _typeof2(obj) {
                    return typeof obj;
                } : function _typeof2(obj) {
                    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
                }, _typeof2(obj);
            }
            function _typeof(obj) {
                return "function" == typeof Symbol && "symbol" === _typeof2(Symbol.iterator) ? module.exports = _typeof = function _typeof(obj) {
                    return _typeof2(obj);
                } : module.exports = _typeof = function _typeof(obj) {
                    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj);
                }, _typeof(obj);
            }
            module.exports = _typeof;
        }, {} ],
        22: [ function(require, module, exports) {
            module.exports = require("regenerator-runtime");
        }, {
            "regenerator-runtime": 153
        } ],
        23: [ function(require, module, exports) {
            var Converter = require("./src/converter");
            function anyBase(srcAlphabet, dstAlphabet) {
                var converter = new Converter(srcAlphabet, dstAlphabet);
                return function(number) {
                    return converter.convert(number);
                };
            }
            anyBase.BIN = "01", anyBase.OCT = "01234567", anyBase.DEC = "0123456789", anyBase.HEX = "0123456789abcdef", 
            module.exports = anyBase;
        }, {
            "./src/converter": 24
        } ],
        24: [ function(require, module, exports) {
            function Converter(srcAlphabet, dstAlphabet) {
                if (!(srcAlphabet && dstAlphabet && srcAlphabet.length && dstAlphabet.length)) throw new Error("Bad alphabet");
                this.srcAlphabet = srcAlphabet, this.dstAlphabet = dstAlphabet;
            }
            Converter.prototype.convert = function(number) {
                var i, divide, newlen, numberMap = {}, fromBase = this.srcAlphabet.length, toBase = this.dstAlphabet.length, length = number.length, result = "string" == typeof number ? "" : [];
                if (!this.isValid(number)) throw new Error('Number "' + number + '" contains of non-alphabetic digits (' + this.srcAlphabet + ")");
                if (this.srcAlphabet === this.dstAlphabet) return number;
                for (i = 0; i < length; i++) numberMap[i] = this.srcAlphabet.indexOf(number[i]);
                do {
                    for (divide = 0, newlen = 0, i = 0; i < length; i++) (divide = divide * fromBase + numberMap[i]) >= toBase ? (numberMap[newlen++] = parseInt(divide / toBase, 10), 
                    divide %= toBase) : newlen > 0 && (numberMap[newlen++] = 0);
                    length = newlen, result = this.dstAlphabet.slice(divide, divide + 1).concat(result);
                } while (0 !== newlen);
                return result;
            }, Converter.prototype.isValid = function(number) {
                for (var i = 0; i < number.length; ++i) if (-1 === this.srcAlphabet.indexOf(number[i])) return !1;
                return !0;
            }, module.exports = Converter;
        }, {} ],
        25: [ function(require, module, exports) {
            (function(global) {
                var objectAssign = require("object-assign");
                /*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */                function compare(a, b) {
                    if (a === b) return 0;
                    for (var x = a.length, y = b.length, i = 0, len = Math.min(x, y); i < len; ++i) if (a[i] !== b[i]) {
                        x = a[i], y = b[i];
                        break;
                    }
                    return x < y ? -1 : y < x ? 1 : 0;
                }
                function isBuffer(b) {
                    return global.Buffer && "function" == typeof global.Buffer.isBuffer ? global.Buffer.isBuffer(b) : !(null == b || !b._isBuffer);
                }
                var util = require("util/"), hasOwn = Object.prototype.hasOwnProperty, pSlice = Array.prototype.slice, functionsHaveNames = "foo" === function foo() {}.name;
                function pToString(obj) {
                    return Object.prototype.toString.call(obj);
                }
                function isView(arrbuf) {
                    return !isBuffer(arrbuf) && "function" == typeof global.ArrayBuffer && ("function" == typeof ArrayBuffer.isView ? ArrayBuffer.isView(arrbuf) : !!arrbuf && (arrbuf instanceof DataView || !!(arrbuf.buffer && arrbuf.buffer instanceof ArrayBuffer)));
                }
                var assert = module.exports = ok, regex = /\s*function\s+([^\(\s]*)\s*/;
                function getName(func) {
                    if (util.isFunction(func)) {
                        if (functionsHaveNames) return func.name;
                        var match = func.toString().match(regex);
                        return match && match[1];
                    }
                }
                function truncate(s, n) {
                    return "string" == typeof s ? s.length < n ? s : s.slice(0, n) : s;
                }
                function inspect(something) {
                    if (functionsHaveNames || !util.isFunction(something)) return util.inspect(something);
                    var rawname = getName(something);
                    return "[Function" + (rawname ? ": " + rawname : "") + "]";
                }
                function fail(actual, expected, message, operator, stackStartFunction) {
                    throw new assert.AssertionError({
                        message,
                        actual,
                        expected,
                        operator,
                        stackStartFunction
                    });
                }
                function ok(value, message) {
                    value || fail(value, !0, message, "==", assert.ok);
                }
                function _deepEqual(actual, expected, strict, memos) {
                    if (actual === expected) return !0;
                    if (isBuffer(actual) && isBuffer(expected)) return 0 === compare(actual, expected);
                    if (util.isDate(actual) && util.isDate(expected)) return actual.getTime() === expected.getTime();
                    if (util.isRegExp(actual) && util.isRegExp(expected)) return actual.source === expected.source && actual.global === expected.global && actual.multiline === expected.multiline && actual.lastIndex === expected.lastIndex && actual.ignoreCase === expected.ignoreCase;
                    if (null !== actual && "object" == typeof actual || null !== expected && "object" == typeof expected) {
                        if (isView(actual) && isView(expected) && pToString(actual) === pToString(expected) && !(actual instanceof Float32Array || actual instanceof Float64Array)) return 0 === compare(new Uint8Array(actual.buffer), new Uint8Array(expected.buffer));
                        if (isBuffer(actual) !== isBuffer(expected)) return !1;
                        var actualIndex = (memos = memos || {
                            actual: [],
                            expected: []
                        }).actual.indexOf(actual);
                        return -1 !== actualIndex && actualIndex === memos.expected.indexOf(expected) || (memos.actual.push(actual), 
                        memos.expected.push(expected), function objEquiv(a, b, strict, actualVisitedObjects) {
                            if (null == a || null == b) return !1;
                            if (util.isPrimitive(a) || util.isPrimitive(b)) return a === b;
                            if (strict && Object.getPrototypeOf(a) !== Object.getPrototypeOf(b)) return !1;
                            var aIsArgs = isArguments(a), bIsArgs = isArguments(b);
                            if (aIsArgs && !bIsArgs || !aIsArgs && bIsArgs) return !1;
                            if (aIsArgs) return _deepEqual(a = pSlice.call(a), b = pSlice.call(b), strict);
                            var key, i, ka = objectKeys(a), kb = objectKeys(b);
                            if (ka.length !== kb.length) return !1;
                            for (ka.sort(), kb.sort(), i = ka.length - 1; i >= 0; i--) if (ka[i] !== kb[i]) return !1;
                            for (i = ka.length - 1; i >= 0; i--) if (!_deepEqual(a[key = ka[i]], b[key], strict, actualVisitedObjects)) return !1;
                            return !0;
                        }(actual, expected, strict, memos));
                    }
                    return strict ? actual === expected : actual == expected;
                }
                function isArguments(object) {
                    return "[object Arguments]" == Object.prototype.toString.call(object);
                }
                function expectedException(actual, expected) {
                    if (!actual || !expected) return !1;
                    if ("[object RegExp]" == Object.prototype.toString.call(expected)) return expected.test(actual);
                    try {
                        if (actual instanceof expected) return !0;
                    } catch (e) {}
                    return !Error.isPrototypeOf(expected) && !0 === expected.call({}, actual);
                }
                function _throws(shouldThrow, block, expected, message) {
                    var actual;
                    if ("function" != typeof block) throw new TypeError('"block" argument must be a function');
                    "string" == typeof expected && (message = expected, expected = null), actual = function _tryBlock(block) {
                        var error;
                        try {
                            block();
                        } catch (e) {
                            error = e;
                        }
                        return error;
                    }(block), message = (expected && expected.name ? " (" + expected.name + ")." : ".") + (message ? " " + message : "."), 
                    shouldThrow && !actual && fail(actual, expected, "Missing expected exception" + message);
                    var userProvidedMessage = "string" == typeof message, isUnexpectedException = !shouldThrow && actual && !expected;
                    if ((!shouldThrow && util.isError(actual) && userProvidedMessage && expectedException(actual, expected) || isUnexpectedException) && fail(actual, expected, "Got unwanted exception" + message), 
                    shouldThrow && actual && expected && !expectedException(actual, expected) || !shouldThrow && actual) throw actual;
                }
                assert.AssertionError = function AssertionError(options) {
                    this.name = "AssertionError", this.actual = options.actual, this.expected = options.expected, 
                    this.operator = options.operator, options.message ? (this.message = options.message, 
                    this.generatedMessage = !1) : (this.message = function getMessage(self) {
                        return truncate(inspect(self.actual), 128) + " " + self.operator + " " + truncate(inspect(self.expected), 128);
                    }(this), this.generatedMessage = !0);
                    var stackStartFunction = options.stackStartFunction || fail;
                    if (Error.captureStackTrace) Error.captureStackTrace(this, stackStartFunction); else {
                        var err = new Error;
                        if (err.stack) {
                            var out = err.stack, fn_name = getName(stackStartFunction), idx = out.indexOf("\n" + fn_name);
                            if (idx >= 0) {
                                var next_line = out.indexOf("\n", idx + 1);
                                out = out.substring(next_line + 1);
                            }
                            this.stack = out;
                        }
                    }
                }, util.inherits(assert.AssertionError, Error), assert.fail = fail, assert.ok = ok, 
                assert.equal = function equal(actual, expected, message) {
                    actual != expected && fail(actual, expected, message, "==", assert.equal);
                }, assert.notEqual = function notEqual(actual, expected, message) {
                    actual == expected && fail(actual, expected, message, "!=", assert.notEqual);
                }, assert.deepEqual = function deepEqual(actual, expected, message) {
                    _deepEqual(actual, expected, !1) || fail(actual, expected, message, "deepEqual", assert.deepEqual);
                }, assert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {
                    _deepEqual(actual, expected, !0) || fail(actual, expected, message, "deepStrictEqual", assert.deepStrictEqual);
                }, assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
                    _deepEqual(actual, expected, !1) && fail(actual, expected, message, "notDeepEqual", assert.notDeepEqual);
                }, assert.notDeepStrictEqual = function notDeepStrictEqual(actual, expected, message) {
                    _deepEqual(actual, expected, !0) && fail(actual, expected, message, "notDeepStrictEqual", notDeepStrictEqual);
                }, assert.strictEqual = function strictEqual(actual, expected, message) {
                    actual !== expected && fail(actual, expected, message, "===", assert.strictEqual);
                }, assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
                    actual === expected && fail(actual, expected, message, "!==", assert.notStrictEqual);
                }, assert.throws = function(block, error, message) {
                    _throws(!0, block, error, message);
                }, assert.doesNotThrow = function(block, error, message) {
                    _throws(!1, block, error, message);
                }, assert.ifError = function(err) {
                    if (err) throw err;
                }, assert.strict = objectAssign((function strict(value, message) {
                    value || fail(value, !0, message, "==", strict);
                }), assert, {
                    equal: assert.strictEqual,
                    deepEqual: assert.deepStrictEqual,
                    notEqual: assert.notStrictEqual,
                    notDeepEqual: assert.notDeepStrictEqual
                }), assert.strict.strict = assert.strict;
                var objectKeys = Object.keys || function(obj) {
                    var keys = [];
                    for (var key in obj) hasOwn.call(obj, key) && keys.push(key);
                    return keys;
                };
            }).call(this, void 0 !== commonjsGlobal ? commonjsGlobal : "undefined" != typeof self ? self : void 0 !== window ? window : {});
        }, {
            "object-assign": 84,
            "util/": 28
        } ],
        26: [ function(require, module, exports) {
            "function" == typeof Object.create ? module.exports = function inherits(ctor, superCtor) {
                ctor.super_ = superCtor, ctor.prototype = Object.create(superCtor.prototype, {
                    constructor: {
                        value: ctor,
                        enumerable: !1,
                        writable: !0,
                        configurable: !0
                    }
                });
            } : module.exports = function inherits(ctor, superCtor) {
                ctor.super_ = superCtor;
                var TempCtor = function() {};
                TempCtor.prototype = superCtor.prototype, ctor.prototype = new TempCtor, ctor.prototype.constructor = ctor;
            };
        }, {} ],
        27: [ function(require, module, exports) {
            module.exports = function isBuffer(arg) {
                return arg && "object" == typeof arg && "function" == typeof arg.copy && "function" == typeof arg.fill && "function" == typeof arg.readUInt8;
            };
        }, {} ],
        28: [ function(require, module, exports) {
            (function(process, global) {
                var formatRegExp = /%[sdj%]/g;
                exports.format = function(f) {
                    if (!isString(f)) {
                        for (var objects = [], i = 0; i < arguments.length; i++) objects.push(inspect(arguments[i]));
                        return objects.join(" ");
                    }
                    i = 1;
                    for (var args = arguments, len = args.length, str = String(f).replace(formatRegExp, (function(x) {
                        if ("%%" === x) return "%";
                        if (i >= len) return x;
                        switch (x) {
                          case "%s":
                            return String(args[i++]);

                          case "%d":
                            return Number(args[i++]);

                          case "%j":
                            try {
                                return JSON.stringify(args[i++]);
                            } catch (_) {
                                return "[Circular]";
                            }

                          default:
                            return x;
                        }
                    })), x = args[i]; i < len; x = args[++i]) isNull(x) || !isObject(x) ? str += " " + x : str += " " + inspect(x);
                    return str;
                }, exports.deprecate = function(fn, msg) {
                    if (isUndefined(global.process)) return function() {
                        return exports.deprecate(fn, msg).apply(this, arguments);
                    };
                    if (!0 === process.noDeprecation) return fn;
                    var warned = !1;
                    return function deprecated() {
                        if (!warned) {
                            if (process.throwDeprecation) throw new Error(msg);
                            process.traceDeprecation ? console.trace(msg) : console.error(msg), warned = !0;
                        }
                        return fn.apply(this, arguments);
                    };
                };
                var debugEnviron, debugs = {};
                function inspect(obj, opts) {
                    var ctx = {
                        seen: [],
                        stylize: stylizeNoColor
                    };
                    return arguments.length >= 3 && (ctx.depth = arguments[2]), arguments.length >= 4 && (ctx.colors = arguments[3]), 
                    isBoolean(opts) ? ctx.showHidden = opts : opts && exports._extend(ctx, opts), isUndefined(ctx.showHidden) && (ctx.showHidden = !1), 
                    isUndefined(ctx.depth) && (ctx.depth = 2), isUndefined(ctx.colors) && (ctx.colors = !1), 
                    isUndefined(ctx.customInspect) && (ctx.customInspect = !0), ctx.colors && (ctx.stylize = stylizeWithColor), 
                    formatValue(ctx, obj, ctx.depth);
                }
                function stylizeWithColor(str, styleType) {
                    var style = inspect.styles[styleType];
                    return style ? "[" + inspect.colors[style][0] + "m" + str + "[" + inspect.colors[style][1] + "m" : str;
                }
                function stylizeNoColor(str, styleType) {
                    return str;
                }
                function formatValue(ctx, value, recurseTimes) {
                    if (ctx.customInspect && value && isFunction(value.inspect) && value.inspect !== exports.inspect && (!value.constructor || value.constructor.prototype !== value)) {
                        var ret = value.inspect(recurseTimes, ctx);
                        return isString(ret) || (ret = formatValue(ctx, ret, recurseTimes)), ret;
                    }
                    var primitive = function formatPrimitive(ctx, value) {
                        if (isUndefined(value)) return ctx.stylize("undefined", "undefined");
                        if (isString(value)) {
                            var simple = "'" + JSON.stringify(value).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
                            return ctx.stylize(simple, "string");
                        }
                        return isNumber(value) ? ctx.stylize("" + value, "number") : isBoolean(value) ? ctx.stylize("" + value, "boolean") : isNull(value) ? ctx.stylize("null", "null") : void 0;
                    }(ctx, value);
                    if (primitive) return primitive;
                    var keys = Object.keys(value), visibleKeys = function arrayToHash(array) {
                        var hash = {};
                        return array.forEach((function(val, idx) {
                            hash[val] = !0;
                        })), hash;
                    }(keys);
                    if (ctx.showHidden && (keys = Object.getOwnPropertyNames(value)), isError(value) && (keys.indexOf("message") >= 0 || keys.indexOf("description") >= 0)) return formatError(value);
                    if (0 === keys.length) {
                        if (isFunction(value)) {
                            var name = value.name ? ": " + value.name : "";
                            return ctx.stylize("[Function" + name + "]", "special");
                        }
                        if (isRegExp(value)) return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
                        if (isDate(value)) return ctx.stylize(Date.prototype.toString.call(value), "date");
                        if (isError(value)) return formatError(value);
                    }
                    var output, base = "", array = !1, braces = [ "{", "}" ];
                    return isArray(value) && (array = !0, braces = [ "[", "]" ]), isFunction(value) && (base = " [Function" + (value.name ? ": " + value.name : "") + "]"), 
                    isRegExp(value) && (base = " " + RegExp.prototype.toString.call(value)), isDate(value) && (base = " " + Date.prototype.toUTCString.call(value)), 
                    isError(value) && (base = " " + formatError(value)), 0 !== keys.length || array && 0 != value.length ? recurseTimes < 0 ? isRegExp(value) ? ctx.stylize(RegExp.prototype.toString.call(value), "regexp") : ctx.stylize("[Object]", "special") : (ctx.seen.push(value), 
                    output = array ? function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
                        for (var output = [], i = 0, l = value.length; i < l; ++i) hasOwnProperty(value, String(i)) ? output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), !0)) : output.push("");
                        return keys.forEach((function(key) {
                            key.match(/^\d+$/) || output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, !0));
                        })), output;
                    }(ctx, value, recurseTimes, visibleKeys, keys) : keys.map((function(key) {
                        return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
                    })), ctx.seen.pop(), function reduceToSingleString(output, base, braces) {
                        return output.reduce((function(prev, cur) {
                            return cur.indexOf("\n"), prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
                        }), 0) > 60 ? braces[0] + ("" === base ? "" : base + "\n ") + " " + output.join(",\n  ") + " " + braces[1] : braces[0] + base + " " + output.join(", ") + " " + braces[1];
                    }(output, base, braces)) : braces[0] + base + braces[1];
                }
                function formatError(value) {
                    return "[" + Error.prototype.toString.call(value) + "]";
                }
                function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
                    var name, str, desc;
                    if ((desc = Object.getOwnPropertyDescriptor(value, key) || {
                        value: value[key]
                    }).get ? str = desc.set ? ctx.stylize("[Getter/Setter]", "special") : ctx.stylize("[Getter]", "special") : desc.set && (str = ctx.stylize("[Setter]", "special")), 
                    hasOwnProperty(visibleKeys, key) || (name = "[" + key + "]"), str || (ctx.seen.indexOf(desc.value) < 0 ? (str = isNull(recurseTimes) ? formatValue(ctx, desc.value, null) : formatValue(ctx, desc.value, recurseTimes - 1)).indexOf("\n") > -1 && (str = array ? str.split("\n").map((function(line) {
                        return "  " + line;
                    })).join("\n").substr(2) : "\n" + str.split("\n").map((function(line) {
                        return "   " + line;
                    })).join("\n")) : str = ctx.stylize("[Circular]", "special")), isUndefined(name)) {
                        if (array && key.match(/^\d+$/)) return str;
                        (name = JSON.stringify("" + key)).match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (name = name.substr(1, name.length - 2), 
                        name = ctx.stylize(name, "name")) : (name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), 
                        name = ctx.stylize(name, "string"));
                    }
                    return name + ": " + str;
                }
                function isArray(ar) {
                    return Array.isArray(ar);
                }
                function isBoolean(arg) {
                    return "boolean" == typeof arg;
                }
                function isNull(arg) {
                    return null === arg;
                }
                function isNumber(arg) {
                    return "number" == typeof arg;
                }
                function isString(arg) {
                    return "string" == typeof arg;
                }
                function isUndefined(arg) {
                    return void 0 === arg;
                }
                function isRegExp(re) {
                    return isObject(re) && "[object RegExp]" === objectToString(re);
                }
                function isObject(arg) {
                    return "object" == typeof arg && null !== arg;
                }
                function isDate(d) {
                    return isObject(d) && "[object Date]" === objectToString(d);
                }
                function isError(e) {
                    return isObject(e) && ("[object Error]" === objectToString(e) || e instanceof Error);
                }
                function isFunction(arg) {
                    return "function" == typeof arg;
                }
                function objectToString(o) {
                    return Object.prototype.toString.call(o);
                }
                function pad(n) {
                    return n < 10 ? "0" + n.toString(10) : n.toString(10);
                }
                exports.debuglog = function(set) {
                    if (isUndefined(debugEnviron) && (debugEnviron = process.env.NODE_DEBUG || ""), 
                    set = set.toUpperCase(), !debugs[set]) if (new RegExp("\\b" + set + "\\b", "i").test(debugEnviron)) {
                        var pid = process.pid;
                        debugs[set] = function() {
                            var msg = exports.format.apply(exports, arguments);
                            console.error("%s %d: %s", set, pid, msg);
                        };
                    } else debugs[set] = function() {};
                    return debugs[set];
                }, exports.inspect = inspect, inspect.colors = {
                    bold: [ 1, 22 ],
                    italic: [ 3, 23 ],
                    underline: [ 4, 24 ],
                    inverse: [ 7, 27 ],
                    white: [ 37, 39 ],
                    grey: [ 90, 39 ],
                    black: [ 30, 39 ],
                    blue: [ 34, 39 ],
                    cyan: [ 36, 39 ],
                    green: [ 32, 39 ],
                    magenta: [ 35, 39 ],
                    red: [ 31, 39 ],
                    yellow: [ 33, 39 ]
                }, inspect.styles = {
                    special: "cyan",
                    number: "yellow",
                    boolean: "yellow",
                    undefined: "grey",
                    null: "bold",
                    string: "green",
                    date: "magenta",
                    regexp: "red"
                }, exports.isArray = isArray, exports.isBoolean = isBoolean, exports.isNull = isNull, 
                exports.isNullOrUndefined = function isNullOrUndefined(arg) {
                    return null == arg;
                }, exports.isNumber = isNumber, exports.isString = isString, exports.isSymbol = function isSymbol(arg) {
                    return "symbol" == typeof arg;
                }, exports.isUndefined = isUndefined, exports.isRegExp = isRegExp, exports.isObject = isObject, 
                exports.isDate = isDate, exports.isError = isError, exports.isFunction = isFunction, 
                exports.isPrimitive = function isPrimitive(arg) {
                    return null === arg || "boolean" == typeof arg || "number" == typeof arg || "string" == typeof arg || "symbol" == typeof arg || void 0 === arg;
                }, exports.isBuffer = require("./support/isBuffer");
                var months = [ "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" ];
                function timestamp() {
                    var d = new Date, time = [ pad(d.getHours()), pad(d.getMinutes()), pad(d.getSeconds()) ].join(":");
                    return [ d.getDate(), months[d.getMonth()], time ].join(" ");
                }
                function hasOwnProperty(obj, prop) {
                    return Object.prototype.hasOwnProperty.call(obj, prop);
                }
                exports.log = function() {
                    console.log("%s - %s", timestamp(), exports.format.apply(exports, arguments));
                }, exports.inherits = require("inherits"), exports._extend = function(origin, add) {
                    if (!add || !isObject(add)) return origin;
                    for (var keys = Object.keys(add), i = keys.length; i--; ) origin[keys[i]] = add[keys[i]];
                    return origin;
                };
            }).call(this, require("_process"), void 0 !== commonjsGlobal ? commonjsGlobal : "undefined" != typeof self ? self : void 0 !== window ? window : {});
        }, {
            "./support/isBuffer": 27,
            _process: 133,
            inherits: 26
        } ],
        29: [ function(require, module, exports) {
            exports.byteLength = function byteLength(b64) {
                var lens = getLens(b64), validLen = lens[0], placeHoldersLen = lens[1];
                return 3 * (validLen + placeHoldersLen) / 4 - placeHoldersLen;
            }, exports.toByteArray = function toByteArray(b64) {
                var tmp, i, lens = getLens(b64), validLen = lens[0], placeHoldersLen = lens[1], arr = new Arr(function _byteLength(b64, validLen, placeHoldersLen) {
                    return 3 * (validLen + placeHoldersLen) / 4 - placeHoldersLen;
                }(0, validLen, placeHoldersLen)), curByte = 0, len = placeHoldersLen > 0 ? validLen - 4 : validLen;
                for (i = 0; i < len; i += 4) tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)], 
                arr[curByte++] = tmp >> 16 & 0xFF, arr[curByte++] = tmp >> 8 & 0xFF, arr[curByte++] = 0xFF & tmp;
                return 2 === placeHoldersLen && (tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4, 
                arr[curByte++] = 0xFF & tmp), 1 === placeHoldersLen && (tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2, 
                arr[curByte++] = tmp >> 8 & 0xFF, arr[curByte++] = 0xFF & tmp), arr;
            }, exports.fromByteArray = function fromByteArray(uint8) {
                for (var tmp, len = uint8.length, extraBytes = len % 3, parts = [], i = 0, len2 = len - extraBytes; i < len2; i += 16383) parts.push(encodeChunk(uint8, i, i + 16383 > len2 ? len2 : i + 16383));
                return 1 === extraBytes ? (tmp = uint8[len - 1], parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 0x3F] + "==")) : 2 === extraBytes && (tmp = (uint8[len - 2] << 8) + uint8[len - 1], 
                parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 0x3F] + lookup[tmp << 2 & 0x3F] + "=")), 
                parts.join("");
            };
            for (var lookup = [], revLookup = [], Arr = "undefined" != typeof Uint8Array ? Uint8Array : Array, code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", i = 0, len = code.length; i < len; ++i) lookup[i] = code[i], 
            revLookup[code.charCodeAt(i)] = i;
            function getLens(b64) {
                var len = b64.length;
                if (len % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
                var validLen = b64.indexOf("=");
                return -1 === validLen && (validLen = len), [ validLen, validLen === len ? 0 : 4 - validLen % 4 ];
            }
            function encodeChunk(uint8, start, end) {
                for (var tmp, output = [], i = start; i < end; i += 3) tmp = (uint8[i] << 16 & 0xFF0000) + (uint8[i + 1] << 8 & 0xFF00) + (0xFF & uint8[i + 2]), 
                output.push(lookup[(num = tmp) >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[0x3F & num]);
                var num;
                return output.join("");
            }
            revLookup["-".charCodeAt(0)] = 62, revLookup["_".charCodeAt(0)] = 63;
        }, {} ],
        30: [ function(require, module, exports) {
            var encode = require("./lib/encoder"), decode = require("./lib/decoder");
            module.exports = {
                encode,
                decode
            };
        }, {
            "./lib/decoder": 31,
            "./lib/encoder": 32
        } ],
        31: [ function(require, module, exports) {
            (function(Buffer) {
                function BmpDecoder(buffer, is_with_alpha) {
                    if (this.pos = 0, this.buffer = buffer, this.is_with_alpha = !!is_with_alpha, this.bottom_up = !0, 
                    this.flag = this.buffer.toString("utf-8", 0, this.pos += 2), "BM" != this.flag) throw new Error("Invalid BMP File");
                    this.parseHeader(), this.parseRGBA();
                }
                BmpDecoder.prototype.parseHeader = function() {
                    if (this.fileSize = this.buffer.readUInt32LE(this.pos), this.pos += 4, this.reserved = this.buffer.readUInt32LE(this.pos), 
                    this.pos += 4, this.offset = this.buffer.readUInt32LE(this.pos), this.pos += 4, 
                    this.headerSize = this.buffer.readUInt32LE(this.pos), this.pos += 4, this.width = this.buffer.readUInt32LE(this.pos), 
                    this.pos += 4, this.height = this.buffer.readInt32LE(this.pos), this.pos += 4, this.planes = this.buffer.readUInt16LE(this.pos), 
                    this.pos += 2, this.bitPP = this.buffer.readUInt16LE(this.pos), this.pos += 2, this.compress = this.buffer.readUInt32LE(this.pos), 
                    this.pos += 4, this.rawSize = this.buffer.readUInt32LE(this.pos), this.pos += 4, 
                    this.hr = this.buffer.readUInt32LE(this.pos), this.pos += 4, this.vr = this.buffer.readUInt32LE(this.pos), 
                    this.pos += 4, this.colors = this.buffer.readUInt32LE(this.pos), this.pos += 4, 
                    this.importantColors = this.buffer.readUInt32LE(this.pos), this.pos += 4, 16 === this.bitPP && this.is_with_alpha && (this.bitPP = 15), 
                    this.bitPP < 15) {
                        var len = 0 === this.colors ? 1 << this.bitPP : this.colors;
                        this.palette = new Array(len);
                        for (var i = 0; i < len; i++) {
                            var blue = this.buffer.readUInt8(this.pos++), green = this.buffer.readUInt8(this.pos++), red = this.buffer.readUInt8(this.pos++), quad = this.buffer.readUInt8(this.pos++);
                            this.palette[i] = {
                                red,
                                green,
                                blue,
                                quad
                            };
                        }
                    }
                    this.height < 0 && (this.height *= -1, this.bottom_up = !1);
                }, BmpDecoder.prototype.parseRGBA = function() {
                    var bitn = "bit" + this.bitPP, len = this.width * this.height * 4;
                    this.data = new Buffer(len), this[bitn]();
                }, BmpDecoder.prototype.bit1 = function() {
                    var xlen = Math.ceil(this.width / 8), mode = xlen % 4, y = this.height >= 0 ? this.height - 1 : -this.height;
                    for (y = this.height - 1; y >= 0; y--) {
                        for (var line = this.bottom_up ? y : this.height - 1 - y, x = 0; x < xlen; x++) for (var b = this.buffer.readUInt8(this.pos++), location = line * this.width * 4 + 8 * x * 4, i = 0; i < 8 && 8 * x + i < this.width; i++) {
                            var rgb = this.palette[b >> 7 - i & 0x1];
                            this.data[location + 4 * i] = 0, this.data[location + 4 * i + 1] = rgb.blue, this.data[location + 4 * i + 2] = rgb.green, 
                            this.data[location + 4 * i + 3] = rgb.red;
                        }
                        0 != mode && (this.pos += 4 - mode);
                    }
                }, BmpDecoder.prototype.bit4 = function() {
                    if (2 == this.compress) {
                        this.data.fill(0xff);
                        for (var location = 0, lines = this.bottom_up ? this.height - 1 : 0, low_nibble = !1; location < this.data.length; ) {
                            var a = this.buffer.readUInt8(this.pos++), b = this.buffer.readUInt8(this.pos++);
                            if (0 == a) {
                                if (0 == b) {
                                    this.bottom_up ? lines-- : lines++, location = lines * this.width * 4, low_nibble = !1;
                                    continue;
                                }
                                if (1 == b) break;
                                if (2 == b) {
                                    var x = this.buffer.readUInt8(this.pos++), y = this.buffer.readUInt8(this.pos++);
                                    this.bottom_up ? lines -= y : lines += y, location += y * this.width * 4 + 4 * x;
                                } else {
                                    for (var c = this.buffer.readUInt8(this.pos++), i = 0; i < b; i++) low_nibble ? setPixelData.call(this, 0x0f & c) : setPixelData.call(this, (0xf0 & c) >> 4), 
                                    1 & i && i + 1 < b && (c = this.buffer.readUInt8(this.pos++)), low_nibble = !low_nibble;
                                    1 == (b + 1 >> 1 & 1) && this.pos++;
                                }
                            } else for (i = 0; i < a; i++) low_nibble ? setPixelData.call(this, 0x0f & b) : setPixelData.call(this, (0xf0 & b) >> 4), 
                            low_nibble = !low_nibble;
                        }
                        function setPixelData(rgbIndex) {
                            var rgb = this.palette[rgbIndex];
                            this.data[location] = 0, this.data[location + 1] = rgb.blue, this.data[location + 2] = rgb.green, 
                            this.data[location + 3] = rgb.red, location += 4;
                        }
                    } else {
                        var xlen = Math.ceil(this.width / 2), mode = xlen % 4;
                        for (y = this.height - 1; y >= 0; y--) {
                            var line = this.bottom_up ? y : this.height - 1 - y;
                            for (x = 0; x < xlen; x++) {
                                b = this.buffer.readUInt8(this.pos++), location = line * this.width * 4 + 2 * x * 4;
                                var before = b >> 4, after = 0x0F & b, rgb = this.palette[before];
                                if (this.data[location] = 0, this.data[location + 1] = rgb.blue, this.data[location + 2] = rgb.green, 
                                this.data[location + 3] = rgb.red, 2 * x + 1 >= this.width) break;
                                rgb = this.palette[after], this.data[location + 4] = 0, this.data[location + 4 + 1] = rgb.blue, 
                                this.data[location + 4 + 2] = rgb.green, this.data[location + 4 + 3] = rgb.red;
                            }
                            0 != mode && (this.pos += 4 - mode);
                        }
                    }
                }, BmpDecoder.prototype.bit8 = function() {
                    if (1 == this.compress) {
                        this.data.fill(0xff);
                        for (var location = 0, lines = this.bottom_up ? this.height - 1 : 0; location < this.data.length; ) {
                            var a = this.buffer.readUInt8(this.pos++), b = this.buffer.readUInt8(this.pos++);
                            if (0 == a) {
                                if (0 == b) {
                                    this.bottom_up ? lines-- : lines++, location = lines * this.width * 4;
                                    continue;
                                }
                                if (1 == b) break;
                                if (2 == b) {
                                    var x = this.buffer.readUInt8(this.pos++), y = this.buffer.readUInt8(this.pos++);
                                    this.bottom_up ? lines -= y : lines += y, location += y * this.width * 4 + 4 * x;
                                } else {
                                    for (var i = 0; i < b; i++) {
                                        var c = this.buffer.readUInt8(this.pos++);
                                        setPixelData.call(this, c);
                                    }
                                    !0 & b && this.pos++;
                                }
                            } else for (i = 0; i < a; i++) setPixelData.call(this, b);
                        }
                        function setPixelData(rgbIndex) {
                            var rgb = this.palette[rgbIndex];
                            this.data[location] = 0, this.data[location + 1] = rgb.blue, this.data[location + 2] = rgb.green, 
                            this.data[location + 3] = rgb.red, location += 4;
                        }
                    } else {
                        var mode = this.width % 4;
                        for (y = this.height - 1; y >= 0; y--) {
                            var line = this.bottom_up ? y : this.height - 1 - y;
                            for (x = 0; x < this.width; x++) if (b = this.buffer.readUInt8(this.pos++), location = line * this.width * 4 + 4 * x, 
                            b < this.palette.length) {
                                var rgb = this.palette[b];
                                this.data[location] = 0, this.data[location + 1] = rgb.blue, this.data[location + 2] = rgb.green, 
                                this.data[location + 3] = rgb.red;
                            } else this.data[location] = 0, this.data[location + 1] = 0xFF, this.data[location + 2] = 0xFF, 
                            this.data[location + 3] = 0xFF;
                            0 != mode && (this.pos += 4 - mode);
                        }
                    }
                }, BmpDecoder.prototype.bit15 = function() {
                    for (var dif_w = this.width % 3, _1_5 = parseInt("11111", 2), y = this.height - 1; y >= 0; y--) {
                        for (var line = this.bottom_up ? y : this.height - 1 - y, x = 0; x < this.width; x++) {
                            var B = this.buffer.readUInt16LE(this.pos);
                            this.pos += 2;
                            var blue = (B & _1_5) / _1_5 * 255 | 0, green = (B >> 5 & _1_5) / _1_5 * 255 | 0, red = (B >> 10 & _1_5) / _1_5 * 255 | 0, alpha = B >> 15 ? 0xFF : 0x00, location = line * this.width * 4 + 4 * x;
                            this.data[location] = alpha, this.data[location + 1] = blue, this.data[location + 2] = green, 
                            this.data[location + 3] = red;
                        }
                        this.pos += dif_w;
                    }
                }, BmpDecoder.prototype.bit16 = function() {
                    var dif_w = this.width % 2 * 2;
                    this.maskRed = 0x7C00, this.maskGreen = 0x3E0, this.maskBlue = 0x1F, this.mask0 = 0, 
                    3 == this.compress && (this.maskRed = this.buffer.readUInt32LE(this.pos), this.pos += 4, 
                    this.maskGreen = this.buffer.readUInt32LE(this.pos), this.pos += 4, this.maskBlue = this.buffer.readUInt32LE(this.pos), 
                    this.pos += 4, this.mask0 = this.buffer.readUInt32LE(this.pos), this.pos += 4);
                    for (var ns = [ 0, 0, 0 ], i = 0; i < 16; i++) this.maskRed >> i & 0x01 && ns[0]++, 
                    this.maskGreen >> i & 0x01 && ns[1]++, this.maskBlue >> i & 0x01 && ns[2]++;
                    ns[1] += ns[0], ns[2] += ns[1], ns[0] = 8 - ns[0], ns[1] -= 8, ns[2] -= 8;
                    for (var y = this.height - 1; y >= 0; y--) {
                        for (var line = this.bottom_up ? y : this.height - 1 - y, x = 0; x < this.width; x++) {
                            var B = this.buffer.readUInt16LE(this.pos);
                            this.pos += 2;
                            var blue = (B & this.maskBlue) << ns[0], green = (B & this.maskGreen) >> ns[1], red = (B & this.maskRed) >> ns[2], location = line * this.width * 4 + 4 * x;
                            this.data[location] = 0, this.data[location + 1] = blue, this.data[location + 2] = green, 
                            this.data[location + 3] = red;
                        }
                        this.pos += dif_w;
                    }
                }, BmpDecoder.prototype.bit24 = function() {
                    for (var y = this.height - 1; y >= 0; y--) {
                        for (var line = this.bottom_up ? y : this.height - 1 - y, x = 0; x < this.width; x++) {
                            var blue = this.buffer.readUInt8(this.pos++), green = this.buffer.readUInt8(this.pos++), red = this.buffer.readUInt8(this.pos++), location = line * this.width * 4 + 4 * x;
                            this.data[location] = 0, this.data[location + 1] = blue, this.data[location + 2] = green, 
                            this.data[location + 3] = red;
                        }
                        this.pos += this.width % 4;
                    }
                }, BmpDecoder.prototype.bit32 = function() {
                    if (3 == this.compress) {
                        this.maskRed = this.buffer.readUInt32LE(this.pos), this.pos += 4, this.maskGreen = this.buffer.readUInt32LE(this.pos), 
                        this.pos += 4, this.maskBlue = this.buffer.readUInt32LE(this.pos), this.pos += 4, 
                        this.mask0 = this.buffer.readUInt32LE(this.pos), this.pos += 4;
                        for (var y = this.height - 1; y >= 0; y--) for (var line = this.bottom_up ? y : this.height - 1 - y, x = 0; x < this.width; x++) {
                            var alpha = this.buffer.readUInt8(this.pos++), blue = this.buffer.readUInt8(this.pos++), green = this.buffer.readUInt8(this.pos++), red = this.buffer.readUInt8(this.pos++), location = line * this.width * 4 + 4 * x;
                            this.data[location] = alpha, this.data[location + 1] = blue, this.data[location + 2] = green, 
                            this.data[location + 3] = red;
                        }
                    } else for (y = this.height - 1; y >= 0; y--) for (line = this.bottom_up ? y : this.height - 1 - y, 
                    x = 0; x < this.width; x++) blue = this.buffer.readUInt8(this.pos++), green = this.buffer.readUInt8(this.pos++), 
                    red = this.buffer.readUInt8(this.pos++), alpha = this.buffer.readUInt8(this.pos++), 
                    location = line * this.width * 4 + 4 * x, this.data[location] = alpha, this.data[location + 1] = blue, 
                    this.data[location + 2] = green, this.data[location + 3] = red;
                }, BmpDecoder.prototype.getData = function() {
                    return this.data;
                }, module.exports = function(bmpData) {
                    return new BmpDecoder(bmpData);
                };
            }).call(this, require("buffer").Buffer);
        }, {
            buffer: 48
        } ],
        32: [ function(require, module, exports) {
            (function(Buffer) {
                function BmpEncoder(imgData) {
                    this.buffer = imgData.data, this.width = imgData.width, this.height = imgData.height, 
                    this.extraBytes = this.width % 4, this.rgbSize = this.height * (3 * this.width + this.extraBytes), 
                    this.headerInfoSize = 40, this.data = [], this.flag = "BM", this.reserved = 0, this.offset = 54, 
                    this.fileSize = this.rgbSize + this.offset, this.planes = 1, this.bitPP = 24, this.compress = 0, 
                    this.hr = 0, this.vr = 0, this.colors = 0, this.importantColors = 0;
                }
                BmpEncoder.prototype.encode = function() {
                    var tempBuffer = new Buffer(this.offset + this.rgbSize);
                    this.pos = 0, tempBuffer.write(this.flag, this.pos, 2), this.pos += 2, tempBuffer.writeUInt32LE(this.fileSize, this.pos), 
                    this.pos += 4, tempBuffer.writeUInt32LE(this.reserved, this.pos), this.pos += 4, 
                    tempBuffer.writeUInt32LE(this.offset, this.pos), this.pos += 4, tempBuffer.writeUInt32LE(this.headerInfoSize, this.pos), 
                    this.pos += 4, tempBuffer.writeUInt32LE(this.width, this.pos), this.pos += 4, tempBuffer.writeInt32LE(-this.height, this.pos), 
                    this.pos += 4, tempBuffer.writeUInt16LE(this.planes, this.pos), this.pos += 2, tempBuffer.writeUInt16LE(this.bitPP, this.pos), 
                    this.pos += 2, tempBuffer.writeUInt32LE(this.compress, this.pos), this.pos += 4, 
                    tempBuffer.writeUInt32LE(this.rgbSize, this.pos), this.pos += 4, tempBuffer.writeUInt32LE(this.hr, this.pos), 
                    this.pos += 4, tempBuffer.writeUInt32LE(this.vr, this.pos), this.pos += 4, tempBuffer.writeUInt32LE(this.colors, this.pos), 
                    this.pos += 4, tempBuffer.writeUInt32LE(this.importantColors, this.pos), this.pos += 4;
                    for (var i = 0, rowBytes = 3 * this.width + this.extraBytes, y = 0; y < this.height; y++) {
                        for (var x = 0; x < this.width; x++) {
                            var p = this.pos + y * rowBytes + 3 * x;
                            i++, tempBuffer[p] = this.buffer[i++], tempBuffer[p + 1] = this.buffer[i++], tempBuffer[p + 2] = this.buffer[i++];
                        }
                        if (this.extraBytes > 0) {
                            var fillOffset = this.pos + y * rowBytes + 3 * this.width;
                            tempBuffer.fill(0, fillOffset, fillOffset + this.extraBytes);
                        }
                    }
                    return tempBuffer;
                }, module.exports = function(imgData, quality) {
                    return {
                        data: new BmpEncoder(imgData).encode(),
                        width: imgData.width,
                        height: imgData.height
                    };
                };
            }).call(this, require("buffer").Buffer);
        }, {
            buffer: 48
        } ],
        33: [ function(require, module, exports) {}, {} ],
        34: [ function(require, module, exports) {
            (function(process, Buffer) {
                var assert = require("assert"), Zstream = require("pako/lib/zlib/zstream"), zlib_deflate = require("pako/lib/zlib/deflate.js"), zlib_inflate = require("pako/lib/zlib/inflate.js"), constants = require("pako/lib/zlib/constants");
                for (var key in constants) exports[key] = constants[key];
                function Zlib(mode) {
                    if ("number" != typeof mode || mode < exports.DEFLATE || mode > exports.UNZIP) throw new TypeError("Bad argument");
                    this.dictionary = null, this.err = 0, this.flush = 0, this.init_done = !1, this.level = 0, 
                    this.memLevel = 0, this.mode = mode, this.strategy = 0, this.windowBits = 0, this.write_in_progress = !1, 
                    this.pending_close = !1, this.gzip_id_bytes_read = 0;
                }
                exports.NONE = 0, exports.DEFLATE = 1, exports.INFLATE = 2, exports.GZIP = 3, exports.GUNZIP = 4, 
                exports.DEFLATERAW = 5, exports.INFLATERAW = 6, exports.UNZIP = 7, Zlib.prototype.close = function() {
                    this.write_in_progress ? this.pending_close = !0 : (this.pending_close = !1, assert(this.init_done, "close before init"), 
                    assert(this.mode <= exports.UNZIP), this.mode === exports.DEFLATE || this.mode === exports.GZIP || this.mode === exports.DEFLATERAW ? zlib_deflate.deflateEnd(this.strm) : this.mode !== exports.INFLATE && this.mode !== exports.GUNZIP && this.mode !== exports.INFLATERAW && this.mode !== exports.UNZIP || zlib_inflate.inflateEnd(this.strm), 
                    this.mode = exports.NONE, this.dictionary = null);
                }, Zlib.prototype.write = function(flush, input, in_off, in_len, out, out_off, out_len) {
                    return this._write(!0, flush, input, in_off, in_len, out, out_off, out_len);
                }, Zlib.prototype.writeSync = function(flush, input, in_off, in_len, out, out_off, out_len) {
                    return this._write(!1, flush, input, in_off, in_len, out, out_off, out_len);
                }, Zlib.prototype._write = function(async, flush, input, in_off, in_len, out, out_off, out_len) {
                    if (assert.equal(arguments.length, 8), assert(this.init_done, "write before init"), 
                    assert(this.mode !== exports.NONE, "already finalized"), assert.equal(!1, this.write_in_progress, "write already in progress"), 
                    assert.equal(!1, this.pending_close, "close is pending"), this.write_in_progress = !0, 
                    assert.equal(!1, void 0 === flush, "must provide flush value"), this.write_in_progress = !0, 
                    flush !== exports.Z_NO_FLUSH && flush !== exports.Z_PARTIAL_FLUSH && flush !== exports.Z_SYNC_FLUSH && flush !== exports.Z_FULL_FLUSH && flush !== exports.Z_FINISH && flush !== exports.Z_BLOCK) throw new Error("Invalid flush value");
                    if (null == input && (input = Buffer.alloc(0), in_len = 0, in_off = 0), this.strm.avail_in = in_len, 
                    this.strm.input = input, this.strm.next_in = in_off, this.strm.avail_out = out_len, 
                    this.strm.output = out, this.strm.next_out = out_off, this.flush = flush, !async) return this._process(), 
                    this._checkError() ? this._afterSync() : void 0;
                    var self = this;
                    return process.nextTick((function() {
                        self._process(), self._after();
                    })), this;
                }, Zlib.prototype._afterSync = function() {
                    var avail_out = this.strm.avail_out, avail_in = this.strm.avail_in;
                    return this.write_in_progress = !1, [ avail_in, avail_out ];
                }, Zlib.prototype._process = function() {
                    var next_expected_header_byte = null;
                    switch (this.mode) {
                      case exports.DEFLATE:
                      case exports.GZIP:
                      case exports.DEFLATERAW:
                        this.err = zlib_deflate.deflate(this.strm, this.flush);
                        break;

                      case exports.UNZIP:
                        switch (this.strm.avail_in > 0 && (next_expected_header_byte = this.strm.next_in), 
                        this.gzip_id_bytes_read) {
                          case 0:
                            if (null === next_expected_header_byte) break;
                            if (31 !== this.strm.input[next_expected_header_byte]) {
                                this.mode = exports.INFLATE;
                                break;
                            }
                            if (this.gzip_id_bytes_read = 1, next_expected_header_byte++, 1 === this.strm.avail_in) break;

                          case 1:
                            if (null === next_expected_header_byte) break;
                            139 === this.strm.input[next_expected_header_byte] ? (this.gzip_id_bytes_read = 2, 
                            this.mode = exports.GUNZIP) : this.mode = exports.INFLATE;
                            break;

                          default:
                            throw new Error("invalid number of gzip magic number bytes read");
                        }

                      case exports.INFLATE:
                      case exports.GUNZIP:
                      case exports.INFLATERAW:
                        for (this.err = zlib_inflate.inflate(this.strm, this.flush), this.err === exports.Z_NEED_DICT && this.dictionary && (this.err = zlib_inflate.inflateSetDictionary(this.strm, this.dictionary), 
                        this.err === exports.Z_OK ? this.err = zlib_inflate.inflate(this.strm, this.flush) : this.err === exports.Z_DATA_ERROR && (this.err = exports.Z_NEED_DICT)); this.strm.avail_in > 0 && this.mode === exports.GUNZIP && this.err === exports.Z_STREAM_END && 0x00 !== this.strm.next_in[0]; ) this.reset(), 
                        this.err = zlib_inflate.inflate(this.strm, this.flush);
                        break;

                      default:
                        throw new Error("Unknown mode " + this.mode);
                    }
                }, Zlib.prototype._checkError = function() {
                    switch (this.err) {
                      case exports.Z_OK:
                      case exports.Z_BUF_ERROR:
                        if (0 !== this.strm.avail_out && this.flush === exports.Z_FINISH) return this._error("unexpected end of file"), 
                        !1;
                        break;

                      case exports.Z_STREAM_END:
                        break;

                      case exports.Z_NEED_DICT:
                        return null == this.dictionary ? this._error("Missing dictionary") : this._error("Bad dictionary"), 
                        !1;

                      default:
                        return this._error("Zlib error"), !1;
                    }
                    return !0;
                }, Zlib.prototype._after = function() {
                    if (this._checkError()) {
                        var avail_out = this.strm.avail_out, avail_in = this.strm.avail_in;
                        this.write_in_progress = !1, this.callback(avail_in, avail_out), this.pending_close && this.close();
                    }
                }, Zlib.prototype._error = function(message) {
                    this.strm.msg && (message = this.strm.msg), this.onerror(message, this.err), this.write_in_progress = !1, 
                    this.pending_close && this.close();
                }, Zlib.prototype.init = function(windowBits, level, memLevel, strategy, dictionary) {
                    assert(4 === arguments.length || 5 === arguments.length, "init(windowBits, level, memLevel, strategy, [dictionary])"), 
                    assert(windowBits >= 8 && windowBits <= 15, "invalid windowBits"), assert(level >= -1 && level <= 9, "invalid compression level"), 
                    assert(memLevel >= 1 && memLevel <= 9, "invalid memlevel"), assert(strategy === exports.Z_FILTERED || strategy === exports.Z_HUFFMAN_ONLY || strategy === exports.Z_RLE || strategy === exports.Z_FIXED || strategy === exports.Z_DEFAULT_STRATEGY, "invalid strategy"), 
                    this._init(level, windowBits, memLevel, strategy, dictionary), this._setDictionary();
                }, Zlib.prototype.params = function() {
                    throw new Error("deflateParams Not supported");
                }, Zlib.prototype.reset = function() {
                    this._reset(), this._setDictionary();
                }, Zlib.prototype._init = function(level, windowBits, memLevel, strategy, dictionary) {
                    switch (this.level = level, this.windowBits = windowBits, this.memLevel = memLevel, 
                    this.strategy = strategy, this.flush = exports.Z_NO_FLUSH, this.err = exports.Z_OK, 
                    this.mode !== exports.GZIP && this.mode !== exports.GUNZIP || (this.windowBits += 16), 
                    this.mode === exports.UNZIP && (this.windowBits += 32), this.mode !== exports.DEFLATERAW && this.mode !== exports.INFLATERAW || (this.windowBits = -1 * this.windowBits), 
                    this.strm = new Zstream, this.mode) {
                      case exports.DEFLATE:
                      case exports.GZIP:
                      case exports.DEFLATERAW:
                        this.err = zlib_deflate.deflateInit2(this.strm, this.level, exports.Z_DEFLATED, this.windowBits, this.memLevel, this.strategy);
                        break;

                      case exports.INFLATE:
                      case exports.GUNZIP:
                      case exports.INFLATERAW:
                      case exports.UNZIP:
                        this.err = zlib_inflate.inflateInit2(this.strm, this.windowBits);
                        break;

                      default:
                        throw new Error("Unknown mode " + this.mode);
                    }
                    this.err !== exports.Z_OK && this._error("Init error"), this.dictionary = dictionary, 
                    this.write_in_progress = !1, this.init_done = !0;
                }, Zlib.prototype._setDictionary = function() {
                    if (null != this.dictionary) {
                        switch (this.err = exports.Z_OK, this.mode) {
                          case exports.DEFLATE:
                          case exports.DEFLATERAW:
                            this.err = zlib_deflate.deflateSetDictionary(this.strm, this.dictionary);
                        }
                        this.err !== exports.Z_OK && this._error("Failed to set dictionary");
                    }
                }, Zlib.prototype._reset = function() {
                    switch (this.err = exports.Z_OK, this.mode) {
                      case exports.DEFLATE:
                      case exports.DEFLATERAW:
                      case exports.GZIP:
                        this.err = zlib_deflate.deflateReset(this.strm);
                        break;

                      case exports.INFLATE:
                      case exports.INFLATERAW:
                      case exports.GUNZIP:
                        this.err = zlib_inflate.inflateReset(this.strm);
                    }
                    this.err !== exports.Z_OK && this._error("Failed to reset stream");
                }, exports.Zlib = Zlib;
            }).call(this, require("_process"), require("buffer").Buffer);
        }, {
            _process: 133,
            assert: 25,
            buffer: 48,
            "pako/lib/zlib/constants": 38,
            "pako/lib/zlib/deflate.js": 40,
            "pako/lib/zlib/inflate.js": 42,
            "pako/lib/zlib/zstream": 46
        } ],
        35: [ function(require, module, exports) {
            (function(process) {
                var Buffer = require("buffer").Buffer, Transform = require("stream").Transform, binding = require("./binding"), util = require("util"), assert = require("assert").ok, kMaxLength = require("buffer").kMaxLength, kRangeErrorMessage = "Cannot create final Buffer. It would be larger than 0x" + kMaxLength.toString(16) + " bytes";
                binding.Z_MIN_WINDOWBITS = 8, binding.Z_MAX_WINDOWBITS = 15, binding.Z_DEFAULT_WINDOWBITS = 15, 
                binding.Z_MIN_CHUNK = 64, binding.Z_MAX_CHUNK = 1 / 0, binding.Z_DEFAULT_CHUNK = 16384, 
                binding.Z_MIN_MEMLEVEL = 1, binding.Z_MAX_MEMLEVEL = 9, binding.Z_DEFAULT_MEMLEVEL = 8, 
                binding.Z_MIN_LEVEL = -1, binding.Z_MAX_LEVEL = 9, binding.Z_DEFAULT_LEVEL = binding.Z_DEFAULT_COMPRESSION;
                for (var bkeys = Object.keys(binding), bk = 0; bk < bkeys.length; bk++) {
                    var bkey = bkeys[bk];
                    bkey.match(/^Z/) && Object.defineProperty(exports, bkey, {
                        enumerable: !0,
                        value: binding[bkey],
                        writable: !1
                    });
                }
                for (var codes = {
                    Z_OK: binding.Z_OK,
                    Z_STREAM_END: binding.Z_STREAM_END,
                    Z_NEED_DICT: binding.Z_NEED_DICT,
                    Z_ERRNO: binding.Z_ERRNO,
                    Z_STREAM_ERROR: binding.Z_STREAM_ERROR,
                    Z_DATA_ERROR: binding.Z_DATA_ERROR,
                    Z_MEM_ERROR: binding.Z_MEM_ERROR,
                    Z_BUF_ERROR: binding.Z_BUF_ERROR,
                    Z_VERSION_ERROR: binding.Z_VERSION_ERROR
                }, ckeys = Object.keys(codes), ck = 0; ck < ckeys.length; ck++) {
                    var ckey = ckeys[ck];
                    codes[codes[ckey]] = ckey;
                }
                function zlibBuffer(engine, buffer, callback) {
                    var buffers = [], nread = 0;
                    function flow() {
                        for (var chunk; null !== (chunk = engine.read()); ) buffers.push(chunk), nread += chunk.length;
                        engine.once("readable", flow);
                    }
                    function onEnd() {
                        var buf, err = null;
                        nread >= kMaxLength ? err = new RangeError(kRangeErrorMessage) : buf = Buffer.concat(buffers, nread), 
                        buffers = [], engine.close(), callback(err, buf);
                    }
                    engine.on("error", (function onError(err) {
                        engine.removeListener("end", onEnd), engine.removeListener("readable", flow), callback(err);
                    })), engine.on("end", onEnd), engine.end(buffer), flow();
                }
                function zlibBufferSync(engine, buffer) {
                    if ("string" == typeof buffer && (buffer = Buffer.from(buffer)), !Buffer.isBuffer(buffer)) throw new TypeError("Not a string or buffer");
                    var flushFlag = engine._finishFlushFlag;
                    return engine._processChunk(buffer, flushFlag);
                }
                function Deflate(opts) {
                    if (!(this instanceof Deflate)) return new Deflate(opts);
                    Zlib.call(this, opts, binding.DEFLATE);
                }
                function Inflate(opts) {
                    if (!(this instanceof Inflate)) return new Inflate(opts);
                    Zlib.call(this, opts, binding.INFLATE);
                }
                function Gzip(opts) {
                    if (!(this instanceof Gzip)) return new Gzip(opts);
                    Zlib.call(this, opts, binding.GZIP);
                }
                function Gunzip(opts) {
                    if (!(this instanceof Gunzip)) return new Gunzip(opts);
                    Zlib.call(this, opts, binding.GUNZIP);
                }
                function DeflateRaw(opts) {
                    if (!(this instanceof DeflateRaw)) return new DeflateRaw(opts);
                    Zlib.call(this, opts, binding.DEFLATERAW);
                }
                function InflateRaw(opts) {
                    if (!(this instanceof InflateRaw)) return new InflateRaw(opts);
                    Zlib.call(this, opts, binding.INFLATERAW);
                }
                function Unzip(opts) {
                    if (!(this instanceof Unzip)) return new Unzip(opts);
                    Zlib.call(this, opts, binding.UNZIP);
                }
                function isValidFlushFlag(flag) {
                    return flag === binding.Z_NO_FLUSH || flag === binding.Z_PARTIAL_FLUSH || flag === binding.Z_SYNC_FLUSH || flag === binding.Z_FULL_FLUSH || flag === binding.Z_FINISH || flag === binding.Z_BLOCK;
                }
                function Zlib(opts, mode) {
                    var _this = this;
                    if (this._opts = opts = opts || {}, this._chunkSize = opts.chunkSize || exports.Z_DEFAULT_CHUNK, 
                    Transform.call(this, opts), opts.flush && !isValidFlushFlag(opts.flush)) throw new Error("Invalid flush flag: " + opts.flush);
                    if (opts.finishFlush && !isValidFlushFlag(opts.finishFlush)) throw new Error("Invalid flush flag: " + opts.finishFlush);
                    if (this._flushFlag = opts.flush || binding.Z_NO_FLUSH, this._finishFlushFlag = void 0 !== opts.finishFlush ? opts.finishFlush : binding.Z_FINISH, 
                    opts.chunkSize && (opts.chunkSize < exports.Z_MIN_CHUNK || opts.chunkSize > exports.Z_MAX_CHUNK)) throw new Error("Invalid chunk size: " + opts.chunkSize);
                    if (opts.windowBits && (opts.windowBits < exports.Z_MIN_WINDOWBITS || opts.windowBits > exports.Z_MAX_WINDOWBITS)) throw new Error("Invalid windowBits: " + opts.windowBits);
                    if (opts.level && (opts.level < exports.Z_MIN_LEVEL || opts.level > exports.Z_MAX_LEVEL)) throw new Error("Invalid compression level: " + opts.level);
                    if (opts.memLevel && (opts.memLevel < exports.Z_MIN_MEMLEVEL || opts.memLevel > exports.Z_MAX_MEMLEVEL)) throw new Error("Invalid memLevel: " + opts.memLevel);
                    if (opts.strategy && opts.strategy != exports.Z_FILTERED && opts.strategy != exports.Z_HUFFMAN_ONLY && opts.strategy != exports.Z_RLE && opts.strategy != exports.Z_FIXED && opts.strategy != exports.Z_DEFAULT_STRATEGY) throw new Error("Invalid strategy: " + opts.strategy);
                    if (opts.dictionary && !Buffer.isBuffer(opts.dictionary)) throw new Error("Invalid dictionary: it should be a Buffer instance");
                    this._handle = new binding.Zlib(mode);
                    var self = this;
                    this._hadError = !1, this._handle.onerror = function(message, errno) {
                        _close(self), self._hadError = !0;
                        var error = new Error(message);
                        error.errno = errno, error.code = exports.codes[errno], self.emit("error", error);
                    };
                    var level = exports.Z_DEFAULT_COMPRESSION;
                    "number" == typeof opts.level && (level = opts.level);
                    var strategy = exports.Z_DEFAULT_STRATEGY;
                    "number" == typeof opts.strategy && (strategy = opts.strategy), this._handle.init(opts.windowBits || exports.Z_DEFAULT_WINDOWBITS, level, opts.memLevel || exports.Z_DEFAULT_MEMLEVEL, strategy, opts.dictionary), 
                    this._buffer = Buffer.allocUnsafe(this._chunkSize), this._offset = 0, this._level = level, 
                    this._strategy = strategy, this.once("end", this.close), Object.defineProperty(this, "_closed", {
                        get: function() {
                            return !_this._handle;
                        },
                        configurable: !0,
                        enumerable: !0
                    });
                }
                function _close(engine, callback) {
                    callback && process.nextTick(callback), engine._handle && (engine._handle.close(), 
                    engine._handle = null);
                }
                function emitCloseNT(self) {
                    self.emit("close");
                }
                Object.defineProperty(exports, "codes", {
                    enumerable: !0,
                    value: Object.freeze(codes),
                    writable: !1
                }), exports.Deflate = Deflate, exports.Inflate = Inflate, exports.Gzip = Gzip, exports.Gunzip = Gunzip, 
                exports.DeflateRaw = DeflateRaw, exports.InflateRaw = InflateRaw, exports.Unzip = Unzip, 
                exports.createDeflate = function(o) {
                    return new Deflate(o);
                }, exports.createInflate = function(o) {
                    return new Inflate(o);
                }, exports.createDeflateRaw = function(o) {
                    return new DeflateRaw(o);
                }, exports.createInflateRaw = function(o) {
                    return new InflateRaw(o);
                }, exports.createGzip = function(o) {
                    return new Gzip(o);
                }, exports.createGunzip = function(o) {
                    return new Gunzip(o);
                }, exports.createUnzip = function(o) {
                    return new Unzip(o);
                }, exports.deflate = function(buffer, opts, callback) {
                    return "function" == typeof opts && (callback = opts, opts = {}), zlibBuffer(new Deflate(opts), buffer, callback);
                }, exports.deflateSync = function(buffer, opts) {
                    return zlibBufferSync(new Deflate(opts), buffer);
                }, exports.gzip = function(buffer, opts, callback) {
                    return "function" == typeof opts && (callback = opts, opts = {}), zlibBuffer(new Gzip(opts), buffer, callback);
                }, exports.gzipSync = function(buffer, opts) {
                    return zlibBufferSync(new Gzip(opts), buffer);
                }, exports.deflateRaw = function(buffer, opts, callback) {
                    return "function" == typeof opts && (callback = opts, opts = {}), zlibBuffer(new DeflateRaw(opts), buffer, callback);
                }, exports.deflateRawSync = function(buffer, opts) {
                    return zlibBufferSync(new DeflateRaw(opts), buffer);
                }, exports.unzip = function(buffer, opts, callback) {
                    return "function" == typeof opts && (callback = opts, opts = {}), zlibBuffer(new Unzip(opts), buffer, callback);
                }, exports.unzipSync = function(buffer, opts) {
                    return zlibBufferSync(new Unzip(opts), buffer);
                }, exports.inflate = function(buffer, opts, callback) {
                    return "function" == typeof opts && (callback = opts, opts = {}), zlibBuffer(new Inflate(opts), buffer, callback);
                }, exports.inflateSync = function(buffer, opts) {
                    return zlibBufferSync(new Inflate(opts), buffer);
                }, exports.gunzip = function(buffer, opts, callback) {
                    return "function" == typeof opts && (callback = opts, opts = {}), zlibBuffer(new Gunzip(opts), buffer, callback);
                }, exports.gunzipSync = function(buffer, opts) {
                    return zlibBufferSync(new Gunzip(opts), buffer);
                }, exports.inflateRaw = function(buffer, opts, callback) {
                    return "function" == typeof opts && (callback = opts, opts = {}), zlibBuffer(new InflateRaw(opts), buffer, callback);
                }, exports.inflateRawSync = function(buffer, opts) {
                    return zlibBufferSync(new InflateRaw(opts), buffer);
                }, util.inherits(Zlib, Transform), Zlib.prototype.params = function(level, strategy, callback) {
                    if (level < exports.Z_MIN_LEVEL || level > exports.Z_MAX_LEVEL) throw new RangeError("Invalid compression level: " + level);
                    if (strategy != exports.Z_FILTERED && strategy != exports.Z_HUFFMAN_ONLY && strategy != exports.Z_RLE && strategy != exports.Z_FIXED && strategy != exports.Z_DEFAULT_STRATEGY) throw new TypeError("Invalid strategy: " + strategy);
                    if (this._level !== level || this._strategy !== strategy) {
                        var self = this;
                        this.flush(binding.Z_SYNC_FLUSH, (function() {
                            assert(self._handle, "zlib binding closed"), self._handle.params(level, strategy), 
                            self._hadError || (self._level = level, self._strategy = strategy, callback && callback());
                        }));
                    } else process.nextTick(callback);
                }, Zlib.prototype.reset = function() {
                    return assert(this._handle, "zlib binding closed"), this._handle.reset();
                }, Zlib.prototype._flush = function(callback) {
                    this._transform(Buffer.alloc(0), "", callback);
                }, Zlib.prototype.flush = function(kind, callback) {
                    var _this2 = this, ws = this._writableState;
                    ("function" == typeof kind || void 0 === kind && !callback) && (callback = kind, 
                    kind = binding.Z_FULL_FLUSH), ws.ended ? callback && process.nextTick(callback) : ws.ending ? callback && this.once("end", callback) : ws.needDrain ? callback && this.once("drain", (function() {
                        return _this2.flush(kind, callback);
                    })) : (this._flushFlag = kind, this.write(Buffer.alloc(0), "", callback));
                }, Zlib.prototype.close = function(callback) {
                    _close(this, callback), process.nextTick(emitCloseNT, this);
                }, Zlib.prototype._transform = function(chunk, encoding, cb) {
                    var flushFlag, ws = this._writableState, last = (ws.ending || ws.ended) && (!chunk || ws.length === chunk.length);
                    return null === chunk || Buffer.isBuffer(chunk) ? this._handle ? (last ? flushFlag = this._finishFlushFlag : (flushFlag = this._flushFlag, 
                    chunk.length >= ws.length && (this._flushFlag = this._opts.flush || binding.Z_NO_FLUSH)), 
                    void this._processChunk(chunk, flushFlag, cb)) : cb(new Error("zlib binding closed")) : cb(new Error("invalid input"));
                }, Zlib.prototype._processChunk = function(chunk, flushFlag, cb) {
                    var availInBefore = chunk && chunk.length, availOutBefore = this._chunkSize - this._offset, inOff = 0, self = this, async = "function" == typeof cb;
                    if (!async) {
                        var error, buffers = [], nread = 0;
                        this.on("error", (function(er) {
                            error = er;
                        })), assert(this._handle, "zlib binding closed");
                        do {
                            var res = this._handle.writeSync(flushFlag, chunk, inOff, availInBefore, this._buffer, this._offset, availOutBefore);
                        } while (!this._hadError && callback(res[0], res[1]));
                        if (this._hadError) throw error;
                        if (nread >= kMaxLength) throw _close(this), new RangeError(kRangeErrorMessage);
                        var buf = Buffer.concat(buffers, nread);
                        return _close(this), buf;
                    }
                    assert(this._handle, "zlib binding closed");
                    var req = this._handle.write(flushFlag, chunk, inOff, availInBefore, this._buffer, this._offset, availOutBefore);
                    function callback(availInAfter, availOutAfter) {
                        if (this && (this.buffer = null, this.callback = null), !self._hadError) {
                            var have = availOutBefore - availOutAfter;
                            if (assert(have >= 0, "have should not go down"), have > 0) {
                                var out = self._buffer.slice(self._offset, self._offset + have);
                                self._offset += have, async ? self.push(out) : (buffers.push(out), nread += out.length);
                            }
                            if ((0 === availOutAfter || self._offset >= self._chunkSize) && (availOutBefore = self._chunkSize, 
                            self._offset = 0, self._buffer = Buffer.allocUnsafe(self._chunkSize)), 0 === availOutAfter) {
                                if (inOff += availInBefore - availInAfter, availInBefore = availInAfter, !async) return !0;
                                var newReq = self._handle.write(flushFlag, chunk, inOff, availInBefore, self._buffer, self._offset, self._chunkSize);
                                return newReq.callback = callback, void (newReq.buffer = chunk);
                            }
                            if (!async) return !1;
                            cb();
                        }
                    }
                    req.buffer = chunk, req.callback = callback;
                }, util.inherits(Deflate, Zlib), util.inherits(Inflate, Zlib), util.inherits(Gzip, Zlib), 
                util.inherits(Gunzip, Zlib), util.inherits(DeflateRaw, Zlib), util.inherits(InflateRaw, Zlib), 
                util.inherits(Unzip, Zlib);
            }).call(this, require("_process"));
        }, {
            "./binding": 34,
            _process: 133,
            assert: 25,
            buffer: 48,
            stream: 155,
            util: 186
        } ],
        36: [ function(require, module, exports) {
            var TYPED_OK = "undefined" != typeof Uint8Array && "undefined" != typeof Uint16Array && "undefined" != typeof Int32Array;
            function _has(obj, key) {
                return Object.prototype.hasOwnProperty.call(obj, key);
            }
            exports.assign = function(obj) {
                for (var sources = Array.prototype.slice.call(arguments, 1); sources.length; ) {
                    var source = sources.shift();
                    if (source) {
                        if ("object" != typeof source) throw new TypeError(source + "must be non-object");
                        for (var p in source) _has(source, p) && (obj[p] = source[p]);
                    }
                }
                return obj;
            }, exports.shrinkBuf = function(buf, size) {
                return buf.length === size ? buf : buf.subarray ? buf.subarray(0, size) : (buf.length = size, 
                buf);
            };
            var fnTyped = {
                arraySet: function(dest, src, src_offs, len, dest_offs) {
                    if (src.subarray && dest.subarray) dest.set(src.subarray(src_offs, src_offs + len), dest_offs); else for (var i = 0; i < len; i++) dest[dest_offs + i] = src[src_offs + i];
                },
                flattenChunks: function(chunks) {
                    var i, l, len, pos, chunk, result;
                    for (len = 0, i = 0, l = chunks.length; i < l; i++) len += chunks[i].length;
                    for (result = new Uint8Array(len), pos = 0, i = 0, l = chunks.length; i < l; i++) chunk = chunks[i], 
                    result.set(chunk, pos), pos += chunk.length;
                    return result;
                }
            }, fnUntyped = {
                arraySet: function(dest, src, src_offs, len, dest_offs) {
                    for (var i = 0; i < len; i++) dest[dest_offs + i] = src[src_offs + i];
                },
                flattenChunks: function(chunks) {
                    return [].concat.apply([], chunks);
                }
            };
            exports.setTyped = function(on) {
                on ? (exports.Buf8 = Uint8Array, exports.Buf16 = Uint16Array, exports.Buf32 = Int32Array, 
                exports.assign(exports, fnTyped)) : (exports.Buf8 = Array, exports.Buf16 = Array, 
                exports.Buf32 = Array, exports.assign(exports, fnUntyped));
            }, exports.setTyped(TYPED_OK);
        }, {} ],
        37: [ function(require, module, exports) {
            module.exports = function adler32(adler, buf, len, pos) {
                for (var s1 = 0xffff & adler | 0, s2 = adler >>> 16 & 0xffff | 0, n = 0; 0 !== len; ) {
                    len -= n = len > 2000 ? 2000 : len;
                    do {
                        s2 = s2 + (s1 = s1 + buf[pos++] | 0) | 0;
                    } while (--n);
                    s1 %= 65521, s2 %= 65521;
                }
                return s1 | s2 << 16 | 0;
            };
        }, {} ],
        38: [ function(require, module, exports) {
            module.exports = {
                Z_NO_FLUSH: 0,
                Z_PARTIAL_FLUSH: 1,
                Z_SYNC_FLUSH: 2,
                Z_FULL_FLUSH: 3,
                Z_FINISH: 4,
                Z_BLOCK: 5,
                Z_TREES: 6,
                Z_OK: 0,
                Z_STREAM_END: 1,
                Z_NEED_DICT: 2,
                Z_ERRNO: -1,
                Z_STREAM_ERROR: -2,
                Z_DATA_ERROR: -3,
                Z_BUF_ERROR: -5,
                Z_NO_COMPRESSION: 0,
                Z_BEST_SPEED: 1,
                Z_BEST_COMPRESSION: 9,
                Z_DEFAULT_COMPRESSION: -1,
                Z_FILTERED: 1,
                Z_HUFFMAN_ONLY: 2,
                Z_RLE: 3,
                Z_FIXED: 4,
                Z_DEFAULT_STRATEGY: 0,
                Z_BINARY: 0,
                Z_TEXT: 1,
                Z_UNKNOWN: 2,
                Z_DEFLATED: 8
            };
        }, {} ],
        39: [ function(require, module, exports) {
            var crcTable = function makeTable() {
                for (var c, table = [], n = 0; n < 256; n++) {
                    c = n;
                    for (var k = 0; k < 8; k++) c = 1 & c ? 0xEDB88320 ^ c >>> 1 : c >>> 1;
                    table[n] = c;
                }
                return table;
            }();
            module.exports = function crc32(crc, buf, len, pos) {
                var t = crcTable, end = pos + len;
                crc ^= -1;
                for (var i = pos; i < end; i++) crc = crc >>> 8 ^ t[0xFF & (crc ^ buf[i])];
                return -1 ^ crc;
            };
        }, {} ],
        40: [ function(require, module, exports) {
            var configuration_table, utils = require("../utils/common"), trees = require("./trees"), adler32 = require("./adler32"), crc32 = require("./crc32"), msg = require("./messages");
            function err(strm, errorCode) {
                return strm.msg = msg[errorCode], errorCode;
            }
            function rank(f) {
                return (f << 1) - (f > 4 ? 9 : 0);
            }
            function zero(buf) {
                for (var len = buf.length; --len >= 0; ) buf[len] = 0;
            }
            function flush_pending(strm) {
                var s = strm.state, len = s.pending;
                len > strm.avail_out && (len = strm.avail_out), 0 !== len && (utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out), 
                strm.next_out += len, s.pending_out += len, strm.total_out += len, strm.avail_out -= len, 
                s.pending -= len, 0 === s.pending && (s.pending_out = 0));
            }
            function flush_block_only(s, last) {
                trees._tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last), 
                s.block_start = s.strstart, flush_pending(s.strm);
            }
            function put_byte(s, b) {
                s.pending_buf[s.pending++] = b;
            }
            function putShortMSB(s, b) {
                s.pending_buf[s.pending++] = b >>> 8 & 0xff, s.pending_buf[s.pending++] = 0xff & b;
            }
            function longest_match(s, cur_match) {
                var match, len, chain_length = s.max_chain_length, scan = s.strstart, best_len = s.prev_length, nice_match = s.nice_match, limit = s.strstart > s.w_size - 262 ? s.strstart - (s.w_size - 262) : 0, _win = s.window, wmask = s.w_mask, prev = s.prev, strend = s.strstart + 258, scan_end1 = _win[scan + best_len - 1], scan_end = _win[scan + best_len];
                s.prev_length >= s.good_match && (chain_length >>= 2), nice_match > s.lookahead && (nice_match = s.lookahead);
                do {
                    if (_win[(match = cur_match) + best_len] === scan_end && _win[match + best_len - 1] === scan_end1 && _win[match] === _win[scan] && _win[++match] === _win[scan + 1]) {
                        scan += 2, match++;
                        do {} while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
                        if (len = 258 - (strend - scan), scan = strend - 258, len > best_len) {
                            if (s.match_start = cur_match, best_len = len, len >= nice_match) break;
                            scan_end1 = _win[scan + best_len - 1], scan_end = _win[scan + best_len];
                        }
                    }
                } while ((cur_match = prev[cur_match & wmask]) > limit && 0 != --chain_length);
                return best_len <= s.lookahead ? best_len : s.lookahead;
            }
            function fill_window(s) {
                var p, n, m, more, str, strm, buf, start, size, len, _w_size = s.w_size;
                do {
                    if (more = s.window_size - s.lookahead - s.strstart, s.strstart >= _w_size + (_w_size - 262)) {
                        utils.arraySet(s.window, s.window, _w_size, _w_size, 0), s.match_start -= _w_size, 
                        s.strstart -= _w_size, s.block_start -= _w_size, p = n = s.hash_size;
                        do {
                            m = s.head[--p], s.head[p] = m >= _w_size ? m - _w_size : 0;
                        } while (--n);
                        p = n = _w_size;
                        do {
                            m = s.prev[--p], s.prev[p] = m >= _w_size ? m - _w_size : 0;
                        } while (--n);
                        more += _w_size;
                    }
                    if (0 === s.strm.avail_in) break;
                    if (strm = s.strm, buf = s.window, start = s.strstart + s.lookahead, size = more, 
                    len = void 0, (len = strm.avail_in) > size && (len = size), n = 0 === len ? 0 : (strm.avail_in -= len, 
                    utils.arraySet(buf, strm.input, strm.next_in, len, start), 1 === strm.state.wrap ? strm.adler = adler32(strm.adler, buf, len, start) : 2 === strm.state.wrap && (strm.adler = crc32(strm.adler, buf, len, start)), 
                    strm.next_in += len, strm.total_in += len, len), s.lookahead += n, s.lookahead + s.insert >= 3) for (str = s.strstart - s.insert, 
                    s.ins_h = s.window[str], s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + 1]) & s.hash_mask; s.insert && (s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + 3 - 1]) & s.hash_mask, 
                    s.prev[str & s.w_mask] = s.head[s.ins_h], s.head[s.ins_h] = str, str++, s.insert--, 
                    !(s.lookahead + s.insert < 3)); ) ;
                } while (s.lookahead < 262 && 0 !== s.strm.avail_in);
            }
            function deflate_fast(s, flush) {
                for (var hash_head, bflush; ;) {
                    if (s.lookahead < 262) {
                        if (fill_window(s), s.lookahead < 262 && 0 === flush) return 1;
                        if (0 === s.lookahead) break;
                    }
                    if (hash_head = 0, s.lookahead >= 3 && (s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + 3 - 1]) & s.hash_mask, 
                    hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h], s.head[s.ins_h] = s.strstart), 
                    0 !== hash_head && s.strstart - hash_head <= s.w_size - 262 && (s.match_length = longest_match(s, hash_head)), 
                    s.match_length >= 3) if (bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - 3), 
                    s.lookahead -= s.match_length, s.match_length <= s.max_lazy_match && s.lookahead >= 3) {
                        s.match_length--;
                        do {
                            s.strstart++, s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + 3 - 1]) & s.hash_mask, 
                            hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h], s.head[s.ins_h] = s.strstart;
                        } while (0 != --s.match_length);
                        s.strstart++;
                    } else s.strstart += s.match_length, s.match_length = 0, s.ins_h = s.window[s.strstart], 
                    s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + 1]) & s.hash_mask; else bflush = trees._tr_tally(s, 0, s.window[s.strstart]), 
                    s.lookahead--, s.strstart++;
                    if (bflush && (flush_block_only(s, !1), 0 === s.strm.avail_out)) return 1;
                }
                return s.insert = s.strstart < 2 ? s.strstart : 2, 4 === flush ? (flush_block_only(s, !0), 
                0 === s.strm.avail_out ? 3 : 4) : s.last_lit && (flush_block_only(s, !1), 0 === s.strm.avail_out) ? 1 : 2;
            }
            function deflate_slow(s, flush) {
                for (var hash_head, bflush, max_insert; ;) {
                    if (s.lookahead < 262) {
                        if (fill_window(s), s.lookahead < 262 && 0 === flush) return 1;
                        if (0 === s.lookahead) break;
                    }
                    if (hash_head = 0, s.lookahead >= 3 && (s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + 3 - 1]) & s.hash_mask, 
                    hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h], s.head[s.ins_h] = s.strstart), 
                    s.prev_length = s.match_length, s.prev_match = s.match_start, s.match_length = 2, 
                    0 !== hash_head && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - 262 && (s.match_length = longest_match(s, hash_head), 
                    s.match_length <= 5 && (1 === s.strategy || 3 === s.match_length && s.strstart - s.match_start > 4096) && (s.match_length = 2)), 
                    s.prev_length >= 3 && s.match_length <= s.prev_length) {
                        max_insert = s.strstart + s.lookahead - 3, bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - 3), 
                        s.lookahead -= s.prev_length - 1, s.prev_length -= 2;
                        do {
                            ++s.strstart <= max_insert && (s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + 3 - 1]) & s.hash_mask, 
                            hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h], s.head[s.ins_h] = s.strstart);
                        } while (0 != --s.prev_length);
                        if (s.match_available = 0, s.match_length = 2, s.strstart++, bflush && (flush_block_only(s, !1), 
                        0 === s.strm.avail_out)) return 1;
                    } else if (s.match_available) {
                        if ((bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1])) && flush_block_only(s, !1), 
                        s.strstart++, s.lookahead--, 0 === s.strm.avail_out) return 1;
                    } else s.match_available = 1, s.strstart++, s.lookahead--;
                }
                return s.match_available && (bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]), 
                s.match_available = 0), s.insert = s.strstart < 2 ? s.strstart : 2, 4 === flush ? (flush_block_only(s, !0), 
                0 === s.strm.avail_out ? 3 : 4) : s.last_lit && (flush_block_only(s, !1), 0 === s.strm.avail_out) ? 1 : 2;
            }
            function Config(good_length, max_lazy, nice_length, max_chain, func) {
                this.good_length = good_length, this.max_lazy = max_lazy, this.nice_length = nice_length, 
                this.max_chain = max_chain, this.func = func;
            }
            function DeflateState() {
                this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, 
                this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, 
                this.method = 8, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, 
                this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, 
                this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, 
                this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, 
                this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, 
                this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, 
                this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new utils.Buf16(1146), 
                this.dyn_dtree = new utils.Buf16(122), this.bl_tree = new utils.Buf16(78), zero(this.dyn_ltree), 
                zero(this.dyn_dtree), zero(this.bl_tree), this.l_desc = null, this.d_desc = null, 
                this.bl_desc = null, this.bl_count = new utils.Buf16(16), this.heap = new utils.Buf16(573), 
                zero(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new utils.Buf16(573), 
                zero(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, 
                this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, 
                this.bi_valid = 0;
            }
            function deflateResetKeep(strm) {
                var s;
                return strm && strm.state ? (strm.total_in = strm.total_out = 0, strm.data_type = 2, 
                (s = strm.state).pending = 0, s.pending_out = 0, s.wrap < 0 && (s.wrap = -s.wrap), 
                s.status = s.wrap ? 42 : 113, strm.adler = 2 === s.wrap ? 0 : 1, s.last_flush = 0, 
                trees._tr_init(s), 0) : err(strm, -2);
            }
            function deflateReset(strm) {
                var ret = deflateResetKeep(strm);
                return 0 === ret && function lm_init(s) {
                    s.window_size = 2 * s.w_size, zero(s.head), s.max_lazy_match = configuration_table[s.level].max_lazy, 
                    s.good_match = configuration_table[s.level].good_length, s.nice_match = configuration_table[s.level].nice_length, 
                    s.max_chain_length = configuration_table[s.level].max_chain, s.strstart = 0, s.block_start = 0, 
                    s.lookahead = 0, s.insert = 0, s.match_length = s.prev_length = 2, s.match_available = 0, 
                    s.ins_h = 0;
                }(strm.state), ret;
            }
            function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
                if (!strm) return -2;
                var wrap = 1;
                if (-1 === level && (level = 6), windowBits < 0 ? (wrap = 0, windowBits = -windowBits) : windowBits > 15 && (wrap = 2, 
                windowBits -= 16), memLevel < 1 || memLevel > 9 || 8 !== method || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > 4) return err(strm, -2);
                8 === windowBits && (windowBits = 9);
                var s = new DeflateState;
                return strm.state = s, s.strm = strm, s.wrap = wrap, s.gzhead = null, s.w_bits = windowBits, 
                s.w_size = 1 << s.w_bits, s.w_mask = s.w_size - 1, s.hash_bits = memLevel + 7, s.hash_size = 1 << s.hash_bits, 
                s.hash_mask = s.hash_size - 1, s.hash_shift = ~~((s.hash_bits + 3 - 1) / 3), s.window = new utils.Buf8(2 * s.w_size), 
                s.head = new utils.Buf16(s.hash_size), s.prev = new utils.Buf16(s.w_size), s.lit_bufsize = 1 << memLevel + 6, 
                s.pending_buf_size = 4 * s.lit_bufsize, s.pending_buf = new utils.Buf8(s.pending_buf_size), 
                s.d_buf = 1 * s.lit_bufsize, s.l_buf = 3 * s.lit_bufsize, s.level = level, s.strategy = strategy, 
                s.method = method, deflateReset(strm);
            }
            configuration_table = [ new Config(0, 0, 0, 0, (function deflate_stored(s, flush) {
                var max_block_size = 0xffff;
                for (max_block_size > s.pending_buf_size - 5 && (max_block_size = s.pending_buf_size - 5); ;) {
                    if (s.lookahead <= 1) {
                        if (fill_window(s), 0 === s.lookahead && 0 === flush) return 1;
                        if (0 === s.lookahead) break;
                    }
                    s.strstart += s.lookahead, s.lookahead = 0;
                    var max_start = s.block_start + max_block_size;
                    if ((0 === s.strstart || s.strstart >= max_start) && (s.lookahead = s.strstart - max_start, 
                    s.strstart = max_start, flush_block_only(s, !1), 0 === s.strm.avail_out)) return 1;
                    if (s.strstart - s.block_start >= s.w_size - 262 && (flush_block_only(s, !1), 0 === s.strm.avail_out)) return 1;
                }
                return s.insert = 0, 4 === flush ? (flush_block_only(s, !0), 0 === s.strm.avail_out ? 3 : 4) : (s.strstart > s.block_start && (flush_block_only(s, !1), 
                s.strm.avail_out), 1);
            })), new Config(4, 4, 8, 4, deflate_fast), new Config(4, 5, 16, 8, deflate_fast), new Config(4, 6, 32, 32, deflate_fast), new Config(4, 4, 16, 16, deflate_slow), new Config(8, 16, 32, 32, deflate_slow), new Config(8, 16, 128, 128, deflate_slow), new Config(8, 32, 128, 256, deflate_slow), new Config(32, 128, 258, 1024, deflate_slow), new Config(32, 258, 258, 4096, deflate_slow) ], 
            exports.deflateInit = function deflateInit(strm, level) {
                return deflateInit2(strm, level, 8, 15, 8, 0);
            }, exports.deflateInit2 = deflateInit2, exports.deflateReset = deflateReset, exports.deflateResetKeep = deflateResetKeep, 
            exports.deflateSetHeader = function deflateSetHeader(strm, head) {
                return strm && strm.state ? 2 !== strm.state.wrap ? -2 : (strm.state.gzhead = head, 
                0) : -2;
            }, exports.deflate = function deflate(strm, flush) {
                var old_flush, s, beg, val;
                if (!strm || !strm.state || flush > 5 || flush < 0) return strm ? err(strm, -2) : -2;
                if (s = strm.state, !strm.output || !strm.input && 0 !== strm.avail_in || 666 === s.status && 4 !== flush) return err(strm, 0 === strm.avail_out ? -5 : -2);
                if (s.strm = strm, old_flush = s.last_flush, s.last_flush = flush, 42 === s.status) if (2 === s.wrap) strm.adler = 0, 
                put_byte(s, 31), put_byte(s, 139), put_byte(s, 8), s.gzhead ? (put_byte(s, (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (s.gzhead.extra ? 4 : 0) + (s.gzhead.name ? 8 : 0) + (s.gzhead.comment ? 16 : 0)), 
                put_byte(s, 0xff & s.gzhead.time), put_byte(s, s.gzhead.time >> 8 & 0xff), put_byte(s, s.gzhead.time >> 16 & 0xff), 
                put_byte(s, s.gzhead.time >> 24 & 0xff), put_byte(s, 9 === s.level ? 2 : s.strategy >= 2 || s.level < 2 ? 4 : 0), 
                put_byte(s, 0xff & s.gzhead.os), s.gzhead.extra && s.gzhead.extra.length && (put_byte(s, 0xff & s.gzhead.extra.length), 
                put_byte(s, s.gzhead.extra.length >> 8 & 0xff)), s.gzhead.hcrc && (strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0)), 
                s.gzindex = 0, s.status = 69) : (put_byte(s, 0), put_byte(s, 0), put_byte(s, 0), 
                put_byte(s, 0), put_byte(s, 0), put_byte(s, 9 === s.level ? 2 : s.strategy >= 2 || s.level < 2 ? 4 : 0), 
                put_byte(s, 3), s.status = 113); else {
                    var header = 8 + (s.w_bits - 8 << 4) << 8;
                    header |= (s.strategy >= 2 || s.level < 2 ? 0 : s.level < 6 ? 1 : 6 === s.level ? 2 : 3) << 6, 
                    0 !== s.strstart && (header |= 32), header += 31 - header % 31, s.status = 113, 
                    putShortMSB(s, header), 0 !== s.strstart && (putShortMSB(s, strm.adler >>> 16), 
                    putShortMSB(s, 0xffff & strm.adler)), strm.adler = 1;
                }
                if (69 === s.status) if (s.gzhead.extra) {
                    for (beg = s.pending; s.gzindex < (0xffff & s.gzhead.extra.length) && (s.pending !== s.pending_buf_size || (s.gzhead.hcrc && s.pending > beg && (strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg)), 
                    flush_pending(strm), beg = s.pending, s.pending !== s.pending_buf_size)); ) put_byte(s, 0xff & s.gzhead.extra[s.gzindex]), 
                    s.gzindex++;
                    s.gzhead.hcrc && s.pending > beg && (strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg)), 
                    s.gzindex === s.gzhead.extra.length && (s.gzindex = 0, s.status = 73);
                } else s.status = 73;
                if (73 === s.status) if (s.gzhead.name) {
                    beg = s.pending;
                    do {
                        if (s.pending === s.pending_buf_size && (s.gzhead.hcrc && s.pending > beg && (strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg)), 
                        flush_pending(strm), beg = s.pending, s.pending === s.pending_buf_size)) {
                            val = 1;
                            break;
                        }
                        val = s.gzindex < s.gzhead.name.length ? 0xff & s.gzhead.name.charCodeAt(s.gzindex++) : 0, 
                        put_byte(s, val);
                    } while (0 !== val);
                    s.gzhead.hcrc && s.pending > beg && (strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg)), 
                    0 === val && (s.gzindex = 0, s.status = 91);
                } else s.status = 91;
                if (91 === s.status) if (s.gzhead.comment) {
                    beg = s.pending;
                    do {
                        if (s.pending === s.pending_buf_size && (s.gzhead.hcrc && s.pending > beg && (strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg)), 
                        flush_pending(strm), beg = s.pending, s.pending === s.pending_buf_size)) {
                            val = 1;
                            break;
                        }
                        val = s.gzindex < s.gzhead.comment.length ? 0xff & s.gzhead.comment.charCodeAt(s.gzindex++) : 0, 
                        put_byte(s, val);
                    } while (0 !== val);
                    s.gzhead.hcrc && s.pending > beg && (strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg)), 
                    0 === val && (s.status = 103);
                } else s.status = 103;
                if (103 === s.status && (s.gzhead.hcrc ? (s.pending + 2 > s.pending_buf_size && flush_pending(strm), 
                s.pending + 2 <= s.pending_buf_size && (put_byte(s, 0xff & strm.adler), put_byte(s, strm.adler >> 8 & 0xff), 
                strm.adler = 0, s.status = 113)) : s.status = 113), 0 !== s.pending) {
                    if (flush_pending(strm), 0 === strm.avail_out) return s.last_flush = -1, 0;
                } else if (0 === strm.avail_in && rank(flush) <= rank(old_flush) && 4 !== flush) return err(strm, -5);
                if (666 === s.status && 0 !== strm.avail_in) return err(strm, -5);
                if (0 !== strm.avail_in || 0 !== s.lookahead || 0 !== flush && 666 !== s.status) {
                    var bstate = 2 === s.strategy ? function deflate_huff(s, flush) {
                        for (var bflush; ;) {
                            if (0 === s.lookahead && (fill_window(s), 0 === s.lookahead)) {
                                if (0 === flush) return 1;
                                break;
                            }
                            if (s.match_length = 0, bflush = trees._tr_tally(s, 0, s.window[s.strstart]), s.lookahead--, 
                            s.strstart++, bflush && (flush_block_only(s, !1), 0 === s.strm.avail_out)) return 1;
                        }
                        return s.insert = 0, 4 === flush ? (flush_block_only(s, !0), 0 === s.strm.avail_out ? 3 : 4) : s.last_lit && (flush_block_only(s, !1), 
                        0 === s.strm.avail_out) ? 1 : 2;
                    }(s, flush) : 3 === s.strategy ? function deflate_rle(s, flush) {
                        for (var bflush, prev, scan, strend, _win = s.window; ;) {
                            if (s.lookahead <= 258) {
                                if (fill_window(s), s.lookahead <= 258 && 0 === flush) return 1;
                                if (0 === s.lookahead) break;
                            }
                            if (s.match_length = 0, s.lookahead >= 3 && s.strstart > 0 && (prev = _win[scan = s.strstart - 1]) === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
                                strend = s.strstart + 258;
                                do {} while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
                                s.match_length = 258 - (strend - scan), s.match_length > s.lookahead && (s.match_length = s.lookahead);
                            }
                            if (s.match_length >= 3 ? (bflush = trees._tr_tally(s, 1, s.match_length - 3), s.lookahead -= s.match_length, 
                            s.strstart += s.match_length, s.match_length = 0) : (bflush = trees._tr_tally(s, 0, s.window[s.strstart]), 
                            s.lookahead--, s.strstart++), bflush && (flush_block_only(s, !1), 0 === s.strm.avail_out)) return 1;
                        }
                        return s.insert = 0, 4 === flush ? (flush_block_only(s, !0), 0 === s.strm.avail_out ? 3 : 4) : s.last_lit && (flush_block_only(s, !1), 
                        0 === s.strm.avail_out) ? 1 : 2;
                    }(s, flush) : configuration_table[s.level].func(s, flush);
                    if (3 !== bstate && 4 !== bstate || (s.status = 666), 1 === bstate || 3 === bstate) return 0 === strm.avail_out && (s.last_flush = -1), 
                    0;
                    if (2 === bstate && (1 === flush ? trees._tr_align(s) : 5 !== flush && (trees._tr_stored_block(s, 0, 0, !1), 
                    3 === flush && (zero(s.head), 0 === s.lookahead && (s.strstart = 0, s.block_start = 0, 
                    s.insert = 0))), flush_pending(strm), 0 === strm.avail_out)) return s.last_flush = -1, 
                    0;
                }
                return 4 !== flush ? 0 : s.wrap <= 0 ? 1 : (2 === s.wrap ? (put_byte(s, 0xff & strm.adler), 
                put_byte(s, strm.adler >> 8 & 0xff), put_byte(s, strm.adler >> 16 & 0xff), put_byte(s, strm.adler >> 24 & 0xff), 
                put_byte(s, 0xff & strm.total_in), put_byte(s, strm.total_in >> 8 & 0xff), put_byte(s, strm.total_in >> 16 & 0xff), 
                put_byte(s, strm.total_in >> 24 & 0xff)) : (putShortMSB(s, strm.adler >>> 16), putShortMSB(s, 0xffff & strm.adler)), 
                flush_pending(strm), s.wrap > 0 && (s.wrap = -s.wrap), 0 !== s.pending ? 0 : 1);
            }, exports.deflateEnd = function deflateEnd(strm) {
                var status;
                return strm && strm.state ? 42 !== (status = strm.state.status) && 69 !== status && 73 !== status && 91 !== status && 103 !== status && 113 !== status && 666 !== status ? err(strm, -2) : (strm.state = null, 
                113 === status ? err(strm, -3) : 0) : -2;
            }, exports.deflateSetDictionary = function deflateSetDictionary(strm, dictionary) {
                var s, str, n, wrap, avail, next, input, tmpDict, dictLength = dictionary.length;
                if (!strm || !strm.state) return -2;
                if (2 === (wrap = (s = strm.state).wrap) || 1 === wrap && 42 !== s.status || s.lookahead) return -2;
                for (1 === wrap && (strm.adler = adler32(strm.adler, dictionary, dictLength, 0)), 
                s.wrap = 0, dictLength >= s.w_size && (0 === wrap && (zero(s.head), s.strstart = 0, 
                s.block_start = 0, s.insert = 0), tmpDict = new utils.Buf8(s.w_size), utils.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0), 
                dictionary = tmpDict, dictLength = s.w_size), avail = strm.avail_in, next = strm.next_in, 
                input = strm.input, strm.avail_in = dictLength, strm.next_in = 0, strm.input = dictionary, 
                fill_window(s); s.lookahead >= 3; ) {
                    str = s.strstart, n = s.lookahead - 2;
                    do {
                        s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + 3 - 1]) & s.hash_mask, s.prev[str & s.w_mask] = s.head[s.ins_h], 
                        s.head[s.ins_h] = str, str++;
                    } while (--n);
                    s.strstart = str, s.lookahead = 2, fill_window(s);
                }
                return s.strstart += s.lookahead, s.block_start = s.strstart, s.insert = s.lookahead, 
                s.lookahead = 0, s.match_length = s.prev_length = 2, s.match_available = 0, strm.next_in = next, 
                strm.input = input, strm.avail_in = avail, s.wrap = wrap, 0;
            }, exports.deflateInfo = "pako deflate (from Nodeca project)";
        }, {
            "../utils/common": 36,
            "./adler32": 37,
            "./crc32": 39,
            "./messages": 44,
            "./trees": 45
        } ],
        41: [ function(require, module, exports) {
            module.exports = function inflate_fast(strm, start) {
                var state, _in, last, _out, beg, end, dmax, wsize, whave, wnext, s_window, hold, bits, lcode, dcode, lmask, dmask, here, op, len, dist, from, from_source, input, output;
                state = strm.state, _in = strm.next_in, input = strm.input, last = _in + (strm.avail_in - 5), 
                _out = strm.next_out, output = strm.output, beg = _out - (start - strm.avail_out), 
                end = _out + (strm.avail_out - 257), dmax = state.dmax, wsize = state.wsize, whave = state.whave, 
                wnext = state.wnext, s_window = state.window, hold = state.hold, bits = state.bits, 
                lcode = state.lencode, dcode = state.distcode, lmask = (1 << state.lenbits) - 1, 
                dmask = (1 << state.distbits) - 1;
                top: do {
                    bits < 15 && (hold += input[_in++] << bits, bits += 8, hold += input[_in++] << bits, 
                    bits += 8), here = lcode[hold & lmask];
                    dolen: for (;;) {
                        if (hold >>>= op = here >>> 24, bits -= op, 0 == (op = here >>> 16 & 0xff)) output[_out++] = 0xffff & here; else {
                            if (!(16 & op)) {
                                if (0 == (64 & op)) {
                                    here = lcode[(0xffff & here) + (hold & (1 << op) - 1)];
                                    continue dolen;
                                }
                                if (32 & op) {
                                    state.mode = 12;
                                    break top;
                                }
                                strm.msg = "invalid literal/length code", state.mode = 30;
                                break top;
                            }
                            len = 0xffff & here, (op &= 15) && (bits < op && (hold += input[_in++] << bits, 
                            bits += 8), len += hold & (1 << op) - 1, hold >>>= op, bits -= op), bits < 15 && (hold += input[_in++] << bits, 
                            bits += 8, hold += input[_in++] << bits, bits += 8), here = dcode[hold & dmask];
                            dodist: for (;;) {
                                if (hold >>>= op = here >>> 24, bits -= op, !(16 & (op = here >>> 16 & 0xff))) {
                                    if (0 == (64 & op)) {
                                        here = dcode[(0xffff & here) + (hold & (1 << op) - 1)];
                                        continue dodist;
                                    }
                                    strm.msg = "invalid distance code", state.mode = 30;
                                    break top;
                                }
                                if (dist = 0xffff & here, bits < (op &= 15) && (hold += input[_in++] << bits, (bits += 8) < op && (hold += input[_in++] << bits, 
                                bits += 8)), (dist += hold & (1 << op) - 1) > dmax) {
                                    strm.msg = "invalid distance too far back", state.mode = 30;
                                    break top;
                                }
                                if (hold >>>= op, bits -= op, dist > (op = _out - beg)) {
                                    if ((op = dist - op) > whave && state.sane) {
                                        strm.msg = "invalid distance too far back", state.mode = 30;
                                        break top;
                                    }
                                    if (from = 0, from_source = s_window, 0 === wnext) {
                                        if (from += wsize - op, op < len) {
                                            len -= op;
                                            do {
                                                output[_out++] = s_window[from++];
                                            } while (--op);
                                            from = _out - dist, from_source = output;
                                        }
                                    } else if (wnext < op) {
                                        if (from += wsize + wnext - op, (op -= wnext) < len) {
                                            len -= op;
                                            do {
                                                output[_out++] = s_window[from++];
                                            } while (--op);
                                            if (from = 0, wnext < len) {
                                                len -= op = wnext;
                                                do {
                                                    output[_out++] = s_window[from++];
                                                } while (--op);
                                                from = _out - dist, from_source = output;
                                            }
                                        }
                                    } else if (from += wnext - op, op < len) {
                                        len -= op;
                                        do {
                                            output[_out++] = s_window[from++];
                                        } while (--op);
                                        from = _out - dist, from_source = output;
                                    }
                                    for (;len > 2; ) output[_out++] = from_source[from++], output[_out++] = from_source[from++], 
                                    output[_out++] = from_source[from++], len -= 3;
                                    len && (output[_out++] = from_source[from++], len > 1 && (output[_out++] = from_source[from++]));
                                } else {
                                    from = _out - dist;
                                    do {
                                        output[_out++] = output[from++], output[_out++] = output[from++], output[_out++] = output[from++], 
                                        len -= 3;
                                    } while (len > 2);
                                    len && (output[_out++] = output[from++], len > 1 && (output[_out++] = output[from++]));
                                }
                                break;
                            }
                        }
                        break;
                    }
                } while (_in < last && _out < end);
                _in -= len = bits >> 3, hold &= (1 << (bits -= len << 3)) - 1, strm.next_in = _in, 
                strm.next_out = _out, strm.avail_in = _in < last ? last - _in + 5 : 5 - (_in - last), 
                strm.avail_out = _out < end ? end - _out + 257 : 257 - (_out - end), state.hold = hold, 
                state.bits = bits;
            };
        }, {} ],
        42: [ function(require, module, exports) {
            var utils = require("../utils/common"), adler32 = require("./adler32"), crc32 = require("./crc32"), inflate_fast = require("./inffast"), inflate_table = require("./inftrees");
            function zswap32(q) {
                return (q >>> 24 & 0xff) + (q >>> 8 & 0xff00) + ((0xff00 & q) << 8) + ((0xff & q) << 24);
            }
            function InflateState() {
                this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.flags = 0, 
                this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, 
                this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, 
                this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, 
                this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, 
                this.ndist = 0, this.have = 0, this.next = null, this.lens = new utils.Buf16(320), 
                this.work = new utils.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, 
                this.back = 0, this.was = 0;
            }
            function inflateResetKeep(strm) {
                var state;
                return strm && strm.state ? (state = strm.state, strm.total_in = strm.total_out = state.total = 0, 
                strm.msg = "", state.wrap && (strm.adler = 1 & state.wrap), state.mode = 1, state.last = 0, 
                state.havedict = 0, state.dmax = 32768, state.head = null, state.hold = 0, state.bits = 0, 
                state.lencode = state.lendyn = new utils.Buf32(852), state.distcode = state.distdyn = new utils.Buf32(592), 
                state.sane = 1, state.back = -1, 0) : -2;
            }
            function inflateReset(strm) {
                var state;
                return strm && strm.state ? ((state = strm.state).wsize = 0, state.whave = 0, state.wnext = 0, 
                inflateResetKeep(strm)) : -2;
            }
            function inflateReset2(strm, windowBits) {
                var wrap, state;
                return strm && strm.state ? (state = strm.state, windowBits < 0 ? (wrap = 0, windowBits = -windowBits) : (wrap = 1 + (windowBits >> 4), 
                windowBits < 48 && (windowBits &= 15)), windowBits && (windowBits < 8 || windowBits > 15) ? -2 : (null !== state.window && state.wbits !== windowBits && (state.window = null), 
                state.wrap = wrap, state.wbits = windowBits, inflateReset(strm))) : -2;
            }
            function inflateInit2(strm, windowBits) {
                var ret, state;
                return strm ? (state = new InflateState, strm.state = state, state.window = null, 
                0 !== (ret = inflateReset2(strm, windowBits)) && (strm.state = null), ret) : -2;
            }
            var lenfix, distfix, virgin = !0;
            function fixedtables(state) {
                if (virgin) {
                    var sym;
                    for (lenfix = new utils.Buf32(512), distfix = new utils.Buf32(32), sym = 0; sym < 144; ) state.lens[sym++] = 8;
                    for (;sym < 256; ) state.lens[sym++] = 9;
                    for (;sym < 280; ) state.lens[sym++] = 7;
                    for (;sym < 288; ) state.lens[sym++] = 8;
                    for (inflate_table(1, state.lens, 0, 288, lenfix, 0, state.work, {
                        bits: 9
                    }), sym = 0; sym < 32; ) state.lens[sym++] = 5;
                    inflate_table(2, state.lens, 0, 32, distfix, 0, state.work, {
                        bits: 5
                    }), virgin = !1;
                }
                state.lencode = lenfix, state.lenbits = 9, state.distcode = distfix, state.distbits = 5;
            }
            function updatewindow(strm, src, end, copy) {
                var dist, state = strm.state;
                return null === state.window && (state.wsize = 1 << state.wbits, state.wnext = 0, 
                state.whave = 0, state.window = new utils.Buf8(state.wsize)), copy >= state.wsize ? (utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0), 
                state.wnext = 0, state.whave = state.wsize) : ((dist = state.wsize - state.wnext) > copy && (dist = copy), 
                utils.arraySet(state.window, src, end - copy, dist, state.wnext), (copy -= dist) ? (utils.arraySet(state.window, src, end - copy, copy, 0), 
                state.wnext = copy, state.whave = state.wsize) : (state.wnext += dist, state.wnext === state.wsize && (state.wnext = 0), 
                state.whave < state.wsize && (state.whave += dist))), 0;
            }
            exports.inflateReset = inflateReset, exports.inflateReset2 = inflateReset2, exports.inflateResetKeep = inflateResetKeep, 
            exports.inflateInit = function inflateInit(strm) {
                return inflateInit2(strm, 15);
            }, exports.inflateInit2 = inflateInit2, exports.inflate = function inflate(strm, flush) {
                var state, input, output, next, put, have, left, hold, bits, _in, _out, copy, from, from_source, here_bits, here_op, here_val, last_bits, last_op, last_val, len, ret, opts, n, here = 0, hbuf = new utils.Buf8(4), order = [ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ];
                if (!strm || !strm.state || !strm.output || !strm.input && 0 !== strm.avail_in) return -2;
                12 === (state = strm.state).mode && (state.mode = 13), put = strm.next_out, output = strm.output, 
                left = strm.avail_out, next = strm.next_in, input = strm.input, have = strm.avail_in, 
                hold = state.hold, bits = state.bits, _in = have, _out = left, ret = 0;
                inf_leave: for (;;) switch (state.mode) {
                  case 1:
                    if (0 === state.wrap) {
                        state.mode = 13;
                        break;
                    }
                    for (;bits < 16; ) {
                        if (0 === have) break inf_leave;
                        have--, hold += input[next++] << bits, bits += 8;
                    }
                    if (2 & state.wrap && 0x8b1f === hold) {
                        state.check = 0, hbuf[0] = 0xff & hold, hbuf[1] = hold >>> 8 & 0xff, state.check = crc32(state.check, hbuf, 2, 0), 
                        hold = 0, bits = 0, state.mode = 2;
                        break;
                    }
                    if (state.flags = 0, state.head && (state.head.done = !1), !(1 & state.wrap) || (((0xff & hold) << 8) + (hold >> 8)) % 31) {
                        strm.msg = "incorrect header check", state.mode = 30;
                        break;
                    }
                    if (8 != (0x0f & hold)) {
                        strm.msg = "unknown compression method", state.mode = 30;
                        break;
                    }
                    if (bits -= 4, len = 8 + (0x0f & (hold >>>= 4)), 0 === state.wbits) state.wbits = len; else if (len > state.wbits) {
                        strm.msg = "invalid window size", state.mode = 30;
                        break;
                    }
                    state.dmax = 1 << len, strm.adler = state.check = 1, state.mode = 0x200 & hold ? 10 : 12, 
                    hold = 0, bits = 0;
                    break;

                  case 2:
                    for (;bits < 16; ) {
                        if (0 === have) break inf_leave;
                        have--, hold += input[next++] << bits, bits += 8;
                    }
                    if (state.flags = hold, 8 != (0xff & state.flags)) {
                        strm.msg = "unknown compression method", state.mode = 30;
                        break;
                    }
                    if (0xe000 & state.flags) {
                        strm.msg = "unknown header flags set", state.mode = 30;
                        break;
                    }
                    state.head && (state.head.text = hold >> 8 & 1), 0x0200 & state.flags && (hbuf[0] = 0xff & hold, 
                    hbuf[1] = hold >>> 8 & 0xff, state.check = crc32(state.check, hbuf, 2, 0)), hold = 0, 
                    bits = 0, state.mode = 3;

                  case 3:
                    for (;bits < 32; ) {
                        if (0 === have) break inf_leave;
                        have--, hold += input[next++] << bits, bits += 8;
                    }
                    state.head && (state.head.time = hold), 0x0200 & state.flags && (hbuf[0] = 0xff & hold, 
                    hbuf[1] = hold >>> 8 & 0xff, hbuf[2] = hold >>> 16 & 0xff, hbuf[3] = hold >>> 24 & 0xff, 
                    state.check = crc32(state.check, hbuf, 4, 0)), hold = 0, bits = 0, state.mode = 4;

                  case 4:
                    for (;bits < 16; ) {
                        if (0 === have) break inf_leave;
                        have--, hold += input[next++] << bits, bits += 8;
                    }
                    state.head && (state.head.xflags = 0xff & hold, state.head.os = hold >> 8), 0x0200 & state.flags && (hbuf[0] = 0xff & hold, 
                    hbuf[1] = hold >>> 8 & 0xff, state.check = crc32(state.check, hbuf, 2, 0)), hold = 0, 
                    bits = 0, state.mode = 5;

                  case 5:
                    if (0x0400 & state.flags) {
                        for (;bits < 16; ) {
                            if (0 === have) break inf_leave;
                            have--, hold += input[next++] << bits, bits += 8;
                        }
                        state.length = hold, state.head && (state.head.extra_len = hold), 0x0200 & state.flags && (hbuf[0] = 0xff & hold, 
                        hbuf[1] = hold >>> 8 & 0xff, state.check = crc32(state.check, hbuf, 2, 0)), hold = 0, 
                        bits = 0;
                    } else state.head && (state.head.extra = null);
                    state.mode = 6;

                  case 6:
                    if (0x0400 & state.flags && ((copy = state.length) > have && (copy = have), copy && (state.head && (len = state.head.extra_len - state.length, 
                    state.head.extra || (state.head.extra = new Array(state.head.extra_len)), utils.arraySet(state.head.extra, input, next, copy, len)), 
                    0x0200 & state.flags && (state.check = crc32(state.check, input, copy, next)), have -= copy, 
                    next += copy, state.length -= copy), state.length)) break inf_leave;
                    state.length = 0, state.mode = 7;

                  case 7:
                    if (0x0800 & state.flags) {
                        if (0 === have) break inf_leave;
                        copy = 0;
                        do {
                            len = input[next + copy++], state.head && len && state.length < 65536 && (state.head.name += String.fromCharCode(len));
                        } while (len && copy < have);
                        if (0x0200 & state.flags && (state.check = crc32(state.check, input, copy, next)), 
                        have -= copy, next += copy, len) break inf_leave;
                    } else state.head && (state.head.name = null);
                    state.length = 0, state.mode = 8;

                  case 8:
                    if (0x1000 & state.flags) {
                        if (0 === have) break inf_leave;
                        copy = 0;
                        do {
                            len = input[next + copy++], state.head && len && state.length < 65536 && (state.head.comment += String.fromCharCode(len));
                        } while (len && copy < have);
                        if (0x0200 & state.flags && (state.check = crc32(state.check, input, copy, next)), 
                        have -= copy, next += copy, len) break inf_leave;
                    } else state.head && (state.head.comment = null);
                    state.mode = 9;

                  case 9:
                    if (0x0200 & state.flags) {
                        for (;bits < 16; ) {
                            if (0 === have) break inf_leave;
                            have--, hold += input[next++] << bits, bits += 8;
                        }
                        if (hold !== (0xffff & state.check)) {
                            strm.msg = "header crc mismatch", state.mode = 30;
                            break;
                        }
                        hold = 0, bits = 0;
                    }
                    state.head && (state.head.hcrc = state.flags >> 9 & 1, state.head.done = !0), strm.adler = state.check = 0, 
                    state.mode = 12;
                    break;

                  case 10:
                    for (;bits < 32; ) {
                        if (0 === have) break inf_leave;
                        have--, hold += input[next++] << bits, bits += 8;
                    }
                    strm.adler = state.check = zswap32(hold), hold = 0, bits = 0, state.mode = 11;

                  case 11:
                    if (0 === state.havedict) return strm.next_out = put, strm.avail_out = left, strm.next_in = next, 
                    strm.avail_in = have, state.hold = hold, state.bits = bits, 2;
                    strm.adler = state.check = 1, state.mode = 12;

                  case 12:
                    if (5 === flush || 6 === flush) break inf_leave;

                  case 13:
                    if (state.last) {
                        hold >>>= 7 & bits, bits -= 7 & bits, state.mode = 27;
                        break;
                    }
                    for (;bits < 3; ) {
                        if (0 === have) break inf_leave;
                        have--, hold += input[next++] << bits, bits += 8;
                    }
                    switch (state.last = 0x01 & hold, bits -= 1, 0x03 & (hold >>>= 1)) {
                      case 0:
                        state.mode = 14;
                        break;

                      case 1:
                        if (fixedtables(state), state.mode = 20, 6 === flush) {
                            hold >>>= 2, bits -= 2;
                            break inf_leave;
                        }
                        break;

                      case 2:
                        state.mode = 17;
                        break;

                      case 3:
                        strm.msg = "invalid block type", state.mode = 30;
                    }
                    hold >>>= 2, bits -= 2;
                    break;

                  case 14:
                    for (hold >>>= 7 & bits, bits -= 7 & bits; bits < 32; ) {
                        if (0 === have) break inf_leave;
                        have--, hold += input[next++] << bits, bits += 8;
                    }
                    if ((0xffff & hold) != (hold >>> 16 ^ 0xffff)) {
                        strm.msg = "invalid stored block lengths", state.mode = 30;
                        break;
                    }
                    if (state.length = 0xffff & hold, hold = 0, bits = 0, state.mode = 15, 6 === flush) break inf_leave;

                  case 15:
                    state.mode = 16;

                  case 16:
                    if (copy = state.length) {
                        if (copy > have && (copy = have), copy > left && (copy = left), 0 === copy) break inf_leave;
                        utils.arraySet(output, input, next, copy, put), have -= copy, next += copy, left -= copy, 
                        put += copy, state.length -= copy;
                        break;
                    }
                    state.mode = 12;
                    break;

                  case 17:
                    for (;bits < 14; ) {
                        if (0 === have) break inf_leave;
                        have--, hold += input[next++] << bits, bits += 8;
                    }
                    if (state.nlen = 257 + (0x1f & hold), hold >>>= 5, bits -= 5, state.ndist = 1 + (0x1f & hold), 
                    hold >>>= 5, bits -= 5, state.ncode = 4 + (0x0f & hold), hold >>>= 4, bits -= 4, 
                    state.nlen > 286 || state.ndist > 30) {
                        strm.msg = "too many length or distance symbols", state.mode = 30;
                        break;
                    }
                    state.have = 0, state.mode = 18;

                  case 18:
                    for (;state.have < state.ncode; ) {
                        for (;bits < 3; ) {
                            if (0 === have) break inf_leave;
                            have--, hold += input[next++] << bits, bits += 8;
                        }
                        state.lens[order[state.have++]] = 0x07 & hold, hold >>>= 3, bits -= 3;
                    }
                    for (;state.have < 19; ) state.lens[order[state.have++]] = 0;
                    if (state.lencode = state.lendyn, state.lenbits = 7, opts = {
                        bits: state.lenbits
                    }, ret = inflate_table(0, state.lens, 0, 19, state.lencode, 0, state.work, opts), 
                    state.lenbits = opts.bits, ret) {
                        strm.msg = "invalid code lengths set", state.mode = 30;
                        break;
                    }
                    state.have = 0, state.mode = 19;

                  case 19:
                    for (;state.have < state.nlen + state.ndist; ) {
                        for (;here_op = (here = state.lencode[hold & (1 << state.lenbits) - 1]) >>> 16 & 0xff, 
                        here_val = 0xffff & here, !((here_bits = here >>> 24) <= bits); ) {
                            if (0 === have) break inf_leave;
                            have--, hold += input[next++] << bits, bits += 8;
                        }
                        if (here_val < 16) hold >>>= here_bits, bits -= here_bits, state.lens[state.have++] = here_val; else {
                            if (16 === here_val) {
                                for (n = here_bits + 2; bits < n; ) {
                                    if (0 === have) break inf_leave;
                                    have--, hold += input[next++] << bits, bits += 8;
                                }
                                if (hold >>>= here_bits, bits -= here_bits, 0 === state.have) {
                                    strm.msg = "invalid bit length repeat", state.mode = 30;
                                    break;
                                }
                                len = state.lens[state.have - 1], copy = 3 + (0x03 & hold), hold >>>= 2, bits -= 2;
                            } else if (17 === here_val) {
                                for (n = here_bits + 3; bits < n; ) {
                                    if (0 === have) break inf_leave;
                                    have--, hold += input[next++] << bits, bits += 8;
                                }
                                bits -= here_bits, len = 0, copy = 3 + (0x07 & (hold >>>= here_bits)), hold >>>= 3, 
                                bits -= 3;
                            } else {
                                for (n = here_bits + 7; bits < n; ) {
                                    if (0 === have) break inf_leave;
                                    have--, hold += input[next++] << bits, bits += 8;
                                }
                                bits -= here_bits, len = 0, copy = 11 + (0x7f & (hold >>>= here_bits)), hold >>>= 7, 
                                bits -= 7;
                            }
                            if (state.have + copy > state.nlen + state.ndist) {
                                strm.msg = "invalid bit length repeat", state.mode = 30;
                                break;
                            }
                            for (;copy--; ) state.lens[state.have++] = len;
                        }
                    }
                    if (30 === state.mode) break;
                    if (0 === state.lens[256]) {
                        strm.msg = "invalid code -- missing end-of-block", state.mode = 30;
                        break;
                    }
                    if (state.lenbits = 9, opts = {
                        bits: state.lenbits
                    }, ret = inflate_table(1, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts), 
                    state.lenbits = opts.bits, ret) {
                        strm.msg = "invalid literal/lengths set", state.mode = 30;
                        break;
                    }
                    if (state.distbits = 6, state.distcode = state.distdyn, opts = {
                        bits: state.distbits
                    }, ret = inflate_table(2, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts), 
                    state.distbits = opts.bits, ret) {
                        strm.msg = "invalid distances set", state.mode = 30;
                        break;
                    }
                    if (state.mode = 20, 6 === flush) break inf_leave;

                  case 20:
                    state.mode = 21;

                  case 21:
                    if (have >= 6 && left >= 258) {
                        strm.next_out = put, strm.avail_out = left, strm.next_in = next, strm.avail_in = have, 
                        state.hold = hold, state.bits = bits, inflate_fast(strm, _out), put = strm.next_out, 
                        output = strm.output, left = strm.avail_out, next = strm.next_in, input = strm.input, 
                        have = strm.avail_in, hold = state.hold, bits = state.bits, 12 === state.mode && (state.back = -1);
                        break;
                    }
                    for (state.back = 0; here_op = (here = state.lencode[hold & (1 << state.lenbits) - 1]) >>> 16 & 0xff, 
                    here_val = 0xffff & here, !((here_bits = here >>> 24) <= bits); ) {
                        if (0 === have) break inf_leave;
                        have--, hold += input[next++] << bits, bits += 8;
                    }
                    if (here_op && 0 == (0xf0 & here_op)) {
                        for (last_bits = here_bits, last_op = here_op, last_val = here_val; here_op = (here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)]) >>> 16 & 0xff, 
                        here_val = 0xffff & here, !(last_bits + (here_bits = here >>> 24) <= bits); ) {
                            if (0 === have) break inf_leave;
                            have--, hold += input[next++] << bits, bits += 8;
                        }
                        hold >>>= last_bits, bits -= last_bits, state.back += last_bits;
                    }
                    if (hold >>>= here_bits, bits -= here_bits, state.back += here_bits, state.length = here_val, 
                    0 === here_op) {
                        state.mode = 26;
                        break;
                    }
                    if (32 & here_op) {
                        state.back = -1, state.mode = 12;
                        break;
                    }
                    if (64 & here_op) {
                        strm.msg = "invalid literal/length code", state.mode = 30;
                        break;
                    }
                    state.extra = 15 & here_op, state.mode = 22;

                  case 22:
                    if (state.extra) {
                        for (n = state.extra; bits < n; ) {
                            if (0 === have) break inf_leave;
                            have--, hold += input[next++] << bits, bits += 8;
                        }
                        state.length += hold & (1 << state.extra) - 1, hold >>>= state.extra, bits -= state.extra, 
                        state.back += state.extra;
                    }
                    state.was = state.length, state.mode = 23;

                  case 23:
                    for (;here_op = (here = state.distcode[hold & (1 << state.distbits) - 1]) >>> 16 & 0xff, 
                    here_val = 0xffff & here, !((here_bits = here >>> 24) <= bits); ) {
                        if (0 === have) break inf_leave;
                        have--, hold += input[next++] << bits, bits += 8;
                    }
                    if (0 == (0xf0 & here_op)) {
                        for (last_bits = here_bits, last_op = here_op, last_val = here_val; here_op = (here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)]) >>> 16 & 0xff, 
                        here_val = 0xffff & here, !(last_bits + (here_bits = here >>> 24) <= bits); ) {
                            if (0 === have) break inf_leave;
                            have--, hold += input[next++] << bits, bits += 8;
                        }
                        hold >>>= last_bits, bits -= last_bits, state.back += last_bits;
                    }
                    if (hold >>>= here_bits, bits -= here_bits, state.back += here_bits, 64 & here_op) {
                        strm.msg = "invalid distance code", state.mode = 30;
                        break;
                    }
                    state.offset = here_val, state.extra = 15 & here_op, state.mode = 24;

                  case 24:
                    if (state.extra) {
                        for (n = state.extra; bits < n; ) {
                            if (0 === have) break inf_leave;
                            have--, hold += input[next++] << bits, bits += 8;
                        }
                        state.offset += hold & (1 << state.extra) - 1, hold >>>= state.extra, bits -= state.extra, 
                        state.back += state.extra;
                    }
                    if (state.offset > state.dmax) {
                        strm.msg = "invalid distance too far back", state.mode = 30;
                        break;
                    }
                    state.mode = 25;

                  case 25:
                    if (0 === left) break inf_leave;
                    if (copy = _out - left, state.offset > copy) {
                        if ((copy = state.offset - copy) > state.whave && state.sane) {
                            strm.msg = "invalid distance too far back", state.mode = 30;
                            break;
                        }
                        copy > state.wnext ? (copy -= state.wnext, from = state.wsize - copy) : from = state.wnext - copy, 
                        copy > state.length && (copy = state.length), from_source = state.window;
                    } else from_source = output, from = put - state.offset, copy = state.length;
                    copy > left && (copy = left), left -= copy, state.length -= copy;
                    do {
                        output[put++] = from_source[from++];
                    } while (--copy);
                    0 === state.length && (state.mode = 21);
                    break;

                  case 26:
                    if (0 === left) break inf_leave;
                    output[put++] = state.length, left--, state.mode = 21;
                    break;

                  case 27:
                    if (state.wrap) {
                        for (;bits < 32; ) {
                            if (0 === have) break inf_leave;
                            have--, hold |= input[next++] << bits, bits += 8;
                        }
                        if (_out -= left, strm.total_out += _out, state.total += _out, _out && (strm.adler = state.check = state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out)), 
                        _out = left, (state.flags ? hold : zswap32(hold)) !== state.check) {
                            strm.msg = "incorrect data check", state.mode = 30;
                            break;
                        }
                        hold = 0, bits = 0;
                    }
                    state.mode = 28;

                  case 28:
                    if (state.wrap && state.flags) {
                        for (;bits < 32; ) {
                            if (0 === have) break inf_leave;
                            have--, hold += input[next++] << bits, bits += 8;
                        }
                        if (hold !== (0xffffffff & state.total)) {
                            strm.msg = "incorrect length check", state.mode = 30;
                            break;
                        }
                        hold = 0, bits = 0;
                    }
                    state.mode = 29;

                  case 29:
                    ret = 1;
                    break inf_leave;

                  case 30:
                    ret = -3;
                    break inf_leave;

                  case 31:
                    return -4;

                  default:
                    return -2;
                }
                return strm.next_out = put, strm.avail_out = left, strm.next_in = next, strm.avail_in = have, 
                state.hold = hold, state.bits = bits, (state.wsize || _out !== strm.avail_out && state.mode < 30 && (state.mode < 27 || 4 !== flush)) && updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out), 
                _in -= strm.avail_in, _out -= strm.avail_out, strm.total_in += _in, strm.total_out += _out, 
                state.total += _out, state.wrap && _out && (strm.adler = state.check = state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out)), 
                strm.data_type = state.bits + (state.last ? 64 : 0) + (12 === state.mode ? 128 : 0) + (20 === state.mode || 15 === state.mode ? 256 : 0), 
                (0 === _in && 0 === _out || 4 === flush) && 0 === ret && (ret = -5), ret;
            }, exports.inflateEnd = function inflateEnd(strm) {
                if (!strm || !strm.state) return -2;
                var state = strm.state;
                return state.window && (state.window = null), strm.state = null, 0;
            }, exports.inflateGetHeader = function inflateGetHeader(strm, head) {
                var state;
                return strm && strm.state ? 0 == (2 & (state = strm.state).wrap) ? -2 : (state.head = head, 
                head.done = !1, 0) : -2;
            }, exports.inflateSetDictionary = function inflateSetDictionary(strm, dictionary) {
                var state, dictLength = dictionary.length;
                return strm && strm.state ? 0 !== (state = strm.state).wrap && 11 !== state.mode ? -2 : 11 === state.mode && adler32(1, dictionary, dictLength, 0) !== state.check ? -3 : updatewindow(strm, dictionary, dictLength, dictLength) ? (state.mode = 31, 
                -4) : (state.havedict = 1, 0) : -2;
            }, exports.inflateInfo = "pako inflate (from Nodeca project)";
        }, {
            "../utils/common": 36,
            "./adler32": 37,
            "./crc32": 39,
            "./inffast": 41,
            "./inftrees": 43
        } ],
        43: [ function(require, module, exports) {
            var utils = require("../utils/common"), lbase = [ 3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0 ], lext = [ 16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78 ], dbase = [ 1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0 ], dext = [ 16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64 ];
            module.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts) {
                var incr, fill, low, mask, next, end, here_bits, here_op, here_val, bits = opts.bits, len = 0, sym = 0, min = 0, max = 0, root = 0, curr = 0, drop = 0, left = 0, used = 0, huff = 0, base = null, base_index = 0, count = new utils.Buf16(16), offs = new utils.Buf16(16), extra = null, extra_index = 0;
                for (len = 0; len <= 15; len++) count[len] = 0;
                for (sym = 0; sym < codes; sym++) count[lens[lens_index + sym]]++;
                for (root = bits, max = 15; max >= 1 && 0 === count[max]; max--) ;
                if (root > max && (root = max), 0 === max) return table[table_index++] = 20971520, 
                table[table_index++] = 20971520, opts.bits = 1, 0;
                for (min = 1; min < max && 0 === count[min]; min++) ;
                for (root < min && (root = min), left = 1, len = 1; len <= 15; len++) if (left <<= 1, 
                (left -= count[len]) < 0) return -1;
                if (left > 0 && (0 === type || 1 !== max)) return -1;
                for (offs[1] = 0, len = 1; len < 15; len++) offs[len + 1] = offs[len] + count[len];
                for (sym = 0; sym < codes; sym++) 0 !== lens[lens_index + sym] && (work[offs[lens[lens_index + sym]]++] = sym);
                if (0 === type ? (base = extra = work, end = 19) : 1 === type ? (base = lbase, base_index -= 257, 
                extra = lext, extra_index -= 257, end = 256) : (base = dbase, extra = dext, end = -1), 
                huff = 0, sym = 0, len = min, next = table_index, curr = root, drop = 0, low = -1, 
                mask = (used = 1 << root) - 1, 1 === type && used > 852 || 2 === type && used > 592) return 1;
                for (;;) {
                    here_bits = len - drop, work[sym] < end ? (here_op = 0, here_val = work[sym]) : work[sym] > end ? (here_op = extra[extra_index + work[sym]], 
                    here_val = base[base_index + work[sym]]) : (here_op = 96, here_val = 0), incr = 1 << len - drop, 
                    min = fill = 1 << curr;
                    do {
                        table[next + (huff >> drop) + (fill -= incr)] = here_bits << 24 | here_op << 16 | here_val | 0;
                    } while (0 !== fill);
                    for (incr = 1 << len - 1; huff & incr; ) incr >>= 1;
                    if (0 !== incr ? (huff &= incr - 1, huff += incr) : huff = 0, sym++, 0 == --count[len]) {
                        if (len === max) break;
                        len = lens[lens_index + work[sym]];
                    }
                    if (len > root && (huff & mask) !== low) {
                        for (0 === drop && (drop = root), next += min, left = 1 << (curr = len - drop); curr + drop < max && !((left -= count[curr + drop]) <= 0); ) curr++, 
                        left <<= 1;
                        if (used += 1 << curr, 1 === type && used > 852 || 2 === type && used > 592) return 1;
                        table[low = huff & mask] = root << 24 | curr << 16 | next - table_index | 0;
                    }
                }
                return 0 !== huff && (table[next + huff] = len - drop << 24 | 64 << 16 | 0), opts.bits = root, 
                0;
            };
        }, {
            "../utils/common": 36
        } ],
        44: [ function(require, module, exports) {
            module.exports = {
                2: "need dictionary",
                1: "stream end",
                0: "",
                "-1": "file error",
                "-2": "stream error",
                "-3": "data error",
                "-4": "insufficient memory",
                "-5": "buffer error",
                "-6": "incompatible version"
            };
        }, {} ],
        45: [ function(require, module, exports) {
            var utils = require("../utils/common");
            function zero(buf) {
                for (var len = buf.length; --len >= 0; ) buf[len] = 0;
            }
            var extra_lbits = [ 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0 ], extra_dbits = [ 0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13 ], extra_blbits = [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7 ], bl_order = [ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ], static_ltree = new Array(576);
            zero(static_ltree);
            var static_dtree = new Array(60);
            zero(static_dtree);
            var _dist_code = new Array(512);
            zero(_dist_code);
            var _length_code = new Array(256);
            zero(_length_code);
            var base_length = new Array(29);
            zero(base_length);
            var static_l_desc, static_d_desc, static_bl_desc, base_dist = new Array(30);
            function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
                this.static_tree = static_tree, this.extra_bits = extra_bits, this.extra_base = extra_base, 
                this.elems = elems, this.max_length = max_length, this.has_stree = static_tree && static_tree.length;
            }
            function TreeDesc(dyn_tree, stat_desc) {
                this.dyn_tree = dyn_tree, this.max_code = 0, this.stat_desc = stat_desc;
            }
            function d_code(dist) {
                return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
            }
            function put_short(s, w) {
                s.pending_buf[s.pending++] = 0xff & w, s.pending_buf[s.pending++] = w >>> 8 & 0xff;
            }
            function send_bits(s, value, length) {
                s.bi_valid > 16 - length ? (s.bi_buf |= value << s.bi_valid & 0xffff, put_short(s, s.bi_buf), 
                s.bi_buf = value >> 16 - s.bi_valid, s.bi_valid += length - 16) : (s.bi_buf |= value << s.bi_valid & 0xffff, 
                s.bi_valid += length);
            }
            function send_code(s, c, tree) {
                send_bits(s, tree[2 * c], tree[2 * c + 1]);
            }
            function bi_reverse(code, len) {
                var res = 0;
                do {
                    res |= 1 & code, code >>>= 1, res <<= 1;
                } while (--len > 0);
                return res >>> 1;
            }
            function gen_codes(tree, max_code, bl_count) {
                var bits, n, next_code = new Array(16), code = 0;
                for (bits = 1; bits <= 15; bits++) next_code[bits] = code = code + bl_count[bits - 1] << 1;
                for (n = 0; n <= max_code; n++) {
                    var len = tree[2 * n + 1];
                    0 !== len && (tree[2 * n] = bi_reverse(next_code[len]++, len));
                }
            }
            function init_block(s) {
                var n;
                for (n = 0; n < 286; n++) s.dyn_ltree[2 * n] = 0;
                for (n = 0; n < 30; n++) s.dyn_dtree[2 * n] = 0;
                for (n = 0; n < 19; n++) s.bl_tree[2 * n] = 0;
                s.dyn_ltree[512] = 1, s.opt_len = s.static_len = 0, s.last_lit = s.matches = 0;
            }
            function bi_windup(s) {
                s.bi_valid > 8 ? put_short(s, s.bi_buf) : s.bi_valid > 0 && (s.pending_buf[s.pending++] = s.bi_buf), 
                s.bi_buf = 0, s.bi_valid = 0;
            }
            function smaller(tree, n, m, depth) {
                var _n2 = 2 * n, _m2 = 2 * m;
                return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n] <= depth[m];
            }
            function pqdownheap(s, tree, k) {
                for (var v = s.heap[k], j = k << 1; j <= s.heap_len && (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth) && j++, 
                !smaller(tree, v, s.heap[j], s.depth)); ) s.heap[k] = s.heap[j], k = j, j <<= 1;
                s.heap[k] = v;
            }
            function compress_block(s, ltree, dtree) {
                var dist, lc, code, extra, lx = 0;
                if (0 !== s.last_lit) do {
                    dist = s.pending_buf[s.d_buf + 2 * lx] << 8 | s.pending_buf[s.d_buf + 2 * lx + 1], 
                    lc = s.pending_buf[s.l_buf + lx], lx++, 0 === dist ? send_code(s, lc, ltree) : (send_code(s, (code = _length_code[lc]) + 256 + 1, ltree), 
                    0 !== (extra = extra_lbits[code]) && send_bits(s, lc -= base_length[code], extra), 
                    send_code(s, code = d_code(--dist), dtree), 0 !== (extra = extra_dbits[code]) && send_bits(s, dist -= base_dist[code], extra));
                } while (lx < s.last_lit);
                send_code(s, 256, ltree);
            }
            function build_tree(s, desc) {
                var n, m, node, tree = desc.dyn_tree, stree = desc.stat_desc.static_tree, has_stree = desc.stat_desc.has_stree, elems = desc.stat_desc.elems, max_code = -1;
                for (s.heap_len = 0, s.heap_max = 573, n = 0; n < elems; n++) 0 !== tree[2 * n] ? (s.heap[++s.heap_len] = max_code = n, 
                s.depth[n] = 0) : tree[2 * n + 1] = 0;
                for (;s.heap_len < 2; ) tree[2 * (node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0)] = 1, 
                s.depth[node] = 0, s.opt_len--, has_stree && (s.static_len -= stree[2 * node + 1]);
                for (desc.max_code = max_code, n = s.heap_len >> 1; n >= 1; n--) pqdownheap(s, tree, n);
                node = elems;
                do {
                    n = s.heap[1], s.heap[1] = s.heap[s.heap_len--], pqdownheap(s, tree, 1), m = s.heap[1], 
                    s.heap[--s.heap_max] = n, s.heap[--s.heap_max] = m, tree[2 * node] = tree[2 * n] + tree[2 * m], 
                    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1, tree[2 * n + 1] = tree[2 * m + 1] = node, 
                    s.heap[1] = node++, pqdownheap(s, tree, 1);
                } while (s.heap_len >= 2);
                s.heap[--s.heap_max] = s.heap[1], function gen_bitlen(s, desc) {
                    var h, n, m, bits, xbits, f, tree = desc.dyn_tree, max_code = desc.max_code, stree = desc.stat_desc.static_tree, has_stree = desc.stat_desc.has_stree, extra = desc.stat_desc.extra_bits, base = desc.stat_desc.extra_base, max_length = desc.stat_desc.max_length, overflow = 0;
                    for (bits = 0; bits <= 15; bits++) s.bl_count[bits] = 0;
                    for (tree[2 * s.heap[s.heap_max] + 1] = 0, h = s.heap_max + 1; h < 573; h++) (bits = tree[2 * tree[2 * (n = s.heap[h]) + 1] + 1] + 1) > max_length && (bits = max_length, 
                    overflow++), tree[2 * n + 1] = bits, n > max_code || (s.bl_count[bits]++, xbits = 0, 
                    n >= base && (xbits = extra[n - base]), f = tree[2 * n], s.opt_len += f * (bits + xbits), 
                    has_stree && (s.static_len += f * (stree[2 * n + 1] + xbits)));
                    if (0 !== overflow) {
                        do {
                            for (bits = max_length - 1; 0 === s.bl_count[bits]; ) bits--;
                            s.bl_count[bits]--, s.bl_count[bits + 1] += 2, s.bl_count[max_length]--, overflow -= 2;
                        } while (overflow > 0);
                        for (bits = max_length; 0 !== bits; bits--) for (n = s.bl_count[bits]; 0 !== n; ) (m = s.heap[--h]) > max_code || (tree[2 * m + 1] !== bits && (s.opt_len += (bits - tree[2 * m + 1]) * tree[2 * m], 
                        tree[2 * m + 1] = bits), n--);
                    }
                }(s, desc), gen_codes(tree, max_code, s.bl_count);
            }
            function scan_tree(s, tree, max_code) {
                var n, curlen, prevlen = -1, nextlen = tree[1], count = 0, max_count = 7, min_count = 4;
                for (0 === nextlen && (max_count = 138, min_count = 3), tree[2 * (max_code + 1) + 1] = 0xffff, 
                n = 0; n <= max_code; n++) curlen = nextlen, nextlen = tree[2 * (n + 1) + 1], ++count < max_count && curlen === nextlen || (count < min_count ? s.bl_tree[2 * curlen] += count : 0 !== curlen ? (curlen !== prevlen && s.bl_tree[2 * curlen]++, 
                s.bl_tree[32]++) : count <= 10 ? s.bl_tree[34]++ : s.bl_tree[36]++, count = 0, prevlen = curlen, 
                0 === nextlen ? (max_count = 138, min_count = 3) : curlen === nextlen ? (max_count = 6, 
                min_count = 3) : (max_count = 7, min_count = 4));
            }
            function send_tree(s, tree, max_code) {
                var n, curlen, prevlen = -1, nextlen = tree[1], count = 0, max_count = 7, min_count = 4;
                for (0 === nextlen && (max_count = 138, min_count = 3), n = 0; n <= max_code; n++) if (curlen = nextlen, 
                nextlen = tree[2 * (n + 1) + 1], !(++count < max_count && curlen === nextlen)) {
                    if (count < min_count) do {
                        send_code(s, curlen, s.bl_tree);
                    } while (0 != --count); else 0 !== curlen ? (curlen !== prevlen && (send_code(s, curlen, s.bl_tree), 
                    count--), send_code(s, 16, s.bl_tree), send_bits(s, count - 3, 2)) : count <= 10 ? (send_code(s, 17, s.bl_tree), 
                    send_bits(s, count - 3, 3)) : (send_code(s, 18, s.bl_tree), send_bits(s, count - 11, 7));
                    count = 0, prevlen = curlen, 0 === nextlen ? (max_count = 138, min_count = 3) : curlen === nextlen ? (max_count = 6, 
                    min_count = 3) : (max_count = 7, min_count = 4);
                }
            }
            zero(base_dist);
            var static_init_done = !1;
            function _tr_stored_block(s, buf, stored_len, last) {
                send_bits(s, 0 + (last ? 1 : 0), 3), function copy_block(s, buf, len, header) {
                    bi_windup(s), header && (put_short(s, len), put_short(s, ~len)), utils.arraySet(s.pending_buf, s.window, buf, len, s.pending), 
                    s.pending += len;
                }(s, buf, stored_len, !0);
            }
            exports._tr_init = function _tr_init(s) {
                static_init_done || (function tr_static_init() {
                    var n, bits, length, code, dist, bl_count = new Array(16);
                    for (length = 0, code = 0; code < 28; code++) for (base_length[code] = length, n = 0; n < 1 << extra_lbits[code]; n++) _length_code[length++] = code;
                    for (_length_code[length - 1] = code, dist = 0, code = 0; code < 16; code++) for (base_dist[code] = dist, 
                    n = 0; n < 1 << extra_dbits[code]; n++) _dist_code[dist++] = code;
                    for (dist >>= 7; code < 30; code++) for (base_dist[code] = dist << 7, n = 0; n < 1 << extra_dbits[code] - 7; n++) _dist_code[256 + dist++] = code;
                    for (bits = 0; bits <= 15; bits++) bl_count[bits] = 0;
                    for (n = 0; n <= 143; ) static_ltree[2 * n + 1] = 8, n++, bl_count[8]++;
                    for (;n <= 255; ) static_ltree[2 * n + 1] = 9, n++, bl_count[9]++;
                    for (;n <= 279; ) static_ltree[2 * n + 1] = 7, n++, bl_count[7]++;
                    for (;n <= 287; ) static_ltree[2 * n + 1] = 8, n++, bl_count[8]++;
                    for (gen_codes(static_ltree, 287, bl_count), n = 0; n < 30; n++) static_dtree[2 * n + 1] = 5, 
                    static_dtree[2 * n] = bi_reverse(n, 5);
                    static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, 257, 286, 15), static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, 30, 15), 
                    static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, 19, 7);
                }(), static_init_done = !0), s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc), 
                s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc), s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc), 
                s.bi_buf = 0, s.bi_valid = 0, init_block(s);
            }, exports._tr_stored_block = _tr_stored_block, exports._tr_flush_block = function _tr_flush_block(s, buf, stored_len, last) {
                var opt_lenb, static_lenb, max_blindex = 0;
                s.level > 0 ? (2 === s.strm.data_type && (s.strm.data_type = function detect_data_type(s) {
                    var n, black_mask = 0xf3ffc07f;
                    for (n = 0; n <= 31; n++, black_mask >>>= 1) if (1 & black_mask && 0 !== s.dyn_ltree[2 * n]) return 0;
                    if (0 !== s.dyn_ltree[18] || 0 !== s.dyn_ltree[20] || 0 !== s.dyn_ltree[26]) return 1;
                    for (n = 32; n < 256; n++) if (0 !== s.dyn_ltree[2 * n]) return 1;
                    return 0;
                }(s)), build_tree(s, s.l_desc), build_tree(s, s.d_desc), max_blindex = function build_bl_tree(s) {
                    var max_blindex;
                    for (scan_tree(s, s.dyn_ltree, s.l_desc.max_code), scan_tree(s, s.dyn_dtree, s.d_desc.max_code), 
                    build_tree(s, s.bl_desc), max_blindex = 18; max_blindex >= 3 && 0 === s.bl_tree[2 * bl_order[max_blindex] + 1]; max_blindex--) ;
                    return s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4, max_blindex;
                }(s), opt_lenb = s.opt_len + 3 + 7 >>> 3, (static_lenb = s.static_len + 3 + 7 >>> 3) <= opt_lenb && (opt_lenb = static_lenb)) : opt_lenb = static_lenb = stored_len + 5, 
                stored_len + 4 <= opt_lenb && -1 !== buf ? _tr_stored_block(s, buf, stored_len, last) : 4 === s.strategy || static_lenb === opt_lenb ? (send_bits(s, 2 + (last ? 1 : 0), 3), 
                compress_block(s, static_ltree, static_dtree)) : (send_bits(s, 4 + (last ? 1 : 0), 3), 
                function send_all_trees(s, lcodes, dcodes, blcodes) {
                    var rank;
                    for (send_bits(s, lcodes - 257, 5), send_bits(s, dcodes - 1, 5), send_bits(s, blcodes - 4, 4), 
                    rank = 0; rank < blcodes; rank++) send_bits(s, s.bl_tree[2 * bl_order[rank] + 1], 3);
                    send_tree(s, s.dyn_ltree, lcodes - 1), send_tree(s, s.dyn_dtree, dcodes - 1);
                }(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1), compress_block(s, s.dyn_ltree, s.dyn_dtree)), 
                init_block(s), last && bi_windup(s);
            }, exports._tr_tally = function _tr_tally(s, dist, lc) {
                return s.pending_buf[s.d_buf + 2 * s.last_lit] = dist >>> 8 & 0xff, s.pending_buf[s.d_buf + 2 * s.last_lit + 1] = 0xff & dist, 
                s.pending_buf[s.l_buf + s.last_lit] = 0xff & lc, s.last_lit++, 0 === dist ? s.dyn_ltree[2 * lc]++ : (s.matches++, 
                dist--, s.dyn_ltree[2 * (_length_code[lc] + 256 + 1)]++, s.dyn_dtree[2 * d_code(dist)]++), 
                s.last_lit === s.lit_bufsize - 1;
            }, exports._tr_align = function _tr_align(s) {
                send_bits(s, 2, 3), send_code(s, 256, static_ltree), function bi_flush(s) {
                    16 === s.bi_valid ? (put_short(s, s.bi_buf), s.bi_buf = 0, s.bi_valid = 0) : s.bi_valid >= 8 && (s.pending_buf[s.pending++] = 0xff & s.bi_buf, 
                    s.bi_buf >>= 8, s.bi_valid -= 8);
                }(s);
            };
        }, {
            "../utils/common": 36
        } ],
        46: [ function(require, module, exports) {
            module.exports = function ZStream() {
                this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, 
                this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, 
                this.data_type = 2, this.adler = 0;
            };
        }, {} ],
        47: [ function(require, module, exports) {
            arguments[4][33][0].apply(exports, arguments);
        }, {
            dup: 33
        } ],
        48: [ function(require, module, exports) {
            (function(Buffer) {
                var base64 = require("base64-js"), ieee754 = require("ieee754"), customInspectSymbol = "function" == typeof Symbol && "function" == typeof Symbol.for ? Symbol.for("nodejs.util.inspect.custom") : null;
                function createBuffer(length) {
                    if (length > 2147483647) throw new RangeError('The value "' + length + '" is invalid for option "size"');
                    var buf = new Uint8Array(length);
                    return Object.setPrototypeOf(buf, Buffer.prototype), buf;
                }
                function Buffer(arg, encodingOrOffset, length) {
                    if ("number" == typeof arg) {
                        if ("string" == typeof encodingOrOffset) throw new TypeError('The "string" argument must be of type string. Received type number');
                        return allocUnsafe(arg);
                    }
                    return from(arg, encodingOrOffset, length);
                }
                function from(value, encodingOrOffset, length) {
                    if ("string" == typeof value) return function fromString(string, encoding) {
                        if ("string" == typeof encoding && "" !== encoding || (encoding = "utf8"), !Buffer.isEncoding(encoding)) throw new TypeError("Unknown encoding: " + encoding);
                        var length = 0 | byteLength(string, encoding), buf = createBuffer(length), actual = buf.write(string, encoding);
                        return actual !== length && (buf = buf.slice(0, actual)), buf;
                    }(value, encodingOrOffset);
                    if (ArrayBuffer.isView(value)) return fromArrayLike(value);
                    if (null == value) throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
                    if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) return function fromArrayBuffer(array, byteOffset, length) {
                        if (byteOffset < 0 || array.byteLength < byteOffset) throw new RangeError('"offset" is outside of buffer bounds');
                        if (array.byteLength < byteOffset + (length || 0)) throw new RangeError('"length" is outside of buffer bounds');
                        var buf;
                        return buf = void 0 === byteOffset && void 0 === length ? new Uint8Array(array) : void 0 === length ? new Uint8Array(array, byteOffset) : new Uint8Array(array, byteOffset, length), 
                        Object.setPrototypeOf(buf, Buffer.prototype), buf;
                    }(value, encodingOrOffset, length);
                    if ("number" == typeof value) throw new TypeError('The "value" argument must not be of type number. Received type number');
                    var valueOf = value.valueOf && value.valueOf();
                    if (null != valueOf && valueOf !== value) return Buffer.from(valueOf, encodingOrOffset, length);
                    var b = function fromObject(obj) {
                        if (Buffer.isBuffer(obj)) {
                            var len = 0 | checked(obj.length), buf = createBuffer(len);
                            return 0 === buf.length || obj.copy(buf, 0, 0, len), buf;
                        }
                        return void 0 !== obj.length ? "number" != typeof obj.length || numberIsNaN(obj.length) ? createBuffer(0) : fromArrayLike(obj) : "Buffer" === obj.type && Array.isArray(obj.data) ? fromArrayLike(obj.data) : void 0;
                    }(value);
                    if (b) return b;
                    if ("undefined" != typeof Symbol && null != Symbol.toPrimitive && "function" == typeof value[Symbol.toPrimitive]) return Buffer.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
                    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
                }
                function assertSize(size) {
                    if ("number" != typeof size) throw new TypeError('"size" argument must be of type number');
                    if (size < 0) throw new RangeError('The value "' + size + '" is invalid for option "size"');
                }
                function allocUnsafe(size) {
                    return assertSize(size), createBuffer(size < 0 ? 0 : 0 | checked(size));
                }
                function fromArrayLike(array) {
                    for (var length = array.length < 0 ? 0 : 0 | checked(array.length), buf = createBuffer(length), i = 0; i < length; i += 1) buf[i] = 255 & array[i];
                    return buf;
                }
                function checked(length) {
                    if (length >= 2147483647) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + 2147483647..toString(16) + " bytes");
                    return 0 | length;
                }
                function byteLength(string, encoding) {
                    if (Buffer.isBuffer(string)) return string.length;
                    if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) return string.byteLength;
                    if ("string" != typeof string) throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string);
                    var len = string.length, mustMatch = arguments.length > 2 && !0 === arguments[2];
                    if (!mustMatch && 0 === len) return 0;
                    for (var loweredCase = !1; ;) switch (encoding) {
                      case "ascii":
                      case "latin1":
                      case "binary":
                        return len;

                      case "utf8":
                      case "utf-8":
                        return utf8ToBytes(string).length;

                      case "ucs2":
                      case "ucs-2":
                      case "utf16le":
                      case "utf-16le":
                        return 2 * len;

                      case "hex":
                        return len >>> 1;

                      case "base64":
                        return base64ToBytes(string).length;

                      default:
                        if (loweredCase) return mustMatch ? -1 : utf8ToBytes(string).length;
                        encoding = ("" + encoding).toLowerCase(), loweredCase = !0;
                    }
                }
                function slowToString(encoding, start, end) {
                    var loweredCase = !1;
                    if ((void 0 === start || start < 0) && (start = 0), start > this.length) return "";
                    if ((void 0 === end || end > this.length) && (end = this.length), end <= 0) return "";
                    if ((end >>>= 0) <= (start >>>= 0)) return "";
                    for (encoding || (encoding = "utf8"); ;) switch (encoding) {
                      case "hex":
                        return hexSlice(this, start, end);

                      case "utf8":
                      case "utf-8":
                        return utf8Slice(this, start, end);

                      case "ascii":
                        return asciiSlice(this, start, end);

                      case "latin1":
                      case "binary":
                        return latin1Slice(this, start, end);

                      case "base64":
                        return base64Slice(this, start, end);

                      case "ucs2":
                      case "ucs-2":
                      case "utf16le":
                      case "utf-16le":
                        return utf16leSlice(this, start, end);

                      default:
                        if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
                        encoding = (encoding + "").toLowerCase(), loweredCase = !0;
                    }
                }
                function swap(b, n, m) {
                    var i = b[n];
                    b[n] = b[m], b[m] = i;
                }
                function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
                    if (0 === buffer.length) return -1;
                    if ("string" == typeof byteOffset ? (encoding = byteOffset, byteOffset = 0) : byteOffset > 0x7fffffff ? byteOffset = 0x7fffffff : byteOffset < -0x80000000 && (byteOffset = -0x80000000), 
                    numberIsNaN(byteOffset = +byteOffset) && (byteOffset = dir ? 0 : buffer.length - 1), 
                    byteOffset < 0 && (byteOffset = buffer.length + byteOffset), byteOffset >= buffer.length) {
                        if (dir) return -1;
                        byteOffset = buffer.length - 1;
                    } else if (byteOffset < 0) {
                        if (!dir) return -1;
                        byteOffset = 0;
                    }
                    if ("string" == typeof val && (val = Buffer.from(val, encoding)), Buffer.isBuffer(val)) return 0 === val.length ? -1 : arrayIndexOf(buffer, val, byteOffset, encoding, dir);
                    if ("number" == typeof val) return val &= 0xFF, "function" == typeof Uint8Array.prototype.indexOf ? dir ? Uint8Array.prototype.indexOf.call(buffer, val, byteOffset) : Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset) : arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir);
                    throw new TypeError("val must be string, number or Buffer");
                }
                function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
                    var i, indexSize = 1, arrLength = arr.length, valLength = val.length;
                    if (void 0 !== encoding && ("ucs2" === (encoding = String(encoding).toLowerCase()) || "ucs-2" === encoding || "utf16le" === encoding || "utf-16le" === encoding)) {
                        if (arr.length < 2 || val.length < 2) return -1;
                        indexSize = 2, arrLength /= 2, valLength /= 2, byteOffset /= 2;
                    }
                    function read(buf, i) {
                        return 1 === indexSize ? buf[i] : buf.readUInt16BE(i * indexSize);
                    }
                    if (dir) {
                        var foundIndex = -1;
                        for (i = byteOffset; i < arrLength; i++) if (read(arr, i) === read(val, -1 === foundIndex ? 0 : i - foundIndex)) {
                            if (-1 === foundIndex && (foundIndex = i), i - foundIndex + 1 === valLength) return foundIndex * indexSize;
                        } else -1 !== foundIndex && (i -= i - foundIndex), foundIndex = -1;
                    } else for (byteOffset + valLength > arrLength && (byteOffset = arrLength - valLength), 
                    i = byteOffset; i >= 0; i--) {
                        for (var found = !0, j = 0; j < valLength; j++) if (read(arr, i + j) !== read(val, j)) {
                            found = !1;
                            break;
                        }
                        if (found) return i;
                    }
                    return -1;
                }
                function hexWrite(buf, string, offset, length) {
                    offset = Number(offset) || 0;
                    var remaining = buf.length - offset;
                    length ? (length = Number(length)) > remaining && (length = remaining) : length = remaining;
                    var strLen = string.length;
                    length > strLen / 2 && (length = strLen / 2);
                    for (var i = 0; i < length; ++i) {
                        var parsed = parseInt(string.substr(2 * i, 2), 16);
                        if (numberIsNaN(parsed)) return i;
                        buf[offset + i] = parsed;
                    }
                    return i;
                }
                function utf8Write(buf, string, offset, length) {
                    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
                }
                function asciiWrite(buf, string, offset, length) {
                    return blitBuffer(function asciiToBytes(str) {
                        for (var byteArray = [], i = 0; i < str.length; ++i) byteArray.push(0xFF & str.charCodeAt(i));
                        return byteArray;
                    }(string), buf, offset, length);
                }
                function latin1Write(buf, string, offset, length) {
                    return asciiWrite(buf, string, offset, length);
                }
                function base64Write(buf, string, offset, length) {
                    return blitBuffer(base64ToBytes(string), buf, offset, length);
                }
                function ucs2Write(buf, string, offset, length) {
                    return blitBuffer(function utf16leToBytes(str, units) {
                        for (var c, hi, lo, byteArray = [], i = 0; i < str.length && !((units -= 2) < 0); ++i) hi = (c = str.charCodeAt(i)) >> 8, 
                        lo = c % 256, byteArray.push(lo), byteArray.push(hi);
                        return byteArray;
                    }(string, buf.length - offset), buf, offset, length);
                }
                function base64Slice(buf, start, end) {
                    return 0 === start && end === buf.length ? base64.fromByteArray(buf) : base64.fromByteArray(buf.slice(start, end));
                }
                function utf8Slice(buf, start, end) {
                    end = Math.min(buf.length, end);
                    for (var res = [], i = start; i < end; ) {
                        var secondByte, thirdByte, fourthByte, tempCodePoint, firstByte = buf[i], codePoint = null, bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;
                        if (i + bytesPerSequence <= end) switch (bytesPerSequence) {
                          case 1:
                            firstByte < 0x80 && (codePoint = firstByte);
                            break;

                          case 2:
                            0x80 == (0xC0 & (secondByte = buf[i + 1])) && (tempCodePoint = (0x1F & firstByte) << 0x6 | 0x3F & secondByte) > 0x7F && (codePoint = tempCodePoint);
                            break;

                          case 3:
                            secondByte = buf[i + 1], thirdByte = buf[i + 2], 0x80 == (0xC0 & secondByte) && 0x80 == (0xC0 & thirdByte) && (tempCodePoint = (0xF & firstByte) << 0xC | (0x3F & secondByte) << 0x6 | 0x3F & thirdByte) > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF) && (codePoint = tempCodePoint);
                            break;

                          case 4:
                            secondByte = buf[i + 1], thirdByte = buf[i + 2], fourthByte = buf[i + 3], 0x80 == (0xC0 & secondByte) && 0x80 == (0xC0 & thirdByte) && 0x80 == (0xC0 & fourthByte) && (tempCodePoint = (0xF & firstByte) << 0x12 | (0x3F & secondByte) << 0xC | (0x3F & thirdByte) << 0x6 | 0x3F & fourthByte) > 0xFFFF && tempCodePoint < 0x110000 && (codePoint = tempCodePoint);
                        }
                        null === codePoint ? (codePoint = 0xFFFD, bytesPerSequence = 1) : codePoint > 0xFFFF && (codePoint -= 0x10000, 
                        res.push(codePoint >>> 10 & 0x3FF | 0xD800), codePoint = 0xDC00 | 0x3FF & codePoint), 
                        res.push(codePoint), i += bytesPerSequence;
                    }
                    return function decodeCodePointsArray(codePoints) {
                        var len = codePoints.length;
                        if (len <= 4096) return String.fromCharCode.apply(String, codePoints);
                        for (var res = "", i = 0; i < len; ) res += String.fromCharCode.apply(String, codePoints.slice(i, i += 4096));
                        return res;
                    }(res);
                }
                function asciiSlice(buf, start, end) {
                    var ret = "";
                    end = Math.min(buf.length, end);
                    for (var i = start; i < end; ++i) ret += String.fromCharCode(0x7F & buf[i]);
                    return ret;
                }
                function latin1Slice(buf, start, end) {
                    var ret = "";
                    end = Math.min(buf.length, end);
                    for (var i = start; i < end; ++i) ret += String.fromCharCode(buf[i]);
                    return ret;
                }
                function hexSlice(buf, start, end) {
                    var len = buf.length;
                    (!start || start < 0) && (start = 0), (!end || end < 0 || end > len) && (end = len);
                    for (var out = "", i = start; i < end; ++i) out += hexSliceLookupTable[buf[i]];
                    return out;
                }
                function utf16leSlice(buf, start, end) {
                    for (var bytes = buf.slice(start, end), res = "", i = 0; i < bytes.length; i += 2) res += String.fromCharCode(bytes[i] + 256 * bytes[i + 1]);
                    return res;
                }
                function checkOffset(offset, ext, length) {
                    if (offset % 1 != 0 || offset < 0) throw new RangeError("offset is not uint");
                    if (offset + ext > length) throw new RangeError("Trying to access beyond buffer length");
                }
                function checkInt(buf, value, offset, ext, max, min) {
                    if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
                    if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
                    if (offset + ext > buf.length) throw new RangeError("Index out of range");
                }
                function checkIEEE754(buf, value, offset, ext, max, min) {
                    if (offset + ext > buf.length) throw new RangeError("Index out of range");
                    if (offset < 0) throw new RangeError("Index out of range");
                }
                function writeFloat(buf, value, offset, littleEndian, noAssert) {
                    return value = +value, offset >>>= 0, noAssert || checkIEEE754(buf, 0, offset, 4), 
                    ieee754.write(buf, value, offset, littleEndian, 23, 4), offset + 4;
                }
                function writeDouble(buf, value, offset, littleEndian, noAssert) {
                    return value = +value, offset >>>= 0, noAssert || checkIEEE754(buf, 0, offset, 8), 
                    ieee754.write(buf, value, offset, littleEndian, 52, 8), offset + 8;
                }
                exports.Buffer = Buffer, exports.SlowBuffer = function SlowBuffer(length) {
                    return +length != length && (length = 0), Buffer.alloc(+length);
                }, exports.INSPECT_MAX_BYTES = 50, exports.kMaxLength = 2147483647, Buffer.TYPED_ARRAY_SUPPORT = function typedArraySupport() {
                    try {
                        var arr = new Uint8Array(1), proto = {
                            foo: function() {
                                return 42;
                            }
                        };
                        return Object.setPrototypeOf(proto, Uint8Array.prototype), Object.setPrototypeOf(arr, proto), 
                        42 === arr.foo();
                    } catch (e) {
                        return !1;
                    }
                }(), Buffer.TYPED_ARRAY_SUPPORT || "undefined" == typeof console || "function" != typeof console.error || console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."), 
                Object.defineProperty(Buffer.prototype, "parent", {
                    enumerable: !0,
                    get: function() {
                        if (Buffer.isBuffer(this)) return this.buffer;
                    }
                }), Object.defineProperty(Buffer.prototype, "offset", {
                    enumerable: !0,
                    get: function() {
                        if (Buffer.isBuffer(this)) return this.byteOffset;
                    }
                }), "undefined" != typeof Symbol && null != Symbol.species && Buffer[Symbol.species] === Buffer && Object.defineProperty(Buffer, Symbol.species, {
                    value: null,
                    configurable: !0,
                    enumerable: !1,
                    writable: !1
                }), Buffer.poolSize = 8192, Buffer.from = function(value, encodingOrOffset, length) {
                    return from(value, encodingOrOffset, length);
                }, Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype), Object.setPrototypeOf(Buffer, Uint8Array), 
                Buffer.alloc = function(size, fill, encoding) {
                    return function alloc(size, fill, encoding) {
                        return assertSize(size), size <= 0 ? createBuffer(size) : void 0 !== fill ? "string" == typeof encoding ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill) : createBuffer(size);
                    }(size, fill, encoding);
                }, Buffer.allocUnsafe = function(size) {
                    return allocUnsafe(size);
                }, Buffer.allocUnsafeSlow = function(size) {
                    return allocUnsafe(size);
                }, Buffer.isBuffer = function isBuffer(b) {
                    return null != b && !0 === b._isBuffer && b !== Buffer.prototype;
                }, Buffer.compare = function compare(a, b) {
                    if (isInstance(a, Uint8Array) && (a = Buffer.from(a, a.offset, a.byteLength)), isInstance(b, Uint8Array) && (b = Buffer.from(b, b.offset, b.byteLength)), 
                    !Buffer.isBuffer(a) || !Buffer.isBuffer(b)) throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
                    if (a === b) return 0;
                    for (var x = a.length, y = b.length, i = 0, len = Math.min(x, y); i < len; ++i) if (a[i] !== b[i]) {
                        x = a[i], y = b[i];
                        break;
                    }
                    return x < y ? -1 : y < x ? 1 : 0;
                }, Buffer.isEncoding = function isEncoding(encoding) {
                    switch (String(encoding).toLowerCase()) {
                      case "hex":
                      case "utf8":
                      case "utf-8":
                      case "ascii":
                      case "latin1":
                      case "binary":
                      case "base64":
                      case "ucs2":
                      case "ucs-2":
                      case "utf16le":
                      case "utf-16le":
                        return !0;

                      default:
                        return !1;
                    }
                }, Buffer.concat = function concat(list, length) {
                    if (!Array.isArray(list)) throw new TypeError('"list" argument must be an Array of Buffers');
                    if (0 === list.length) return Buffer.alloc(0);
                    var i;
                    if (void 0 === length) for (length = 0, i = 0; i < list.length; ++i) length += list[i].length;
                    var buffer = Buffer.allocUnsafe(length), pos = 0;
                    for (i = 0; i < list.length; ++i) {
                        var buf = list[i];
                        if (isInstance(buf, Uint8Array) && (buf = Buffer.from(buf)), !Buffer.isBuffer(buf)) throw new TypeError('"list" argument must be an Array of Buffers');
                        buf.copy(buffer, pos), pos += buf.length;
                    }
                    return buffer;
                }, Buffer.byteLength = byteLength, Buffer.prototype._isBuffer = !0, Buffer.prototype.swap16 = function swap16() {
                    var len = this.length;
                    if (len % 2 != 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
                    for (var i = 0; i < len; i += 2) swap(this, i, i + 1);
                    return this;
                }, Buffer.prototype.swap32 = function swap32() {
                    var len = this.length;
                    if (len % 4 != 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
                    for (var i = 0; i < len; i += 4) swap(this, i, i + 3), swap(this, i + 1, i + 2);
                    return this;
                }, Buffer.prototype.swap64 = function swap64() {
                    var len = this.length;
                    if (len % 8 != 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
                    for (var i = 0; i < len; i += 8) swap(this, i, i + 7), swap(this, i + 1, i + 6), 
                    swap(this, i + 2, i + 5), swap(this, i + 3, i + 4);
                    return this;
                }, Buffer.prototype.toString = function toString() {
                    var length = this.length;
                    return 0 === length ? "" : 0 === arguments.length ? utf8Slice(this, 0, length) : slowToString.apply(this, arguments);
                }, Buffer.prototype.toLocaleString = Buffer.prototype.toString, Buffer.prototype.equals = function equals(b) {
                    if (!Buffer.isBuffer(b)) throw new TypeError("Argument must be a Buffer");
                    return this === b || 0 === Buffer.compare(this, b);
                }, Buffer.prototype.inspect = function inspect() {
                    var str = "", max = exports.INSPECT_MAX_BYTES;
                    return str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim(), this.length > max && (str += " ... "), 
                    "<Buffer " + str + ">";
                }, customInspectSymbol && (Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect), 
                Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
                    if (isInstance(target, Uint8Array) && (target = Buffer.from(target, target.offset, target.byteLength)), 
                    !Buffer.isBuffer(target)) throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target);
                    if (void 0 === start && (start = 0), void 0 === end && (end = target ? target.length : 0), 
                    void 0 === thisStart && (thisStart = 0), void 0 === thisEnd && (thisEnd = this.length), 
                    start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) throw new RangeError("out of range index");
                    if (thisStart >= thisEnd && start >= end) return 0;
                    if (thisStart >= thisEnd) return -1;
                    if (start >= end) return 1;
                    if (this === target) return 0;
                    for (var x = (thisEnd >>>= 0) - (thisStart >>>= 0), y = (end >>>= 0) - (start >>>= 0), len = Math.min(x, y), thisCopy = this.slice(thisStart, thisEnd), targetCopy = target.slice(start, end), i = 0; i < len; ++i) if (thisCopy[i] !== targetCopy[i]) {
                        x = thisCopy[i], y = targetCopy[i];
                        break;
                    }
                    return x < y ? -1 : y < x ? 1 : 0;
                }, Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
                    return -1 !== this.indexOf(val, byteOffset, encoding);
                }, Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
                    return bidirectionalIndexOf(this, val, byteOffset, encoding, !0);
                }, Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
                    return bidirectionalIndexOf(this, val, byteOffset, encoding, !1);
                }, Buffer.prototype.write = function write(string, offset, length, encoding) {
                    if (void 0 === offset) encoding = "utf8", length = this.length, offset = 0; else if (void 0 === length && "string" == typeof offset) encoding = offset, 
                    length = this.length, offset = 0; else {
                        if (!isFinite(offset)) throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
                        offset >>>= 0, isFinite(length) ? (length >>>= 0, void 0 === encoding && (encoding = "utf8")) : (encoding = length, 
                        length = void 0);
                    }
                    var remaining = this.length - offset;
                    if ((void 0 === length || length > remaining) && (length = remaining), string.length > 0 && (length < 0 || offset < 0) || offset > this.length) throw new RangeError("Attempt to write outside buffer bounds");
                    encoding || (encoding = "utf8");
                    for (var loweredCase = !1; ;) switch (encoding) {
                      case "hex":
                        return hexWrite(this, string, offset, length);

                      case "utf8":
                      case "utf-8":
                        return utf8Write(this, string, offset, length);

                      case "ascii":
                        return asciiWrite(this, string, offset, length);

                      case "latin1":
                      case "binary":
                        return latin1Write(this, string, offset, length);

                      case "base64":
                        return base64Write(this, string, offset, length);

                      case "ucs2":
                      case "ucs-2":
                      case "utf16le":
                      case "utf-16le":
                        return ucs2Write(this, string, offset, length);

                      default:
                        if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
                        encoding = ("" + encoding).toLowerCase(), loweredCase = !0;
                    }
                }, Buffer.prototype.toJSON = function toJSON() {
                    return {
                        type: "Buffer",
                        data: Array.prototype.slice.call(this._arr || this, 0)
                    };
                }, Buffer.prototype.slice = function slice(start, end) {
                    var len = this.length;
                    (start = ~~start) < 0 ? (start += len) < 0 && (start = 0) : start > len && (start = len), 
                    (end = void 0 === end ? len : ~~end) < 0 ? (end += len) < 0 && (end = 0) : end > len && (end = len), 
                    end < start && (end = start);
                    var newBuf = this.subarray(start, end);
                    return Object.setPrototypeOf(newBuf, Buffer.prototype), newBuf;
                }, Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
                    offset >>>= 0, byteLength >>>= 0, noAssert || checkOffset(offset, byteLength, this.length);
                    for (var val = this[offset], mul = 1, i = 0; ++i < byteLength && (mul *= 0x100); ) val += this[offset + i] * mul;
                    return val;
                }, Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
                    offset >>>= 0, byteLength >>>= 0, noAssert || checkOffset(offset, byteLength, this.length);
                    for (var val = this[offset + --byteLength], mul = 1; byteLength > 0 && (mul *= 0x100); ) val += this[offset + --byteLength] * mul;
                    return val;
                }, Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
                    return offset >>>= 0, noAssert || checkOffset(offset, 1, this.length), this[offset];
                }, Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
                    return offset >>>= 0, noAssert || checkOffset(offset, 2, this.length), this[offset] | this[offset + 1] << 8;
                }, Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
                    return offset >>>= 0, noAssert || checkOffset(offset, 2, this.length), this[offset] << 8 | this[offset + 1];
                }, Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
                    return offset >>>= 0, noAssert || checkOffset(offset, 4, this.length), (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + 0x1000000 * this[offset + 3];
                }, Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
                    return offset >>>= 0, noAssert || checkOffset(offset, 4, this.length), 0x1000000 * this[offset] + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
                }, Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
                    offset >>>= 0, byteLength >>>= 0, noAssert || checkOffset(offset, byteLength, this.length);
                    for (var val = this[offset], mul = 1, i = 0; ++i < byteLength && (mul *= 0x100); ) val += this[offset + i] * mul;
                    return val >= (mul *= 0x80) && (val -= Math.pow(2, 8 * byteLength)), val;
                }, Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
                    offset >>>= 0, byteLength >>>= 0, noAssert || checkOffset(offset, byteLength, this.length);
                    for (var i = byteLength, mul = 1, val = this[offset + --i]; i > 0 && (mul *= 0x100); ) val += this[offset + --i] * mul;
                    return val >= (mul *= 0x80) && (val -= Math.pow(2, 8 * byteLength)), val;
                }, Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
                    return offset >>>= 0, noAssert || checkOffset(offset, 1, this.length), 0x80 & this[offset] ? -1 * (0xff - this[offset] + 1) : this[offset];
                }, Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
                    offset >>>= 0, noAssert || checkOffset(offset, 2, this.length);
                    var val = this[offset] | this[offset + 1] << 8;
                    return 0x8000 & val ? 0xFFFF0000 | val : val;
                }, Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
                    offset >>>= 0, noAssert || checkOffset(offset, 2, this.length);
                    var val = this[offset + 1] | this[offset] << 8;
                    return 0x8000 & val ? 0xFFFF0000 | val : val;
                }, Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
                    return offset >>>= 0, noAssert || checkOffset(offset, 4, this.length), this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
                }, Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
                    return offset >>>= 0, noAssert || checkOffset(offset, 4, this.length), this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
                }, Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
                    return offset >>>= 0, noAssert || checkOffset(offset, 4, this.length), ieee754.read(this, offset, !0, 23, 4);
                }, Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
                    return offset >>>= 0, noAssert || checkOffset(offset, 4, this.length), ieee754.read(this, offset, !1, 23, 4);
                }, Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
                    return offset >>>= 0, noAssert || checkOffset(offset, 8, this.length), ieee754.read(this, offset, !0, 52, 8);
                }, Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
                    return offset >>>= 0, noAssert || checkOffset(offset, 8, this.length), ieee754.read(this, offset, !1, 52, 8);
                }, Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
                    value = +value, offset >>>= 0, byteLength >>>= 0, noAssert || checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength) - 1, 0);
                    var mul = 1, i = 0;
                    for (this[offset] = 0xFF & value; ++i < byteLength && (mul *= 0x100); ) this[offset + i] = value / mul & 0xFF;
                    return offset + byteLength;
                }, Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
                    value = +value, offset >>>= 0, byteLength >>>= 0, noAssert || checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength) - 1, 0);
                    var i = byteLength - 1, mul = 1;
                    for (this[offset + i] = 0xFF & value; --i >= 0 && (mul *= 0x100); ) this[offset + i] = value / mul & 0xFF;
                    return offset + byteLength;
                }, Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
                    return value = +value, offset >>>= 0, noAssert || checkInt(this, value, offset, 1, 0xff, 0), 
                    this[offset] = 0xff & value, offset + 1;
                }, Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
                    return value = +value, offset >>>= 0, noAssert || checkInt(this, value, offset, 2, 0xffff, 0), 
                    this[offset] = 0xff & value, this[offset + 1] = value >>> 8, offset + 2;
                }, Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
                    return value = +value, offset >>>= 0, noAssert || checkInt(this, value, offset, 2, 0xffff, 0), 
                    this[offset] = value >>> 8, this[offset + 1] = 0xff & value, offset + 2;
                }, Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
                    return value = +value, offset >>>= 0, noAssert || checkInt(this, value, offset, 4, 0xffffffff, 0), 
                    this[offset + 3] = value >>> 24, this[offset + 2] = value >>> 16, this[offset + 1] = value >>> 8, 
                    this[offset] = 0xff & value, offset + 4;
                }, Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
                    return value = +value, offset >>>= 0, noAssert || checkInt(this, value, offset, 4, 0xffffffff, 0), 
                    this[offset] = value >>> 24, this[offset + 1] = value >>> 16, this[offset + 2] = value >>> 8, 
                    this[offset + 3] = 0xff & value, offset + 4;
                }, Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
                    if (value = +value, offset >>>= 0, !noAssert) {
                        var limit = Math.pow(2, 8 * byteLength - 1);
                        checkInt(this, value, offset, byteLength, limit - 1, -limit);
                    }
                    var i = 0, mul = 1, sub = 0;
                    for (this[offset] = 0xFF & value; ++i < byteLength && (mul *= 0x100); ) value < 0 && 0 === sub && 0 !== this[offset + i - 1] && (sub = 1), 
                    this[offset + i] = (value / mul >> 0) - sub & 0xFF;
                    return offset + byteLength;
                }, Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
                    if (value = +value, offset >>>= 0, !noAssert) {
                        var limit = Math.pow(2, 8 * byteLength - 1);
                        checkInt(this, value, offset, byteLength, limit - 1, -limit);
                    }
                    var i = byteLength - 1, mul = 1, sub = 0;
                    for (this[offset + i] = 0xFF & value; --i >= 0 && (mul *= 0x100); ) value < 0 && 0 === sub && 0 !== this[offset + i + 1] && (sub = 1), 
                    this[offset + i] = (value / mul >> 0) - sub & 0xFF;
                    return offset + byteLength;
                }, Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
                    return value = +value, offset >>>= 0, noAssert || checkInt(this, value, offset, 1, 0x7f, -0x80), 
                    value < 0 && (value = 0xff + value + 1), this[offset] = 0xff & value, offset + 1;
                }, Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
                    return value = +value, offset >>>= 0, noAssert || checkInt(this, value, offset, 2, 0x7fff, -0x8000), 
                    this[offset] = 0xff & value, this[offset + 1] = value >>> 8, offset + 2;
                }, Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
                    return value = +value, offset >>>= 0, noAssert || checkInt(this, value, offset, 2, 0x7fff, -0x8000), 
                    this[offset] = value >>> 8, this[offset + 1] = 0xff & value, offset + 2;
                }, Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
                    return value = +value, offset >>>= 0, noAssert || checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000), 
                    this[offset] = 0xff & value, this[offset + 1] = value >>> 8, this[offset + 2] = value >>> 16, 
                    this[offset + 3] = value >>> 24, offset + 4;
                }, Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
                    return value = +value, offset >>>= 0, noAssert || checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000), 
                    value < 0 && (value = 0xffffffff + value + 1), this[offset] = value >>> 24, this[offset + 1] = value >>> 16, 
                    this[offset + 2] = value >>> 8, this[offset + 3] = 0xff & value, offset + 4;
                }, Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
                    return writeFloat(this, value, offset, !0, noAssert);
                }, Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
                    return writeFloat(this, value, offset, !1, noAssert);
                }, Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
                    return writeDouble(this, value, offset, !0, noAssert);
                }, Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
                    return writeDouble(this, value, offset, !1, noAssert);
                }, Buffer.prototype.copy = function copy(target, targetStart, start, end) {
                    if (!Buffer.isBuffer(target)) throw new TypeError("argument should be a Buffer");
                    if (start || (start = 0), end || 0 === end || (end = this.length), targetStart >= target.length && (targetStart = target.length), 
                    targetStart || (targetStart = 0), end > 0 && end < start && (end = start), end === start) return 0;
                    if (0 === target.length || 0 === this.length) return 0;
                    if (targetStart < 0) throw new RangeError("targetStart out of bounds");
                    if (start < 0 || start >= this.length) throw new RangeError("Index out of range");
                    if (end < 0) throw new RangeError("sourceEnd out of bounds");
                    end > this.length && (end = this.length), target.length - targetStart < end - start && (end = target.length - targetStart + start);
                    var len = end - start;
                    if (this === target && "function" == typeof Uint8Array.prototype.copyWithin) this.copyWithin(targetStart, start, end); else if (this === target && start < targetStart && targetStart < end) for (var i = len - 1; i >= 0; --i) target[i + targetStart] = this[i + start]; else Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
                    return len;
                }, Buffer.prototype.fill = function fill(val, start, end, encoding) {
                    if ("string" == typeof val) {
                        if ("string" == typeof start ? (encoding = start, start = 0, end = this.length) : "string" == typeof end && (encoding = end, 
                        end = this.length), void 0 !== encoding && "string" != typeof encoding) throw new TypeError("encoding must be a string");
                        if ("string" == typeof encoding && !Buffer.isEncoding(encoding)) throw new TypeError("Unknown encoding: " + encoding);
                        if (1 === val.length) {
                            var code = val.charCodeAt(0);
                            ("utf8" === encoding && code < 128 || "latin1" === encoding) && (val = code);
                        }
                    } else "number" == typeof val ? val &= 255 : "boolean" == typeof val && (val = Number(val));
                    if (start < 0 || this.length < start || this.length < end) throw new RangeError("Out of range index");
                    if (end <= start) return this;
                    var i;
                    if (start >>>= 0, end = void 0 === end ? this.length : end >>> 0, val || (val = 0), 
                    "number" == typeof val) for (i = start; i < end; ++i) this[i] = val; else {
                        var bytes = Buffer.isBuffer(val) ? val : Buffer.from(val, encoding), len = bytes.length;
                        if (0 === len) throw new TypeError('The value "' + val + '" is invalid for argument "value"');
                        for (i = 0; i < end - start; ++i) this[i + start] = bytes[i % len];
                    }
                    return this;
                };
                var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
                function utf8ToBytes(string, units) {
                    var codePoint;
                    units = units || 1 / 0;
                    for (var length = string.length, leadSurrogate = null, bytes = [], i = 0; i < length; ++i) {
                        if ((codePoint = string.charCodeAt(i)) > 0xD7FF && codePoint < 0xE000) {
                            if (!leadSurrogate) {
                                if (codePoint > 0xDBFF) {
                                    (units -= 3) > -1 && bytes.push(0xEF, 0xBF, 0xBD);
                                    continue;
                                }
                                if (i + 1 === length) {
                                    (units -= 3) > -1 && bytes.push(0xEF, 0xBF, 0xBD);
                                    continue;
                                }
                                leadSurrogate = codePoint;
                                continue;
                            }
                            if (codePoint < 0xDC00) {
                                (units -= 3) > -1 && bytes.push(0xEF, 0xBF, 0xBD), leadSurrogate = codePoint;
                                continue;
                            }
                            codePoint = 0x10000 + (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00);
                        } else leadSurrogate && (units -= 3) > -1 && bytes.push(0xEF, 0xBF, 0xBD);
                        if (leadSurrogate = null, codePoint < 0x80) {
                            if ((units -= 1) < 0) break;
                            bytes.push(codePoint);
                        } else if (codePoint < 0x800) {
                            if ((units -= 2) < 0) break;
                            bytes.push(codePoint >> 0x6 | 0xC0, 0x3F & codePoint | 0x80);
                        } else if (codePoint < 0x10000) {
                            if ((units -= 3) < 0) break;
                            bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, 0x3F & codePoint | 0x80);
                        } else {
                            if (!(codePoint < 0x110000)) throw new Error("Invalid code point");
                            if ((units -= 4) < 0) break;
                            bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, 0x3F & codePoint | 0x80);
                        }
                    }
                    return bytes;
                }
                function base64ToBytes(str) {
                    return base64.toByteArray(function base64clean(str) {
                        if ((str = (str = str.split("=")[0]).trim().replace(INVALID_BASE64_RE, "")).length < 2) return "";
                        for (;str.length % 4 != 0; ) str += "=";
                        return str;
                    }(str));
                }
                function blitBuffer(src, dst, offset, length) {
                    for (var i = 0; i < length && !(i + offset >= dst.length || i >= src.length); ++i) dst[i + offset] = src[i];
                    return i;
                }
                function isInstance(obj, type) {
                    return obj instanceof type || null != obj && null != obj.constructor && null != obj.constructor.name && obj.constructor.name === type.name;
                }
                function numberIsNaN(obj) {
                    return obj != obj;
                }
                var hexSliceLookupTable = function() {
                    for (var table = new Array(256), i = 0; i < 16; ++i) for (var i16 = 16 * i, j = 0; j < 16; ++j) table[i16 + j] = "0123456789abcdef"[i] + "0123456789abcdef"[j];
                    return table;
                }();
            }).call(this, require("buffer").Buffer);
        }, {
            "base64-js": 29,
            buffer: 48,
            ieee754: 73
        } ],
        49: [ function(require, module, exports) {
            var Buffer = require("buffer").Buffer;
            module.exports = function(a, b) {
                if (Buffer.isBuffer(a) && Buffer.isBuffer(b)) {
                    if ("function" == typeof a.equals) return a.equals(b);
                    if (a.length !== b.length) return !1;
                    for (var i = 0; i < a.length; i++) if (a[i] !== b[i]) return !1;
                    return !0;
                }
            };
        }, {
            buffer: 48
        } ],
        50: [ function(require, module, exports) {
            module.exports = {
                100: "Continue",
                101: "Switching Protocols",
                102: "Processing",
                200: "OK",
                201: "Created",
                202: "Accepted",
                203: "Non-Authoritative Information",
                204: "No Content",
                205: "Reset Content",
                206: "Partial Content",
                207: "Multi-Status",
                208: "Already Reported",
                226: "IM Used",
                300: "Multiple Choices",
                301: "Moved Permanently",
                302: "Found",
                303: "See Other",
                304: "Not Modified",
                305: "Use Proxy",
                307: "Temporary Redirect",
                308: "Permanent Redirect",
                400: "Bad Request",
                401: "Unauthorized",
                402: "Payment Required",
                403: "Forbidden",
                404: "Not Found",
                405: "Method Not Allowed",
                406: "Not Acceptable",
                407: "Proxy Authentication Required",
                408: "Request Timeout",
                409: "Conflict",
                410: "Gone",
                411: "Length Required",
                412: "Precondition Failed",
                413: "Payload Too Large",
                414: "URI Too Long",
                415: "Unsupported Media Type",
                416: "Range Not Satisfiable",
                417: "Expectation Failed",
                418: "I'm a teapot",
                421: "Misdirected Request",
                422: "Unprocessable Entity",
                423: "Locked",
                424: "Failed Dependency",
                425: "Unordered Collection",
                426: "Upgrade Required",
                428: "Precondition Required",
                429: "Too Many Requests",
                431: "Request Header Fields Too Large",
                451: "Unavailable For Legal Reasons",
                500: "Internal Server Error",
                501: "Not Implemented",
                502: "Bad Gateway",
                503: "Service Unavailable",
                504: "Gateway Timeout",
                505: "HTTP Version Not Supported",
                506: "Variant Also Negotiates",
                507: "Insufficient Storage",
                508: "Loop Detected",
                509: "Bandwidth Limit Exceeded",
                510: "Not Extended",
                511: "Network Authentication Required"
            };
        }, {} ],
        51: [ function(require, module, exports) {
            (function(Buffer) {
                function objectToString(o) {
                    return Object.prototype.toString.call(o);
                }
                exports.isArray = function isArray(arg) {
                    return Array.isArray ? Array.isArray(arg) : "[object Array]" === objectToString(arg);
                }, exports.isBoolean = function isBoolean(arg) {
                    return "boolean" == typeof arg;
                }, exports.isNull = function isNull(arg) {
                    return null === arg;
                }, exports.isNullOrUndefined = function isNullOrUndefined(arg) {
                    return null == arg;
                }, exports.isNumber = function isNumber(arg) {
                    return "number" == typeof arg;
                }, exports.isString = function isString(arg) {
                    return "string" == typeof arg;
                }, exports.isSymbol = function isSymbol(arg) {
                    return "symbol" == typeof arg;
                }, exports.isUndefined = function isUndefined(arg) {
                    return void 0 === arg;
                }, exports.isRegExp = function isRegExp(re) {
                    return "[object RegExp]" === objectToString(re);
                }, exports.isObject = function isObject(arg) {
                    return "object" == typeof arg && null !== arg;
                }, exports.isDate = function isDate(d) {
                    return "[object Date]" === objectToString(d);
                }, exports.isError = function isError(e) {
                    return "[object Error]" === objectToString(e) || e instanceof Error;
                }, exports.isFunction = function isFunction(arg) {
                    return "function" == typeof arg;
                }, exports.isPrimitive = function isPrimitive(arg) {
                    return null === arg || "boolean" == typeof arg || "number" == typeof arg || "string" == typeof arg || "symbol" == typeof arg || void 0 === arg;
                }, exports.isBuffer = Buffer.isBuffer;
            }).call(this, {
                isBuffer: require("../../is-buffer/index.js")
            });
        }, {
            "../../is-buffer/index.js": 76
        } ],
        52: [ function(require, module, exports) {
            var objectCreate = Object.create || function objectCreatePolyfill(proto) {
                var F = function() {};
                return F.prototype = proto, new F;
            }, objectKeys = Object.keys || function objectKeysPolyfill(obj) {
                for (var k in obj) Object.prototype.hasOwnProperty.call(obj, k);
                return k;
            }, bind = Function.prototype.bind || function functionBindPolyfill(context) {
                var fn = this;
                return function() {
                    return fn.apply(context, arguments);
                };
            };
            function EventEmitter() {
                this._events && Object.prototype.hasOwnProperty.call(this, "_events") || (this._events = objectCreate(null), 
                this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
            }
            module.exports = EventEmitter, EventEmitter.EventEmitter = EventEmitter, EventEmitter.prototype._events = void 0, 
            EventEmitter.prototype._maxListeners = void 0;
            var hasDefineProperty, defaultMaxListeners = 10;
            try {
                var o = {};
                Object.defineProperty && Object.defineProperty(o, "x", {
                    value: 0
                }), hasDefineProperty = 0 === o.x;
            } catch (err) {
                hasDefineProperty = !1;
            }
            function $getMaxListeners(that) {
                return void 0 === that._maxListeners ? EventEmitter.defaultMaxListeners : that._maxListeners;
            }
            function emitNone(handler, isFn, self) {
                if (isFn) handler.call(self); else for (var len = handler.length, listeners = arrayClone(handler, len), i = 0; i < len; ++i) listeners[i].call(self);
            }
            function emitOne(handler, isFn, self, arg1) {
                if (isFn) handler.call(self, arg1); else for (var len = handler.length, listeners = arrayClone(handler, len), i = 0; i < len; ++i) listeners[i].call(self, arg1);
            }
            function emitTwo(handler, isFn, self, arg1, arg2) {
                if (isFn) handler.call(self, arg1, arg2); else for (var len = handler.length, listeners = arrayClone(handler, len), i = 0; i < len; ++i) listeners[i].call(self, arg1, arg2);
            }
            function emitThree(handler, isFn, self, arg1, arg2, arg3) {
                if (isFn) handler.call(self, arg1, arg2, arg3); else for (var len = handler.length, listeners = arrayClone(handler, len), i = 0; i < len; ++i) listeners[i].call(self, arg1, arg2, arg3);
            }
            function emitMany(handler, isFn, self, args) {
                if (isFn) handler.apply(self, args); else for (var len = handler.length, listeners = arrayClone(handler, len), i = 0; i < len; ++i) listeners[i].apply(self, args);
            }
            function _addListener(target, type, listener, prepend) {
                var m, events, existing;
                if ("function" != typeof listener) throw new TypeError('"listener" argument must be a function');
                if ((events = target._events) ? (events.newListener && (target.emit("newListener", type, listener.listener ? listener.listener : listener), 
                events = target._events), existing = events[type]) : (events = target._events = objectCreate(null), 
                target._eventsCount = 0), existing) {
                    if ("function" == typeof existing ? existing = events[type] = prepend ? [ listener, existing ] : [ existing, listener ] : prepend ? existing.unshift(listener) : existing.push(listener), 
                    !existing.warned && (m = $getMaxListeners(target)) && m > 0 && existing.length > m) {
                        existing.warned = !0;
                        var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + ' "' + String(type) + '" listeners added. Use emitter.setMaxListeners() to increase limit.');
                        w.name = "MaxListenersExceededWarning", w.emitter = target, w.type = type, w.count = existing.length, 
                        "object" == typeof console && console.warn && console.warn("%s: %s", w.name, w.message);
                    }
                } else existing = events[type] = listener, ++target._eventsCount;
                return target;
            }
            function onceWrapper() {
                if (!this.fired) switch (this.target.removeListener(this.type, this.wrapFn), this.fired = !0, 
                arguments.length) {
                  case 0:
                    return this.listener.call(this.target);

                  case 1:
                    return this.listener.call(this.target, arguments[0]);

                  case 2:
                    return this.listener.call(this.target, arguments[0], arguments[1]);

                  case 3:
                    return this.listener.call(this.target, arguments[0], arguments[1], arguments[2]);

                  default:
                    for (var args = new Array(arguments.length), i = 0; i < args.length; ++i) args[i] = arguments[i];
                    this.listener.apply(this.target, args);
                }
            }
            function _onceWrap(target, type, listener) {
                var state = {
                    fired: !1,
                    wrapFn: void 0,
                    target,
                    type,
                    listener
                }, wrapped = bind.call(onceWrapper, state);
                return wrapped.listener = listener, state.wrapFn = wrapped, wrapped;
            }
            function _listeners(target, type, unwrap) {
                var events = target._events;
                if (!events) return [];
                var evlistener = events[type];
                return evlistener ? "function" == typeof evlistener ? unwrap ? [ evlistener.listener || evlistener ] : [ evlistener ] : unwrap ? function unwrapListeners(arr) {
                    for (var ret = new Array(arr.length), i = 0; i < ret.length; ++i) ret[i] = arr[i].listener || arr[i];
                    return ret;
                }(evlistener) : arrayClone(evlistener, evlistener.length) : [];
            }
            function listenerCount(type) {
                var events = this._events;
                if (events) {
                    var evlistener = events[type];
                    if ("function" == typeof evlistener) return 1;
                    if (evlistener) return evlistener.length;
                }
                return 0;
            }
            function arrayClone(arr, n) {
                for (var copy = new Array(n), i = 0; i < n; ++i) copy[i] = arr[i];
                return copy;
            }
            hasDefineProperty ? Object.defineProperty(EventEmitter, "defaultMaxListeners", {
                enumerable: !0,
                get: function() {
                    return defaultMaxListeners;
                },
                set: function(arg) {
                    if ("number" != typeof arg || arg < 0 || arg != arg) throw new TypeError('"defaultMaxListeners" must be a positive number');
                    defaultMaxListeners = arg;
                }
            }) : EventEmitter.defaultMaxListeners = defaultMaxListeners, EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
                if ("number" != typeof n || n < 0 || isNaN(n)) throw new TypeError('"n" argument must be a positive number');
                return this._maxListeners = n, this;
            }, EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
                return $getMaxListeners(this);
            }, EventEmitter.prototype.emit = function emit(type) {
                var er, handler, len, args, i, events, doError = "error" === type;
                if (events = this._events) doError = doError && null == events.error; else if (!doError) return !1;
                if (doError) {
                    if (arguments.length > 1 && (er = arguments[1]), er instanceof Error) throw er;
                    var err = new Error('Unhandled "error" event. (' + er + ")");
                    throw err.context = er, err;
                }
                if (!(handler = events[type])) return !1;
                var isFn = "function" == typeof handler;
                switch (len = arguments.length) {
                  case 1:
                    emitNone(handler, isFn, this);
                    break;

                  case 2:
                    emitOne(handler, isFn, this, arguments[1]);
                    break;

                  case 3:
                    emitTwo(handler, isFn, this, arguments[1], arguments[2]);
                    break;

                  case 4:
                    emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
                    break;

                  default:
                    for (args = new Array(len - 1), i = 1; i < len; i++) args[i - 1] = arguments[i];
                    emitMany(handler, isFn, this, args);
                }
                return !0;
            }, EventEmitter.prototype.addListener = function addListener(type, listener) {
                return _addListener(this, type, listener, !1);
            }, EventEmitter.prototype.on = EventEmitter.prototype.addListener, EventEmitter.prototype.prependListener = function prependListener(type, listener) {
                return _addListener(this, type, listener, !0);
            }, EventEmitter.prototype.once = function once(type, listener) {
                if ("function" != typeof listener) throw new TypeError('"listener" argument must be a function');
                return this.on(type, _onceWrap(this, type, listener)), this;
            }, EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
                if ("function" != typeof listener) throw new TypeError('"listener" argument must be a function');
                return this.prependListener(type, _onceWrap(this, type, listener)), this;
            }, EventEmitter.prototype.removeListener = function removeListener(type, listener) {
                var list, events, position, i, originalListener;
                if ("function" != typeof listener) throw new TypeError('"listener" argument must be a function');
                if (!(events = this._events)) return this;
                if (!(list = events[type])) return this;
                if (list === listener || list.listener === listener) 0 == --this._eventsCount ? this._events = objectCreate(null) : (delete events[type], 
                events.removeListener && this.emit("removeListener", type, list.listener || listener)); else if ("function" != typeof list) {
                    for (position = -1, i = list.length - 1; i >= 0; i--) if (list[i] === listener || list[i].listener === listener) {
                        originalListener = list[i].listener, position = i;
                        break;
                    }
                    if (position < 0) return this;
                    0 === position ? list.shift() : function spliceOne(list, index) {
                        for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1) list[i] = list[k];
                        list.pop();
                    }(list, position), 1 === list.length && (events[type] = list[0]), events.removeListener && this.emit("removeListener", type, originalListener || listener);
                }
                return this;
            }, EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
                var listeners, events, i;
                if (!(events = this._events)) return this;
                if (!events.removeListener) return 0 === arguments.length ? (this._events = objectCreate(null), 
                this._eventsCount = 0) : events[type] && (0 == --this._eventsCount ? this._events = objectCreate(null) : delete events[type]), 
                this;
                if (0 === arguments.length) {
                    var key, keys = objectKeys(events);
                    for (i = 0; i < keys.length; ++i) "removeListener" !== (key = keys[i]) && this.removeAllListeners(key);
                    return this.removeAllListeners("removeListener"), this._events = objectCreate(null), 
                    this._eventsCount = 0, this;
                }
                if ("function" == typeof (listeners = events[type])) this.removeListener(type, listeners); else if (listeners) for (i = listeners.length - 1; i >= 0; i--) this.removeListener(type, listeners[i]);
                return this;
            }, EventEmitter.prototype.listeners = function listeners(type) {
                return _listeners(this, type, !0);
            }, EventEmitter.prototype.rawListeners = function rawListeners(type) {
                return _listeners(this, type, !1);
            }, EventEmitter.listenerCount = function(emitter, type) {
                return "function" == typeof emitter.listenerCount ? emitter.listenerCount(type) : listenerCount.call(emitter, type);
            }, EventEmitter.prototype.listenerCount = listenerCount, EventEmitter.prototype.eventNames = function eventNames() {
                return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
            };
        }, {} ],
        53: [ function(require, module, exports) {
            var Parser = require("./lib/parser");
            module.exports = {
                create: function(buffer, global) {
                    if (buffer instanceof (global = global || function getGlobal() {
                        return (0, eval)("this");
                    }()).ArrayBuffer) {
                        var DOMBufferStream = require("./lib/dom-bufferstream");
                        return new Parser(new DOMBufferStream(buffer, 0, buffer.byteLength, !0, global));
                    }
                    var NodeBufferStream = require("./lib/bufferstream");
                    return new Parser(new NodeBufferStream(buffer, 0, buffer.length, !0));
                }
            };
        }, {
            "./lib/bufferstream": 54,
            "./lib/dom-bufferstream": 56,
            "./lib/parser": 60
        } ],
        54: [ function(require, module, exports) {
            function BufferStream(buffer, offset, length, bigEndian) {
                this.buffer = buffer, this.offset = offset || 0, length = "number" == typeof length ? length : buffer.length, 
                this.endPosition = this.offset + length, this.setBigEndian(bigEndian);
            }
            BufferStream.prototype = {
                setBigEndian: function(bigEndian) {
                    this.bigEndian = !!bigEndian;
                },
                nextUInt8: function() {
                    var value = this.buffer.readUInt8(this.offset);
                    return this.offset += 1, value;
                },
                nextInt8: function() {
                    var value = this.buffer.readInt8(this.offset);
                    return this.offset += 1, value;
                },
                nextUInt16: function() {
                    var value = this.bigEndian ? this.buffer.readUInt16BE(this.offset) : this.buffer.readUInt16LE(this.offset);
                    return this.offset += 2, value;
                },
                nextUInt32: function() {
                    var value = this.bigEndian ? this.buffer.readUInt32BE(this.offset) : this.buffer.readUInt32LE(this.offset);
                    return this.offset += 4, value;
                },
                nextInt16: function() {
                    var value = this.bigEndian ? this.buffer.readInt16BE(this.offset) : this.buffer.readInt16LE(this.offset);
                    return this.offset += 2, value;
                },
                nextInt32: function() {
                    var value = this.bigEndian ? this.buffer.readInt32BE(this.offset) : this.buffer.readInt32LE(this.offset);
                    return this.offset += 4, value;
                },
                nextFloat: function() {
                    var value = this.bigEndian ? this.buffer.readFloatBE(this.offset) : this.buffer.readFloatLE(this.offset);
                    return this.offset += 4, value;
                },
                nextDouble: function() {
                    var value = this.bigEndian ? this.buffer.readDoubleBE(this.offset) : this.buffer.readDoubleLE(this.offset);
                    return this.offset += 8, value;
                },
                nextBuffer: function(length) {
                    var value = this.buffer.slice(this.offset, this.offset + length);
                    return this.offset += length, value;
                },
                remainingLength: function() {
                    return this.endPosition - this.offset;
                },
                nextString: function(length) {
                    var value = this.buffer.toString("utf8", this.offset, this.offset + length);
                    return this.offset += length, value;
                },
                mark: function() {
                    var self = this;
                    return {
                        openWithOffset: function(offset) {
                            return offset = (offset || 0) + this.offset, new BufferStream(self.buffer, offset, self.endPosition - offset, self.bigEndian);
                        },
                        offset: this.offset
                    };
                },
                offsetFrom: function(marker) {
                    return this.offset - marker.offset;
                },
                skip: function(amount) {
                    this.offset += amount;
                },
                branch: function(offset, length) {
                    return length = "number" == typeof length ? length : this.endPosition - (this.offset + offset), 
                    new BufferStream(this.buffer, this.offset + offset, length, this.bigEndian);
                }
            }, module.exports = BufferStream;
        }, {} ],
        55: [ function(require, module, exports) {
            function parseNumber(s) {
                return parseInt(s, 10);
            }
            function parseDateTimeParts(dateParts, timeParts) {
                dateParts = dateParts.map(parseNumber), timeParts = timeParts.map(parseNumber);
                var year = dateParts[0], month = dateParts[1] - 1, day = dateParts[2], hours = timeParts[0], minutes = timeParts[1], seconds = timeParts[2];
                return Date.UTC(year, month, day, hours, minutes, seconds, 0) / 1000;
            }
            function parseDateWithTimezoneFormat(dateTimeStr) {
                var dateParts = dateTimeStr.substr(0, 10).split("-"), timeParts = dateTimeStr.substr(11, 8).split(":"), timezoneParts = dateTimeStr.substr(19, 6).split(":").map(parseNumber), timezoneOffset = 3600 * timezoneParts[0] + 60 * timezoneParts[1], timestamp = parseDateTimeParts(dateParts, timeParts);
                if ("number" == typeof (timestamp -= timezoneOffset) && !isNaN(timestamp)) return timestamp;
            }
            function parseDateWithSpecFormat(dateTimeStr) {
                var parts = dateTimeStr.split(" "), timestamp = parseDateTimeParts(parts[0].split(":"), parts[1].split(":"));
                if ("number" == typeof timestamp && !isNaN(timestamp)) return timestamp;
            }
            module.exports = {
                parseDateWithSpecFormat,
                parseDateWithTimezoneFormat,
                parseExifDate: function parseExifDate(dateTimeStr) {
                    var isSpecFormat = 19 === dateTimeStr.length && ":" === dateTimeStr.charAt(4);
                    return 25 === dateTimeStr.length && "T" === dateTimeStr.charAt(10) ? parseDateWithTimezoneFormat(dateTimeStr) : isSpecFormat ? parseDateWithSpecFormat(dateTimeStr) : void 0;
                }
            };
        }, {} ],
        56: [ function(require, module, exports) {
            function DOMBufferStream(arrayBuffer, offset, length, bigEndian, global, parentOffset) {
                this.global = global, offset = offset || 0, length = length || arrayBuffer.byteLength - offset, 
                this.arrayBuffer = arrayBuffer.slice(offset, offset + length), this.view = new global.DataView(this.arrayBuffer, 0, this.arrayBuffer.byteLength), 
                this.setBigEndian(bigEndian), this.offset = 0, this.parentOffset = (parentOffset || 0) + offset;
            }
            DOMBufferStream.prototype = {
                setBigEndian: function(bigEndian) {
                    this.littleEndian = !bigEndian;
                },
                nextUInt8: function() {
                    var value = this.view.getUint8(this.offset);
                    return this.offset += 1, value;
                },
                nextInt8: function() {
                    var value = this.view.getInt8(this.offset);
                    return this.offset += 1, value;
                },
                nextUInt16: function() {
                    var value = this.view.getUint16(this.offset, this.littleEndian);
                    return this.offset += 2, value;
                },
                nextUInt32: function() {
                    var value = this.view.getUint32(this.offset, this.littleEndian);
                    return this.offset += 4, value;
                },
                nextInt16: function() {
                    var value = this.view.getInt16(this.offset, this.littleEndian);
                    return this.offset += 2, value;
                },
                nextInt32: function() {
                    var value = this.view.getInt32(this.offset, this.littleEndian);
                    return this.offset += 4, value;
                },
                nextFloat: function() {
                    var value = this.view.getFloat32(this.offset, this.littleEndian);
                    return this.offset += 4, value;
                },
                nextDouble: function() {
                    var value = this.view.getFloat64(this.offset, this.littleEndian);
                    return this.offset += 8, value;
                },
                nextBuffer: function(length) {
                    var value = this.arrayBuffer.slice(this.offset, this.offset + length);
                    return this.offset += length, value;
                },
                remainingLength: function() {
                    return this.arrayBuffer.byteLength - this.offset;
                },
                nextString: function(length) {
                    var value = this.arrayBuffer.slice(this.offset, this.offset + length);
                    return value = String.fromCharCode.apply(null, new this.global.Uint8Array(value)), 
                    this.offset += length, value;
                },
                mark: function() {
                    var self = this;
                    return {
                        openWithOffset: function(offset) {
                            return offset = (offset || 0) + this.offset, new DOMBufferStream(self.arrayBuffer, offset, self.arrayBuffer.byteLength - offset, !self.littleEndian, self.global, self.parentOffset);
                        },
                        offset: this.offset,
                        getParentOffset: function() {
                            return self.parentOffset;
                        }
                    };
                },
                offsetFrom: function(marker) {
                    return this.parentOffset + this.offset - (marker.offset + marker.getParentOffset());
                },
                skip: function(amount) {
                    this.offset += amount;
                },
                branch: function(offset, length) {
                    return length = "number" == typeof length ? length : this.arrayBuffer.byteLength - (this.offset + offset), 
                    new DOMBufferStream(this.arrayBuffer, this.offset + offset, length, !this.littleEndian, this.global, this.parentOffset);
                }
            }, module.exports = DOMBufferStream;
        }, {} ],
        57: [ function(require, module, exports) {
            module.exports = {
                exif: {
                    1: "InteropIndex",
                    2: "InteropVersion",
                    11: "ProcessingSoftware",
                    254: "SubfileType",
                    255: "OldSubfileType",
                    256: "ImageWidth",
                    257: "ImageHeight",
                    258: "BitsPerSample",
                    259: "Compression",
                    262: "PhotometricInterpretation",
                    263: "Thresholding",
                    264: "CellWidth",
                    265: "CellLength",
                    266: "FillOrder",
                    269: "DocumentName",
                    270: "ImageDescription",
                    271: "Make",
                    272: "Model",
                    273: "StripOffsets",
                    274: "Orientation",
                    277: "SamplesPerPixel",
                    278: "RowsPerStrip",
                    279: "StripByteCounts",
                    280: "MinSampleValue",
                    281: "MaxSampleValue",
                    282: "XResolution",
                    283: "YResolution",
                    284: "PlanarConfiguration",
                    285: "PageName",
                    286: "XPosition",
                    287: "YPosition",
                    288: "FreeOffsets",
                    289: "FreeByteCounts",
                    290: "GrayResponseUnit",
                    291: "GrayResponseCurve",
                    292: "T4Options",
                    293: "T6Options",
                    296: "ResolutionUnit",
                    297: "PageNumber",
                    300: "ColorResponseUnit",
                    301: "TransferFunction",
                    305: "Software",
                    306: "ModifyDate",
                    315: "Artist",
                    316: "HostComputer",
                    317: "Predictor",
                    318: "WhitePoint",
                    319: "PrimaryChromaticities",
                    320: "ColorMap",
                    321: "HalftoneHints",
                    322: "TileWidth",
                    323: "TileLength",
                    324: "TileOffsets",
                    325: "TileByteCounts",
                    326: "BadFaxLines",
                    327: "CleanFaxData",
                    328: "ConsecutiveBadFaxLines",
                    330: "SubIFD",
                    332: "InkSet",
                    333: "InkNames",
                    334: "NumberofInks",
                    336: "DotRange",
                    337: "TargetPrinter",
                    338: "ExtraSamples",
                    339: "SampleFormat",
                    340: "SMinSampleValue",
                    341: "SMaxSampleValue",
                    342: "TransferRange",
                    343: "ClipPath",
                    344: "XClipPathUnits",
                    345: "YClipPathUnits",
                    346: "Indexed",
                    347: "JPEGTables",
                    351: "OPIProxy",
                    400: "GlobalParametersIFD",
                    401: "ProfileType",
                    402: "FaxProfile",
                    403: "CodingMethods",
                    404: "VersionYear",
                    405: "ModeNumber",
                    433: "Decode",
                    434: "DefaultImageColor",
                    435: "T82Options",
                    437: "JPEGTables",
                    512: "JPEGProc",
                    513: "ThumbnailOffset",
                    514: "ThumbnailLength",
                    515: "JPEGRestartInterval",
                    517: "JPEGLosslessPredictors",
                    518: "JPEGPointTransforms",
                    519: "JPEGQTables",
                    520: "JPEGDCTables",
                    521: "JPEGACTables",
                    529: "YCbCrCoefficients",
                    530: "YCbCrSubSampling",
                    531: "YCbCrPositioning",
                    532: "ReferenceBlackWhite",
                    559: "StripRowCounts",
                    700: "ApplicationNotes",
                    999: "USPTOMiscellaneous",
                    4096: "RelatedImageFileFormat",
                    4097: "RelatedImageWidth",
                    4098: "RelatedImageHeight",
                    18246: "Rating",
                    18247: "XP_DIP_XML",
                    18248: "StitchInfo",
                    18249: "RatingPercent",
                    32781: "ImageID",
                    32931: "WangTag1",
                    32932: "WangAnnotation",
                    32933: "WangTag3",
                    32934: "WangTag4",
                    32995: "Matteing",
                    32996: "DataType",
                    32997: "ImageDepth",
                    32998: "TileDepth",
                    33405: "Model2",
                    33421: "CFARepeatPatternDim",
                    33422: "CFAPattern2",
                    33423: "BatteryLevel",
                    33424: "KodakIFD",
                    33432: "Copyright",
                    33434: "ExposureTime",
                    33437: "FNumber",
                    33445: "MDFileTag",
                    33446: "MDScalePixel",
                    33447: "MDColorTable",
                    33448: "MDLabName",
                    33449: "MDSampleInfo",
                    33450: "MDPrepDate",
                    33451: "MDPrepTime",
                    33452: "MDFileUnits",
                    33550: "PixelScale",
                    33589: "AdventScale",
                    33590: "AdventRevision",
                    33628: "UIC1Tag",
                    33629: "UIC2Tag",
                    33630: "UIC3Tag",
                    33631: "UIC4Tag",
                    33723: "IPTC-NAA",
                    33918: "IntergraphPacketData",
                    33919: "IntergraphFlagRegisters",
                    33920: "IntergraphMatrix",
                    33921: "INGRReserved",
                    33922: "ModelTiePoint",
                    34016: "Site",
                    34017: "ColorSequence",
                    34018: "IT8Header",
                    34019: "RasterPadding",
                    34020: "BitsPerRunLength",
                    34021: "BitsPerExtendedRunLength",
                    34022: "ColorTable",
                    34023: "ImageColorIndicator",
                    34024: "BackgroundColorIndicator",
                    34025: "ImageColorValue",
                    34026: "BackgroundColorValue",
                    34027: "PixelIntensityRange",
                    34028: "TransparencyIndicator",
                    34029: "ColorCharacterization",
                    34030: "HCUsage",
                    34031: "TrapIndicator",
                    34032: "CMYKEquivalent",
                    34118: "SEMInfo",
                    34152: "AFCP_IPTC",
                    34232: "PixelMagicJBIGOptions",
                    34264: "ModelTransform",
                    34306: "WB_GRGBLevels",
                    34310: "LeafData",
                    34377: "PhotoshopSettings",
                    34665: "ExifOffset",
                    34675: "ICC_Profile",
                    34687: "TIFF_FXExtensions",
                    34688: "MultiProfiles",
                    34689: "SharedData",
                    34690: "T88Options",
                    34732: "ImageLayer",
                    34735: "GeoTiffDirectory",
                    34736: "GeoTiffDoubleParams",
                    34737: "GeoTiffAsciiParams",
                    34850: "ExposureProgram",
                    34852: "SpectralSensitivity",
                    34853: "GPSInfo",
                    34855: "ISO",
                    34856: "Opto-ElectricConvFactor",
                    34857: "Interlace",
                    34858: "TimeZoneOffset",
                    34859: "SelfTimerMode",
                    34864: "SensitivityType",
                    34865: "StandardOutputSensitivity",
                    34866: "RecommendedExposureIndex",
                    34867: "ISOSpeed",
                    34868: "ISOSpeedLatitudeyyy",
                    34869: "ISOSpeedLatitudezzz",
                    34908: "FaxRecvParams",
                    34909: "FaxSubAddress",
                    34910: "FaxRecvTime",
                    34954: "LeafSubIFD",
                    36864: "ExifVersion",
                    36867: "DateTimeOriginal",
                    36868: "CreateDate",
                    37121: "ComponentsConfiguration",
                    37122: "CompressedBitsPerPixel",
                    37377: "ShutterSpeedValue",
                    37378: "ApertureValue",
                    37379: "BrightnessValue",
                    37380: "ExposureCompensation",
                    37381: "MaxApertureValue",
                    37382: "SubjectDistance",
                    37383: "MeteringMode",
                    37384: "LightSource",
                    37385: "Flash",
                    37386: "FocalLength",
                    37387: "FlashEnergy",
                    37388: "SpatialFrequencyResponse",
                    37389: "Noise",
                    37390: "FocalPlaneXResolution",
                    37391: "FocalPlaneYResolution",
                    37392: "FocalPlaneResolutionUnit",
                    37393: "ImageNumber",
                    37394: "SecurityClassification",
                    37395: "ImageHistory",
                    37396: "SubjectArea",
                    37397: "ExposureIndex",
                    37398: "TIFF-EPStandardID",
                    37399: "SensingMethod",
                    37434: "CIP3DataFile",
                    37435: "CIP3Sheet",
                    37436: "CIP3Side",
                    37439: "StoNits",
                    37500: "MakerNote",
                    37510: "UserComment",
                    37520: "SubSecTime",
                    37521: "SubSecTimeOriginal",
                    37522: "SubSecTimeDigitized",
                    37679: "MSDocumentText",
                    37680: "MSPropertySetStorage",
                    37681: "MSDocumentTextPosition",
                    37724: "ImageSourceData",
                    40091: "XPTitle",
                    40092: "XPComment",
                    40093: "XPAuthor",
                    40094: "XPKeywords",
                    40095: "XPSubject",
                    40960: "FlashpixVersion",
                    40961: "ColorSpace",
                    40962: "ExifImageWidth",
                    40963: "ExifImageHeight",
                    40964: "RelatedSoundFile",
                    40965: "InteropOffset",
                    41483: "FlashEnergy",
                    41484: "SpatialFrequencyResponse",
                    41485: "Noise",
                    41486: "FocalPlaneXResolution",
                    41487: "FocalPlaneYResolution",
                    41488: "FocalPlaneResolutionUnit",
                    41489: "ImageNumber",
                    41490: "SecurityClassification",
                    41491: "ImageHistory",
                    41492: "SubjectLocation",
                    41493: "ExposureIndex",
                    41494: "TIFF-EPStandardID",
                    41495: "SensingMethod",
                    41728: "FileSource",
                    41729: "SceneType",
                    41730: "CFAPattern",
                    41985: "CustomRendered",
                    41986: "ExposureMode",
                    41987: "WhiteBalance",
                    41988: "DigitalZoomRatio",
                    41989: "FocalLengthIn35mmFormat",
                    41990: "SceneCaptureType",
                    41991: "GainControl",
                    41992: "Contrast",
                    41993: "Saturation",
                    41994: "Sharpness",
                    41995: "DeviceSettingDescription",
                    41996: "SubjectDistanceRange",
                    42016: "ImageUniqueID",
                    42032: "OwnerName",
                    42033: "SerialNumber",
                    42034: "LensInfo",
                    42035: "LensMake",
                    42036: "LensModel",
                    42037: "LensSerialNumber",
                    42112: "GDALMetadata",
                    42113: "GDALNoData",
                    42240: "Gamma",
                    44992: "ExpandSoftware",
                    44993: "ExpandLens",
                    44994: "ExpandFilm",
                    44995: "ExpandFilterLens",
                    44996: "ExpandScanner",
                    44997: "ExpandFlashLamp",
                    48129: "PixelFormat",
                    48130: "Transformation",
                    48131: "Uncompressed",
                    48132: "ImageType",
                    48256: "ImageWidth",
                    48257: "ImageHeight",
                    48258: "WidthResolution",
                    48259: "HeightResolution",
                    48320: "ImageOffset",
                    48321: "ImageByteCount",
                    48322: "AlphaOffset",
                    48323: "AlphaByteCount",
                    48324: "ImageDataDiscard",
                    48325: "AlphaDataDiscard",
                    50215: "OceScanjobDesc",
                    50216: "OceApplicationSelector",
                    50217: "OceIDNumber",
                    50218: "OceImageLogic",
                    50255: "Annotations",
                    50341: "PrintIM",
                    50560: "USPTOOriginalContentType",
                    50706: "DNGVersion",
                    50707: "DNGBackwardVersion",
                    50708: "UniqueCameraModel",
                    50709: "LocalizedCameraModel",
                    50710: "CFAPlaneColor",
                    50711: "CFALayout",
                    50712: "LinearizationTable",
                    50713: "BlackLevelRepeatDim",
                    50714: "BlackLevel",
                    50715: "BlackLevelDeltaH",
                    50716: "BlackLevelDeltaV",
                    50717: "WhiteLevel",
                    50718: "DefaultScale",
                    50719: "DefaultCropOrigin",
                    50720: "DefaultCropSize",
                    50721: "ColorMatrix1",
                    50722: "ColorMatrix2",
                    50723: "CameraCalibration1",
                    50724: "CameraCalibration2",
                    50725: "ReductionMatrix1",
                    50726: "ReductionMatrix2",
                    50727: "AnalogBalance",
                    50728: "AsShotNeutral",
                    50729: "AsShotWhiteXY",
                    50730: "BaselineExposure",
                    50731: "BaselineNoise",
                    50732: "BaselineSharpness",
                    50733: "BayerGreenSplit",
                    50734: "LinearResponseLimit",
                    50735: "CameraSerialNumber",
                    50736: "DNGLensInfo",
                    50737: "ChromaBlurRadius",
                    50738: "AntiAliasStrength",
                    50739: "ShadowScale",
                    50740: "DNGPrivateData",
                    50741: "MakerNoteSafety",
                    50752: "RawImageSegmentation",
                    50778: "CalibrationIlluminant1",
                    50779: "CalibrationIlluminant2",
                    50780: "BestQualityScale",
                    50781: "RawDataUniqueID",
                    50784: "AliasLayerMetadata",
                    50827: "OriginalRawFileName",
                    50828: "OriginalRawFileData",
                    50829: "ActiveArea",
                    50830: "MaskedAreas",
                    50831: "AsShotICCProfile",
                    50832: "AsShotPreProfileMatrix",
                    50833: "CurrentICCProfile",
                    50834: "CurrentPreProfileMatrix",
                    50879: "ColorimetricReference",
                    50898: "PanasonicTitle",
                    50899: "PanasonicTitle2",
                    50931: "CameraCalibrationSig",
                    50932: "ProfileCalibrationSig",
                    50933: "ProfileIFD",
                    50934: "AsShotProfileName",
                    50935: "NoiseReductionApplied",
                    50936: "ProfileName",
                    50937: "ProfileHueSatMapDims",
                    50938: "ProfileHueSatMapData1",
                    50939: "ProfileHueSatMapData2",
                    50940: "ProfileToneCurve",
                    50941: "ProfileEmbedPolicy",
                    50942: "ProfileCopyright",
                    50964: "ForwardMatrix1",
                    50965: "ForwardMatrix2",
                    50966: "PreviewApplicationName",
                    50967: "PreviewApplicationVersion",
                    50968: "PreviewSettingsName",
                    50969: "PreviewSettingsDigest",
                    50970: "PreviewColorSpace",
                    50971: "PreviewDateTime",
                    50972: "RawImageDigest",
                    50973: "OriginalRawFileDigest",
                    50974: "SubTileBlockSize",
                    50975: "RowInterleaveFactor",
                    50981: "ProfileLookTableDims",
                    50982: "ProfileLookTableData",
                    51008: "OpcodeList1",
                    51009: "OpcodeList2",
                    51022: "OpcodeList3",
                    51041: "NoiseProfile",
                    51043: "TimeCodes",
                    51044: "FrameRate",
                    51058: "TStop",
                    51081: "ReelName",
                    51089: "OriginalDefaultFinalSize",
                    51090: "OriginalBestQualitySize",
                    51091: "OriginalDefaultCropSize",
                    51105: "CameraLabel",
                    51107: "ProfileHueSatMapEncoding",
                    51108: "ProfileLookTableEncoding",
                    51109: "BaselineExposureOffset",
                    51110: "DefaultBlackRender",
                    51111: "NewRawImageDigest",
                    51112: "RawToPreviewGain",
                    51125: "DefaultUserCrop",
                    59932: "Padding",
                    59933: "OffsetSchema",
                    65000: "OwnerName",
                    65001: "SerialNumber",
                    65002: "Lens",
                    65024: "KDC_IFD",
                    65100: "RawFile",
                    65101: "Converter",
                    65102: "WhiteBalance",
                    65105: "Exposure",
                    65106: "Shadows",
                    65107: "Brightness",
                    65108: "Contrast",
                    65109: "Saturation",
                    65110: "Sharpness",
                    65111: "Smoothness",
                    65112: "MoireFilter"
                },
                gps: {
                    0: "GPSVersionID",
                    1: "GPSLatitudeRef",
                    2: "GPSLatitude",
                    3: "GPSLongitudeRef",
                    4: "GPSLongitude",
                    5: "GPSAltitudeRef",
                    6: "GPSAltitude",
                    7: "GPSTimeStamp",
                    8: "GPSSatellites",
                    9: "GPSStatus",
                    10: "GPSMeasureMode",
                    11: "GPSDOP",
                    12: "GPSSpeedRef",
                    13: "GPSSpeed",
                    14: "GPSTrackRef",
                    15: "GPSTrack",
                    16: "GPSImgDirectionRef",
                    17: "GPSImgDirection",
                    18: "GPSMapDatum",
                    19: "GPSDestLatitudeRef",
                    20: "GPSDestLatitude",
                    21: "GPSDestLongitudeRef",
                    22: "GPSDestLongitude",
                    23: "GPSDestBearingRef",
                    24: "GPSDestBearing",
                    25: "GPSDestDistanceRef",
                    26: "GPSDestDistance",
                    27: "GPSProcessingMethod",
                    28: "GPSAreaInformation",
                    29: "GPSDateStamp",
                    30: "GPSDifferential",
                    31: "GPSHPositioningError"
                }
            };
        }, {} ],
        58: [ function(require, module, exports) {
            function readExifValue(format, stream) {
                switch (format) {
                  case 1:
                    return stream.nextUInt8();

                  case 3:
                  case 8:
                    return stream.nextUInt16();

                  case 4:
                  case 9:
                    return stream.nextUInt32();

                  case 5:
                    return [ stream.nextUInt32(), stream.nextUInt32() ];

                  case 6:
                    return stream.nextInt8();

                  case 10:
                    return [ stream.nextInt32(), stream.nextInt32() ];

                  case 11:
                    return stream.nextFloat();

                  case 12:
                    return stream.nextDouble();

                  default:
                    throw new Error("Invalid format while decoding: " + format);
                }
            }
            function readExifTag(tiffMarker, stream) {
                var values, c, tagType = stream.nextUInt16(), format = stream.nextUInt16(), bytesPerComponent = function getBytesPerComponent(format) {
                    switch (format) {
                      case 1:
                      case 2:
                      case 6:
                      case 7:
                        return 1;

                      case 3:
                      case 8:
                        return 2;

                      case 4:
                      case 9:
                      case 11:
                        return 4;

                      case 5:
                      case 10:
                      case 12:
                        return 8;

                      default:
                        return 0;
                    }
                }(format), components = stream.nextUInt32(), valueBytes = bytesPerComponent * components;
                if (valueBytes > 4 && (stream = tiffMarker.openWithOffset(stream.nextUInt32())), 
                2 === format) {
                    var lastNull = (values = stream.nextString(components)).indexOf("\0");
                    -1 !== lastNull && (values = values.substr(0, lastNull));
                } else if (7 === format) values = stream.nextBuffer(components); else if (0 !== format) for (values = [], 
                c = 0; c < components; ++c) values.push(readExifValue(format, stream));
                return valueBytes < 4 && stream.skip(4 - valueBytes), [ tagType, values, format ];
            }
            function readIFDSection(tiffMarker, stream, iterator) {
                var tag, i, numberOfEntries = stream.nextUInt16();
                for (i = 0; i < numberOfEntries; ++i) iterator((tag = readExifTag(tiffMarker, stream))[0], tag[1], tag[2]);
            }
            module.exports = {
                IFD0: 1,
                IFD1: 2,
                GPSIFD: 3,
                SubIFD: 4,
                InteropIFD: 5,
                parseTags: function(stream, iterator) {
                    var tiffMarker, subIfdOffset, gpsOffset, interopOffset;
                    try {
                        tiffMarker = function readHeader(stream) {
                            if ("Exif\0\0" !== stream.nextString(6)) throw new Error("Invalid EXIF header");
                            var tiffMarker = stream.mark(), tiffHeader = stream.nextUInt16();
                            if (0x4949 === tiffHeader) stream.setBigEndian(!1); else {
                                if (0x4D4D !== tiffHeader) throw new Error("Invalid TIFF header");
                                stream.setBigEndian(!0);
                            }
                            if (0x002A !== stream.nextUInt16()) throw new Error("Invalid TIFF data");
                            return tiffMarker;
                        }(stream);
                    } catch (e) {
                        return !1;
                    }
                    var ifd0Stream = tiffMarker.openWithOffset(stream.nextUInt32()), IFD0 = this.IFD0;
                    readIFDSection(tiffMarker, ifd0Stream, (function(tagType, value, format) {
                        switch (tagType) {
                          case 0x8825:
                            gpsOffset = value[0];
                            break;

                          case 0x8769:
                            subIfdOffset = value[0];
                            break;

                          default:
                            iterator(IFD0, tagType, value, format);
                        }
                    }));
                    var ifd1Offset = ifd0Stream.nextUInt32();
                    if (0 !== ifd1Offset) {
                        var ifd1Stream = tiffMarker.openWithOffset(ifd1Offset);
                        readIFDSection(tiffMarker, ifd1Stream, iterator.bind(null, this.IFD1));
                    }
                    if (gpsOffset) {
                        var gpsStream = tiffMarker.openWithOffset(gpsOffset);
                        readIFDSection(tiffMarker, gpsStream, iterator.bind(null, this.GPSIFD));
                    }
                    if (subIfdOffset) {
                        var subIfdStream = tiffMarker.openWithOffset(subIfdOffset), InteropIFD = this.InteropIFD;
                        readIFDSection(tiffMarker, subIfdStream, (function(tagType, value, format) {
                            0xA005 === tagType ? interopOffset = value[0] : iterator(InteropIFD, tagType, value, format);
                        }));
                    }
                    if (interopOffset) {
                        var interopStream = tiffMarker.openWithOffset(interopOffset);
                        readIFDSection(tiffMarker, interopStream, iterator.bind(null, this.InteropIFD));
                    }
                    return !0;
                }
            };
        }, {} ],
        59: [ function(require, module, exports) {
            module.exports = {
                parseSections: function(stream, iterator) {
                    var len, markerType;
                    for (stream.setBigEndian(!0); stream.remainingLength() > 0 && 0xDA !== markerType; ) {
                        if (0xFF !== stream.nextUInt8()) throw new Error("Invalid JPEG section offset");
                        len = (markerType = stream.nextUInt8()) >= 0xD0 && markerType <= 0xD9 || 0xDA === markerType ? 0 : stream.nextUInt16() - 2, 
                        iterator(markerType, stream.branch(0, len)), stream.skip(len);
                    }
                },
                getSizeFromSOFSection: function(stream) {
                    return stream.skip(1), {
                        height: stream.nextUInt16(),
                        width: stream.nextUInt16()
                    };
                },
                getSectionName: function(markerType) {
                    var name, index;
                    switch (markerType) {
                      case 0xD8:
                        name = "SOI";
                        break;

                      case 0xC4:
                        name = "DHT";
                        break;

                      case 0xDB:
                        name = "DQT";
                        break;

                      case 0xDD:
                        name = "DRI";
                        break;

                      case 0xDA:
                        name = "SOS";
                        break;

                      case 0xFE:
                        name = "COM";
                        break;

                      case 0xD9:
                        name = "EOI";
                        break;

                      default:
                        markerType >= 0xE0 && markerType <= 0xEF ? (name = "APP", index = markerType - 0xE0) : markerType >= 0xC0 && markerType <= 0xCF && 0xC4 !== markerType && 0xC8 !== markerType && 0xCC !== markerType ? (name = "SOF", 
                        index = markerType - 0xC0) : markerType >= 0xD0 && markerType <= 0xD7 && (name = "RST", 
                        index = markerType - 0xD0);
                    }
                    var nameStruct = {
                        name
                    };
                    return "number" == typeof index && (nameStruct.index = index), nameStruct;
                }
            };
        }, {} ],
        60: [ function(require, module, exports) {
            var jpeg = require("./jpeg"), exif = require("./exif"), simplify = require("./simplify");
            function ExifResult(startMarker, tags, imageSize, thumbnailOffset, thumbnailLength, thumbnailType, app1Offset) {
                this.startMarker = startMarker, this.tags = tags, this.imageSize = imageSize, this.thumbnailOffset = thumbnailOffset, 
                this.thumbnailLength = thumbnailLength, this.thumbnailType = thumbnailType, this.app1Offset = app1Offset;
            }
            function Parser(stream) {
                this.stream = stream, this.flags = {
                    readBinaryTags: !1,
                    resolveTagNames: !0,
                    simplifyValues: !0,
                    imageSize: !0,
                    hidePointers: !0,
                    returnTags: !0
                };
            }
            ExifResult.prototype = {
                hasThumbnail: function(mime) {
                    return !(!this.thumbnailOffset || !this.thumbnailLength || "string" == typeof mime && ("image/jpeg" === mime.toLowerCase().trim() ? 6 !== this.thumbnailType : "image/tiff" !== mime.toLowerCase().trim() || 1 !== this.thumbnailType));
                },
                getThumbnailOffset: function() {
                    return this.app1Offset + 6 + this.thumbnailOffset;
                },
                getThumbnailLength: function() {
                    return this.thumbnailLength;
                },
                getThumbnailBuffer: function() {
                    return this._getThumbnailStream().nextBuffer(this.thumbnailLength);
                },
                _getThumbnailStream: function() {
                    return this.startMarker.openWithOffset(this.getThumbnailOffset());
                },
                getImageSize: function() {
                    return this.imageSize;
                },
                getThumbnailSize: function() {
                    var size, stream = this._getThumbnailStream();
                    return jpeg.parseSections(stream, (function(sectionType, sectionStream) {
                        "SOF" === jpeg.getSectionName(sectionType).name && (size = jpeg.getSizeFromSOFSection(sectionStream));
                    })), size;
                }
            }, Parser.prototype = {
                enableBinaryFields: function(enable) {
                    return this.flags.readBinaryTags = !!enable, this;
                },
                enablePointers: function(enable) {
                    return this.flags.hidePointers = !enable, this;
                },
                enableTagNames: function(enable) {
                    return this.flags.resolveTagNames = !!enable, this;
                },
                enableImageSize: function(enable) {
                    return this.flags.imageSize = !!enable, this;
                },
                enableReturnTags: function(enable) {
                    return this.flags.returnTags = !!enable, this;
                },
                enableSimpleValues: function(enable) {
                    return this.flags.simplifyValues = !!enable, this;
                },
                parse: function() {
                    var tags, imageSize, thumbnailOffset, thumbnailLength, thumbnailType, app1Offset, tagNames, getTagValue, setTagValue, start = this.stream.mark(), stream = start.openWithOffset(0), flags = this.flags;
                    return flags.resolveTagNames && (tagNames = require("./exif-tags")), flags.resolveTagNames ? (tags = {}, 
                    getTagValue = function(t) {
                        return tags[t.name];
                    }, setTagValue = function(t, value) {
                        tags[t.name] = value;
                    }) : (tags = [], getTagValue = function(t) {
                        var i;
                        for (i = 0; i < tags.length; ++i) if (tags[i].type === t.type && tags[i].section === t.section) return tags.value;
                    }, setTagValue = function(t, value) {
                        var i;
                        for (i = 0; i < tags.length; ++i) if (tags[i].type === t.type && tags[i].section === t.section) return void (tags.value = value);
                    }), jpeg.parseSections(stream, (function(sectionType, sectionStream) {
                        var sectionOffset = sectionStream.offsetFrom(start);
                        0xE1 === sectionType ? exif.parseTags(sectionStream, (function(ifdSection, tagType, value, format) {
                            if (flags.readBinaryTags || 7 !== format) {
                                if (0x0201 === tagType) {
                                    if (thumbnailOffset = value[0], flags.hidePointers) return;
                                } else if (0x0202 === tagType) {
                                    if (thumbnailLength = value[0], flags.hidePointers) return;
                                } else if (0x0103 === tagType && (thumbnailType = value[0], flags.hidePointers)) return;
                                if (flags.returnTags) if (flags.simplifyValues && (value = simplify.simplifyValue(value, format)), 
                                flags.resolveTagNames) {
                                    var name = (ifdSection === exif.GPSIFD ? tagNames.gps : tagNames.exif)[tagType];
                                    name || (name = tagNames.exif[tagType]), tags.hasOwnProperty(name) || (tags[name] = value);
                                } else tags.push({
                                    section: ifdSection,
                                    type: tagType,
                                    value
                                });
                            }
                        })) && (app1Offset = sectionOffset) : flags.imageSize && "SOF" === jpeg.getSectionName(sectionType).name && (imageSize = jpeg.getSizeFromSOFSection(sectionStream));
                    })), flags.simplifyValues && (simplify.castDegreeValues(getTagValue, setTagValue), 
                    simplify.castDateValues(getTagValue, setTagValue)), new ExifResult(start, tags, imageSize, thumbnailOffset, thumbnailLength, thumbnailType, app1Offset);
                }
            }, module.exports = Parser;
        }, {
            "./exif": 58,
            "./exif-tags": 57,
            "./jpeg": 59,
            "./simplify": 61
        } ],
        61: [ function(require, module, exports) {
            var exif = require("./exif"), date = require("./date"), degreeTags = [ {
                section: exif.GPSIFD,
                type: 0x0002,
                name: "GPSLatitude",
                refType: 0x0001,
                refName: "GPSLatitudeRef",
                posVal: "N"
            }, {
                section: exif.GPSIFD,
                type: 0x0004,
                name: "GPSLongitude",
                refType: 0x0003,
                refName: "GPSLongitudeRef",
                posVal: "E"
            } ], dateTags = [ {
                section: exif.SubIFD,
                type: 0x0132,
                name: "ModifyDate"
            }, {
                section: exif.SubIFD,
                type: 0x9003,
                name: "DateTimeOriginal"
            }, {
                section: exif.SubIFD,
                type: 0x9004,
                name: "CreateDate"
            }, {
                section: exif.SubIFD,
                type: 0x0132,
                name: "ModifyDate"
            } ];
            module.exports = {
                castDegreeValues: function(getTagValue, setTagValue) {
                    degreeTags.forEach((function(t) {
                        var degreeVal = getTagValue(t);
                        if (degreeVal) {
                            var degreeNumRef = getTagValue({
                                section: t.section,
                                type: t.refType,
                                name: t.refName
                            }) === t.posVal ? 1 : -1, degree = (degreeVal[0] + degreeVal[1] / 60 + degreeVal[2] / 3600) * degreeNumRef;
                            setTagValue(t, degree);
                        }
                    }));
                },
                castDateValues: function(getTagValue, setTagValue) {
                    dateTags.forEach((function(t) {
                        var dateStrVal = getTagValue(t);
                        if (dateStrVal) {
                            var timestamp = date.parseExifDate(dateStrVal);
                            void 0 !== timestamp && setTagValue(t, timestamp);
                        }
                    }));
                },
                simplifyValue: function(values, format) {
                    return Array.isArray(values) && 1 === (values = values.map((function(value) {
                        return 10 === format || 5 === format ? value[0] / value[1] : value;
                    }))).length && (values = values[0]), values;
                }
            };
        }, {
            "./date": 55,
            "./exif": 58
        } ],
        62: [ function(require, module, exports) {
            var _toConsumableArray2 = require("@babel/runtime/helpers/interopRequireDefault")(require("@babel/runtime/helpers/toConsumableArray")), toBytes = function toBytes(s) {
                return (0, _toConsumableArray2.default)(s).map((function(c) {
                    return c.charCodeAt(0);
                }));
            }, xpiZipFilename = toBytes("META-INF/mozilla.rsa"), oxmlContentTypes = toBytes("[Content_Types].xml"), oxmlRels = toBytes("_rels/.rels");
            module.exports = function(input) {
                var buf = input instanceof Uint8Array ? input : new Uint8Array(input);
                if (!(buf && buf.length > 1)) return null;
                var check = function check(header, options) {
                    options = Object.assign({
                        offset: 0
                    }, options);
                    for (var i = 0; i < header.length; i++) if (options.mask) {
                        if (header[i] !== (options.mask[i] & buf[i + options.offset])) return !1;
                    } else if (header[i] !== buf[i + options.offset]) return !1;
                    return !0;
                }, checkString = function checkString(header, options) {
                    return check(toBytes(header), options);
                };
                if (check([ 0xFF, 0xD8, 0xFF ])) return {
                    ext: "jpg",
                    mime: "image/jpeg"
                };
                if (check([ 0x89, 0x50, 0x4E, 0x47, 0x0D, 0x0A, 0x1A, 0x0A ])) return {
                    ext: "png",
                    mime: "image/png"
                };
                if (check([ 0x47, 0x49, 0x46 ])) return {
                    ext: "gif",
                    mime: "image/gif"
                };
                if (check([ 0x57, 0x45, 0x42, 0x50 ], {
                    offset: 8
                })) return {
                    ext: "webp",
                    mime: "image/webp"
                };
                if (check([ 0x46, 0x4C, 0x49, 0x46 ])) return {
                    ext: "flif",
                    mime: "image/flif"
                };
                if ((check([ 0x49, 0x49, 0x2A, 0x0 ]) || check([ 0x4D, 0x4D, 0x0, 0x2A ])) && check([ 0x43, 0x52 ], {
                    offset: 8
                })) return {
                    ext: "cr2",
                    mime: "image/x-canon-cr2"
                };
                if (check([ 0x49, 0x49, 0x2A, 0x0 ]) || check([ 0x4D, 0x4D, 0x0, 0x2A ])) return {
                    ext: "tif",
                    mime: "image/tiff"
                };
                if (check([ 0x42, 0x4D ])) return {
                    ext: "bmp",
                    mime: "image/bmp"
                };
                if (check([ 0x49, 0x49, 0xBC ])) return {
                    ext: "jxr",
                    mime: "image/vnd.ms-photo"
                };
                if (check([ 0x38, 0x42, 0x50, 0x53 ])) return {
                    ext: "psd",
                    mime: "image/vnd.adobe.photoshop"
                };
                if (check([ 0x50, 0x4B, 0x3, 0x4 ])) {
                    if (check([ 0x6D, 0x69, 0x6D, 0x65, 0x74, 0x79, 0x70, 0x65, 0x61, 0x70, 0x70, 0x6C, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6F, 0x6E, 0x2F, 0x65, 0x70, 0x75, 0x62, 0x2B, 0x7A, 0x69, 0x70 ], {
                        offset: 30
                    })) return {
                        ext: "epub",
                        mime: "application/epub+zip"
                    };
                    if (check(xpiZipFilename, {
                        offset: 30
                    })) return {
                        ext: "xpi",
                        mime: "application/x-xpinstall"
                    };
                    if (checkString("mimetypeapplication/vnd.oasis.opendocument.text", {
                        offset: 30
                    })) return {
                        ext: "odt",
                        mime: "application/vnd.oasis.opendocument.text"
                    };
                    if (checkString("mimetypeapplication/vnd.oasis.opendocument.spreadsheet", {
                        offset: 30
                    })) return {
                        ext: "ods",
                        mime: "application/vnd.oasis.opendocument.spreadsheet"
                    };
                    if (checkString("mimetypeapplication/vnd.oasis.opendocument.presentation", {
                        offset: 30
                    })) return {
                        ext: "odp",
                        mime: "application/vnd.oasis.opendocument.presentation"
                    };
                    var findNextZipHeaderIndex = function findNextZipHeaderIndex(arr) {
                        var startAt = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
                        return arr.findIndex((function(el, i, arr) {
                            return i >= startAt && 0x50 === arr[i] && 0x4B === arr[i + 1] && 0x3 === arr[i + 2] && 0x4 === arr[i + 3];
                        }));
                    }, zipHeaderIndex = 0, oxmlFound = !1, type = null;
                    do {
                        var offset = zipHeaderIndex + 30;
                        if (oxmlFound || (oxmlFound = check(oxmlContentTypes, {
                            offset
                        }) || check(oxmlRels, {
                            offset
                        })), type || (checkString("word/", {
                            offset
                        }) ? type = {
                            ext: "docx",
                            mime: "application/vnd.openxmlformats-officedocument.wordprocessingml.document"
                        } : checkString("ppt/", {
                            offset
                        }) ? type = {
                            ext: "pptx",
                            mime: "application/vnd.openxmlformats-officedocument.presentationml.presentation"
                        } : checkString("xl/", {
                            offset
                        }) && (type = {
                            ext: "xlsx",
                            mime: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
                        })), oxmlFound && type) return type;
                        zipHeaderIndex = findNextZipHeaderIndex(buf, offset);
                    } while (zipHeaderIndex >= 0);
                    if (type) return type;
                }
                if (check([ 0x50, 0x4B ]) && (0x3 === buf[2] || 0x5 === buf[2] || 0x7 === buf[2]) && (0x4 === buf[3] || 0x6 === buf[3] || 0x8 === buf[3])) return {
                    ext: "zip",
                    mime: "application/zip"
                };
                if (check([ 0x75, 0x73, 0x74, 0x61, 0x72 ], {
                    offset: 257
                })) return {
                    ext: "tar",
                    mime: "application/x-tar"
                };
                if (check([ 0x52, 0x61, 0x72, 0x21, 0x1A, 0x7 ]) && (0x0 === buf[6] || 0x1 === buf[6])) return {
                    ext: "rar",
                    mime: "application/x-rar-compressed"
                };
                if (check([ 0x1F, 0x8B, 0x8 ])) return {
                    ext: "gz",
                    mime: "application/gzip"
                };
                if (check([ 0x42, 0x5A, 0x68 ])) return {
                    ext: "bz2",
                    mime: "application/x-bzip2"
                };
                if (check([ 0x37, 0x7A, 0xBC, 0xAF, 0x27, 0x1C ])) return {
                    ext: "7z",
                    mime: "application/x-7z-compressed"
                };
                if (check([ 0x78, 0x01 ])) return {
                    ext: "dmg",
                    mime: "application/x-apple-diskimage"
                };
                if (check([ 0x33, 0x67, 0x70, 0x35 ]) || check([ 0x0, 0x0, 0x0 ]) && check([ 0x66, 0x74, 0x79, 0x70 ], {
                    offset: 4
                }) && (check([ 0x6D, 0x70, 0x34, 0x31 ], {
                    offset: 8
                }) || check([ 0x6D, 0x70, 0x34, 0x32 ], {
                    offset: 8
                }) || check([ 0x69, 0x73, 0x6F, 0x6D ], {
                    offset: 8
                }) || check([ 0x69, 0x73, 0x6F, 0x32 ], {
                    offset: 8
                }) || check([ 0x6D, 0x6D, 0x70, 0x34 ], {
                    offset: 8
                }) || check([ 0x4D, 0x34, 0x56 ], {
                    offset: 8
                }) || check([ 0x64, 0x61, 0x73, 0x68 ], {
                    offset: 8
                }))) return {
                    ext: "mp4",
                    mime: "video/mp4"
                };
                if (check([ 0x4D, 0x54, 0x68, 0x64 ])) return {
                    ext: "mid",
                    mime: "audio/midi"
                };
                if (check([ 0x1A, 0x45, 0xDF, 0xA3 ])) {
                    var sliced = buf.subarray(4, 4100), idPos = sliced.findIndex((function(el, i, arr) {
                        return 0x42 === arr[i] && 0x82 === arr[i + 1];
                    }));
                    if (-1 !== idPos) {
                        var docTypePos = idPos + 3, findDocType = function findDocType(type) {
                            return (0, _toConsumableArray2.default)(type).every((function(c, i) {
                                return sliced[docTypePos + i] === c.charCodeAt(0);
                            }));
                        };
                        if (findDocType("matroska")) return {
                            ext: "mkv",
                            mime: "video/x-matroska"
                        };
                        if (findDocType("webm")) return {
                            ext: "webm",
                            mime: "video/webm"
                        };
                    }
                }
                if (check([ 0x0, 0x0, 0x0, 0x14, 0x66, 0x74, 0x79, 0x70, 0x71, 0x74, 0x20, 0x20 ]) || check([ 0x66, 0x72, 0x65, 0x65 ], {
                    offset: 4
                }) || check([ 0x66, 0x74, 0x79, 0x70, 0x71, 0x74, 0x20, 0x20 ], {
                    offset: 4
                }) || check([ 0x6D, 0x64, 0x61, 0x74 ], {
                    offset: 4
                }) || check([ 0x77, 0x69, 0x64, 0x65 ], {
                    offset: 4
                })) return {
                    ext: "mov",
                    mime: "video/quicktime"
                };
                if (check([ 0x52, 0x49, 0x46, 0x46 ])) {
                    if (check([ 0x41, 0x56, 0x49 ], {
                        offset: 8
                    })) return {
                        ext: "avi",
                        mime: "video/vnd.avi"
                    };
                    if (check([ 0x57, 0x41, 0x56, 0x45 ], {
                        offset: 8
                    })) return {
                        ext: "wav",
                        mime: "audio/vnd.wave"
                    };
                    if (check([ 0x51, 0x4C, 0x43, 0x4D ], {
                        offset: 8
                    })) return {
                        ext: "qcp",
                        mime: "audio/qcelp"
                    };
                }
                if (check([ 0x30, 0x26, 0xB2, 0x75, 0x8E, 0x66, 0xCF, 0x11, 0xA6, 0xD9 ])) return {
                    ext: "wmv",
                    mime: "video/x-ms-wmv"
                };
                if (check([ 0x0, 0x0, 0x1, 0xBA ]) || check([ 0x0, 0x0, 0x1, 0xB3 ])) return {
                    ext: "mpg",
                    mime: "video/mpeg"
                };
                if (check([ 0x66, 0x74, 0x79, 0x70, 0x33, 0x67 ], {
                    offset: 4
                })) return {
                    ext: "3gp",
                    mime: "video/3gpp"
                };
                for (var start = 0; start < 2 && start < buf.length - 16; start++) {
                    if (check([ 0x49, 0x44, 0x33 ], {
                        offset: start
                    }) || check([ 0xFF, 0xE2 ], {
                        offset: start,
                        mask: [ 0xFF, 0xE2 ]
                    })) return {
                        ext: "mp3",
                        mime: "audio/mpeg"
                    };
                    if (check([ 0xFF, 0xE4 ], {
                        offset: start,
                        mask: [ 0xFF, 0xE4 ]
                    })) return {
                        ext: "mp2",
                        mime: "audio/mpeg"
                    };
                    if (check([ 0xFF, 0xF8 ], {
                        offset: start,
                        mask: [ 0xFF, 0xFC ]
                    })) return {
                        ext: "mp2",
                        mime: "audio/mpeg"
                    };
                    if (check([ 0xFF, 0xF0 ], {
                        offset: start,
                        mask: [ 0xFF, 0xFC ]
                    })) return {
                        ext: "mp4",
                        mime: "audio/mpeg"
                    };
                }
                if (check([ 0x66, 0x74, 0x79, 0x70, 0x4D, 0x34, 0x41 ], {
                    offset: 4
                }) || check([ 0x4D, 0x34, 0x41, 0x20 ])) return {
                    ext: "m4a",
                    mime: "audio/mp4"
                };
                if (check([ 0x4F, 0x70, 0x75, 0x73, 0x48, 0x65, 0x61, 0x64 ], {
                    offset: 28
                })) return {
                    ext: "opus",
                    mime: "audio/opus"
                };
                if (check([ 0x4F, 0x67, 0x67, 0x53 ])) return check([ 0x80, 0x74, 0x68, 0x65, 0x6F, 0x72, 0x61 ], {
                    offset: 28
                }) ? {
                    ext: "ogv",
                    mime: "video/ogg"
                } : check([ 0x01, 0x76, 0x69, 0x64, 0x65, 0x6F, 0x00 ], {
                    offset: 28
                }) ? {
                    ext: "ogm",
                    mime: "video/ogg"
                } : check([ 0x7F, 0x46, 0x4C, 0x41, 0x43 ], {
                    offset: 28
                }) ? {
                    ext: "oga",
                    mime: "audio/ogg"
                } : check([ 0x53, 0x70, 0x65, 0x65, 0x78, 0x20, 0x20 ], {
                    offset: 28
                }) ? {
                    ext: "spx",
                    mime: "audio/ogg"
                } : check([ 0x01, 0x76, 0x6F, 0x72, 0x62, 0x69, 0x73 ], {
                    offset: 28
                }) ? {
                    ext: "ogg",
                    mime: "audio/ogg"
                } : {
                    ext: "ogx",
                    mime: "application/ogg"
                };
                if (check([ 0x66, 0x4C, 0x61, 0x43 ])) return {
                    ext: "flac",
                    mime: "audio/x-flac"
                };
                if (check([ 0x4D, 0x41, 0x43, 0x20 ])) return {
                    ext: "ape",
                    mime: "audio/ape"
                };
                if (check([ 0x77, 0x76, 0x70, 0x6B ])) return {
                    ext: "wv",
                    mime: "audio/wavpack"
                };
                if (check([ 0x23, 0x21, 0x41, 0x4D, 0x52, 0x0A ])) return {
                    ext: "amr",
                    mime: "audio/amr"
                };
                if (check([ 0x25, 0x50, 0x44, 0x46 ])) return {
                    ext: "pdf",
                    mime: "application/pdf"
                };
                if (check([ 0x4D, 0x5A ])) return {
                    ext: "exe",
                    mime: "application/x-msdownload"
                };
                if ((0x43 === buf[0] || 0x46 === buf[0]) && check([ 0x57, 0x53 ], {
                    offset: 1
                })) return {
                    ext: "swf",
                    mime: "application/x-shockwave-flash"
                };
                if (check([ 0x7B, 0x5C, 0x72, 0x74, 0x66 ])) return {
                    ext: "rtf",
                    mime: "application/rtf"
                };
                if (check([ 0x00, 0x61, 0x73, 0x6D ])) return {
                    ext: "wasm",
                    mime: "application/wasm"
                };
                if (check([ 0x77, 0x4F, 0x46, 0x46 ]) && (check([ 0x00, 0x01, 0x00, 0x00 ], {
                    offset: 4
                }) || check([ 0x4F, 0x54, 0x54, 0x4F ], {
                    offset: 4
                }))) return {
                    ext: "woff",
                    mime: "font/woff"
                };
                if (check([ 0x77, 0x4F, 0x46, 0x32 ]) && (check([ 0x00, 0x01, 0x00, 0x00 ], {
                    offset: 4
                }) || check([ 0x4F, 0x54, 0x54, 0x4F ], {
                    offset: 4
                }))) return {
                    ext: "woff2",
                    mime: "font/woff2"
                };
                if (check([ 0x4C, 0x50 ], {
                    offset: 34
                }) && (check([ 0x00, 0x00, 0x01 ], {
                    offset: 8
                }) || check([ 0x01, 0x00, 0x02 ], {
                    offset: 8
                }) || check([ 0x02, 0x00, 0x02 ], {
                    offset: 8
                }))) return {
                    ext: "eot",
                    mime: "application/vnd.ms-fontobject"
                };
                if (check([ 0x00, 0x01, 0x00, 0x00, 0x00 ])) return {
                    ext: "ttf",
                    mime: "font/ttf"
                };
                if (check([ 0x4F, 0x54, 0x54, 0x4F, 0x00 ])) return {
                    ext: "otf",
                    mime: "font/otf"
                };
                if (check([ 0x00, 0x00, 0x01, 0x00 ])) return {
                    ext: "ico",
                    mime: "image/x-icon"
                };
                if (check([ 0x00, 0x00, 0x02, 0x00 ])) return {
                    ext: "cur",
                    mime: "image/x-icon"
                };
                if (check([ 0x46, 0x4C, 0x56, 0x01 ])) return {
                    ext: "flv",
                    mime: "video/x-flv"
                };
                if (check([ 0x25, 0x21 ])) return {
                    ext: "ps",
                    mime: "application/postscript"
                };
                if (check([ 0xFD, 0x37, 0x7A, 0x58, 0x5A, 0x00 ])) return {
                    ext: "xz",
                    mime: "application/x-xz"
                };
                if (check([ 0x53, 0x51, 0x4C, 0x69 ])) return {
                    ext: "sqlite",
                    mime: "application/x-sqlite3"
                };
                if (check([ 0x4E, 0x45, 0x53, 0x1A ])) return {
                    ext: "nes",
                    mime: "application/x-nintendo-nes-rom"
                };
                if (check([ 0x43, 0x72, 0x32, 0x34 ])) return {
                    ext: "crx",
                    mime: "application/x-google-chrome-extension"
                };
                if (check([ 0x4D, 0x53, 0x43, 0x46 ]) || check([ 0x49, 0x53, 0x63, 0x28 ])) return {
                    ext: "cab",
                    mime: "application/vnd.ms-cab-compressed"
                };
                if (check([ 0x21, 0x3C, 0x61, 0x72, 0x63, 0x68, 0x3E, 0x0A, 0x64, 0x65, 0x62, 0x69, 0x61, 0x6E, 0x2D, 0x62, 0x69, 0x6E, 0x61, 0x72, 0x79 ])) return {
                    ext: "deb",
                    mime: "application/x-deb"
                };
                if (check([ 0x21, 0x3C, 0x61, 0x72, 0x63, 0x68, 0x3E ])) return {
                    ext: "ar",
                    mime: "application/x-unix-archive"
                };
                if (check([ 0xED, 0xAB, 0xEE, 0xDB ])) return {
                    ext: "rpm",
                    mime: "application/x-rpm"
                };
                if (check([ 0x1F, 0xA0 ]) || check([ 0x1F, 0x9D ])) return {
                    ext: "Z",
                    mime: "application/x-compress"
                };
                if (check([ 0x4C, 0x5A, 0x49, 0x50 ])) return {
                    ext: "lz",
                    mime: "application/x-lzip"
                };
                if (check([ 0xD0, 0xCF, 0x11, 0xE0, 0xA1, 0xB1, 0x1A, 0xE1 ])) return {
                    ext: "msi",
                    mime: "application/x-msi"
                };
                if (check([ 0x06, 0x0E, 0x2B, 0x34, 0x02, 0x05, 0x01, 0x01, 0x0D, 0x01, 0x02, 0x01, 0x01, 0x02 ])) return {
                    ext: "mxf",
                    mime: "application/mxf"
                };
                if (check([ 0x47 ], {
                    offset: 4
                }) && (check([ 0x47 ], {
                    offset: 192
                }) || check([ 0x47 ], {
                    offset: 196
                }))) return {
                    ext: "mts",
                    mime: "video/mp2t"
                };
                if (check([ 0x42, 0x4C, 0x45, 0x4E, 0x44, 0x45, 0x52 ])) return {
                    ext: "blend",
                    mime: "application/x-blender"
                };
                if (check([ 0x42, 0x50, 0x47, 0xFB ])) return {
                    ext: "bpg",
                    mime: "image/bpg"
                };
                if (check([ 0x00, 0x00, 0x00, 0x0C, 0x6A, 0x50, 0x20, 0x20, 0x0D, 0x0A, 0x87, 0x0A ])) {
                    if (check([ 0x6A, 0x70, 0x32, 0x20 ], {
                        offset: 20
                    })) return {
                        ext: "jp2",
                        mime: "image/jp2"
                    };
                    if (check([ 0x6A, 0x70, 0x78, 0x20 ], {
                        offset: 20
                    })) return {
                        ext: "jpx",
                        mime: "image/jpx"
                    };
                    if (check([ 0x6A, 0x70, 0x6D, 0x20 ], {
                        offset: 20
                    })) return {
                        ext: "jpm",
                        mime: "image/jpm"
                    };
                    if (check([ 0x6D, 0x6A, 0x70, 0x32 ], {
                        offset: 20
                    })) return {
                        ext: "mj2",
                        mime: "image/mj2"
                    };
                }
                if (check([ 0x46, 0x4F, 0x52, 0x4D, 0x00 ])) return {
                    ext: "aif",
                    mime: "audio/aiff"
                };
                if (checkString("<?xml ")) return {
                    ext: "xml",
                    mime: "application/xml"
                };
                if (check([ 0x42, 0x4F, 0x4F, 0x4B, 0x4D, 0x4F, 0x42, 0x49 ], {
                    offset: 60
                })) return {
                    ext: "mobi",
                    mime: "application/x-mobipocket-ebook"
                };
                if (check([ 0x66, 0x74, 0x79, 0x70 ], {
                    offset: 4
                })) {
                    if (check([ 0x6D, 0x69, 0x66, 0x31 ], {
                        offset: 8
                    })) return {
                        ext: "heic",
                        mime: "image/heif"
                    };
                    if (check([ 0x6D, 0x73, 0x66, 0x31 ], {
                        offset: 8
                    })) return {
                        ext: "heic",
                        mime: "image/heif-sequence"
                    };
                    if (check([ 0x68, 0x65, 0x69, 0x63 ], {
                        offset: 8
                    }) || check([ 0x68, 0x65, 0x69, 0x78 ], {
                        offset: 8
                    })) return {
                        ext: "heic",
                        mime: "image/heic"
                    };
                    if (check([ 0x68, 0x65, 0x76, 0x63 ], {
                        offset: 8
                    }) || check([ 0x68, 0x65, 0x76, 0x78 ], {
                        offset: 8
                    })) return {
                        ext: "heic",
                        mime: "image/heic-sequence"
                    };
                }
                return check([ 0xAB, 0x4B, 0x54, 0x58, 0x20, 0x31, 0x31, 0xBB, 0x0D, 0x0A, 0x1A, 0x0A ]) ? {
                    ext: "ktx",
                    mime: "image/ktx"
                } : null;
            };
        }, {
            "@babel/runtime/helpers/interopRequireDefault": 11,
            "@babel/runtime/helpers/toConsumableArray": 20
        } ],
        63: [ function(require, module, exports) {
            var isCallable = require("is-callable"), toStr = Object.prototype.toString, hasOwnProperty = Object.prototype.hasOwnProperty, forEachArray = function forEachArray(array, iterator, receiver) {
                for (var i = 0, len = array.length; i < len; i++) hasOwnProperty.call(array, i) && (null == receiver ? iterator(array[i], i, array) : iterator.call(receiver, array[i], i, array));
            }, forEachString = function forEachString(string, iterator, receiver) {
                for (var i = 0, len = string.length; i < len; i++) null == receiver ? iterator(string.charAt(i), i, string) : iterator.call(receiver, string.charAt(i), i, string);
            }, forEachObject = function forEachObject(object, iterator, receiver) {
                for (var k in object) hasOwnProperty.call(object, k) && (null == receiver ? iterator(object[k], k, object) : iterator.call(receiver, object[k], k, object));
            };
            module.exports = function forEach(list, iterator, thisArg) {
                if (!isCallable(iterator)) throw new TypeError("iterator must be a function");
                var receiver;
                arguments.length >= 3 && (receiver = thisArg), "[object Array]" === toStr.call(list) ? forEachArray(list, iterator, receiver) : "string" == typeof list ? forEachString(list, iterator, receiver) : forEachObject(list, iterator, receiver);
            };
        }, {
            "is-callable": 77
        } ],
        64: [ function(require, module, exports) {
            function GifReaderLZWOutputIndexStream(code_stream, p, output, output_length) {
                for (var min_code_size = code_stream[p++], clear_code = 1 << min_code_size, eoi_code = clear_code + 1, next_code = eoi_code + 1, cur_code_size = min_code_size + 1, code_mask = (1 << cur_code_size) - 1, cur_shift = 0, cur = 0, op = 0, subblock_size = code_stream[p++], code_table = new Int32Array(4096), prev_code = null; ;) {
                    for (;cur_shift < 16 && 0 !== subblock_size; ) cur |= code_stream[p++] << cur_shift, 
                    cur_shift += 8, 1 === subblock_size ? subblock_size = code_stream[p++] : --subblock_size;
                    if (cur_shift < cur_code_size) break;
                    var code = cur & code_mask;
                    if (cur >>= cur_code_size, cur_shift -= cur_code_size, code !== clear_code) {
                        if (code === eoi_code) break;
                        for (var chase_code = code < next_code ? code : prev_code, chase_length = 0, chase = chase_code; chase > clear_code; ) chase = code_table[chase] >> 8, 
                        ++chase_length;
                        var k = chase;
                        if (op + chase_length + (chase_code !== code ? 1 : 0) > output_length) return void console.log("Warning, gif stream longer than expected.");
                        output[op++] = k;
                        var b = op += chase_length;
                        for (chase_code !== code && (output[op++] = k), chase = chase_code; chase_length--; ) chase = code_table[chase], 
                        output[--b] = 0xff & chase, chase >>= 8;
                        null !== prev_code && next_code < 4096 && (code_table[next_code++] = prev_code << 8 | k, 
                        next_code >= code_mask + 1 && cur_code_size < 12 && (++cur_code_size, code_mask = code_mask << 1 | 1)), 
                        prev_code = code;
                    } else next_code = eoi_code + 1, code_mask = (1 << (cur_code_size = min_code_size + 1)) - 1, 
                    prev_code = null;
                }
                return op !== output_length && console.log("Warning, gif stream shorter than expected."), 
                output;
            }
            try {
                exports.GifWriter = function GifWriter(buf, width, height, gopts) {
                    var p = 0, loop_count = void 0 === (gopts = void 0 === gopts ? {} : gopts).loop ? null : gopts.loop, global_palette = void 0 === gopts.palette ? null : gopts.palette;
                    if (width <= 0 || height <= 0 || width > 65535 || height > 65535) throw new Error("Width/Height invalid.");
                    function check_palette_and_num_colors(palette) {
                        var num_colors = palette.length;
                        if (num_colors < 2 || num_colors > 256 || num_colors & num_colors - 1) throw new Error("Invalid code/color length, must be power of 2 and 2 .. 256.");
                        return num_colors;
                    }
                    buf[p++] = 0x47, buf[p++] = 0x49, buf[p++] = 0x46, buf[p++] = 0x38, buf[p++] = 0x39, 
                    buf[p++] = 0x61;
                    var gp_num_colors_pow2 = 0, background = 0;
                    if (null !== global_palette) {
                        for (var gp_num_colors = check_palette_and_num_colors(global_palette); gp_num_colors >>= 1; ) ++gp_num_colors_pow2;
                        if (gp_num_colors = 1 << gp_num_colors_pow2, --gp_num_colors_pow2, void 0 !== gopts.background) {
                            if ((background = gopts.background) >= gp_num_colors) throw new Error("Background index out of range.");
                            if (0 === background) throw new Error("Background index explicitly passed as 0.");
                        }
                    }
                    if (buf[p++] = 0xff & width, buf[p++] = width >> 8 & 0xff, buf[p++] = 0xff & height, 
                    buf[p++] = height >> 8 & 0xff, buf[p++] = (null !== global_palette ? 0x80 : 0) | gp_num_colors_pow2, 
                    buf[p++] = background, buf[p++] = 0, null !== global_palette) for (var i = 0, il = global_palette.length; i < il; ++i) {
                        var rgb = global_palette[i];
                        buf[p++] = rgb >> 16 & 0xff, buf[p++] = rgb >> 8 & 0xff, buf[p++] = 0xff & rgb;
                    }
                    if (null !== loop_count) {
                        if (loop_count < 0 || loop_count > 65535) throw new Error("Loop count invalid.");
                        buf[p++] = 0x21, buf[p++] = 0xff, buf[p++] = 0x0b, buf[p++] = 0x4e, buf[p++] = 0x45, 
                        buf[p++] = 0x54, buf[p++] = 0x53, buf[p++] = 0x43, buf[p++] = 0x41, buf[p++] = 0x50, 
                        buf[p++] = 0x45, buf[p++] = 0x32, buf[p++] = 0x2e, buf[p++] = 0x30, buf[p++] = 0x03, 
                        buf[p++] = 0x01, buf[p++] = 0xff & loop_count, buf[p++] = loop_count >> 8 & 0xff, 
                        buf[p++] = 0x00;
                    }
                    var ended = !1;
                    this.addFrame = function(x, y, w, h, indexed_pixels, opts) {
                        if (!0 === ended && (--p, ended = !1), opts = void 0 === opts ? {} : opts, x < 0 || y < 0 || x > 65535 || y > 65535) throw new Error("x/y invalid.");
                        if (w <= 0 || h <= 0 || w > 65535 || h > 65535) throw new Error("Width/Height invalid.");
                        if (indexed_pixels.length < w * h) throw new Error("Not enough pixels for the frame size.");
                        var using_local_palette = !0, palette = opts.palette;
                        if (null == palette && (using_local_palette = !1, palette = global_palette), null == palette) throw new Error("Must supply either a local or global palette.");
                        for (var num_colors = check_palette_and_num_colors(palette), min_code_size = 0; num_colors >>= 1; ) ++min_code_size;
                        num_colors = 1 << min_code_size;
                        var delay = void 0 === opts.delay ? 0 : opts.delay, disposal = void 0 === opts.disposal ? 0 : opts.disposal;
                        if (disposal < 0 || disposal > 3) throw new Error("Disposal out of range.");
                        var use_transparency = !1, transparent_index = 0;
                        if (void 0 !== opts.transparent && null !== opts.transparent && (use_transparency = !0, 
                        (transparent_index = opts.transparent) < 0 || transparent_index >= num_colors)) throw new Error("Transparent color index.");
                        if ((0 !== disposal || use_transparency || 0 !== delay) && (buf[p++] = 0x21, buf[p++] = 0xf9, 
                        buf[p++] = 4, buf[p++] = disposal << 2 | (!0 === use_transparency ? 1 : 0), buf[p++] = 0xff & delay, 
                        buf[p++] = delay >> 8 & 0xff, buf[p++] = transparent_index, buf[p++] = 0), buf[p++] = 0x2c, 
                        buf[p++] = 0xff & x, buf[p++] = x >> 8 & 0xff, buf[p++] = 0xff & y, buf[p++] = y >> 8 & 0xff, 
                        buf[p++] = 0xff & w, buf[p++] = w >> 8 & 0xff, buf[p++] = 0xff & h, buf[p++] = h >> 8 & 0xff, 
                        buf[p++] = !0 === using_local_palette ? 0x80 | min_code_size - 1 : 0, !0 === using_local_palette) for (var i = 0, il = palette.length; i < il; ++i) {
                            var rgb = palette[i];
                            buf[p++] = rgb >> 16 & 0xff, buf[p++] = rgb >> 8 & 0xff, buf[p++] = 0xff & rgb;
                        }
                        return p = function GifWriterOutputLZWCodeStream(buf, p, min_code_size, index_stream) {
                            buf[p++] = min_code_size;
                            var cur_subblock = p++, clear_code = 1 << min_code_size, code_mask = clear_code - 1, eoi_code = clear_code + 1, next_code = eoi_code + 1, cur_code_size = min_code_size + 1, cur_shift = 0, cur = 0;
                            function emit_bytes_to_buffer(bit_block_size) {
                                for (;cur_shift >= bit_block_size; ) buf[p++] = 0xff & cur, cur >>= 8, cur_shift -= 8, 
                                p === cur_subblock + 256 && (buf[cur_subblock] = 255, cur_subblock = p++);
                            }
                            function emit_code(c) {
                                cur |= c << cur_shift, cur_shift += cur_code_size, emit_bytes_to_buffer(8);
                            }
                            var ib_code = index_stream[0] & code_mask, code_table = {};
                            emit_code(clear_code);
                            for (var i = 1, il = index_stream.length; i < il; ++i) {
                                var k = index_stream[i] & code_mask, cur_key = ib_code << 8 | k, cur_code = code_table[cur_key];
                                if (void 0 === cur_code) {
                                    for (cur |= ib_code << cur_shift, cur_shift += cur_code_size; cur_shift >= 8; ) buf[p++] = 0xff & cur, 
                                    cur >>= 8, cur_shift -= 8, p === cur_subblock + 256 && (buf[cur_subblock] = 255, 
                                    cur_subblock = p++);
                                    4096 === next_code ? (emit_code(clear_code), next_code = eoi_code + 1, cur_code_size = min_code_size + 1, 
                                    code_table = {}) : (next_code >= 1 << cur_code_size && ++cur_code_size, code_table[cur_key] = next_code++), 
                                    ib_code = k;
                                } else ib_code = cur_code;
                            }
                            return emit_code(ib_code), emit_code(eoi_code), emit_bytes_to_buffer(1), cur_subblock + 1 === p ? buf[cur_subblock] = 0 : (buf[cur_subblock] = p - cur_subblock - 1, 
                            buf[p++] = 0), p;
                        }(buf, p, min_code_size < 2 ? 2 : min_code_size, indexed_pixels);
                    }, this.end = function() {
                        return !1 === ended && (buf[p++] = 0x3b, ended = !0), p;
                    }, this.getOutputBuffer = function() {
                        return buf;
                    }, this.setOutputBuffer = function(v) {
                        buf = v;
                    }, this.getOutputBufferPosition = function() {
                        return p;
                    }, this.setOutputBufferPosition = function(v) {
                        p = v;
                    };
                }, exports.GifReader = function GifReader(buf) {
                    var p = 0;
                    if (0x47 !== buf[p++] || 0x49 !== buf[p++] || 0x46 !== buf[p++] || 0x38 !== buf[p++] || 0x38 != (buf[p++] + 1 & 0xfd) || 0x61 !== buf[p++]) throw new Error("Invalid GIF 87a/89a header.");
                    var width = buf[p++] | buf[p++] << 8, height = buf[p++] | buf[p++] << 8, pf0 = buf[p++], global_palette_flag = pf0 >> 7, num_global_colors = 1 << 1 + (0x7 & pf0);
                    buf[p++], buf[p++];
                    var global_palette_offset = null, global_palette_size = null;
                    global_palette_flag && (global_palette_offset = p, global_palette_size = num_global_colors, 
                    p += 3 * num_global_colors);
                    var no_eof = !0, frames = [], delay = 0, transparent_index = null, disposal = 0, loop_count = null;
                    for (this.width = width, this.height = height; no_eof && p < buf.length; ) switch (buf[p++]) {
                      case 0x21:
                        switch (buf[p++]) {
                          case 0xff:
                            if (0x0b !== buf[p] || 0x4e == buf[p + 1] && 0x45 == buf[p + 2] && 0x54 == buf[p + 3] && 0x53 == buf[p + 4] && 0x43 == buf[p + 5] && 0x41 == buf[p + 6] && 0x50 == buf[p + 7] && 0x45 == buf[p + 8] && 0x32 == buf[p + 9] && 0x2e == buf[p + 10] && 0x30 == buf[p + 11] && 0x03 == buf[p + 12] && 0x01 == buf[p + 13] && 0 == buf[p + 16]) p += 14, 
                            loop_count = buf[p++] | buf[p++] << 8, p++; else for (p += 12; ;) {
                                if (!((block_size = buf[p++]) >= 0)) throw Error("Invalid block size");
                                if (0 === block_size) break;
                                p += block_size;
                            }
                            break;

                          case 0xf9:
                            if (0x4 !== buf[p++] || 0 !== buf[p + 4]) throw new Error("Invalid graphics extension block.");
                            var pf1 = buf[p++];
                            delay = buf[p++] | buf[p++] << 8, transparent_index = buf[p++], 0 == (1 & pf1) && (transparent_index = null), 
                            disposal = pf1 >> 2 & 0x7, p++;
                            break;

                          case 0xfe:
                            for (;;) {
                                if (!((block_size = buf[p++]) >= 0)) throw Error("Invalid block size");
                                if (0 === block_size) break;
                                p += block_size;
                            }
                            break;

                          default:
                            throw new Error("Unknown graphic control label: 0x" + buf[p - 1].toString(16));
                        }
                        break;

                      case 0x2c:
                        var x = buf[p++] | buf[p++] << 8, y = buf[p++] | buf[p++] << 8, w = buf[p++] | buf[p++] << 8, h = buf[p++] | buf[p++] << 8, pf2 = buf[p++], interlace_flag = pf2 >> 6 & 1, num_local_colors = 1 << 1 + (0x7 & pf2), palette_offset = global_palette_offset, palette_size = global_palette_size, has_local_palette = !1;
                        pf2 >> 7 && (has_local_palette = !0, palette_offset = p, palette_size = num_local_colors, 
                        p += 3 * num_local_colors);
                        var data_offset = p;
                        for (p++; ;) {
                            var block_size;
                            if (!((block_size = buf[p++]) >= 0)) throw Error("Invalid block size");
                            if (0 === block_size) break;
                            p += block_size;
                        }
                        frames.push({
                            x,
                            y,
                            width: w,
                            height: h,
                            has_local_palette,
                            palette_offset,
                            palette_size,
                            data_offset,
                            data_length: p - data_offset,
                            transparent_index,
                            interlaced: !!interlace_flag,
                            delay,
                            disposal
                        });
                        break;

                      case 0x3b:
                        no_eof = !1;
                        break;

                      default:
                        throw new Error("Unknown gif block: 0x" + buf[p - 1].toString(16));
                    }
                    this.numFrames = function() {
                        return frames.length;
                    }, this.loopCount = function() {
                        return loop_count;
                    }, this.frameInfo = function(frame_num) {
                        if (frame_num < 0 || frame_num >= frames.length) throw new Error("Frame index out of range.");
                        return frames[frame_num];
                    }, this.decodeAndBlitFrameBGRA = function(frame_num, pixels) {
                        var frame = this.frameInfo(frame_num), num_pixels = frame.width * frame.height, index_stream = new Uint8Array(num_pixels);
                        GifReaderLZWOutputIndexStream(buf, frame.data_offset, index_stream, num_pixels);
                        var palette_offset = frame.palette_offset, trans = frame.transparent_index;
                        null === trans && (trans = 256);
                        var framewidth = frame.width, framestride = width - framewidth, xleft = framewidth, opbeg = 4 * (frame.y * width + frame.x), opend = 4 * ((frame.y + frame.height) * width + frame.x), op = opbeg, scanstride = 4 * framestride;
                        !0 === frame.interlaced && (scanstride += 4 * width * 7);
                        for (var interlaceskip = 8, i = 0, il = index_stream.length; i < il; ++i) {
                            var index = index_stream[i];
                            if (0 === xleft && (xleft = framewidth, (op += scanstride) >= opend && (scanstride = 4 * framestride + 4 * width * (interlaceskip - 1), 
                            op = opbeg + (framewidth + framestride) * (interlaceskip << 1), interlaceskip >>= 1)), 
                            index === trans) op += 4; else {
                                var r = buf[palette_offset + 3 * index], g = buf[palette_offset + 3 * index + 1], b = buf[palette_offset + 3 * index + 2];
                                pixels[op++] = b, pixels[op++] = g, pixels[op++] = r, pixels[op++] = 255;
                            }
                            --xleft;
                        }
                    }, this.decodeAndBlitFrameRGBA = function(frame_num, pixels) {
                        var frame = this.frameInfo(frame_num), num_pixels = frame.width * frame.height, index_stream = new Uint8Array(num_pixels);
                        GifReaderLZWOutputIndexStream(buf, frame.data_offset, index_stream, num_pixels);
                        var palette_offset = frame.palette_offset, trans = frame.transparent_index;
                        null === trans && (trans = 256);
                        var framewidth = frame.width, framestride = width - framewidth, xleft = framewidth, opbeg = 4 * (frame.y * width + frame.x), opend = 4 * ((frame.y + frame.height) * width + frame.x), op = opbeg, scanstride = 4 * framestride;
                        !0 === frame.interlaced && (scanstride += 4 * width * 7);
                        for (var interlaceskip = 8, i = 0, il = index_stream.length; i < il; ++i) {
                            var index = index_stream[i];
                            if (0 === xleft && (xleft = framewidth, (op += scanstride) >= opend && (scanstride = 4 * framestride + 4 * width * (interlaceskip - 1), 
                            op = opbeg + (framewidth + framestride) * (interlaceskip << 1), interlaceskip >>= 1)), 
                            index === trans) op += 4; else {
                                var r = buf[palette_offset + 3 * index], g = buf[palette_offset + 3 * index + 1], b = buf[palette_offset + 3 * index + 2];
                                pixels[op++] = r, pixels[op++] = g, pixels[op++] = b, pixels[op++] = 255;
                            }
                            --xleft;
                        }
                    };
                };
            } catch (e) {}
        }, {} ],
        65: [ function(require, module, exports) {
            (function(Buffer) {
                class BitmapImage {
                    constructor(...args) {
                        if (0 === args.length) throw new Error("constructor requires parameters");
                        const firstArg = args[0];
                        if (null !== firstArg && "object" == typeof firstArg) if (firstArg instanceof BitmapImage) {
                            const sourceBitmap = firstArg.bitmap;
                            this.bitmap = {
                                width: sourceBitmap.width,
                                height: sourceBitmap.height,
                                data: new Buffer(sourceBitmap.width * sourceBitmap.height * 4)
                            }, sourceBitmap.data.copy(this.bitmap.data);
                        } else {
                            if (!(firstArg.width && firstArg.height && firstArg.data)) throw new Error("unrecognized constructor parameters");
                            this.bitmap = firstArg;
                        } else {
                            if ("number" != typeof firstArg || "number" != typeof args[1]) throw new Error("unrecognized constructor parameters");
                            {
                                const width = firstArg, height = args[1], thirdArg = args[2];
                                this.bitmap = {
                                    width,
                                    height
                                }, Buffer.isBuffer(thirdArg) ? this.bitmap.data = thirdArg : (this.bitmap.data = new Buffer(width * height * 4), 
                                "number" == typeof thirdArg && this.fillRGBA(thirdArg));
                            }
                        }
                    }
                    blit(toImage, toX, toY, fromX, fromY, fromWidth, fromHeight) {
                        if (fromX + fromWidth > this.bitmap.width) throw new Error("copy exceeds width of source bitmap");
                        if (toX + fromWidth > toImage.bitmap.width) throw new Error("copy exceeds width of target bitmap");
                        if (fromY + fromHeight > this.bitmap.height) throw new Error("copy exceeds height of source bitmap");
                        if (toY + fromHeight > toImage.bitmap.height) throw new Erro("copy exceeds height of target bitmap");
                        const sourceBuf = this.bitmap.data, targetBuf = toImage.bitmap.data, sourceByteWidth = 4 * this.bitmap.width, targetByteWidth = 4 * toImage.bitmap.width, copyByteWidth = 4 * fromWidth;
                        let si = fromY * sourceByteWidth + 4 * fromX, ti = toY * targetByteWidth + 4 * toX;
                        for (;--fromHeight >= 0; ) sourceBuf.copy(targetBuf, ti, si, si + copyByteWidth), 
                        si += sourceByteWidth, ti += targetByteWidth;
                        return this;
                    }
                    fillRGBA(rgba) {
                        const buf = this.bitmap.data, bufByteWidth = 4 * this.bitmap.height;
                        let bi = 0;
                        for (;bi < bufByteWidth; ) buf.writeUInt32BE(rgba, bi), bi += 4;
                        for (;bi < buf.length; ) buf.copy(buf, bi, 0, bufByteWidth), bi += bufByteWidth;
                        return this;
                    }
                    getRGBA(x, y) {
                        const bi = 4 * (y * this.bitmap.width + x);
                        return this.bitmap.data.readUInt32BE(bi);
                    }
                    getRGBASet() {
                        const rgbaSet = new Set, buf = this.bitmap.data;
                        for (let bi = 0; bi < buf.length; bi += 4) rgbaSet.add(buf.readUInt32BE(bi, !0));
                        return rgbaSet;
                    }
                    greyscale() {
                        const buf = this.bitmap.data;
                        return this.scan(0, 0, this.bitmap.width, this.bitmap.height, ((x, y, idx) => {
                            const grey = Math.round(0.299 * buf[idx] + 0.587 * buf[idx + 1] + 0.114 * buf[idx + 2]);
                            buf[idx] = grey, buf[idx + 1] = grey, buf[idx + 2] = grey;
                        })), this;
                    }
                    reframe(xOffset, yOffset, width, height, fillRGBA) {
                        const cropX = xOffset < 0 ? 0 : xOffset, cropY = yOffset < 0 ? 0 : yOffset, cropWidth = width + cropX > this.bitmap.width ? this.bitmap.width - cropX : width, cropHeight = height + cropY > this.bitmap.height ? this.bitmap.height - cropY : height, newX = xOffset < 0 ? -xOffset : 0, newY = yOffset < 0 ? -yOffset : 0;
                        let image;
                        if (void 0 === fillRGBA) {
                            if (cropX !== xOffset || cropY != yOffset || cropWidth !== width || cropHeight !== height) throw new GifError("fillRGBA required for this reframing");
                            image = new BitmapImage(width, height);
                        } else image = new BitmapImage(width, height, fillRGBA);
                        return this.blit(image, newX, newY, cropX, cropY, cropWidth, cropHeight), this.bitmap = image.bitmap, 
                        this;
                    }
                    scale(factor) {
                        if (1 === factor) return;
                        if (!Number.isInteger(factor) || factor < 1) throw new Error("the scale must be an integer >= 1");
                        const sourceWidth = this.bitmap.width, sourceHeight = this.bitmap.height, destByteWidth = sourceWidth * factor * 4, sourceBuf = this.bitmap.data, destBuf = new Buffer(sourceHeight * destByteWidth * factor);
                        let priorDestRowIndex, sourceIndex = 0, destIndex = 0;
                        for (let y = 0; y < sourceHeight; ++y) {
                            priorDestRowIndex = destIndex;
                            for (let x = 0; x < sourceWidth; ++x) {
                                const color = sourceBuf.readUInt32BE(sourceIndex, !0);
                                for (let cx = 0; cx < factor; ++cx) destBuf.writeUInt32BE(color, destIndex), destIndex += 4;
                                sourceIndex += 4;
                            }
                            for (let cy = 1; cy < factor; ++cy) destBuf.copy(destBuf, destIndex, priorDestRowIndex, destIndex), 
                            destIndex += destByteWidth, priorDestRowIndex += destByteWidth;
                        }
                        return this.bitmap = {
                            width: sourceWidth * factor,
                            height: sourceHeight * factor,
                            data: destBuf
                        }, this;
                    }
                    scanAllCoords(scanHandler) {
                        const width = this.bitmap.width, bufferLength = this.bitmap.data.length;
                        let x = 0, y = 0;
                        for (let bi = 0; bi < bufferLength; bi += 4) scanHandler(x, y, bi), ++x === width && (x = 0, 
                        ++y);
                    }
                    scanAllIndexes(scanHandler) {
                        const bufferLength = this.bitmap.data.length;
                        for (let bi = 0; bi < bufferLength; bi += 4) scanHandler(bi);
                    }
                }
                module.exports = BitmapImage;
            }).call(this, require("buffer").Buffer);
        }, {
            buffer: 48
        } ],
        66: [ function(require, module, exports) {
            class Gif {
                constructor(buffer, frames, spec) {
                    this.width = spec.width, this.height = spec.height, this.loops = spec.loops, this.usesTransparency = spec.usesTransparency, 
                    this.colorScope = spec.colorScope, this.frames = frames, this.buffer = buffer;
                }
            }
            Gif.GlobalColorsPreferred = 0, Gif.GlobalColorsOnly = 1, Gif.LocalColorsOnly = 2;
            class GifError extends Error {
                constructor(messageOrError) {
                    super(messageOrError), messageOrError instanceof Error && (this.stack = "Gif" + messageOrError.stack);
                }
            }
            exports.Gif = Gif, exports.GifError = GifError;
        }, {} ],
        67: [ function(require, module, exports) {
            (function(process, Buffer) {
                const Omggif = require("omggif"), {Gif, GifError} = require("./gif");
                let GifUtil;
                process.nextTick((() => {
                    GifUtil = require("./gifutil");
                }));
                const {GifFrame} = require("./gifframe");
                function _colorLookupLinear(colors, color) {
                    const index = colors.indexOf(color);
                    return -1 === index ? null : index;
                }
                function _colorLookupBinary(colors, color) {
                    for (var mid, lo = 0, hi = colors.length - 1; lo <= hi; ) if (colors[mid = Math.floor((lo + hi) / 2)] > color) hi = mid - 1; else {
                        if (!(colors[mid] < color)) return mid;
                        lo = mid + 1;
                    }
                    return null;
                }
                function _extendPaletteToPowerOf2(palette) {
                    const colors = palette.colors;
                    palette.usesTransparency && colors.push(0);
                    const colorCount = colors.length;
                    let powerOf2 = 2;
                    for (;colorCount > powerOf2; ) powerOf2 <<= 1;
                    colors.length = powerOf2, colors.fill(0, colorCount);
                }
                function _getFrameSizeEst(frame, pixelBitWidth) {
                    let byteLength = frame.bitmap.width * frame.bitmap.height;
                    return byteLength = Math.ceil(byteLength * pixelBitWidth / 8), byteLength += Math.ceil(byteLength / 255), 
                    100 + byteLength + 768;
                }
                function _getPixelBitWidth(palette) {
                    let indexCount = palette.indexCount, pixelBitWidth = 0;
                    for (--indexCount; indexCount; ) ++pixelBitWidth, indexCount >>= 1;
                    return pixelBitWidth > 0 ? pixelBitWidth : 1;
                }
                function _writeFrame(gifWriter, frameIndex, frame, palette, isLocalPalette) {
                    if (frame.interlaced) throw new GifError("writing interlaced GIFs is not supported");
                    const frameInfo = function _getIndexedImage(frameIndex, frame, palette) {
                        const colors = palette.colors, colorToIndexFunc = colors.length <= 8 ? _colorLookupLinear : _colorLookupBinary, colorBuffer = frame.bitmap.data, indexBuffer = new Buffer(colorBuffer.length / 4);
                        let transparentIndex = colors.length, i = 0, j = 0;
                        for (;i < colorBuffer.length; ) {
                            if (0 !== colorBuffer[i + 3]) {
                                const color = colorBuffer.readUInt32BE(i, !0) >> 8 & 0xFFFFFF;
                                indexBuffer[j] = colorToIndexFunc(colors, color);
                            } else indexBuffer[j] = transparentIndex;
                            i += 4, ++j;
                        }
                        if (palette.usesTransparency) {
                            if (256 === transparentIndex) throw new GifError(`Frame ${frameIndex} already has 256 colorsand so can't use transparency`);
                        } else transparentIndex = null;
                        return {
                            buffer: indexBuffer,
                            transparentIndex
                        };
                    }(frameIndex, frame, palette), options = {
                        delay: frame.delayCentisecs,
                        disposal: frame.disposalMethod,
                        transparent: frameInfo.transparentIndex
                    };
                    isLocalPalette && (_extendPaletteToPowerOf2(palette), options.palette = palette.colors);
                    try {
                        let endOfFrame, buffer = gifWriter.getOutputBuffer(), startOfFrame = gifWriter.getOutputBufferPosition(), tryAgain = !0;
                        for (;tryAgain; ) if (endOfFrame = gifWriter.addFrame(frame.xOffset, frame.yOffset, frame.bitmap.width, frame.bitmap.height, frameInfo.buffer, options), 
                        tryAgain = !1, endOfFrame >= buffer.length - 1) {
                            const biggerBuffer = new Buffer(1.5 * buffer.length);
                            buffer.copy(biggerBuffer), gifWriter.setOutputBuffer(biggerBuffer), gifWriter.setOutputBufferPosition(startOfFrame), 
                            buffer = biggerBuffer, tryAgain = !0;
                        }
                        return buffer;
                    } catch (err) {
                        throw new GifError(err);
                    }
                }
                exports.GifCodec = class GifCodec {
                    constructor(options = {}) {
                        this._transparentRGB = null, "number" == typeof options.transparentRGB && 0 !== options.transparentRGB && (this._transparentRGBA = 256 * options.transparentRGB), 
                        this._testInitialBufferSize = 0;
                    }
                    decodeGif(buffer) {
                        try {
                            let reader;
                            try {
                                reader = new Omggif.GifReader(buffer);
                            } catch (err) {
                                throw new GifError(err);
                            }
                            const frameCount = reader.numFrames(), frames = [], spec = {
                                width: reader.width,
                                height: reader.height,
                                loops: reader.loopCount(),
                                usesTransparency: !1
                            };
                            for (let i = 0; i < frameCount; ++i) {
                                const frameInfo = this._decodeFrame(reader, i, spec.usesTransparency);
                                frames.push(frameInfo.frame), frameInfo.usesTransparency && (spec.usesTransparency = !0);
                            }
                            return Promise.resolve(new Gif(buffer, frames, spec));
                        } catch (err) {
                            return Promise.reject(err);
                        }
                    }
                    encodeGif(frames, spec = {}) {
                        try {
                            if (null === frames || 0 === frames.length) throw new GifError("there are no frames");
                            const dims = GifUtil.getMaxDimensions(frames);
                            return (spec = Object.assign({}, spec)).width = dims.maxWidth, spec.height = dims.maxHeight, 
                            spec.loops = spec.loops || 0, spec.colorScope = spec.colorScope || Gif.GlobalColorsPreferred, 
                            Promise.resolve(this._encodeGif(frames, spec));
                        } catch (err) {
                            return Promise.reject(err);
                        }
                    }
                    _decodeFrame(reader, frameIndex, alreadyUsedTransparency) {
                        let info, buffer;
                        try {
                            if (info = reader.frameInfo(frameIndex), buffer = new Buffer(reader.width * reader.height * 4), 
                            reader.decodeAndBlitFrameRGBA(frameIndex, buffer), info.width !== reader.width || info.height !== reader.height) {
                                if (info.y && (buffer = buffer.slice(info.y * reader.width * 4)), reader.width > info.width) for (let ii = 0; ii < info.height; ++ii) buffer.copy(buffer, ii * info.width * 4, 4 * (info.x + ii * reader.width), 4 * (info.x + ii * reader.width) + 4 * info.width);
                                buffer = buffer.slice(0, info.width * info.height * 4);
                            }
                        } catch (err) {
                            throw new GifError(err);
                        }
                        let usesTransparency = !1;
                        if (null === this._transparentRGBA) {
                            if (!alreadyUsedTransparency) for (let i = 3; i < buffer.length; i += 4) 0 === buffer[i] && (usesTransparency = !0, 
                            i = buffer.length);
                        } else for (let i = 3; i < buffer.length; i += 4) 0 === buffer[i] && (buffer.writeUInt32BE(this._transparentRGBA, i - 3), 
                        usesTransparency = !0);
                        return {
                            frame: new GifFrame(info.width, info.height, buffer, {
                                xOffset: info.x,
                                yOffset: info.y,
                                disposalMethod: info.disposal,
                                interlaced: info.interlaced,
                                delayCentisecs: info.delay
                            }),
                            usesTransparency
                        };
                    }
                    _encodeGif(frames, spec) {
                        let colorInfo;
                        if (spec.colorScope === Gif.LocalColorsOnly) colorInfo = GifUtil.getColorInfo(frames, 0); else if (colorInfo = GifUtil.getColorInfo(frames, 256), 
                        !colorInfo.colors) {
                            if (spec.colorScope === Gif.GlobalColorsOnly) throw new GifError("Too many color indexes for global color table");
                            spec.colorScope = Gif.LocalColorsOnly;
                        }
                        spec.usesTransparency = colorInfo.usesTransparency;
                        const localPalettes = colorInfo.palettes;
                        return spec.colorScope === Gif.LocalColorsOnly ? function _encodeLocal(frames, spec, bufferSizeEst, localPalettes) {
                            const options = {
                                loop: spec.loops
                            };
                            let gifWriter, buffer = new Buffer(bufferSizeEst);
                            try {
                                gifWriter = new Omggif.GifWriter(buffer, spec.width, spec.height, options);
                            } catch (err) {
                                throw new GifError(err);
                            }
                            for (let i = 0; i < frames.length; ++i) buffer = _writeFrame(gifWriter, i, frames[i], localPalettes[i], !0);
                            return new Gif(buffer.slice(0, gifWriter.end()), frames, spec);
                        }(frames, spec, 2000, localPalettes) : function _encodeGlobal(frames, spec, bufferSizeEst, globalPalette) {
                            const extendedGlobalPalette = {
                                colors: globalPalette.colors.slice(),
                                usesTransparency: globalPalette.usesTransparency
                            };
                            _extendPaletteToPowerOf2(extendedGlobalPalette);
                            const options = {
                                palette: extendedGlobalPalette.colors,
                                loop: spec.loops
                            };
                            let gifWriter, buffer = new Buffer(bufferSizeEst);
                            try {
                                gifWriter = new Omggif.GifWriter(buffer, spec.width, spec.height, options);
                            } catch (err) {
                                throw new GifError(err);
                            }
                            for (let i = 0; i < frames.length; ++i) buffer = _writeFrame(gifWriter, i, frames[i], globalPalette, !1);
                            return new Gif(buffer.slice(0, gifWriter.end()), frames, spec);
                        }(frames, spec, 2000, colorInfo);
                    }
                    _getSizeEstimateGlobal(globalPalette, frames) {
                        if (this._testInitialBufferSize > 0) return this._testInitialBufferSize;
                        let sizeEst = 968;
                        const pixelBitWidth = _getPixelBitWidth(globalPalette);
                        return frames.forEach((frame => {
                            sizeEst += _getFrameSizeEst(frame, pixelBitWidth);
                        })), sizeEst;
                    }
                    _getSizeEstimateLocal(palettes, frames) {
                        if (this._testInitialBufferSize > 0) return this._testInitialBufferSize;
                        let sizeEst = 200;
                        for (let i = 0; i < frames.length; ++i) {
                            const pixelBitWidth = _getPixelBitWidth(palettes[i]);
                            sizeEst += _getFrameSizeEst(frames[i], pixelBitWidth);
                        }
                        return sizeEst;
                    }
                };
            }).call(this, require("_process"), require("buffer").Buffer);
        }, {
            "./gif": 66,
            "./gifframe": 68,
            "./gifutil": 69,
            _process: 133,
            buffer: 48,
            omggif: 64
        } ],
        68: [ function(require, module, exports) {
            const BitmapImage = require("./bitmapimage");
            require("./gif");
            class GifFrame extends BitmapImage {
                constructor(...args) {
                    if (super(...args), args[0] instanceof GifFrame) {
                        const source = args[0];
                        this.xOffset = source.xOffset, this.yOffset = source.yOffset, this.disposalMethod = source.disposalMethod, 
                        this.delayCentisecs = source.delayCentisecs, this.interlaced = source.interlaced;
                    } else {
                        const lastArg = args[args.length - 1];
                        let options = {};
                        "object" != typeof lastArg || lastArg instanceof BitmapImage || (options = lastArg), 
                        this.xOffset = options.xOffset || 0, this.yOffset = options.yOffset || 0, this.disposalMethod = void 0 !== options.disposalMethod ? options.disposalMethod : GifFrame.DisposeToBackgroundColor, 
                        this.delayCentisecs = options.delayCentisecs || 8, this.interlaced = options.interlaced || !1;
                    }
                }
                getPalette() {
                    const colorSet = new Set, buf = this.bitmap.data;
                    let i = 0, usesTransparency = !1;
                    for (;i < buf.length; ) {
                        if (0 === buf[i + 3]) usesTransparency = !0; else {
                            const color = buf.readUInt32BE(i, !0) >> 8 & 0xFFFFFF;
                            colorSet.add(color);
                        }
                        i += 4;
                    }
                    const colors = new Array(colorSet.size), iter = colorSet.values();
                    for (i = 0; i < colors.length; ++i) colors[i] = iter.next().value;
                    colors.sort(((a, b) => a - b));
                    let indexCount = colors.length;
                    return usesTransparency && ++indexCount, {
                        colors,
                        usesTransparency,
                        indexCount
                    };
                }
            }
            GifFrame.DisposeToAnything = 0, GifFrame.DisposeNothing = 1, GifFrame.DisposeToBackgroundColor = 2, 
            GifFrame.DisposeToPrevious = 3, exports.GifFrame = GifFrame;
        }, {
            "./bitmapimage": 65,
            "./gif": 66
        } ],
        69: [ function(require, module, exports) {
            (function(Buffer) {
                const fs = require("fs"), ImageQ = require("image-q"), BitmapImage = require("./bitmapimage"), {GifFrame} = require("./gifframe"), {GifError} = require("./gif"), {GifCodec} = require("./gifcodec"), INVALID_SUFFIXES = [ ".jpg", ".jpeg", ".png", ".bmp" ], defaultCodec = new GifCodec;
                function _quantize(imageOrImages, method, maxColorIndexes, modifier, dither) {
                    const images = Array.isArray(imageOrImages) ? imageOrImages : [ imageOrImages ];
                    if (dither) {
                        if ([ "FloydSteinberg", "FalseFloydSteinberg", "Stucki", "Atkinson", "Jarvis", "Burkes", "Sierra", "TwoSierra", "SierraLite" ].indexOf(dither.ditherAlgorithm) < 0) throw new Error(`Invalid ditherAlgorithm '${dither.ditherAlgorithm}'`);
                        void 0 === dither.serpentine && (dither.serpentine = !0), void 0 === dither.minimumColorDistanceToDither && (dither.minimumColorDistanceToDither = 0), 
                        void 0 === dither.calculateErrorLikeGIMP && (dither.calculateErrorLikeGIMP = !1);
                    }
                    const distCalculator = new ImageQ.distance.Euclidean, quantizer = new ImageQ.palette[method](distCalculator, maxColorIndexes, modifier);
                    let imageMaker;
                    imageMaker = dither ? new ImageQ.image.ErrorDiffusionArray(distCalculator, ImageQ.image.ErrorDiffusionArrayKernel[dither.ditherAlgorithm], dither.serpentine, dither.minimumColorDistanceToDither, dither.calculateErrorLikeGIMP) : new ImageQ.image.NearestColor(distCalculator);
                    const inputContainers = [];
                    images.forEach((image => {
                        const imageBuf = image.bitmap.data, inputBuf = new ArrayBuffer(imageBuf.length), inputArray = new Uint32Array(inputBuf);
                        for (let bi = 0, ai = 0; bi < imageBuf.length; bi += 4, ++ai) inputArray[ai] = imageBuf.readUInt32LE(bi, !0);
                        const inputContainer = ImageQ.utils.PointContainer.fromUint32Array(inputArray, image.bitmap.width, image.bitmap.height);
                        quantizer.sample(inputContainer), inputContainers.push(inputContainer);
                    }));
                    const limitedPalette = quantizer.quantize();
                    for (let i = 0; i < images.length; ++i) {
                        const imageBuf = images[i].bitmap.data, outputArray = imageMaker.quantize(inputContainers[i], limitedPalette).toUint32Array();
                        for (let bi = 0, ai = 0; bi < imageBuf.length; bi += 4, ++ai) imageBuf.writeUInt32LE(outputArray[ai], bi);
                    }
                }
                exports.cloneFrames = function(frames) {
                    let clones = [];
                    return frames.forEach((frame => {
                        clones.push(new GifFrame(frame));
                    })), clones;
                }, exports.getColorInfo = function(frames, maxGlobalIndex) {
                    let usesTransparency = !1;
                    const palettes = [];
                    for (let i = 0; i < frames.length; ++i) {
                        let palette = frames[i].getPalette();
                        if (palette.usesTransparency && (usesTransparency = !0), palette.indexCount > 256) throw new GifError(`Frame ${i} uses more than 256 color indexes`);
                        palettes.push(palette);
                    }
                    if (0 === maxGlobalIndex) return {
                        usesTransparency,
                        palettes
                    };
                    const globalColorSet = new Set;
                    palettes.forEach((palette => {
                        palette.colors.forEach((color => {
                            globalColorSet.add(color);
                        }));
                    }));
                    let indexCount = globalColorSet.size;
                    if (usesTransparency && ++indexCount, maxGlobalIndex && indexCount > maxGlobalIndex) return {
                        usesTransparency,
                        palettes
                    };
                    const colors = new Array(globalColorSet.size), iter = globalColorSet.values();
                    for (let i = 0; i < colors.length; ++i) colors[i] = iter.next().value;
                    return colors.sort(((a, b) => a - b)), {
                        colors,
                        indexCount,
                        usesTransparency,
                        palettes
                    };
                }, exports.copyAsJimp = function(jimp, bitmapImageToCopy) {
                    return exports.shareAsJimp(jimp, new BitmapImage(bitmapImageToCopy));
                }, exports.getMaxDimensions = function(frames) {
                    let maxWidth = 0, maxHeight = 0;
                    return frames.forEach((frame => {
                        const width = frame.xOffset + frame.bitmap.width;
                        width > maxWidth && (maxWidth = width);
                        const height = frame.yOffset + frame.bitmap.height;
                        height > maxHeight && (maxHeight = height);
                    })), {
                        maxWidth,
                        maxHeight
                    };
                }, exports.quantizeDekker = function(imageOrImages, maxColorIndexes, dither) {
                    _quantize(imageOrImages, "NeuQuantFloat", maxColorIndexes = maxColorIndexes || 256, 0, dither);
                }, exports.quantizeSorokin = function(imageOrImages, maxColorIndexes, histogram, dither) {
                    let histogramID;
                    switch (maxColorIndexes = maxColorIndexes || 256, histogram = histogram || "min-pop") {
                      case "min-pop":
                        histogramID = 2;
                        break;

                      case "top-pop":
                        histogramID = 1;
                        break;

                      default:
                        throw new Error(`Invalid quantizeSorokin histogram '${histogram}'`);
                    }
                    _quantize(imageOrImages, "RGBQuant", maxColorIndexes, histogramID, dither);
                }, exports.quantizeWu = function(imageOrImages, maxColorIndexes, significantBits, dither) {
                    if (maxColorIndexes = maxColorIndexes || 256, (significantBits = significantBits || 5) < 1 || significantBits > 8) throw new Error("Invalid quantization quality");
                    _quantize(imageOrImages, "WuQuant", maxColorIndexes, significantBits, dither);
                }, exports.read = function(source, decoder) {
                    return decoder = decoder || defaultCodec, Buffer.isBuffer(source) ? decoder.decodeGif(source) : function _readBinary(path) {
                        return new Promise(((resolve, reject) => {
                            fs.readFile(path, ((err, buffer) => err ? reject(err) : resolve(buffer)));
                        }));
                    }(source).then((buffer => decoder.decodeGif(buffer)));
                }, exports.shareAsJimp = function(jimp, bitmapImageToShare) {
                    const jimpImage = new jimp(bitmapImageToShare.bitmap.width, bitmapImageToShare.bitmap.height, 0);
                    return jimpImage.bitmap.data = bitmapImageToShare.bitmap.data, jimpImage;
                }, exports.write = function(path, frames, spec, encoder) {
                    encoder = encoder || defaultCodec;
                    const matches = path.match(/\.[a-zA-Z]+$/);
                    if (null !== matches && INVALID_SUFFIXES.includes(matches[0].toLowerCase())) throw new Error(`GIF '${path}' has an unexpected suffix`);
                    return encoder.encodeGif(frames, spec).then((gif => function _writeBinary(path, buffer) {
                        return new Promise(((resolve, reject) => {
                            fs.writeFile(path, buffer, (err => err ? reject(err) : resolve()));
                        }));
                    }(path, gif.buffer).then((() => gif))));
                };
            }).call(this, {
                isBuffer: require("../../is-buffer/index.js")
            });
        }, {
            "../../is-buffer/index.js": 76,
            "./bitmapimage": 65,
            "./gif": 66,
            "./gifcodec": 67,
            "./gifframe": 68,
            fs: 47,
            "image-q": 74
        } ],
        70: [ function(require, module, exports) {
            const BitmapImage = require("./bitmapimage"), {Gif, GifError} = require("./gif"), {GifCodec} = require("./gifcodec"), {GifFrame} = require("./gifframe"), GifUtil = require("./gifutil");
            module.exports = {
                BitmapImage,
                Gif,
                GifCodec,
                GifFrame,
                GifUtil,
                GifError
            };
        }, {
            "./bitmapimage": 65,
            "./gif": 66,
            "./gifcodec": 67,
            "./gifframe": 68,
            "./gifutil": 69
        } ],
        71: [ function(require, module, exports) {
            (function(global) {
                var win;
                win = void 0 !== window ? window : void 0 !== global ? global : "undefined" != typeof self ? self : {}, 
                module.exports = win;
            }).call(this, void 0 !== commonjsGlobal ? commonjsGlobal : "undefined" != typeof self ? self : void 0 !== window ? window : {});
        }, {} ],
        72: [ function(require, module, exports) {
            var http = require("http"), url = require("url"), https = module.exports;
            for (var key in http) http.hasOwnProperty(key) && (https[key] = http[key]);
            function validateParams(params) {
                if ("string" == typeof params && (params = url.parse(params)), params.protocol || (params.protocol = "https:"), 
                "https:" !== params.protocol) throw new Error('Protocol "' + params.protocol + '" not supported. Expected "https:"');
                return params;
            }
            https.request = function(params, cb) {
                return params = validateParams(params), http.request.call(this, params, cb);
            }, https.get = function(params, cb) {
                return params = validateParams(params), http.get.call(this, params, cb);
            };
        }, {
            http: 156,
            url: 180
        } ],
        73: [ function(require, module, exports) {
            exports.read = function(buffer, offset, isLE, mLen, nBytes) {
                var e, m, eLen = 8 * nBytes - mLen - 1, eMax = (1 << eLen) - 1, eBias = eMax >> 1, nBits = -7, i = isLE ? nBytes - 1 : 0, d = isLE ? -1 : 1, s = buffer[offset + i];
                for (i += d, e = s & (1 << -nBits) - 1, s >>= -nBits, nBits += eLen; nBits > 0; e = 256 * e + buffer[offset + i], 
                i += d, nBits -= 8) ;
                for (m = e & (1 << -nBits) - 1, e >>= -nBits, nBits += mLen; nBits > 0; m = 256 * m + buffer[offset + i], 
                i += d, nBits -= 8) ;
                if (0 === e) e = 1 - eBias; else {
                    if (e === eMax) return m ? NaN : 1 / 0 * (s ? -1 : 1);
                    m += Math.pow(2, mLen), e -= eBias;
                }
                return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
            }, exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
                var e, m, c, eLen = 8 * nBytes - mLen - 1, eMax = (1 << eLen) - 1, eBias = eMax >> 1, rt = 23 === mLen ? Math.pow(2, -24) - Math.pow(2, -77) : 0, i = isLE ? 0 : nBytes - 1, d = isLE ? 1 : -1, s = value < 0 || 0 === value && 1 / value < 0 ? 1 : 0;
                for (value = Math.abs(value), isNaN(value) || value === 1 / 0 ? (m = isNaN(value) ? 1 : 0, 
                e = eMax) : (e = Math.floor(Math.log(value) / Math.LN2), value * (c = Math.pow(2, -e)) < 1 && (e--, 
                c *= 2), (value += e + eBias >= 1 ? rt / c : rt * Math.pow(2, 1 - eBias)) * c >= 2 && (e++, 
                c /= 2), e + eBias >= eMax ? (m = 0, e = eMax) : e + eBias >= 1 ? (m = (value * c - 1) * Math.pow(2, mLen), 
                e += eBias) : (m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen), e = 0)); mLen >= 8; buffer[offset + i] = 0xff & m, 
                i += d, m /= 256, mLen -= 8) ;
                for (e = e << mLen | m, eLen += mLen; eLen > 0; buffer[offset + i] = 0xff & e, i += d, 
                e /= 256, eLen -= 8) ;
                buffer[offset + i - d] |= 128 * s;
            };
        }, {} ],
        74: [ function(require, module, exports) {
            !function webpackUniversalModuleDefinition(root, factory) {
                "object" == typeof exports && "object" == typeof module ? module.exports = factory() : "object" == typeof exports ? exports.iq = factory() : root.iq = factory();
            }(this, (function() {
                return function(modules) {
                    var installedModules = {};
                    function __webpack_require__(moduleId) {
                        if (installedModules[moduleId]) return installedModules[moduleId].exports;
                        var module = installedModules[moduleId] = {
                            exports: {},
                            id: moduleId,
                            loaded: !1
                        };
                        return modules[moduleId].call(module.exports, module, module.exports, __webpack_require__), 
                        module.loaded = !0, module.exports;
                    }
                    return __webpack_require__.m = modules, __webpack_require__.c = installedModules, 
                    __webpack_require__.p = "", __webpack_require__(0);
                }([ function(module, exports, __webpack_require__) {
                    /**
	 * @preserve
	 * Copyright 2015-2016 Igor Bezkrovnyi
	 * All rights reserved. (MIT Licensed)
	 *
	 * iq.ts - Image Quantization Library
	 */
                    var constants = __webpack_require__(1);
                    exports.constants = constants;
                    var conversion = __webpack_require__(3);
                    exports.conversion = conversion;
                    var distance = __webpack_require__(12);
                    exports.distance = distance;
                    var palette = __webpack_require__(20);
                    exports.palette = palette;
                    var image = __webpack_require__(30);
                    exports.image = image;
                    var quality = __webpack_require__(35);
                    exports.quality = quality;
                    var utils = __webpack_require__(37);
                    exports.utils = utils;
                }, function(module, exports, __webpack_require__) {
                    /**
	 * @preserve
	 * Copyright 2015-2016 Igor Bezkrovnyi
	 * All rights reserved. (MIT Licensed)
	 *
	 * constants.ts - part of Image Quantization Library
	 */
                    var bt709 = __webpack_require__(2);
                    exports.bt709 = bt709;
                }, function(module, exports) {
                    var Y, x, y;
                    !function(Y) {
                        Y[Y.RED = 0.2126] = "RED", Y[Y.GREEN = 0.7152] = "GREEN", Y[Y.BLUE = 0.0722] = "BLUE", 
                        Y[Y.WHITE = 1] = "WHITE";
                    }(Y || (Y = {})), exports.Y = Y, function(x) {
                        x[x.RED = 0.64] = "RED", x[x.GREEN = 0.3] = "GREEN", x[x.BLUE = 0.15] = "BLUE", 
                        x[x.WHITE = 0.3127] = "WHITE";
                    }(x || (x = {})), exports.x = x, function(y) {
                        y[y.RED = 0.33] = "RED", y[y.GREEN = 0.6] = "GREEN", y[y.BLUE = 0.06] = "BLUE", 
                        y[y.WHITE = 0.329] = "WHITE";
                    }(y || (y = {})), exports.y = y;
                }, function(module, exports, __webpack_require__) {
                    /**
	 * @preserve
	 * Copyright 2015-2016 Igor Bezkrovnyi
	 * All rights reserved. (MIT Licensed)
	 *
	 * iq.ts - Image Quantization Library
	 */
                    var rgb2xyz_1 = __webpack_require__(4);
                    exports.rgb2xyz = rgb2xyz_1.rgb2xyz;
                    var rgb2hsl_1 = __webpack_require__(5);
                    exports.rgb2hsl = rgb2hsl_1.rgb2hsl;
                    var rgb2lab_1 = __webpack_require__(7);
                    exports.rgb2lab = rgb2lab_1.rgb2lab;
                    var lab2xyz_1 = __webpack_require__(9);
                    exports.lab2xyz = lab2xyz_1.lab2xyz;
                    var lab2rgb_1 = __webpack_require__(10);
                    exports.lab2rgb = lab2rgb_1.lab2rgb;
                    var xyz2lab_1 = __webpack_require__(8);
                    exports.xyz2lab = xyz2lab_1.xyz2lab;
                    var xyz2rgb_1 = __webpack_require__(11);
                    exports.xyz2rgb = xyz2rgb_1.xyz2rgb;
                }, function(module, exports) {
                    /**
	 * @preserve
	 * Copyright 2015-2016 Igor Bezkrovnyi
	 * All rights reserved. (MIT Licensed)
	 *
	 * rgb2xyz.ts - part of Image Quantization Library
	 */
                    function correctGamma(n) {
                        return n > 0.04045 ? Math.pow((n + 0.055) / 1.055, 2.4) : n / 12.92;
                    }
                    exports.rgb2xyz = function rgb2xyz(r, g, b) {
                        return {
                            x: 0.4124 * (r = correctGamma(r / 255)) + 0.3576 * (g = correctGamma(g / 255)) + 0.1805 * (b = correctGamma(b / 255)),
                            y: 0.2126 * r + 0.7152 * g + 0.0722 * b,
                            z: 0.0193 * r + 0.1192 * g + 0.9505 * b
                        };
                    };
                }, function(module, exports, __webpack_require__) {
                    /**
	 * @preserve
	 * Copyright 2015-2016 Igor Bezkrovnyi
	 * All rights reserved. (MIT Licensed)
	 *
	 * rgb2hsl.ts - part of Image Quantization Library
	 */
                    var arithmetic_1 = __webpack_require__(6);
                    exports.rgb2hsl = function rgb2hsl(r, g, b) {
                        var min = arithmetic_1.min3(r, g, b), max = arithmetic_1.max3(r, g, b), delta = max - min, l = (min + max) / 510, s = 0;
                        l > 0 && l < 1 && (s = delta / (l < 0.5 ? max + min : 510 - max - min));
                        var h = 0;
                        return delta > 0 && (h = max === r ? (g - b) / delta : max === g ? 2 + (b - r) / delta : 4 + (r - g) / delta, 
                        (h *= 60) < 0 && (h += 360)), {
                            h,
                            s,
                            l
                        };
                    };
                }, function(module, exports) {
                    exports.degrees2radians = function degrees2radians(n) {
                        return n * (Math.PI / 180);
                    }, exports.max3 = function max3(a, b, c) {
                        var m = a;
                        return m < b && (m = b), m < c && (m = c), m;
                    }, exports.min3 = function min3(a, b, c) {
                        var m = a;
                        return m > b && (m = b), m > c && (m = c), m;
                    }, exports.intInRange = function intInRange(value, low, high) {
                        return value > high && (value = high), value < low && (value = low), 0 | value;
                    }, exports.inRange0to255Rounded = function inRange0to255Rounded(n) {
                        return (n = Math.round(n)) > 255 ? n = 255 : n < 0 && (n = 0), n;
                    }, exports.inRange0to255 = function inRange0to255(n) {
                        return n > 255 ? n = 255 : n < 0 && (n = 0), n;
                    }, exports.stableSort = function stableSort(arrayToSort, callback) {
                        var sorted, type = typeof arrayToSort[0];
                        if ("number" === type || "string" === type) {
                            for (var ord_1 = Object.create(null), i = 0, l = arrayToSort.length; i < l; i++) {
                                var val = arrayToSort[i];
                                ord_1[val] || 0 === ord_1[val] || (ord_1[val] = i);
                            }
                            sorted = arrayToSort.sort((function(a, b) {
                                return callback(a, b) || ord_1[a] - ord_1[b];
                            }));
                        } else {
                            var ord2_1 = arrayToSort.slice(0);
                            sorted = arrayToSort.sort((function(a, b) {
                                return callback(a, b) || ord2_1.indexOf(a) - ord2_1.indexOf(b);
                            }));
                        }
                        return sorted;
                    };
                }, function(module, exports, __webpack_require__) {
                    /**
	 * @preserve
	 * Copyright 2015-2016 Igor Bezkrovnyi
	 * All rights reserved. (MIT Licensed)
	 *
	 * rgb2lab.ts - part of Image Quantization Library
	 */
                    var rgb2xyz_1 = __webpack_require__(4), xyz2lab_1 = __webpack_require__(8);
                    exports.rgb2lab = function rgb2lab(r, g, b) {
                        var xyz = rgb2xyz_1.rgb2xyz(r, g, b);
                        return xyz2lab_1.xyz2lab(xyz.x, xyz.y, xyz.z);
                    };
                }, function(module, exports) {
                    function pivot(n) {
                        return n > 0.008856 ? Math.pow(n, 1 / 3) : 7.787 * n + 16 / 116;
                    }
                    exports.xyz2lab = function xyz2lab(x, y, z) {
                        if (x = pivot(x / .95047), y = pivot(y / 1), z = pivot(z / 1.08883), 116 * y - 16 < 0) throw new Error("xxx");
                        return {
                            L: Math.max(0, 116 * y - 16),
                            a: 500 * (x - y),
                            b: 200 * (y - z)
                        };
                    };
                }, function(module, exports) {
                    function pivot(n) {
                        return n > 0.206893034 ? Math.pow(n, 3) : (n - 16 / 116) / 7.787;
                    }
                    exports.lab2xyz = function lab2xyz(L, a, b) {
                        var y = (L + 16) / 116, z = y - b / 200;
                        return {
                            x: .95047 * pivot(a / 500 + y),
                            y: 1 * pivot(y),
                            z: 1.08883 * pivot(z)
                        };
                    };
                }, function(module, exports, __webpack_require__) {
                    /**
	 * @preserve
	 * Copyright 2015-2016 Igor Bezkrovnyi
	 * All rights reserved. (MIT Licensed)
	 *
	 * lab2rgb.ts - part of Image Quantization Library
	 */
                    var lab2xyz_1 = __webpack_require__(9), xyz2rgb_1 = __webpack_require__(11);
                    exports.lab2rgb = function lab2rgb(L, a, b) {
                        var xyz = lab2xyz_1.lab2xyz(L, a, b);
                        return xyz2rgb_1.xyz2rgb(xyz.x, xyz.y, xyz.z);
                    };
                }, function(module, exports, __webpack_require__) {
                    /**
	 * @preserve
	 * Copyright 2015-2016 Igor Bezkrovnyi
	 * All rights reserved. (MIT Licensed)
	 *
	 * xyz2rgb.ts - part of Image Quantization Library
	 */
                    var arithmetic_1 = __webpack_require__(6);
                    function correctGamma(n) {
                        return n > 0.0031308 ? 1.055 * Math.pow(n, 1 / 2.4) - 0.055 : 12.92 * n;
                    }
                    exports.xyz2rgb = function xyz2rgb(x, y, z) {
                        var r = correctGamma(3.2406 * x + -1.5372 * y + -0.4986 * z), g = correctGamma(-0.9689 * x + 1.8758 * y + 0.0415 * z), b = correctGamma(0.0557 * x + -0.2040 * y + 1.0570 * z);
                        return {
                            r: arithmetic_1.inRange0to255Rounded(255 * r),
                            g: arithmetic_1.inRange0to255Rounded(255 * g),
                            b: arithmetic_1.inRange0to255Rounded(255 * b)
                        };
                    };
                }, function(module, exports, __webpack_require__) {
                    /**
	 * @preserve
	 * Copyright 2015-2016 Igor Bezkrovnyi
	 * All rights reserved. (MIT Licensed)
	 *
	 * iq.ts - Image Quantization Library
	 */
                    var abstractDistanceCalculator_1 = __webpack_require__(13);
                    exports.AbstractDistanceCalculator = abstractDistanceCalculator_1.AbstractDistanceCalculator;
                    var cie94_1 = __webpack_require__(14);
                    exports.CIE94Textiles = cie94_1.CIE94Textiles, exports.CIE94GraphicArts = cie94_1.CIE94GraphicArts;
                    var ciede2000_1 = __webpack_require__(15);
                    exports.CIEDE2000 = ciede2000_1.CIEDE2000;
                    var cmetric_1 = __webpack_require__(16);
                    exports.CMETRIC = cmetric_1.CMETRIC;
                    var euclidean_1 = __webpack_require__(17);
                    exports.AbstractEuclidean = euclidean_1.AbstractEuclidean, exports.Euclidean = euclidean_1.Euclidean, 
                    exports.EuclideanRgbQuantWOAlpha = euclidean_1.EuclideanRgbQuantWOAlpha, exports.EuclideanRgbQuantWithAlpha = euclidean_1.EuclideanRgbQuantWithAlpha;
                    var manhattan_1 = __webpack_require__(18);
                    exports.AbstractManhattan = manhattan_1.AbstractManhattan, exports.Manhattan = manhattan_1.Manhattan, 
                    exports.ManhattanSRGB = manhattan_1.ManhattanSRGB, exports.ManhattanNommyde = manhattan_1.ManhattanNommyde;
                    var pngQuant_1 = __webpack_require__(19);
                    exports.PNGQUANT = pngQuant_1.PNGQUANT;
                }, function(module, exports) {
                    var AbstractDistanceCalculator = function() {
                        function AbstractDistanceCalculator() {
                            this._setDefaults(), this.setWhitePoint(255, 255, 255, 255);
                        }
                        return AbstractDistanceCalculator.prototype.setWhitePoint = function(r, g, b, a) {
                            this._whitePoint = {
                                r: r > 0 ? 255 / r : 0,
                                g: g > 0 ? 255 / g : 0,
                                b: b > 0 ? 255 / b : 0,
                                a: a > 0 ? 255 / a : 0
                            }, this._maxDistance = this.calculateRaw(r, g, b, a, 0, 0, 0, 0);
                        }, AbstractDistanceCalculator.prototype.calculateNormalized = function(colorA, colorB) {
                            return this.calculateRaw(colorA.r, colorA.g, colorA.b, colorA.a, colorB.r, colorB.g, colorB.b, colorB.a) / this._maxDistance;
                        }, AbstractDistanceCalculator.prototype._setDefaults = function() {}, AbstractDistanceCalculator;
                    }();
                    exports.AbstractDistanceCalculator = AbstractDistanceCalculator;
                }, function(module, exports, __webpack_require__) {
                    var __extends = this && this.__extends || function(d, b) {
                        for (var p in b) b.hasOwnProperty(p) && (d[p] = b[p]);
                        function __() {
                            this.constructor = d;
                        }
                        d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, new __);
                    }, abstractDistanceCalculator_1 = __webpack_require__(13), rgb2lab_1 = __webpack_require__(7), arithmetic_1 = __webpack_require__(6), AbstractCIE94 = function(_super) {
                        function AbstractCIE94() {
                            _super.apply(this, arguments);
                        }
                        return __extends(AbstractCIE94, _super), AbstractCIE94.prototype.calculateRaw = function(r1, g1, b1, a1, r2, g2, b2, a2) {
                            var lab1 = rgb2lab_1.rgb2lab(arithmetic_1.inRange0to255(r1 * this._whitePoint.r), arithmetic_1.inRange0to255(g1 * this._whitePoint.g), arithmetic_1.inRange0to255(b1 * this._whitePoint.b)), lab2 = rgb2lab_1.rgb2lab(arithmetic_1.inRange0to255(r2 * this._whitePoint.r), arithmetic_1.inRange0to255(g2 * this._whitePoint.g), arithmetic_1.inRange0to255(b2 * this._whitePoint.b)), dL = lab1.L - lab2.L, dA = lab1.a - lab2.a, dB = lab1.b - lab2.b, c1 = Math.sqrt(lab1.a * lab1.a + lab1.b * lab1.b), dC = c1 - Math.sqrt(lab2.a * lab2.a + lab2.b * lab2.b), deltaH = dA * dA + dB * dB - dC * dC;
                            deltaH = deltaH < 0 ? 0 : Math.sqrt(deltaH);
                            var dAlpha = (a2 - a1) * this._whitePoint.a * this._kA;
                            return Math.sqrt(Math.pow(dL / this._Kl, 2) + Math.pow(dC / (1.0 + this._K1 * c1), 2) + Math.pow(deltaH / (1.0 + this._K2 * c1), 2) + Math.pow(dAlpha, 2));
                        }, AbstractCIE94;
                    }(abstractDistanceCalculator_1.AbstractDistanceCalculator);
                    /**
	 * @preserve
	 * Copyright 2015-2016 Igor Bezkrovnyi
	 * All rights reserved. (MIT Licensed)
	 *
	 * cie94.ts - part of Image Quantization Library
	 */                    exports.AbstractCIE94 = AbstractCIE94;
                    var CIE94Textiles = function(_super) {
                        function CIE94Textiles() {
                            _super.apply(this, arguments);
                        }
                        return __extends(CIE94Textiles, _super), CIE94Textiles.prototype._setDefaults = function() {
                            this._Kl = 2.0, this._K1 = 0.048, this._K2 = 0.014, this._kA = 12.5 / 255;
                        }, CIE94Textiles;
                    }(AbstractCIE94);
                    exports.CIE94Textiles = CIE94Textiles;
                    var CIE94GraphicArts = function(_super) {
                        function CIE94GraphicArts() {
                            _super.apply(this, arguments);
                        }
                        return __extends(CIE94GraphicArts, _super), CIE94GraphicArts.prototype._setDefaults = function() {
                            this._Kl = 1.0, this._K1 = 0.045, this._K2 = 0.015, this._kA = 25 / 255;
                        }, CIE94GraphicArts;
                    }(AbstractCIE94);
                    exports.CIE94GraphicArts = CIE94GraphicArts;
                }, function(module, exports, __webpack_require__) {
                    var __extends = this && this.__extends || function(d, b) {
                        for (var p in b) b.hasOwnProperty(p) && (d[p] = b[p]);
                        function __() {
                            this.constructor = d;
                        }
                        d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, new __);
                    }, abstractDistanceCalculator_1 = __webpack_require__(13), rgb2lab_1 = __webpack_require__(7), arithmetic_1 = __webpack_require__(6), CIEDE2000 = function(_super) {
                        function CIEDE2000() {
                            _super.apply(this, arguments);
                        }
                        return __extends(CIEDE2000, _super), CIEDE2000.prototype.calculateRaw = function(r1, g1, b1, a1, r2, g2, b2, a2) {
                            var lab1 = rgb2lab_1.rgb2lab(arithmetic_1.inRange0to255(r1 * this._whitePoint.r), arithmetic_1.inRange0to255(g1 * this._whitePoint.g), arithmetic_1.inRange0to255(b1 * this._whitePoint.b)), lab2 = rgb2lab_1.rgb2lab(arithmetic_1.inRange0to255(r2 * this._whitePoint.r), arithmetic_1.inRange0to255(g2 * this._whitePoint.g), arithmetic_1.inRange0to255(b2 * this._whitePoint.b)), dA = (a2 - a1) * this._whitePoint.a * CIEDE2000._kA, dE2 = this.calculateRawInLab(lab1, lab2);
                            return Math.sqrt(dE2 + dA * dA);
                        }, CIEDE2000.prototype.calculateRawInLab = function(Lab1, Lab2) {
                            var L1 = Lab1.L, a1 = Lab1.a, b1 = Lab1.b, L2 = Lab2.L, a2 = Lab2.a, b2 = Lab2.b, C1 = Math.sqrt(a1 * a1 + b1 * b1), C2 = Math.sqrt(a2 * a2 + b2 * b2), pow_a_C1_C2_to_7 = Math.pow((C1 + C2) / 2.0, 7.0), G = 0.5 * (1.0 - Math.sqrt(pow_a_C1_C2_to_7 / (pow_a_C1_C2_to_7 + CIEDE2000._pow25to7))), a1p = (1.0 + G) * a1, a2p = (1.0 + G) * a2, C1p = Math.sqrt(a1p * a1p + b1 * b1), C2p = Math.sqrt(a2p * a2p + b2 * b2), C1pC2p = C1p * C2p, h1p = CIEDE2000._calculatehp(b1, a1p), h2p = CIEDE2000._calculatehp(b2, a2p), h_bar = Math.abs(h1p - h2p), dLp = L2 - L1, dCp = C2p - C1p, dHp = CIEDE2000._calculate_dHp(C1pC2p, h_bar, h2p, h1p), ahp = CIEDE2000._calculate_ahp(C1pC2p, h_bar, h1p, h2p), T = CIEDE2000._calculateT(ahp), aCp = (C1p + C2p) / 2.0, aLp_minus_50_square = Math.pow((L1 + L2) / 2.0 - 50.0, 2.0), S_L = 1.0 + .015 * aLp_minus_50_square / Math.sqrt(20.0 + aLp_minus_50_square), S_C = 1.0 + .045 * aCp, S_H = 1.0 + .015 * T * aCp, R_T = CIEDE2000._calculateRT(ahp, aCp), dLpSL = dLp / S_L, dCpSC = dCp / S_C, dHpSH = dHp / S_H;
                            return Math.pow(dLpSL, 2) + Math.pow(dCpSC, 2) + Math.pow(dHpSH, 2) + R_T * dCpSC * dHpSH;
                        }, CIEDE2000._calculatehp = function(b, ap) {
                            var hp = Math.atan2(b, ap);
                            return hp >= 0 ? hp : hp + CIEDE2000._deg360InRad;
                        }, CIEDE2000._calculateRT = function(ahp, aCp) {
                            var aCp_to_7 = Math.pow(aCp, 7.0), R_C = 2.0 * Math.sqrt(aCp_to_7 / (aCp_to_7 + CIEDE2000._pow25to7)), delta_theta = CIEDE2000._deg30InRad * Math.exp(-Math.pow((ahp - CIEDE2000._deg275InRad) / CIEDE2000._deg25InRad, 2.0));
                            return -Math.sin(2.0 * delta_theta) * R_C;
                        }, CIEDE2000._calculateT = function(ahp) {
                            return 1.0 - .17 * Math.cos(ahp - CIEDE2000._deg30InRad) + .24 * Math.cos(2.0 * ahp) + .32 * Math.cos(3.0 * ahp + CIEDE2000._deg6InRad) - .2 * Math.cos(4.0 * ahp - CIEDE2000._deg63InRad);
                        }, CIEDE2000._calculate_ahp = function(C1pC2p, h_bar, h1p, h2p) {
                            var hpSum = h1p + h2p;
                            return 0 == C1pC2p ? hpSum : h_bar <= CIEDE2000._deg180InRad ? hpSum / 2.0 : hpSum < CIEDE2000._deg360InRad ? (hpSum + CIEDE2000._deg360InRad) / 2.0 : (hpSum - CIEDE2000._deg360InRad) / 2.0;
                        }, CIEDE2000._calculate_dHp = function(C1pC2p, h_bar, h2p, h1p) {
                            var dhp;
                            return dhp = 0 == C1pC2p ? 0 : h_bar <= CIEDE2000._deg180InRad ? h2p - h1p : h2p <= h1p ? h2p - h1p + CIEDE2000._deg360InRad : h2p - h1p - CIEDE2000._deg360InRad, 
                            2.0 * Math.sqrt(C1pC2p) * Math.sin(dhp / 2.0);
                        }, CIEDE2000._kA = 25 / 255, CIEDE2000._pow25to7 = Math.pow(25, 7), CIEDE2000._deg360InRad = arithmetic_1.degrees2radians(360), 
                        CIEDE2000._deg180InRad = arithmetic_1.degrees2radians(180), CIEDE2000._deg30InRad = arithmetic_1.degrees2radians(30), 
                        CIEDE2000._deg6InRad = arithmetic_1.degrees2radians(6), CIEDE2000._deg63InRad = arithmetic_1.degrees2radians(63), 
                        CIEDE2000._deg275InRad = arithmetic_1.degrees2radians(275), CIEDE2000._deg25InRad = arithmetic_1.degrees2radians(25), 
                        CIEDE2000;
                    }(abstractDistanceCalculator_1.AbstractDistanceCalculator);
                    /**
	 * @preserve
	 * Copyright 2015-2016 Igor Bezkrovnyi
	 * All rights reserved. (MIT Licensed)
	 *
	 * ciede2000.ts - part of Image Quantization Library
	 */                    exports.CIEDE2000 = CIEDE2000;
                }, function(module, exports, __webpack_require__) {
                    var __extends = this && this.__extends || function(d, b) {
                        for (var p in b) b.hasOwnProperty(p) && (d[p] = b[p]);
                        function __() {
                            this.constructor = d;
                        }
                        d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, new __);
                    }, CMETRIC = function(_super) {
                        function CMETRIC() {
                            _super.apply(this, arguments);
                        }
                        return __extends(CMETRIC, _super), CMETRIC.prototype.calculateRaw = function(r1, g1, b1, a1, r2, g2, b2, a2) {
                            var rmean = (r1 + r2) / 2 * this._whitePoint.r, r = (r1 - r2) * this._whitePoint.r, g = (g1 - g2) * this._whitePoint.g, b = (b1 - b2) * this._whitePoint.b, dE = ((512 + rmean) * r * r >> 8) + 4 * g * g + ((767 - rmean) * b * b >> 8), dA = (a2 - a1) * this._whitePoint.a;
                            return Math.sqrt(dE + dA * dA);
                        }, CMETRIC;
                    }(__webpack_require__(13).AbstractDistanceCalculator);
                    /**
	 * @preserve
	 * Copyright 2015-2016 Igor Bezkrovnyi
	 * All rights reserved. (MIT Licensed)
	 *
	 * cmetric.ts - part of Image Quantization Library
	 */                    exports.CMETRIC = CMETRIC;
                }, function(module, exports, __webpack_require__) {
                    var __extends = this && this.__extends || function(d, b) {
                        for (var p in b) b.hasOwnProperty(p) && (d[p] = b[p]);
                        function __() {
                            this.constructor = d;
                        }
                        d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, new __);
                    }, abstractDistanceCalculator_1 = __webpack_require__(13), bt709_1 = __webpack_require__(2), AbstractEuclidean = function(_super) {
                        function AbstractEuclidean() {
                            _super.apply(this, arguments);
                        }
                        return __extends(AbstractEuclidean, _super), AbstractEuclidean.prototype.calculateRaw = function(r1, g1, b1, a1, r2, g2, b2, a2) {
                            var dR = r2 - r1, dG = g2 - g1, dB = b2 - b1, dA = a2 - a1;
                            return Math.sqrt(this._kR * dR * dR + this._kG * dG * dG + this._kB * dB * dB + this._kA * dA * dA);
                        }, AbstractEuclidean;
                    }(abstractDistanceCalculator_1.AbstractDistanceCalculator);
                    /**
	 * @preserve
	 * Copyright 2015-2016 Igor Bezkrovnyi
	 * All rights reserved. (MIT Licensed)
	 *
	 * euclidean.ts - part of Image Quantization Library
	 */                    exports.AbstractEuclidean = AbstractEuclidean;
                    var Euclidean = function(_super) {
                        function Euclidean() {
                            _super.apply(this, arguments);
                        }
                        return __extends(Euclidean, _super), Euclidean.prototype._setDefaults = function() {
                            this._kR = 1, this._kG = 1, this._kB = 1, this._kA = 1;
                        }, Euclidean;
                    }(AbstractEuclidean);
                    exports.Euclidean = Euclidean;
                    var EuclideanRgbQuantWithAlpha = function(_super) {
                        function EuclideanRgbQuantWithAlpha() {
                            _super.apply(this, arguments);
                        }
                        return __extends(EuclideanRgbQuantWithAlpha, _super), EuclideanRgbQuantWithAlpha.prototype._setDefaults = function() {
                            this._kR = bt709_1.Y.RED, this._kG = bt709_1.Y.GREEN, this._kB = bt709_1.Y.BLUE, 
                            this._kA = 1;
                        }, EuclideanRgbQuantWithAlpha;
                    }(AbstractEuclidean);
                    exports.EuclideanRgbQuantWithAlpha = EuclideanRgbQuantWithAlpha;
                    var EuclideanRgbQuantWOAlpha = function(_super) {
                        function EuclideanRgbQuantWOAlpha() {
                            _super.apply(this, arguments);
                        }
                        return __extends(EuclideanRgbQuantWOAlpha, _super), EuclideanRgbQuantWOAlpha.prototype._setDefaults = function() {
                            this._kR = bt709_1.Y.RED, this._kG = bt709_1.Y.GREEN, this._kB = bt709_1.Y.BLUE, 
                            this._kA = 0;
                        }, EuclideanRgbQuantWOAlpha;
                    }(AbstractEuclidean);
                    exports.EuclideanRgbQuantWOAlpha = EuclideanRgbQuantWOAlpha;
                }, function(module, exports, __webpack_require__) {
                    var __extends = this && this.__extends || function(d, b) {
                        for (var p in b) b.hasOwnProperty(p) && (d[p] = b[p]);
                        function __() {
                            this.constructor = d;
                        }
                        d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, new __);
                    }, abstractDistanceCalculator_1 = __webpack_require__(13), bt709_1 = __webpack_require__(2), AbstractManhattan = function(_super) {
                        function AbstractManhattan() {
                            _super.apply(this, arguments);
                        }
                        return __extends(AbstractManhattan, _super), AbstractManhattan.prototype.calculateRaw = function(r1, g1, b1, a1, r2, g2, b2, a2) {
                            var dR = r2 - r1, dG = g2 - g1, dB = b2 - b1, dA = a2 - a1;
                            return dR < 0 && (dR = 0 - dR), dG < 0 && (dG = 0 - dG), dB < 0 && (dB = 0 - dB), 
                            dA < 0 && (dA = 0 - dA), this._kR * dR + this._kG * dG + this._kB * dB + this._kA * dA;
                        }, AbstractManhattan;
                    }(abstractDistanceCalculator_1.AbstractDistanceCalculator);
                    /**
	 * @preserve
	 * Copyright 2015-2016 Igor Bezkrovnyi
	 * All rights reserved. (MIT Licensed)
	 *
	 * manhattanNeuQuant.ts - part of Image Quantization Library
	 */                    exports.AbstractManhattan = AbstractManhattan;
                    var Manhattan = function(_super) {
                        function Manhattan() {
                            _super.apply(this, arguments);
                        }
                        return __extends(Manhattan, _super), Manhattan.prototype._setDefaults = function() {
                            this._kR = 1, this._kG = 1, this._kB = 1, this._kA = 1;
                        }, Manhattan;
                    }(AbstractManhattan);
                    exports.Manhattan = Manhattan;
                    var ManhattanNommyde = function(_super) {
                        function ManhattanNommyde() {
                            _super.apply(this, arguments);
                        }
                        return __extends(ManhattanNommyde, _super), ManhattanNommyde.prototype._setDefaults = function() {
                            this._kR = 0.4984, this._kG = 0.8625, this._kB = 0.2979, this._kA = 1;
                        }, ManhattanNommyde;
                    }(AbstractManhattan);
                    exports.ManhattanNommyde = ManhattanNommyde;
                    var ManhattanSRGB = function(_super) {
                        function ManhattanSRGB() {
                            _super.apply(this, arguments);
                        }
                        return __extends(ManhattanSRGB, _super), ManhattanSRGB.prototype._setDefaults = function() {
                            this._kR = bt709_1.Y.RED, this._kG = bt709_1.Y.GREEN, this._kB = bt709_1.Y.BLUE, 
                            this._kA = 1;
                        }, ManhattanSRGB;
                    }(AbstractManhattan);
                    exports.ManhattanSRGB = ManhattanSRGB;
                }, function(module, exports, __webpack_require__) {
                    var __extends = this && this.__extends || function(d, b) {
                        for (var p in b) b.hasOwnProperty(p) && (d[p] = b[p]);
                        function __() {
                            this.constructor = d;
                        }
                        d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, new __);
                    }, PNGQUANT = function(_super) {
                        function PNGQUANT() {
                            _super.apply(this, arguments);
                        }
                        return __extends(PNGQUANT, _super), PNGQUANT.prototype.calculateRaw = function(r1, g1, b1, a1, r2, g2, b2, a2) {
                            var alphas = (a2 - a1) * this._whitePoint.a;
                            return this._colordifference_ch(r1 * this._whitePoint.r, r2 * this._whitePoint.r, alphas) + this._colordifference_ch(g1 * this._whitePoint.g, g2 * this._whitePoint.g, alphas) + this._colordifference_ch(b1 * this._whitePoint.b, b2 * this._whitePoint.b, alphas);
                        }, PNGQUANT.prototype._colordifference_ch = function(x, y, alphas) {
                            var black = x - y, white = black + alphas;
                            return black * black + white * white;
                        }, PNGQUANT;
                    }(__webpack_require__(13).AbstractDistanceCalculator);
                    /**
	 * @preserve
	 * Copyright 2015-2016 Igor Bezkrovnyi
	 * All rights reserved. (MIT Licensed)
	 *
	 * pngQuant.ts - part of Image Quantization Library
	 */                    exports.PNGQUANT = PNGQUANT;
                }, function(module, exports, __webpack_require__) {
                    var neuquant_1 = __webpack_require__(21);
                    exports.NeuQuant = neuquant_1.NeuQuant;
                    var neuquantFloat_1 = __webpack_require__(25);
                    exports.NeuQuantFloat = neuquantFloat_1.NeuQuantFloat;
                    var rgbquant_1 = __webpack_require__(26);
                    exports.RGBQuant = rgbquant_1.RGBQuant;
                    var colorHistogram_1 = __webpack_require__(27);
                    exports.ColorHistogram = colorHistogram_1.ColorHistogram;
                    var wuQuant_1 = __webpack_require__(29);
                    exports.WuQuant = wuQuant_1.WuQuant, exports.WuColorCube = wuQuant_1.WuColorCube;
                }, function(module, exports, __webpack_require__) {
                    /**
	 * @preserve TypeScript port:
	 * Copyright 2015-2016 Igor Bezkrovnyi
	 * All rights reserved. (MIT Licensed)
	 *
	 * neuquant.ts - part of Image Quantization Library
	 */
                    var palette_1 = __webpack_require__(22), point_1 = __webpack_require__(24), Neuron = function() {
                        function Neuron(defaultValue) {
                            this.r = this.g = this.b = this.a = defaultValue;
                        }
                        return Neuron.prototype.toPoint = function() {
                            return point_1.Point.createByRGBA(this.r >> 3, this.g >> 3, this.b >> 3, this.a >> 3);
                        }, Neuron.prototype.subtract = function(r, g, b, a) {
                            this.r -= 0 | r, this.g -= 0 | g, this.b -= 0 | b, this.a -= 0 | a;
                        }, Neuron;
                    }(), NeuQuant = function() {
                        function NeuQuant(colorDistanceCalculator, colors) {
                            void 0 === colors && (colors = 256), this._distance = colorDistanceCalculator, this._pointArray = [], 
                            this._sampleFactor = 1, this._networkSize = colors, this._distance.setWhitePoint(2040, 2040, 2040, 2040);
                        }
                        return NeuQuant.prototype.sample = function(pointBuffer) {
                            this._pointArray = this._pointArray.concat(pointBuffer.getPointArray());
                        }, NeuQuant.prototype.quantize = function() {
                            return this._init(), this._learn(), this._buildPalette();
                        }, NeuQuant.prototype._init = function() {
                            this._freq = [], this._bias = [], this._radPower = [], this._network = [];
                            for (var i = 0; i < this._networkSize; i++) this._network[i] = new Neuron((i << 11) / this._networkSize | 0), 
                            this._freq[i] = NeuQuant._initialBias / this._networkSize | 0, this._bias[i] = 0;
                        }, NeuQuant.prototype._learn = function() {
                            var sampleFactor = this._sampleFactor, pointsNumber = this._pointArray.length;
                            pointsNumber < NeuQuant._minpicturebytes && (sampleFactor = 1);
                            var step, alphadec = 30 + (sampleFactor - 1) / 3 | 0, pointsToSample = pointsNumber / sampleFactor | 0, delta = pointsToSample / NeuQuant._nCycles | 0, alpha = NeuQuant._initAlpha, radius = (this._networkSize >> 3) * NeuQuant._radiusBias, rad = radius >> NeuQuant._radiusBiasShift;
                            rad <= 1 && (rad = 0);
                            for (var i = 0; i < rad; i++) this._radPower[i] = alpha * ((rad * rad - i * i) * NeuQuant._radBias / (rad * rad)) >>> 0;
                            step = pointsNumber < NeuQuant._minpicturebytes ? 1 : pointsNumber % NeuQuant._prime1 != 0 ? NeuQuant._prime1 : pointsNumber % NeuQuant._prime2 != 0 ? NeuQuant._prime2 : pointsNumber % NeuQuant._prime3 != 0 ? NeuQuant._prime3 : NeuQuant._prime4, 
                            i = 0;
                            for (var pointIndex = 0; i < pointsToSample; ) {
                                var point = this._pointArray[pointIndex], b = point.b << 3, g = point.g << 3, r = point.r << 3, a = point.a << 3, neuronIndex = this._contest(b, g, r, a);
                                if (this._alterSingle(alpha, neuronIndex, b, g, r, a), 0 !== rad && this._alterNeighbour(rad, neuronIndex, b, g, r, a), 
                                (pointIndex += step) >= pointsNumber && (pointIndex -= pointsNumber), 0 === delta && (delta = 1), 
                                ++i % delta == 0) {
                                    alpha -= alpha / alphadec | 0, (rad = (radius -= radius / NeuQuant._radiusDecrease | 0) >> NeuQuant._radiusBiasShift) <= 1 && (rad = 0);
                                    for (var j = 0; j < rad; j++) this._radPower[j] = alpha * ((rad * rad - j * j) * NeuQuant._radBias / (rad * rad)) >>> 0;
                                }
                            }
                        }, NeuQuant.prototype._buildPalette = function() {
                            var palette = new palette_1.Palette;
                            return this._network.forEach((function(neuron) {
                                palette.add(neuron.toPoint());
                            })), palette.sort(), palette;
                        }, NeuQuant.prototype._alterNeighbour = function(rad, i, b, g, r, al) {
                            var lo = i - rad;
                            lo < -1 && (lo = -1);
                            var hi = i + rad;
                            hi > this._networkSize && (hi = this._networkSize);
                            for (var j = i + 1, k = i - 1, m = 1; j < hi || k > lo; ) {
                                var p, a = this._radPower[m++] / NeuQuant._alphaRadBias;
                                j < hi && (p = this._network[j++]).subtract(a * (p.r - r), a * (p.g - g), a * (p.b - b), a * (p.a - al)), 
                                k > lo && (p = this._network[k--]).subtract(a * (p.r - r), a * (p.g - g), a * (p.b - b), a * (p.a - al));
                            }
                        }, NeuQuant.prototype._alterSingle = function(alpha, i, b, g, r, a) {
                            alpha /= NeuQuant._initAlpha;
                            var n = this._network[i];
                            n.subtract(alpha * (n.r - r), alpha * (n.g - g), alpha * (n.b - b), alpha * (n.a - a));
                        }, NeuQuant.prototype._contest = function(b, g, r, a) {
                            for (var bestd = ~(1 << 31), bestbiasd = bestd, bestpos = -1, bestbiaspos = bestpos, i = 0; i < this._networkSize; i++) {
                                var n = this._network[i], dist = 8160 * this._distance.calculateNormalized(n, {
                                    r,
                                    g,
                                    b,
                                    a
                                }) | 0;
                                dist < bestd && (bestd = dist, bestpos = i);
                                var biasdist = dist - (this._bias[i] >> NeuQuant._initialBiasShift - 3);
                                biasdist < bestbiasd && (bestbiasd = biasdist, bestbiaspos = i);
                                var betafreq = this._freq[i] >> NeuQuant._betaShift;
                                this._freq[i] -= betafreq, this._bias[i] += betafreq << NeuQuant._gammaShift;
                            }
                            return this._freq[bestpos] += NeuQuant._beta, this._bias[bestpos] -= NeuQuant._betaGamma, 
                            bestbiaspos;
                        }, NeuQuant._prime1 = 499, NeuQuant._prime2 = 491, NeuQuant._prime3 = 487, NeuQuant._prime4 = 503, 
                        NeuQuant._minpicturebytes = NeuQuant._prime4, NeuQuant._nCycles = 100, NeuQuant._initialBiasShift = 16, 
                        NeuQuant._initialBias = 1 << NeuQuant._initialBiasShift, NeuQuant._gammaShift = 10, 
                        NeuQuant._betaShift = 10, NeuQuant._beta = NeuQuant._initialBias >> NeuQuant._betaShift, 
                        NeuQuant._betaGamma = NeuQuant._initialBias << NeuQuant._gammaShift - NeuQuant._betaShift, 
                        NeuQuant._radiusBiasShift = 6, NeuQuant._radiusBias = 1 << NeuQuant._radiusBiasShift, 
                        NeuQuant._radiusDecrease = 30, NeuQuant._alphaBiasShift = 10, NeuQuant._initAlpha = 1 << NeuQuant._alphaBiasShift, 
                        NeuQuant._radBiasShift = 8, NeuQuant._radBias = 1 << NeuQuant._radBiasShift, NeuQuant._alphaRadBiasShift = NeuQuant._alphaBiasShift + NeuQuant._radBiasShift, 
                        NeuQuant._alphaRadBias = 1 << NeuQuant._alphaRadBiasShift, NeuQuant;
                    }();
                    exports.NeuQuant = NeuQuant;
                }, function(module, exports, __webpack_require__) {
                    var pointContainer_1 = __webpack_require__(23), rgb2hsl_1 = __webpack_require__(5);
                    function hueGroup(hue, segmentsNumber) {
                        for (var seg = 360 / segmentsNumber, i = 1, mid = seg - seg / 2; i < segmentsNumber; i++, 
                        mid += seg) if (hue >= mid && hue < mid + seg) return i;
                        return 0;
                    }
                    exports.hueGroup = hueGroup;
                    var Palette = function() {
                        function Palette() {
                            this._pointArray = [], this._i32idx = {}, this._pointContainer = new pointContainer_1.PointContainer, 
                            this._pointContainer.setHeight(1), this._pointArray = this._pointContainer.getPointArray();
                        }
                        return Palette.prototype.add = function(color) {
                            this._pointArray.push(color), this._pointContainer.setWidth(this._pointArray.length);
                        }, Palette.prototype.has = function(color) {
                            for (var i = this._pointArray.length - 1; i >= 0; i--) if (color.uint32 === this._pointArray[i].uint32) return !0;
                            return !1;
                        }, Palette.prototype.getNearestColor = function(colorDistanceCalculator, color) {
                            return this._pointArray[0 | this.getNearestIndex(colorDistanceCalculator, color)];
                        }, Palette.prototype.getPointContainer = function() {
                            return this._pointContainer;
                        }, Palette.prototype._nearestPointFromCache = function(key) {
                            return "number" == typeof this._i32idx[key] ? this._i32idx[key] : -1;
                        }, Palette.prototype.getNearestIndex = function(colorDistanceCalculator, point) {
                            var idx = this._nearestPointFromCache("" + point.uint32);
                            if (idx >= 0) return idx;
                            var minimalDistance = Number.MAX_VALUE;
                            idx = 0;
                            for (var i = 0, l = this._pointArray.length; i < l; i++) {
                                var p = this._pointArray[i], distance = colorDistanceCalculator.calculateRaw(point.r, point.g, point.b, point.a, p.r, p.g, p.b, p.a);
                                distance < minimalDistance && (minimalDistance = distance, idx = i);
                            }
                            return this._i32idx[point.uint32] = idx, idx;
                        }, Palette.prototype.sort = function() {
                            this._i32idx = {}, this._pointArray.sort((function(a, b) {
                                var hslA = rgb2hsl_1.rgb2hsl(a.r, a.g, a.b), hslB = rgb2hsl_1.rgb2hsl(b.r, b.g, b.b), hueA = a.r === a.g && a.g === a.b ? 0 : 1 + hueGroup(hslA.h, 10), hueDiff = (b.r === b.g && b.g === b.b ? 0 : 1 + hueGroup(hslB.h, 10)) - hueA;
                                if (hueDiff) return -hueDiff;
                                var lA = a.getLuminosity(!0), lB = b.getLuminosity(!0);
                                if (lB - lA != 0) return lB - lA;
                                var satDiff = (100 * hslB.s | 0) - (100 * hslA.s | 0);
                                return satDiff ? -satDiff : 0;
                            }));
                        }, Palette;
                    }();
                    exports.Palette = Palette;
                }, function(module, exports, __webpack_require__) {
                    /**
	 * @preserve
	 * Copyright 2015-2016 Igor Bezkrovnyi
	 * All rights reserved. (MIT Licensed)
	 *
	 * pointContainer.ts - part of Image Quantization Library
	 */
                    var point_1 = __webpack_require__(24), PointContainer = function() {
                        function PointContainer() {
                            this._width = 0, this._height = 0, this._pointArray = [];
                        }
                        return PointContainer.prototype.getWidth = function() {
                            return this._width;
                        }, PointContainer.prototype.getHeight = function() {
                            return this._height;
                        }, PointContainer.prototype.setWidth = function(width) {
                            this._width = width;
                        }, PointContainer.prototype.setHeight = function(height) {
                            this._height = height;
                        }, PointContainer.prototype.getPointArray = function() {
                            return this._pointArray;
                        }, PointContainer.prototype.clone = function() {
                            var clone = new PointContainer;
                            clone._width = this._width, clone._height = this._height;
                            for (var i = 0, l = this._pointArray.length; i < l; i++) clone._pointArray[i] = point_1.Point.createByUint32(0 | this._pointArray[i].uint32);
                            return clone;
                        }, PointContainer.prototype.toUint32Array = function() {
                            for (var l = this._pointArray.length, uint32Array = new Uint32Array(l), i = 0; i < l; i++) uint32Array[i] = this._pointArray[i].uint32;
                            return uint32Array;
                        }, PointContainer.prototype.toUint8Array = function() {
                            return new Uint8Array(this.toUint32Array().buffer);
                        }, PointContainer.fromHTMLImageElement = function(img) {
                            var width = img.naturalWidth, height = img.naturalHeight, canvas = document.createElement("canvas");
                            return canvas.width = width, canvas.height = height, canvas.getContext("2d").drawImage(img, 0, 0, width, height, 0, 0, width, height), 
                            PointContainer.fromHTMLCanvasElement(canvas);
                        }, PointContainer.fromHTMLCanvasElement = function(canvas) {
                            var width = canvas.width, height = canvas.height, imgData = canvas.getContext("2d").getImageData(0, 0, width, height);
                            return PointContainer.fromImageData(imgData);
                        }, PointContainer.fromNodeCanvas = function(canvas) {
                            return PointContainer.fromHTMLCanvasElement(canvas);
                        }, PointContainer.fromImageData = function(imageData) {
                            var width = imageData.width, height = imageData.height;
                            return PointContainer.fromCanvasPixelArray(imageData.data, width, height);
                        }, PointContainer.fromArray = function(byteArray, width, height) {
                            var uint8array = new Uint8Array(byteArray);
                            return PointContainer.fromUint8Array(uint8array, width, height);
                        }, PointContainer.fromCanvasPixelArray = function(data, width, height) {
                            return PointContainer.fromArray(data, width, height);
                        }, PointContainer.fromUint8Array = function(uint8array, width, height) {
                            return PointContainer.fromUint32Array(new Uint32Array(uint8array.buffer), width, height);
                        }, PointContainer.fromUint32Array = function(uint32array, width, height) {
                            var container = new PointContainer;
                            container._width = width, container._height = height;
                            for (var i = 0, l = uint32array.length; i < l; i++) container._pointArray[i] = point_1.Point.createByUint32(0 | uint32array[i]);
                            return container;
                        }, PointContainer;
                    }();
                    exports.PointContainer = PointContainer;
                }, function(module, exports, __webpack_require__) {
                    /**
	 * @preserve
	 * Copyright 2015-2016 Igor Bezkrovnyi
	 * All rights reserved. (MIT Licensed)
	 *
	 * point.ts - part of Image Quantization Library
	 */
                    var bt709_1 = __webpack_require__(2), Point = function() {
                        function Point() {
                            this.uint32 = -1 >>> 0, this.r = this.g = this.b = this.a = 0, this.rgba = new Array(4), 
                            this.rgba[0] = 0, this.rgba[1] = 0, this.rgba[2] = 0, this.rgba[3] = 0;
                        }
                        return Point.createByQuadruplet = function(quadruplet) {
                            var point = new Point;
                            return point.r = 0 | quadruplet[0], point.g = 0 | quadruplet[1], point.b = 0 | quadruplet[2], 
                            point.a = 0 | quadruplet[3], point._loadUINT32(), point._loadQuadruplet(), point;
                        }, Point.createByRGBA = function(red, green, blue, alpha) {
                            var point = new Point;
                            return point.r = 0 | red, point.g = 0 | green, point.b = 0 | blue, point.a = 0 | alpha, 
                            point._loadUINT32(), point._loadQuadruplet(), point;
                        }, Point.createByUint32 = function(uint32) {
                            var point = new Point;
                            return point.uint32 = uint32 >>> 0, point._loadRGBA(), point._loadQuadruplet(), 
                            point;
                        }, Point.prototype.from = function(point) {
                            this.r = point.r, this.g = point.g, this.b = point.b, this.a = point.a, this.uint32 = point.uint32, 
                            this.rgba[0] = point.r, this.rgba[1] = point.g, this.rgba[2] = point.b, this.rgba[3] = point.a;
                        }, Point.prototype.getLuminosity = function(useAlphaChannel) {
                            var r = this.r, g = this.g, b = this.b;
                            return useAlphaChannel && (r = Math.min(255, 255 - this.a + this.a * r / 255), g = Math.min(255, 255 - this.a + this.a * g / 255), 
                            b = Math.min(255, 255 - this.a + this.a * b / 255)), r * bt709_1.Y.RED + g * bt709_1.Y.GREEN + b * bt709_1.Y.BLUE;
                        }, Point.prototype._loadUINT32 = function() {
                            this.uint32 = (this.a << 24 | this.b << 16 | this.g << 8 | this.r) >>> 0;
                        }, Point.prototype._loadRGBA = function() {
                            this.r = 0xff & this.uint32, this.g = this.uint32 >>> 8 & 0xff, this.b = this.uint32 >>> 16 & 0xff, 
                            this.a = this.uint32 >>> 24 & 0xff;
                        }, Point.prototype._loadQuadruplet = function() {
                            this.rgba[0] = this.r, this.rgba[1] = this.g, this.rgba[2] = this.b, this.rgba[3] = this.a;
                        }, Point;
                    }();
                    exports.Point = Point;
                }, function(module, exports, __webpack_require__) {
                    /**
	 * @preserve TypeScript port:
	 * Copyright 2015-2016 Igor Bezkrovnyi
	 * All rights reserved. (MIT Licensed)
	 *
	 * neuquant.ts - part of Image Quantization Library
	 */
                    var palette_1 = __webpack_require__(22), point_1 = __webpack_require__(24), NeuronFloat = function() {
                        function NeuronFloat(defaultValue) {
                            this.r = this.g = this.b = this.a = defaultValue;
                        }
                        return NeuronFloat.prototype.toPoint = function() {
                            return point_1.Point.createByRGBA(this.r >> 3, this.g >> 3, this.b >> 3, this.a >> 3);
                        }, NeuronFloat.prototype.subtract = function(r, g, b, a) {
                            this.r -= r, this.g -= g, this.b -= b, this.a -= a;
                        }, NeuronFloat;
                    }(), NeuQuantFloat = function() {
                        function NeuQuantFloat(colorDistanceCalculator, colors) {
                            void 0 === colors && (colors = 256), this._distance = colorDistanceCalculator, this._pointArray = [], 
                            this._sampleFactor = 1, this._networkSize = colors, this._distance.setWhitePoint(2040, 2040, 2040, 2040);
                        }
                        return NeuQuantFloat.prototype.sample = function(pointBuffer) {
                            this._pointArray = this._pointArray.concat(pointBuffer.getPointArray());
                        }, NeuQuantFloat.prototype.quantize = function() {
                            return this._init(), this._learn(), this._buildPalette();
                        }, NeuQuantFloat.prototype._init = function() {
                            this._freq = [], this._bias = [], this._radPower = [], this._network = [];
                            for (var i = 0; i < this._networkSize; i++) this._network[i] = new NeuronFloat((i << 11) / this._networkSize), 
                            this._freq[i] = NeuQuantFloat._initialBias / this._networkSize, this._bias[i] = 0;
                        }, NeuQuantFloat.prototype._learn = function() {
                            var sampleFactor = this._sampleFactor, pointsNumber = this._pointArray.length;
                            pointsNumber < NeuQuantFloat._minpicturebytes && (sampleFactor = 1);
                            var step, alphadec = 30 + (sampleFactor - 1) / 3, pointsToSample = pointsNumber / sampleFactor, delta = pointsToSample / NeuQuantFloat._nCycles | 0, alpha = NeuQuantFloat._initAlpha, radius = (this._networkSize >> 3) * NeuQuantFloat._radiusBias, rad = radius >> NeuQuantFloat._radiusBiasShift;
                            rad <= 1 && (rad = 0);
                            for (var i = 0; i < rad; i++) this._radPower[i] = alpha * ((rad * rad - i * i) * NeuQuantFloat._radBias / (rad * rad));
                            step = pointsNumber < NeuQuantFloat._minpicturebytes ? 1 : pointsNumber % NeuQuantFloat._prime1 != 0 ? NeuQuantFloat._prime1 : pointsNumber % NeuQuantFloat._prime2 != 0 ? NeuQuantFloat._prime2 : pointsNumber % NeuQuantFloat._prime3 != 0 ? NeuQuantFloat._prime3 : NeuQuantFloat._prime4, 
                            i = 0;
                            for (var pointIndex = 0; i < pointsToSample; ) {
                                var point = this._pointArray[pointIndex], b = point.b << 3, g = point.g << 3, r = point.r << 3, a = point.a << 3, neuronIndex = this._contest(b, g, r, a);
                                if (this._alterSingle(alpha, neuronIndex, b, g, r, a), 0 != rad && this._alterNeighbour(rad, neuronIndex, b, g, r, a), 
                                (pointIndex += step) >= pointsNumber && (pointIndex -= pointsNumber), 0 == delta && (delta = 1), 
                                ++i % delta == 0) {
                                    alpha -= alpha / alphadec, (rad = (radius -= radius / NeuQuantFloat._radiusDecrease) >> NeuQuantFloat._radiusBiasShift) <= 1 && (rad = 0);
                                    for (var j = 0; j < rad; j++) this._radPower[j] = alpha * ((rad * rad - j * j) * NeuQuantFloat._radBias / (rad * rad));
                                }
                            }
                        }, NeuQuantFloat.prototype._buildPalette = function() {
                            var palette = new palette_1.Palette;
                            return this._network.forEach((function(neuron) {
                                palette.add(neuron.toPoint());
                            })), palette.sort(), palette;
                        }, NeuQuantFloat.prototype._alterNeighbour = function(rad, i, b, g, r, al) {
                            var lo = i - rad;
                            lo < -1 && (lo = -1);
                            var hi = i + rad;
                            hi > this._networkSize && (hi = this._networkSize);
                            for (var j = i + 1, k = i - 1, m = 1; j < hi || k > lo; ) {
                                var p, a = this._radPower[m++] / NeuQuantFloat._alphaRadBias;
                                j < hi && (p = this._network[j++]).subtract(a * (p.r - r), a * (p.g - g), a * (p.b - b), a * (p.a - al)), 
                                k > lo && (p = this._network[k--]).subtract(a * (p.r - r), a * (p.g - g), a * (p.b - b), a * (p.a - al));
                            }
                        }, NeuQuantFloat.prototype._alterSingle = function(alpha, i, b, g, r, a) {
                            alpha /= NeuQuantFloat._initAlpha;
                            var n = this._network[i];
                            n.subtract(alpha * (n.r - r), alpha * (n.g - g), alpha * (n.b - b), alpha * (n.a - a));
                        }, NeuQuantFloat.prototype._contest = function(b, g, r, al) {
                            for (var bestd = ~(1 << 31), bestbiasd = bestd, bestpos = -1, bestbiaspos = bestpos, i = 0; i < this._networkSize; i++) {
                                var n = this._network[i], dist = 8160 * this._distance.calculateNormalized(n, {
                                    r,
                                    g,
                                    b,
                                    a: al
                                });
                                dist < bestd && (bestd = dist, bestpos = i);
                                var biasdist = dist - (this._bias[i] >> NeuQuantFloat._initialBiasShift - 3);
                                biasdist < bestbiasd && (bestbiasd = biasdist, bestbiaspos = i);
                                var betafreq = this._freq[i] >> NeuQuantFloat._betaShift;
                                this._freq[i] -= betafreq, this._bias[i] += betafreq << NeuQuantFloat._gammaShift;
                            }
                            return this._freq[bestpos] += NeuQuantFloat._beta, this._bias[bestpos] -= NeuQuantFloat._betaGamma, 
                            bestbiaspos;
                        }, NeuQuantFloat._prime1 = 499, NeuQuantFloat._prime2 = 491, NeuQuantFloat._prime3 = 487, 
                        NeuQuantFloat._prime4 = 503, NeuQuantFloat._minpicturebytes = NeuQuantFloat._prime4, 
                        NeuQuantFloat._nCycles = 100, NeuQuantFloat._initialBiasShift = 16, NeuQuantFloat._initialBias = 1 << NeuQuantFloat._initialBiasShift, 
                        NeuQuantFloat._gammaShift = 10, NeuQuantFloat._betaShift = 10, NeuQuantFloat._beta = NeuQuantFloat._initialBias >> NeuQuantFloat._betaShift, 
                        NeuQuantFloat._betaGamma = NeuQuantFloat._initialBias << NeuQuantFloat._gammaShift - NeuQuantFloat._betaShift, 
                        NeuQuantFloat._radiusBiasShift = 6, NeuQuantFloat._radiusBias = 1 << NeuQuantFloat._radiusBiasShift, 
                        NeuQuantFloat._radiusDecrease = 30, NeuQuantFloat._alphaBiasShift = 10, NeuQuantFloat._initAlpha = 1 << NeuQuantFloat._alphaBiasShift, 
                        NeuQuantFloat._radBiasShift = 8, NeuQuantFloat._radBias = 1 << NeuQuantFloat._radBiasShift, 
                        NeuQuantFloat._alphaRadBiasShift = NeuQuantFloat._alphaBiasShift + NeuQuantFloat._radBiasShift, 
                        NeuQuantFloat._alphaRadBias = 1 << NeuQuantFloat._alphaRadBiasShift, NeuQuantFloat;
                    }();
                    exports.NeuQuantFloat = NeuQuantFloat;
                }, function(module, exports, __webpack_require__) {
                    /**
	 * @preserve TypeScript port:
	 * Copyright 2015-2016 Igor Bezkrovnyi
	 * All rights reserved. (MIT Licensed)
	 *
	 * rgbquant.ts - part of Image Quantization Library
	 */
                    var palette_1 = __webpack_require__(22), point_1 = __webpack_require__(24), colorHistogram_1 = __webpack_require__(27), arithmetic_1 = __webpack_require__(6), RemovedColor = function RemovedColor(index, color, distance) {
                        this.index = index, this.color = color, this.distance = distance;
                    }, RGBQuant = function() {
                        function RGBQuant(colorDistanceCalculator, colors, method) {
                            void 0 === colors && (colors = 256), void 0 === method && (method = 2), this._distance = colorDistanceCalculator, 
                            this._colors = colors, this._histogram = new colorHistogram_1.ColorHistogram(method, colors), 
                            this._initialDistance = 0.01, this._distanceIncrement = 0.005;
                        }
                        return RGBQuant.prototype.sample = function(image) {
                            this._histogram.sample(image);
                        }, RGBQuant.prototype.quantize = function() {
                            var idxi32 = this._histogram.getImportanceSortedColorsIDXI32();
                            if (0 === idxi32.length) throw new Error("No colors in image");
                            var palette = this._buildPalette(idxi32);
                            return palette.sort(), palette;
                        }, RGBQuant.prototype._buildPalette = function(idxi32) {
                            for (var palette = new palette_1.Palette, colorArray = palette.getPointContainer().getPointArray(), usageArray = new Array(idxi32.length), i = 0; i < idxi32.length; i++) colorArray.push(point_1.Point.createByUint32(idxi32[i])), 
                            usageArray[i] = 1;
                            for (var len = colorArray.length, memDist = [], palLen = len, thold = this._initialDistance; palLen > this._colors; ) {
                                for (memDist.length = 0, i = 0; i < len; i++) if (0 !== usageArray[i]) for (var pxi = colorArray[i], j = i + 1; j < len; j++) if (0 !== usageArray[j]) {
                                    var pxj = colorArray[j], dist = this._distance.calculateNormalized(pxi, pxj);
                                    dist < thold && (memDist.push(new RemovedColor(j, pxj, dist)), usageArray[j] = 0, 
                                    palLen--);
                                }
                                thold += palLen > 3 * this._colors ? this._initialDistance : this._distanceIncrement;
                            }
                            if (palLen < this._colors) {
                                arithmetic_1.stableSort(memDist, (function(a, b) {
                                    return b.distance - a.distance;
                                }));
                                for (var k = 0; palLen < this._colors && k < memDist.length; ) usageArray[memDist[k].index] = 1, 
                                palLen++, k++;
                            }
                            for (var colors = colorArray.length, colorIndex = colors - 1; colorIndex >= 0; colorIndex--) 0 === usageArray[colorIndex] && (colorIndex !== colors - 1 && (colorArray[colorIndex] = colorArray[colors - 1]), 
                            --colors);
                            return colorArray.length = colors, palette;
                        }, RGBQuant;
                    }();
                    exports.RGBQuant = RGBQuant;
                }, function(module, exports, __webpack_require__) {
                    /**
	 * @preserve TypeScript port:
	 * Copyright 2015-2016 Igor Bezkrovnyi
	 * All rights reserved. (MIT Licensed)
	 *
	 * colorHistogram.ts - part of Image Quantization Library
	 */
                    var hueStatistics_1 = __webpack_require__(28), arithmetic_1 = __webpack_require__(6), ColorHistogram = function() {
                        function ColorHistogram(method, colors) {
                            this._method = method, this._minHueCols = colors << 2, this._initColors = colors << 2, 
                            this._hueStats = new hueStatistics_1.HueStatistics(ColorHistogram._hueGroups, this._minHueCols), 
                            this._histogram = Object.create(null);
                        }
                        return ColorHistogram.prototype.sample = function(pointBuffer) {
                            switch (this._method) {
                              case 1:
                                this._colorStats1D(pointBuffer);
                                break;

                              case 2:
                                this._colorStats2D(pointBuffer);
                            }
                        }, ColorHistogram.prototype.getImportanceSortedColorsIDXI32 = function() {
                            var idxi32, _this = this, sorted = arithmetic_1.stableSort(Object.keys(this._histogram), (function(a, b) {
                                return _this._histogram[b] - _this._histogram[a];
                            }));
                            if (0 === sorted.length) return [];
                            switch (this._method) {
                              case 1:
                                var initialColorsLimit = Math.min(sorted.length, this._initColors), last = sorted[initialColorsLimit - 1], freq = this._histogram[last];
                                idxi32 = sorted.slice(0, initialColorsLimit);
                                for (var pos = initialColorsLimit, len = sorted.length; pos < len && this._histogram[sorted[pos]] == freq; ) idxi32.push(sorted[pos++]);
                                this._hueStats.injectIntoArray(idxi32);
                                break;

                              case 2:
                                idxi32 = sorted;
                                break;

                              default:
                                throw new Error("Incorrect method");
                            }
                            return idxi32.map((function(v) {
                                return +v;
                            }));
                        }, ColorHistogram.prototype._colorStats1D = function(pointBuffer) {
                            for (var histG = this._histogram, pointArray = pointBuffer.getPointArray(), len = pointArray.length, i = 0; i < len; i++) {
                                var col = pointArray[i].uint32;
                                this._hueStats.check(col), col in histG ? histG[col]++ : histG[col] = 1;
                            }
                        }, ColorHistogram.prototype._colorStats2D = function(pointBuffer) {
                            var _this = this, width = pointBuffer.getWidth(), height = pointBuffer.getHeight(), pointArray = pointBuffer.getPointArray(), boxW = ColorHistogram._boxSize[0], boxH = ColorHistogram._boxSize[1], area = boxW * boxH, boxes = this._makeBoxes(width, height, boxW, boxH), histG = this._histogram;
                            boxes.forEach((function(box) {
                                var effc = Math.round(box.w * box.h / area) * ColorHistogram._boxPixels;
                                effc < 2 && (effc = 2);
                                var histL = {};
                                _this._iterateBox(box, width, (function(i) {
                                    var col = pointArray[i].uint32;
                                    _this._hueStats.check(col), col in histG ? histG[col]++ : col in histL ? ++histL[col] >= effc && (histG[col] = histL[col]) : histL[col] = 1;
                                }));
                            })), this._hueStats.injectIntoDictionary(histG);
                        }, ColorHistogram.prototype._iterateBox = function(bbox, wid, fn) {
                            var b = bbox, i0 = b.y * wid + b.x, i1 = (b.y + b.h - 1) * wid + (b.x + b.w - 1), incr = wid - b.w + 1, cnt = 0, i = i0;
                            do {
                                fn.call(this, i), i += ++cnt % b.w == 0 ? incr : 1;
                            } while (i <= i1);
                        }, ColorHistogram.prototype._makeBoxes = function(width, height, stepX, stepY) {
                            for (var wrem = width % stepX, hrem = height % stepY, xend = width - wrem, yend = height - hrem, boxesArray = [], y = 0; y < height; y += stepY) for (var x = 0; x < width; x += stepX) boxesArray.push({
                                x,
                                y,
                                w: x == xend ? wrem : stepX,
                                h: y == yend ? hrem : stepY
                            });
                            return boxesArray;
                        }, ColorHistogram._boxSize = [ 64, 64 ], ColorHistogram._boxPixels = 2, ColorHistogram._hueGroups = 10, 
                        ColorHistogram;
                    }();
                    exports.ColorHistogram = ColorHistogram;
                }, function(module, exports, __webpack_require__) {
                    /**
	 * @preserve
	 * Copyright 2015-2016 Igor Bezkrovnyi
	 * All rights reserved. (MIT Licensed)
	 *
	 * hueStatistics.ts - part of Image Quantization Library
	 */
                    var rgb2hsl_1 = __webpack_require__(5), palette_1 = __webpack_require__(22), HueGroup = function HueGroup() {
                        this.num = 0, this.cols = [];
                    }, HueStatistics = function() {
                        function HueStatistics(numGroups, minCols) {
                            this._numGroups = numGroups, this._minCols = minCols, this._stats = [];
                            for (var i = 0; i <= numGroups; i++) this._stats[i] = new HueGroup;
                            this._groupsFull = 0;
                        }
                        return HueStatistics.prototype.check = function(i32) {
                            this._groupsFull == this._numGroups + 1 && (this.check = function() {});
                            var r = 0xff & i32, g = i32 >>> 8 & 0xff, b = i32 >>> 16 & 0xff, hg = r == g && g == b ? 0 : 1 + palette_1.hueGroup(rgb2hsl_1.rgb2hsl(r, g, b).h, this._numGroups), gr = this._stats[hg], min = this._minCols;
                            gr.num++, gr.num > min || (gr.num == min && this._groupsFull++, gr.num <= min && this._stats[hg].cols.push(i32));
                        }, HueStatistics.prototype.injectIntoDictionary = function(histG) {
                            for (var i = 0; i <= this._numGroups; i++) this._stats[i].num <= this._minCols && this._stats[i].cols.forEach((function(col) {
                                histG[col] ? histG[col]++ : histG[col] = 1;
                            }));
                        }, HueStatistics.prototype.injectIntoArray = function(histG) {
                            for (var i = 0; i <= this._numGroups; i++) this._stats[i].num <= this._minCols && this._stats[i].cols.forEach((function(col) {
                                -1 == histG.indexOf(col) && histG.push(col);
                            }));
                        }, HueStatistics;
                    }();
                    exports.HueStatistics = HueStatistics;
                }, function(module, exports, __webpack_require__) {
                    /**
	 * @preserve
	 * Copyright 2015-2016 Igor Bezkrovnyi
	 * All rights reserved. (MIT Licensed)
	 *
	 * wuQuant.ts - part of Image Quantization Library
	 */
                    var palette_1 = __webpack_require__(22), point_1 = __webpack_require__(24);
                    function createArray1D(dimension1) {
                        for (var a = [], k = 0; k < dimension1; k++) a[k] = 0;
                        return a;
                    }
                    function createArray4D(dimension1, dimension2, dimension3, dimension4) {
                        for (var a = new Array(dimension1), i = 0; i < dimension1; i++) {
                            a[i] = new Array(dimension2);
                            for (var j = 0; j < dimension2; j++) {
                                a[i][j] = new Array(dimension3);
                                for (var k = 0; k < dimension3; k++) {
                                    a[i][j][k] = new Array(dimension4);
                                    for (var l = 0; l < dimension4; l++) a[i][j][k][l] = 0;
                                }
                            }
                        }
                        return a;
                    }
                    function createArray3D(dimension1, dimension2, dimension3) {
                        for (var a = new Array(dimension1), i = 0; i < dimension1; i++) {
                            a[i] = new Array(dimension2);
                            for (var j = 0; j < dimension2; j++) {
                                a[i][j] = new Array(dimension3);
                                for (var k = 0; k < dimension3; k++) a[i][j][k] = 0;
                            }
                        }
                        return a;
                    }
                    function fillArray3D(a, dimension1, dimension2, dimension3, value) {
                        for (var i = 0; i < dimension1; i++) {
                            a[i] = [];
                            for (var j = 0; j < dimension2; j++) {
                                a[i][j] = [];
                                for (var k = 0; k < dimension3; k++) a[i][j][k] = value;
                            }
                        }
                    }
                    function fillArray1D(a, dimension1, value) {
                        for (var i = 0; i < dimension1; i++) a[i] = value;
                    }
                    var WuColorCube = function WuColorCube() {};
                    exports.WuColorCube = WuColorCube;
                    var WuQuant = function() {
                        function WuQuant(colorDistanceCalculator, colors, significantBitsPerChannel) {
                            void 0 === colors && (colors = 256), void 0 === significantBitsPerChannel && (significantBitsPerChannel = 5), 
                            this._distance = colorDistanceCalculator, this._setQuality(significantBitsPerChannel), 
                            this._initialize(colors);
                        }
                        return WuQuant.prototype.sample = function(image) {
                            for (var pointArray = image.getPointArray(), i = 0, l = pointArray.length; i < l; i++) this._addColor(pointArray[i]);
                            this._pixels = this._pixels.concat(pointArray);
                        }, WuQuant.prototype.quantize = function() {
                            this._preparePalette();
                            for (var palette = new palette_1.Palette, paletteIndex = 0; paletteIndex < this._colors; paletteIndex++) if (this._sums[paletteIndex] > 0) {
                                var sum = this._sums[paletteIndex], r = this._reds[paletteIndex] / sum, g = this._greens[paletteIndex] / sum, b = this._blues[paletteIndex] / sum, a = this._alphas[paletteIndex] / sum, color = point_1.Point.createByRGBA(0 | r, 0 | g, 0 | b, 0 | a);
                                palette.add(color);
                            }
                            return palette.sort(), palette;
                        }, WuQuant.prototype._preparePalette = function() {
                            this._calculateMoments();
                            for (var next = 0, volumeVariance = createArray1D(this._colors), cubeIndex = 1; cubeIndex < this._colors; ++cubeIndex) {
                                this._cut(this._cubes[next], this._cubes[cubeIndex]) ? (volumeVariance[next] = this._cubes[next].volume > 1 ? this._calculateVariance(this._cubes[next]) : 0.0, 
                                volumeVariance[cubeIndex] = this._cubes[cubeIndex].volume > 1 ? this._calculateVariance(this._cubes[cubeIndex]) : 0.0) : (volumeVariance[next] = 0.0, 
                                cubeIndex--), next = 0;
                                for (var temp = volumeVariance[0], index = 1; index <= cubeIndex; ++index) volumeVariance[index] > temp && (temp = volumeVariance[index], 
                                next = index);
                                if (temp <= 0.0) {
                                    this._colors = cubeIndex + 1;
                                    break;
                                }
                            }
                            for (var lookupRed = [], lookupGreen = [], lookupBlue = [], lookupAlpha = [], k = 0; k < this._colors; ++k) {
                                var weight = WuQuant._volume(this._cubes[k], this._weights);
                                weight > 0 ? (lookupRed[k] = WuQuant._volume(this._cubes[k], this._momentsRed) / weight | 0, 
                                lookupGreen[k] = WuQuant._volume(this._cubes[k], this._momentsGreen) / weight | 0, 
                                lookupBlue[k] = WuQuant._volume(this._cubes[k], this._momentsBlue) / weight | 0, 
                                lookupAlpha[k] = WuQuant._volume(this._cubes[k], this._momentsAlpha) / weight | 0) : (lookupRed[k] = 0, 
                                lookupGreen[k] = 0, lookupBlue[k] = 0, lookupAlpha[k] = 0);
                            }
                            this._reds = createArray1D(this._colors + 1), this._greens = createArray1D(this._colors + 1), 
                            this._blues = createArray1D(this._colors + 1), this._alphas = createArray1D(this._colors + 1), 
                            this._sums = createArray1D(this._colors + 1), index = 0;
                            for (var l = this._pixels.length; index < l; index++) {
                                for (var color = this._pixels[index], bestMatch = -1, bestDistance = Number.MAX_VALUE, lookup = 0; lookup < this._colors; lookup++) {
                                    var foundRed = lookupRed[lookup], foundGreen = lookupGreen[lookup], foundBlue = lookupBlue[lookup], foundAlpha = lookupAlpha[lookup], distance = this._distance.calculateRaw(foundRed, foundGreen, foundBlue, foundAlpha, color.r, color.g, color.b, color.a);
                                    distance < bestDistance && (bestDistance = distance, bestMatch = lookup);
                                }
                                this._reds[bestMatch] += color.r, this._greens[bestMatch] += color.g, this._blues[bestMatch] += color.b, 
                                this._alphas[bestMatch] += color.a, this._sums[bestMatch]++;
                            }
                        }, WuQuant.prototype._addColor = function(color) {
                            var bitsToRemove = 8 - this._significantBitsPerChannel, indexRed = 1 + (color.r >> bitsToRemove), indexGreen = 1 + (color.g >> bitsToRemove), indexBlue = 1 + (color.b >> bitsToRemove), indexAlpha = 1 + (color.a >> bitsToRemove);
                            this._weights[indexAlpha][indexRed][indexGreen][indexBlue]++, this._momentsRed[indexAlpha][indexRed][indexGreen][indexBlue] += color.r, 
                            this._momentsGreen[indexAlpha][indexRed][indexGreen][indexBlue] += color.g, this._momentsBlue[indexAlpha][indexRed][indexGreen][indexBlue] += color.b, 
                            this._momentsAlpha[indexAlpha][indexRed][indexGreen][indexBlue] += color.a, this._moments[indexAlpha][indexRed][indexGreen][indexBlue] += this._table[color.r] + this._table[color.g] + this._table[color.b] + this._table[color.a];
                        }, WuQuant.prototype._calculateMoments = function() {
                            for (var area = [], areaRed = [], areaGreen = [], areaBlue = [], areaAlpha = [], area2 = [], xarea = createArray3D(this._sideSize, this._sideSize, this._sideSize), xareaRed = createArray3D(this._sideSize, this._sideSize, this._sideSize), xareaGreen = createArray3D(this._sideSize, this._sideSize, this._sideSize), xareaBlue = createArray3D(this._sideSize, this._sideSize, this._sideSize), xareaAlpha = createArray3D(this._sideSize, this._sideSize, this._sideSize), xarea2 = createArray3D(this._sideSize, this._sideSize, this._sideSize), alphaIndex = 1; alphaIndex <= this._alphaMaxSideIndex; ++alphaIndex) {
                                fillArray3D(xarea, this._sideSize, this._sideSize, this._sideSize, 0), fillArray3D(xareaRed, this._sideSize, this._sideSize, this._sideSize, 0), 
                                fillArray3D(xareaGreen, this._sideSize, this._sideSize, this._sideSize, 0), fillArray3D(xareaBlue, this._sideSize, this._sideSize, this._sideSize, 0), 
                                fillArray3D(xareaAlpha, this._sideSize, this._sideSize, this._sideSize, 0), fillArray3D(xarea2, this._sideSize, this._sideSize, this._sideSize, 0);
                                for (var redIndex = 1; redIndex <= this._maxSideIndex; ++redIndex) {
                                    fillArray1D(area, this._sideSize, 0), fillArray1D(areaRed, this._sideSize, 0), fillArray1D(areaGreen, this._sideSize, 0), 
                                    fillArray1D(areaBlue, this._sideSize, 0), fillArray1D(areaAlpha, this._sideSize, 0), 
                                    fillArray1D(area2, this._sideSize, 0);
                                    for (var greenIndex = 1; greenIndex <= this._maxSideIndex; ++greenIndex) for (var line = 0, lineRed = 0, lineGreen = 0, lineBlue = 0, lineAlpha = 0, line2 = 0.0, blueIndex = 1; blueIndex <= this._maxSideIndex; ++blueIndex) line += this._weights[alphaIndex][redIndex][greenIndex][blueIndex], 
                                    lineRed += this._momentsRed[alphaIndex][redIndex][greenIndex][blueIndex], lineGreen += this._momentsGreen[alphaIndex][redIndex][greenIndex][blueIndex], 
                                    lineBlue += this._momentsBlue[alphaIndex][redIndex][greenIndex][blueIndex], lineAlpha += this._momentsAlpha[alphaIndex][redIndex][greenIndex][blueIndex], 
                                    line2 += this._moments[alphaIndex][redIndex][greenIndex][blueIndex], area[blueIndex] += line, 
                                    areaRed[blueIndex] += lineRed, areaGreen[blueIndex] += lineGreen, areaBlue[blueIndex] += lineBlue, 
                                    areaAlpha[blueIndex] += lineAlpha, area2[blueIndex] += line2, xarea[redIndex][greenIndex][blueIndex] = xarea[redIndex - 1][greenIndex][blueIndex] + area[blueIndex], 
                                    xareaRed[redIndex][greenIndex][blueIndex] = xareaRed[redIndex - 1][greenIndex][blueIndex] + areaRed[blueIndex], 
                                    xareaGreen[redIndex][greenIndex][blueIndex] = xareaGreen[redIndex - 1][greenIndex][blueIndex] + areaGreen[blueIndex], 
                                    xareaBlue[redIndex][greenIndex][blueIndex] = xareaBlue[redIndex - 1][greenIndex][blueIndex] + areaBlue[blueIndex], 
                                    xareaAlpha[redIndex][greenIndex][blueIndex] = xareaAlpha[redIndex - 1][greenIndex][blueIndex] + areaAlpha[blueIndex], 
                                    xarea2[redIndex][greenIndex][blueIndex] = xarea2[redIndex - 1][greenIndex][blueIndex] + area2[blueIndex], 
                                    this._weights[alphaIndex][redIndex][greenIndex][blueIndex] = this._weights[alphaIndex - 1][redIndex][greenIndex][blueIndex] + xarea[redIndex][greenIndex][blueIndex], 
                                    this._momentsRed[alphaIndex][redIndex][greenIndex][blueIndex] = this._momentsRed[alphaIndex - 1][redIndex][greenIndex][blueIndex] + xareaRed[redIndex][greenIndex][blueIndex], 
                                    this._momentsGreen[alphaIndex][redIndex][greenIndex][blueIndex] = this._momentsGreen[alphaIndex - 1][redIndex][greenIndex][blueIndex] + xareaGreen[redIndex][greenIndex][blueIndex], 
                                    this._momentsBlue[alphaIndex][redIndex][greenIndex][blueIndex] = this._momentsBlue[alphaIndex - 1][redIndex][greenIndex][blueIndex] + xareaBlue[redIndex][greenIndex][blueIndex], 
                                    this._momentsAlpha[alphaIndex][redIndex][greenIndex][blueIndex] = this._momentsAlpha[alphaIndex - 1][redIndex][greenIndex][blueIndex] + xareaAlpha[redIndex][greenIndex][blueIndex], 
                                    this._moments[alphaIndex][redIndex][greenIndex][blueIndex] = this._moments[alphaIndex - 1][redIndex][greenIndex][blueIndex] + xarea2[redIndex][greenIndex][blueIndex];
                                }
                            }
                        }, WuQuant._volumeFloat = function(cube, moment) {
                            return moment[cube.alphaMaximum][cube.redMaximum][cube.greenMaximum][cube.blueMaximum] - moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][cube.blueMaximum] - moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][cube.blueMaximum] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] - moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][cube.blueMaximum] + moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMaximum] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMaximum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] - (moment[cube.alphaMaximum][cube.redMaximum][cube.greenMaximum][cube.blueMinimum] - moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][cube.blueMinimum] - moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] - moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum]);
                        }, WuQuant._volume = function(cube, moment) {
                            return 0 | WuQuant._volumeFloat(cube, moment);
                        }, WuQuant._top = function(cube, direction, position, moment) {
                            var result;
                            switch (direction) {
                              case WuQuant.alpha:
                                result = moment[position][cube.redMaximum][cube.greenMaximum][cube.blueMaximum] - moment[position][cube.redMaximum][cube.greenMinimum][cube.blueMaximum] - moment[position][cube.redMinimum][cube.greenMaximum][cube.blueMaximum] + moment[position][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] - (moment[position][cube.redMaximum][cube.greenMaximum][cube.blueMinimum] - moment[position][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] - moment[position][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] + moment[position][cube.redMinimum][cube.greenMinimum][cube.blueMinimum]);
                                break;

                              case WuQuant.red:
                                result = moment[cube.alphaMaximum][position][cube.greenMaximum][cube.blueMaximum] - moment[cube.alphaMaximum][position][cube.greenMinimum][cube.blueMaximum] - moment[cube.alphaMinimum][position][cube.greenMaximum][cube.blueMaximum] + moment[cube.alphaMinimum][position][cube.greenMinimum][cube.blueMaximum] - (moment[cube.alphaMaximum][position][cube.greenMaximum][cube.blueMinimum] - moment[cube.alphaMaximum][position][cube.greenMinimum][cube.blueMinimum] - moment[cube.alphaMinimum][position][cube.greenMaximum][cube.blueMinimum] + moment[cube.alphaMinimum][position][cube.greenMinimum][cube.blueMinimum]);
                                break;

                              case WuQuant.green:
                                result = moment[cube.alphaMaximum][cube.redMaximum][position][cube.blueMaximum] - moment[cube.alphaMaximum][cube.redMinimum][position][cube.blueMaximum] - moment[cube.alphaMinimum][cube.redMaximum][position][cube.blueMaximum] + moment[cube.alphaMinimum][cube.redMinimum][position][cube.blueMaximum] - (moment[cube.alphaMaximum][cube.redMaximum][position][cube.blueMinimum] - moment[cube.alphaMaximum][cube.redMinimum][position][cube.blueMinimum] - moment[cube.alphaMinimum][cube.redMaximum][position][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMinimum][position][cube.blueMinimum]);
                                break;

                              case WuQuant.blue:
                                result = moment[cube.alphaMaximum][cube.redMaximum][cube.greenMaximum][position] - moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][position] - moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][position] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][position] - (moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][position] - moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][position] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][position] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][position]);
                                break;

                              default:
                                throw new Error("impossible");
                            }
                            return 0 | result;
                        }, WuQuant._bottom = function(cube, direction, moment) {
                            switch (direction) {
                              case WuQuant.alpha:
                                return -moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][cube.blueMaximum] + moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMaximum] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMaximum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] - (-moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum]);

                              case WuQuant.red:
                                return -moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][cube.blueMaximum] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMaximum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] - (-moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum]);

                              case WuQuant.green:
                                return -moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][cube.blueMaximum] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] + moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMaximum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMaximum] - (-moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum]);

                              case WuQuant.blue:
                                return -moment[cube.alphaMaximum][cube.redMaximum][cube.greenMaximum][cube.blueMinimum] + moment[cube.alphaMaximum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] + moment[cube.alphaMaximum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] - moment[cube.alphaMaximum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum] - (-moment[cube.alphaMinimum][cube.redMaximum][cube.greenMaximum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMaximum][cube.greenMinimum][cube.blueMinimum] + moment[cube.alphaMinimum][cube.redMinimum][cube.greenMaximum][cube.blueMinimum] - moment[cube.alphaMinimum][cube.redMinimum][cube.greenMinimum][cube.blueMinimum]);

                              default:
                                return 0;
                            }
                        }, WuQuant.prototype._calculateVariance = function(cube) {
                            var volumeRed = WuQuant._volume(cube, this._momentsRed), volumeGreen = WuQuant._volume(cube, this._momentsGreen), volumeBlue = WuQuant._volume(cube, this._momentsBlue), volumeAlpha = WuQuant._volume(cube, this._momentsAlpha);
                            return WuQuant._volumeFloat(cube, this._moments) - (volumeRed * volumeRed + volumeGreen * volumeGreen + volumeBlue * volumeBlue + volumeAlpha * volumeAlpha) / WuQuant._volume(cube, this._weights);
                        }, WuQuant.prototype._maximize = function(cube, direction, first, last, wholeRed, wholeGreen, wholeBlue, wholeAlpha, wholeWeight) {
                            for (var bottomRed = 0 | WuQuant._bottom(cube, direction, this._momentsRed), bottomGreen = 0 | WuQuant._bottom(cube, direction, this._momentsGreen), bottomBlue = 0 | WuQuant._bottom(cube, direction, this._momentsBlue), bottomAlpha = 0 | WuQuant._bottom(cube, direction, this._momentsAlpha), bottomWeight = 0 | WuQuant._bottom(cube, direction, this._weights), result = 0.0, cutPosition = -1, position = first; position < last; ++position) {
                                var halfRed = bottomRed + WuQuant._top(cube, direction, position, this._momentsRed), halfGreen = bottomGreen + WuQuant._top(cube, direction, position, this._momentsGreen), halfBlue = bottomBlue + WuQuant._top(cube, direction, position, this._momentsBlue), halfAlpha = bottomAlpha + WuQuant._top(cube, direction, position, this._momentsAlpha), halfWeight = bottomWeight + WuQuant._top(cube, direction, position, this._weights);
                                if (0 != halfWeight) {
                                    var halfDistance = halfRed * halfRed + halfGreen * halfGreen + halfBlue * halfBlue + halfAlpha * halfAlpha, temp = halfDistance / halfWeight;
                                    halfRed = wholeRed - halfRed, halfGreen = wholeGreen - halfGreen, halfBlue = wholeBlue - halfBlue, 
                                    halfAlpha = wholeAlpha - halfAlpha, 0 != (halfWeight = wholeWeight - halfWeight) && (temp += (halfDistance = halfRed * halfRed + halfGreen * halfGreen + halfBlue * halfBlue + halfAlpha * halfAlpha) / halfWeight) > result && (result = temp, 
                                    cutPosition = position);
                                }
                            }
                            return {
                                max: result,
                                position: cutPosition
                            };
                        }, WuQuant.prototype._cut = function(first, second) {
                            var direction, wholeRed = WuQuant._volume(first, this._momentsRed), wholeGreen = WuQuant._volume(first, this._momentsGreen), wholeBlue = WuQuant._volume(first, this._momentsBlue), wholeAlpha = WuQuant._volume(first, this._momentsAlpha), wholeWeight = WuQuant._volume(first, this._weights), red = this._maximize(first, WuQuant.red, first.redMinimum + 1, first.redMaximum, wholeRed, wholeGreen, wholeBlue, wholeAlpha, wholeWeight), green = this._maximize(first, WuQuant.green, first.greenMinimum + 1, first.greenMaximum, wholeRed, wholeGreen, wholeBlue, wholeAlpha, wholeWeight), blue = this._maximize(first, WuQuant.blue, first.blueMinimum + 1, first.blueMaximum, wholeRed, wholeGreen, wholeBlue, wholeAlpha, wholeWeight), alpha = this._maximize(first, WuQuant.alpha, first.alphaMinimum + 1, first.alphaMaximum, wholeRed, wholeGreen, wholeBlue, wholeAlpha, wholeWeight);
                            if (alpha.max >= red.max && alpha.max >= green.max && alpha.max >= blue.max) {
                                if (direction = WuQuant.alpha, alpha.position < 0) return !1;
                            } else direction = red.max >= alpha.max && red.max >= green.max && red.max >= blue.max ? WuQuant.red : green.max >= alpha.max && green.max >= red.max && green.max >= blue.max ? WuQuant.green : WuQuant.blue;
                            switch (second.redMaximum = first.redMaximum, second.greenMaximum = first.greenMaximum, 
                            second.blueMaximum = first.blueMaximum, second.alphaMaximum = first.alphaMaximum, 
                            direction) {
                              case WuQuant.red:
                                second.redMinimum = first.redMaximum = red.position, second.greenMinimum = first.greenMinimum, 
                                second.blueMinimum = first.blueMinimum, second.alphaMinimum = first.alphaMinimum;
                                break;

                              case WuQuant.green:
                                second.greenMinimum = first.greenMaximum = green.position, second.redMinimum = first.redMinimum, 
                                second.blueMinimum = first.blueMinimum, second.alphaMinimum = first.alphaMinimum;
                                break;

                              case WuQuant.blue:
                                second.blueMinimum = first.blueMaximum = blue.position, second.redMinimum = first.redMinimum, 
                                second.greenMinimum = first.greenMinimum, second.alphaMinimum = first.alphaMinimum;
                                break;

                              case WuQuant.alpha:
                                second.alphaMinimum = first.alphaMaximum = alpha.position, second.blueMinimum = first.blueMinimum, 
                                second.redMinimum = first.redMinimum, second.greenMinimum = first.greenMinimum;
                            }
                            return first.volume = (first.redMaximum - first.redMinimum) * (first.greenMaximum - first.greenMinimum) * (first.blueMaximum - first.blueMinimum) * (first.alphaMaximum - first.alphaMinimum), 
                            second.volume = (second.redMaximum - second.redMinimum) * (second.greenMaximum - second.greenMinimum) * (second.blueMaximum - second.blueMinimum) * (second.alphaMaximum - second.alphaMinimum), 
                            !0;
                        }, WuQuant.prototype._initialize = function(colors) {
                            this._colors = colors, this._cubes = [];
                            for (var cubeIndex = 0; cubeIndex < colors; cubeIndex++) this._cubes[cubeIndex] = new WuColorCube;
                            this._cubes[0].redMinimum = 0, this._cubes[0].greenMinimum = 0, this._cubes[0].blueMinimum = 0, 
                            this._cubes[0].alphaMinimum = 0, this._cubes[0].redMaximum = this._maxSideIndex, 
                            this._cubes[0].greenMaximum = this._maxSideIndex, this._cubes[0].blueMaximum = this._maxSideIndex, 
                            this._cubes[0].alphaMaximum = this._alphaMaxSideIndex, this._weights = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize), 
                            this._momentsRed = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize), 
                            this._momentsGreen = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize), 
                            this._momentsBlue = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize), 
                            this._momentsAlpha = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize), 
                            this._moments = createArray4D(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize), 
                            this._table = [];
                            for (var tableIndex = 0; tableIndex < 256; ++tableIndex) this._table[tableIndex] = tableIndex * tableIndex;
                            this._pixels = [];
                        }, WuQuant.prototype._setQuality = function(significantBitsPerChannel) {
                            void 0 === significantBitsPerChannel && (significantBitsPerChannel = 5), this._significantBitsPerChannel = significantBitsPerChannel, 
                            this._maxSideIndex = 1 << this._significantBitsPerChannel, this._alphaMaxSideIndex = this._maxSideIndex, 
                            this._sideSize = this._maxSideIndex + 1, this._alphaSideSize = this._alphaMaxSideIndex + 1;
                        }, WuQuant.alpha = 3, WuQuant.red = 2, WuQuant.green = 1, WuQuant.blue = 0, WuQuant;
                    }();
                    exports.WuQuant = WuQuant;
                }, function(module, exports, __webpack_require__) {
                    var nearestColor_1 = __webpack_require__(31);
                    exports.NearestColor = nearestColor_1.NearestColor;
                    var array_1 = __webpack_require__(32);
                    exports.ErrorDiffusionArray = array_1.ErrorDiffusionArray, exports.ErrorDiffusionArrayKernel = array_1.ErrorDiffusionArrayKernel;
                    var riemersma_1 = __webpack_require__(33);
                    exports.ErrorDiffusionRiemersma = riemersma_1.ErrorDiffusionRiemersma;
                }, function(module, exports) {
                    var NearestColor = function() {
                        function NearestColor(colorDistanceCalculator) {
                            this._distance = colorDistanceCalculator;
                        }
                        return NearestColor.prototype.quantize = function(pointBuffer, palette) {
                            for (var pointArray = pointBuffer.getPointArray(), width = pointBuffer.getWidth(), height = pointBuffer.getHeight(), y = 0; y < height; y++) for (var x = 0, idx = y * width; x < width; x++, 
                            idx++) {
                                var point = pointArray[idx];
                                point.from(palette.getNearestColor(this._distance, point));
                            }
                            return pointBuffer;
                        }, NearestColor;
                    }();
                    exports.NearestColor = NearestColor;
                }, function(module, exports, __webpack_require__) {
                    var point_1 = __webpack_require__(24), arithmetic_1 = __webpack_require__(6);
                    !function(ErrorDiffusionArrayKernel) {
                        ErrorDiffusionArrayKernel[ErrorDiffusionArrayKernel.FloydSteinberg = 0] = "FloydSteinberg", 
                        ErrorDiffusionArrayKernel[ErrorDiffusionArrayKernel.FalseFloydSteinberg = 1] = "FalseFloydSteinberg", 
                        ErrorDiffusionArrayKernel[ErrorDiffusionArrayKernel.Stucki = 2] = "Stucki", ErrorDiffusionArrayKernel[ErrorDiffusionArrayKernel.Atkinson = 3] = "Atkinson", 
                        ErrorDiffusionArrayKernel[ErrorDiffusionArrayKernel.Jarvis = 4] = "Jarvis", ErrorDiffusionArrayKernel[ErrorDiffusionArrayKernel.Burkes = 5] = "Burkes", 
                        ErrorDiffusionArrayKernel[ErrorDiffusionArrayKernel.Sierra = 6] = "Sierra", ErrorDiffusionArrayKernel[ErrorDiffusionArrayKernel.TwoSierra = 7] = "TwoSierra", 
                        ErrorDiffusionArrayKernel[ErrorDiffusionArrayKernel.SierraLite = 8] = "SierraLite";
                    }(exports.ErrorDiffusionArrayKernel || (exports.ErrorDiffusionArrayKernel = {}));
                    var ErrorDiffusionArrayKernel = exports.ErrorDiffusionArrayKernel, ErrorDiffusionArray = function() {
                        function ErrorDiffusionArray(colorDistanceCalculator, kernel, serpentine, minimumColorDistanceToDither, calculateErrorLikeGIMP) {
                            void 0 === serpentine && (serpentine = !0), void 0 === minimumColorDistanceToDither && (minimumColorDistanceToDither = 0), 
                            void 0 === calculateErrorLikeGIMP && (calculateErrorLikeGIMP = !1), this._setKernel(kernel), 
                            this._distance = colorDistanceCalculator, this._minColorDistance = minimumColorDistanceToDither, 
                            this._serpentine = serpentine, this._calculateErrorLikeGIMP = calculateErrorLikeGIMP;
                        }
                        return ErrorDiffusionArray.prototype.quantize = function(pointBuffer, palette) {
                            for (var pointArray = pointBuffer.getPointArray(), originalPoint = new point_1.Point, width = pointBuffer.getWidth(), height = pointBuffer.getHeight(), errorLines = [], dir = 1, maxErrorLines = 1, i = 0; i < this._kernel.length; i++) {
                                var kernelErrorLines = this._kernel[i][2] + 1;
                                maxErrorLines < kernelErrorLines && (maxErrorLines = kernelErrorLines);
                            }
                            for (i = 0; i < maxErrorLines; i++) this._fillErrorLine(errorLines[i] = [], width);
                            for (var y = 0; y < height; y++) {
                                this._serpentine && (dir *= -1);
                                var lni = y * width, xStart = 1 == dir ? 0 : width - 1, xEnd = 1 == dir ? width : -1;
                                this._fillErrorLine(errorLines[0], width), errorLines.push(errorLines.shift());
                                for (var errorLine = errorLines[0], x = xStart, idx = lni + xStart; x !== xEnd; x += dir, 
                                idx += dir) {
                                    var point = pointArray[idx], error = errorLine[x];
                                    originalPoint.from(point);
                                    var correctedPoint = point_1.Point.createByRGBA(arithmetic_1.inRange0to255Rounded(point.r + error[0]), arithmetic_1.inRange0to255Rounded(point.g + error[1]), arithmetic_1.inRange0to255Rounded(point.b + error[2]), arithmetic_1.inRange0to255Rounded(point.a + error[3])), palettePoint = palette.getNearestColor(this._distance, correctedPoint);
                                    if (point.from(palettePoint), !(this._minColorDistance && this._distance.calculateNormalized(point, palettePoint) < this._minColorDistance)) {
                                        var er = void 0, eg = void 0, eb = void 0, ea = void 0;
                                        this._calculateErrorLikeGIMP ? (er = correctedPoint.r - palettePoint.r, eg = correctedPoint.g - palettePoint.g, 
                                        eb = correctedPoint.b - palettePoint.b, ea = correctedPoint.a - palettePoint.a) : (er = originalPoint.r - palettePoint.r, 
                                        eg = originalPoint.g - palettePoint.g, eb = originalPoint.b - palettePoint.b, ea = originalPoint.a - palettePoint.a);
                                        var dStart = 1 == dir ? 0 : this._kernel.length - 1, dEnd = 1 == dir ? this._kernel.length : -1;
                                        for (i = dStart; i !== dEnd; i += dir) {
                                            var x1 = this._kernel[i][1] * dir, y1 = this._kernel[i][2];
                                            if (x1 + x >= 0 && x1 + x < width && y1 + y >= 0 && y1 + y < height) {
                                                var d = this._kernel[i][0], e = errorLines[y1][x1 + x];
                                                e[0] = e[0] + er * d, e[1] = e[1] + eg * d, e[2] = e[2] + eb * d, e[3] = e[3] + ea * d;
                                            }
                                        }
                                    }
                                }
                            }
                            return pointBuffer;
                        }, ErrorDiffusionArray.prototype._fillErrorLine = function(errorLine, width) {
                            errorLine.length > width && (errorLine.length = width);
                            for (var l = errorLine.length, i = 0; i < l; i++) {
                                var error = errorLine[i];
                                error[0] = error[1] = error[2] = error[3] = 0;
                            }
                            for (i = l; i < width; i++) errorLine[i] = [ 0.0, 0.0, 0.0, 0.0 ];
                        }, ErrorDiffusionArray.prototype._setKernel = function(kernel) {
                            switch (kernel) {
                              case ErrorDiffusionArrayKernel.FloydSteinberg:
                                this._kernel = [ [ 7 / 16, 1, 0 ], [ 3 / 16, -1, 1 ], [ 5 / 16, 0, 1 ], [ 1 / 16, 1, 1 ] ];
                                break;

                              case ErrorDiffusionArrayKernel.FalseFloydSteinberg:
                                this._kernel = [ [ 3 / 8, 1, 0 ], [ 3 / 8, 0, 1 ], [ 2 / 8, 1, 1 ] ];
                                break;

                              case ErrorDiffusionArrayKernel.Stucki:
                                this._kernel = [ [ 8 / 42, 1, 0 ], [ 4 / 42, 2, 0 ], [ 2 / 42, -2, 1 ], [ 4 / 42, -1, 1 ], [ 8 / 42, 0, 1 ], [ 4 / 42, 1, 1 ], [ 2 / 42, 2, 1 ], [ 1 / 42, -2, 2 ], [ 2 / 42, -1, 2 ], [ 4 / 42, 0, 2 ], [ 2 / 42, 1, 2 ], [ 1 / 42, 2, 2 ] ];
                                break;

                              case ErrorDiffusionArrayKernel.Atkinson:
                                this._kernel = [ [ 1 / 8, 1, 0 ], [ 1 / 8, 2, 0 ], [ 1 / 8, -1, 1 ], [ 1 / 8, 0, 1 ], [ 1 / 8, 1, 1 ], [ 1 / 8, 0, 2 ] ];
                                break;

                              case ErrorDiffusionArrayKernel.Jarvis:
                                this._kernel = [ [ 7 / 48, 1, 0 ], [ 5 / 48, 2, 0 ], [ 3 / 48, -2, 1 ], [ 5 / 48, -1, 1 ], [ 7 / 48, 0, 1 ], [ 5 / 48, 1, 1 ], [ 3 / 48, 2, 1 ], [ 1 / 48, -2, 2 ], [ 3 / 48, -1, 2 ], [ 5 / 48, 0, 2 ], [ 3 / 48, 1, 2 ], [ 1 / 48, 2, 2 ] ];
                                break;

                              case ErrorDiffusionArrayKernel.Burkes:
                                this._kernel = [ [ .25, 1, 0 ], [ 4 / 32, 2, 0 ], [ 2 / 32, -2, 1 ], [ 4 / 32, -1, 1 ], [ .25, 0, 1 ], [ 4 / 32, 1, 1 ], [ 2 / 32, 2, 1 ] ];
                                break;

                              case ErrorDiffusionArrayKernel.Sierra:
                                this._kernel = [ [ 5 / 32, 1, 0 ], [ 3 / 32, 2, 0 ], [ 2 / 32, -2, 1 ], [ 4 / 32, -1, 1 ], [ 5 / 32, 0, 1 ], [ 4 / 32, 1, 1 ], [ 2 / 32, 2, 1 ], [ 2 / 32, -1, 2 ], [ 3 / 32, 0, 2 ], [ 2 / 32, 1, 2 ] ];
                                break;

                              case ErrorDiffusionArrayKernel.TwoSierra:
                                this._kernel = [ [ .25, 1, 0 ], [ 3 / 16, 2, 0 ], [ 1 / 16, -2, 1 ], [ 2 / 16, -1, 1 ], [ 3 / 16, 0, 1 ], [ 2 / 16, 1, 1 ], [ 1 / 16, 2, 1 ] ];
                                break;

                              case ErrorDiffusionArrayKernel.SierraLite:
                                this._kernel = [ [ .5, 1, 0 ], [ 1 / 4, -1, 1 ], [ 1 / 4, 0, 1 ] ];
                                break;

                              default:
                                throw new Error("ErrorDiffusionArray: unknown kernel = " + kernel);
                            }
                        }, ErrorDiffusionArray;
                    }();
                    exports.ErrorDiffusionArray = ErrorDiffusionArray;
                }, function(module, exports, __webpack_require__) {
                    var hilbertCurve_1 = __webpack_require__(34), point_1 = __webpack_require__(24), arithmetic_1 = __webpack_require__(6), ErrorDiffusionRiemersma = function() {
                        function ErrorDiffusionRiemersma(colorDistanceCalculator, errorQueueSize, errorPropagation) {
                            void 0 === errorQueueSize && (errorQueueSize = 16), void 0 === errorPropagation && (errorPropagation = 1), 
                            this._distance = colorDistanceCalculator, this._errorPropagation = errorPropagation, 
                            this._errorQueueSize = errorQueueSize, this._max = this._errorQueueSize, this._createWeights();
                        }
                        return ErrorDiffusionRiemersma.prototype.quantize = function(pointBuffer, palette) {
                            for (var _this = this, curve = new hilbertCurve_1.HilbertCurveBase, pointArray = pointBuffer.getPointArray(), width = pointBuffer.getWidth(), height = pointBuffer.getHeight(), errorQueue = [], head = 0, i = 0; i < this._errorQueueSize; i++) errorQueue[i] = {
                                r: 0,
                                g: 0,
                                b: 0,
                                a: 0
                            };
                            return curve.walk(width, height, (function(x, y) {
                                for (var p = pointArray[x + y * width], r = p.r, g = p.g, b = p.b, a = p.a, i = 0; i < _this._errorQueueSize; i++) {
                                    var weight = _this._weights[i], e = errorQueue[(i + head) % _this._errorQueueSize];
                                    r += e.r * weight, g += e.g * weight, b += e.b * weight, a += e.a * weight;
                                }
                                var correctedPoint = point_1.Point.createByRGBA(arithmetic_1.inRange0to255Rounded(r), arithmetic_1.inRange0to255Rounded(g), arithmetic_1.inRange0to255Rounded(b), arithmetic_1.inRange0to255Rounded(a)), quantizedPoint = palette.getNearestColor(_this._distance, correctedPoint), tail = ((head = (head + 1) % _this._errorQueueSize) + _this._errorQueueSize - 1) % _this._errorQueueSize;
                                errorQueue[tail].r = p.r - quantizedPoint.r, errorQueue[tail].g = p.g - quantizedPoint.g, 
                                errorQueue[tail].b = p.b - quantizedPoint.b, errorQueue[tail].a = p.a - quantizedPoint.a, 
                                p.from(quantizedPoint);
                            })), pointBuffer;
                        }, ErrorDiffusionRiemersma.prototype._createWeights = function() {
                            this._weights = [];
                            for (var multiplier = Math.exp(Math.log(this._max) / (this._errorQueueSize - 1)), i = 0, next = 1; i < this._errorQueueSize; i++) this._weights[i] = (next + 0.5 | 0) / this._max * this._errorPropagation, 
                            next *= multiplier;
                        }, ErrorDiffusionRiemersma;
                    }();
                    exports.ErrorDiffusionRiemersma = ErrorDiffusionRiemersma;
                }, function(module, exports) {
                    var Direction;
                    !function(Direction) {
                        Direction[Direction.NONE = 0] = "NONE", Direction[Direction.UP = 1] = "UP", Direction[Direction.LEFT = 2] = "LEFT", 
                        Direction[Direction.RIGHT = 3] = "RIGHT", Direction[Direction.DOWN = 4] = "DOWN";
                    }(Direction || (Direction = {}));
                    var HilbertCurveBase = function() {
                        function HilbertCurveBase() {}
                        return HilbertCurveBase.prototype.walk = function(width, height, visitorCallback) {
                            this._x = 0, this._y = 0, this._d = 0, this._width = width, this._height = height, 
                            this._callback = visitorCallback;
                            var maxBound = Math.max(width, height);
                            this._level = Math.log(maxBound) / Math.log(2) + 1 | 0, this._walkHilbert(Direction.UP), 
                            this._visit(Direction.NONE);
                        }, HilbertCurveBase.prototype._walkHilbert = function(direction) {
                            if (!(this._level < 1)) {
                                switch (this._level--, direction) {
                                  case Direction.LEFT:
                                    this._walkHilbert(Direction.UP), this._visit(Direction.RIGHT), this._walkHilbert(Direction.LEFT), 
                                    this._visit(Direction.DOWN), this._walkHilbert(Direction.LEFT), this._visit(Direction.LEFT), 
                                    this._walkHilbert(Direction.DOWN);
                                    break;

                                  case Direction.RIGHT:
                                    this._walkHilbert(Direction.DOWN), this._visit(Direction.LEFT), this._walkHilbert(Direction.RIGHT), 
                                    this._visit(Direction.UP), this._walkHilbert(Direction.RIGHT), this._visit(Direction.RIGHT), 
                                    this._walkHilbert(Direction.UP);
                                    break;

                                  case Direction.UP:
                                    this._walkHilbert(Direction.LEFT), this._visit(Direction.DOWN), this._walkHilbert(Direction.UP), 
                                    this._visit(Direction.RIGHT), this._walkHilbert(Direction.UP), this._visit(Direction.UP), 
                                    this._walkHilbert(Direction.RIGHT);
                                    break;

                                  case Direction.DOWN:
                                    this._walkHilbert(Direction.RIGHT), this._visit(Direction.UP), this._walkHilbert(Direction.DOWN), 
                                    this._visit(Direction.LEFT), this._walkHilbert(Direction.DOWN), this._visit(Direction.DOWN), 
                                    this._walkHilbert(Direction.LEFT);
                                }
                                this._level++;
                            }
                        }, HilbertCurveBase.prototype._visit = function(direction) {
                            switch (this._x >= 0 && this._x < this._width && this._y >= 0 && this._y < this._height && (this._callback(this._x, this._y, this._d), 
                            this._d++), direction) {
                              case Direction.LEFT:
                                this._x--;
                                break;

                              case Direction.RIGHT:
                                this._x++;
                                break;

                              case Direction.UP:
                                this._y--;
                                break;

                              case Direction.DOWN:
                                this._y++;
                            }
                        }, HilbertCurveBase;
                    }();
                    exports.HilbertCurveBase = HilbertCurveBase;
                }, function(module, exports, __webpack_require__) {
                    /**
	 * @preserve
	 * Copyright 2015-2016 Igor Bezkrovnyi
	 * All rights reserved. (MIT Licensed)
	 *
	 * iq.ts - Image Quantization Library
	 */
                    var ssim_1 = __webpack_require__(36);
                    exports.SSIM = ssim_1.SSIM;
                }, function(module, exports, __webpack_require__) {
                    var bt709_1 = __webpack_require__(2), SSIM = function() {
                        function SSIM() {}
                        return SSIM.prototype.compare = function(image1, image2) {
                            if (image1.getHeight() !== image2.getHeight() || image1.getWidth() !== image2.getWidth()) throw new Error("Images have different sizes!");
                            var c1 = Math.pow(.01 * 255, 2), c2 = Math.pow(.03 * 255, 2), numWindows = 0, mssim = 0.0;
                            return this._iterate(image1, image2, (function(lumaValues1, lumaValues2, averageLumaValue1, averageLumaValue2) {
                                for (var sigxy = 0.0, sigsqx = 0.0, sigsqy = 0.0, i = 0; i < lumaValues1.length; i++) sigsqx += Math.pow(lumaValues1[i] - averageLumaValue1, 2), 
                                sigsqy += Math.pow(lumaValues2[i] - averageLumaValue2, 2), sigxy += (lumaValues1[i] - averageLumaValue1) * (lumaValues2[i] - averageLumaValue2);
                                var numPixelsInWin = lumaValues1.length - 1;
                                sigsqx /= numPixelsInWin, sigsqy /= numPixelsInWin;
                                var numerator = (2 * averageLumaValue1 * averageLumaValue2 + c1) * (2 * (sigxy /= numPixelsInWin) + c2), denominator = (Math.pow(averageLumaValue1, 2) + Math.pow(averageLumaValue2, 2) + c1) * (sigsqx + sigsqy + c2);
                                mssim += numerator / denominator, numWindows++;
                            })), mssim / numWindows;
                        }, SSIM.prototype._iterate = function(image1, image2, callback) {
                            for (var width = image1.getWidth(), height = image1.getHeight(), y = 0; y < height; y += 8) for (var x = 0; x < width; x += 8) {
                                var windowWidth = Math.min(8, width - x), windowHeight = Math.min(8, height - y), lumaValues1 = this._calculateLumaValuesForWindow(image1, x, y, windowWidth, windowHeight), lumaValues2 = this._calculateLumaValuesForWindow(image2, x, y, windowWidth, windowHeight);
                                callback(lumaValues1, lumaValues2, this._calculateAverageLuma(lumaValues1), this._calculateAverageLuma(lumaValues2));
                            }
                        }, SSIM.prototype._calculateLumaValuesForWindow = function(image, x, y, width, height) {
                            for (var pointArray = image.getPointArray(), lumaValues = [], counter = 0, j = y; j < y + height; j++) for (var offset = j * image.getWidth(), i = x; i < x + width; i++) {
                                var point = pointArray[offset + i];
                                lumaValues[counter] = point.r * bt709_1.Y.RED + point.g * bt709_1.Y.GREEN + point.b * bt709_1.Y.BLUE, 
                                counter++;
                            }
                            return lumaValues;
                        }, SSIM.prototype._calculateAverageLuma = function(lumaValues) {
                            for (var sumLuma = 0.0, i = 0; i < lumaValues.length; i++) sumLuma += lumaValues[i];
                            return sumLuma / lumaValues.length;
                        }, SSIM;
                    }();
                    exports.SSIM = SSIM;
                }, function(module, exports, __webpack_require__) {
                    /**
	 * @preserve
	 * Copyright 2015-2016 Igor Bezkrovnyi
	 * All rights reserved. (MIT Licensed)
	 *
	 * iq.ts - Image Quantization Library
	 */
                    var arithmetic = __webpack_require__(6);
                    exports.arithmetic = arithmetic;
                    var hueStatistics_1 = __webpack_require__(28);
                    exports.HueStatistics = hueStatistics_1.HueStatistics;
                    var palette_1 = __webpack_require__(22);
                    exports.Palette = palette_1.Palette;
                    var point_1 = __webpack_require__(24);
                    exports.Point = point_1.Point;
                    var pointContainer_1 = __webpack_require__(23);
                    exports.PointContainer = pointContainer_1.PointContainer;
                } ]);
            }));
        }, {} ],
        75: [ function(require, module, exports) {
            "function" == typeof Object.create ? module.exports = function inherits(ctor, superCtor) {
                superCtor && (ctor.super_ = superCtor, ctor.prototype = Object.create(superCtor.prototype, {
                    constructor: {
                        value: ctor,
                        enumerable: !1,
                        writable: !0,
                        configurable: !0
                    }
                }));
            } : module.exports = function inherits(ctor, superCtor) {
                if (superCtor) {
                    ctor.super_ = superCtor;
                    var TempCtor = function() {};
                    TempCtor.prototype = superCtor.prototype, ctor.prototype = new TempCtor, ctor.prototype.constructor = ctor;
                }
            };
        }, {} ],
        76: [ function(require, module, exports) {
            function isBuffer(obj) {
                return !!obj.constructor && "function" == typeof obj.constructor.isBuffer && obj.constructor.isBuffer(obj);
            }
            /*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
            module.exports = function(obj) {
                return null != obj && (isBuffer(obj) || function isSlowBuffer(obj) {
                    return "function" == typeof obj.readFloatLE && "function" == typeof obj.slice && isBuffer(obj.slice(0, 0));
                }(obj) || !!obj._isBuffer);
            };
        }, {} ],
        77: [ function(require, module, exports) {
            var fnToStr = Function.prototype.toString, constructorRegex = /^\s*class\b/, isES6ClassFn = function isES6ClassFunction(value) {
                try {
                    var fnStr = fnToStr.call(value);
                    return constructorRegex.test(fnStr);
                } catch (e) {
                    return !1;
                }
            }, toStr = Object.prototype.toString, hasToStringTag = "function" == typeof Symbol && "symbol" == typeof Symbol.toStringTag;
            module.exports = function isCallable(value) {
                if (!value) return !1;
                if ("function" != typeof value && "object" != typeof value) return !1;
                if ("function" == typeof value && !value.prototype) return !0;
                if (hasToStringTag) return function tryFunctionToStr(value) {
                    try {
                        return !isES6ClassFn(value) && (fnToStr.call(value), !0);
                    } catch (e) {
                        return !1;
                    }
                }(value);
                if (isES6ClassFn(value)) return !1;
                var strClass = toStr.call(value);
                return "[object Function]" === strClass || "[object GeneratorFunction]" === strClass;
            };
        }, {} ],
        78: [ function(require, module, exports) {
            module.exports = function isFunction(fn) {
                var string = toString.call(fn);
                return "[object Function]" === string || "function" == typeof fn && "[object RegExp]" !== string || void 0 !== window && (fn === window.setTimeout || fn === window.alert || fn === window.confirm || fn === window.prompt);
            };
            var toString = Object.prototype.toString;
        }, {} ],
        79: [ function(require, module, exports) {
            var toString = {}.toString;
            module.exports = Array.isArray || function(arr) {
                return "[object Array]" == toString.call(arr);
            };
        }, {} ],
        80: [ function(require, module, exports) {
            var encode = require("./lib/encoder"), decode = require("./lib/decoder");
            module.exports = {
                encode,
                decode
            };
        }, {
            "./lib/decoder": 81,
            "./lib/encoder": 82
        } ],
        81: [ function(require, module, exports) {
            (function(Buffer) {
                var JpegImage = function jpegImage() {
                    var dctZigZag = new Int32Array([ 0, 1, 8, 16, 9, 2, 3, 10, 17, 24, 32, 25, 18, 11, 4, 5, 12, 19, 26, 33, 40, 48, 41, 34, 27, 20, 13, 6, 7, 14, 21, 28, 35, 42, 49, 56, 57, 50, 43, 36, 29, 22, 15, 23, 30, 37, 44, 51, 58, 59, 52, 45, 38, 31, 39, 46, 53, 60, 61, 54, 47, 55, 62, 63 ]);
                    function constructor() {}
                    function buildHuffmanTable(codeLengths, values) {
                        for (var i, j, k = 0, code = [], length = 16; length > 0 && !codeLengths[length - 1]; ) length--;
                        code.push({
                            children: [],
                            index: 0
                        });
                        var q, p = code[0];
                        for (i = 0; i < length; i++) {
                            for (j = 0; j < codeLengths[i]; j++) {
                                for ((p = code.pop()).children[p.index] = values[k]; p.index > 0; ) {
                                    if (0 === code.length) throw new Error("Could not recreate Huffman Table");
                                    p = code.pop();
                                }
                                for (p.index++, code.push(p); code.length <= i; ) code.push(q = {
                                    children: [],
                                    index: 0
                                }), p.children[p.index] = q.children, p = q;
                                k++;
                            }
                            i + 1 < length && (code.push(q = {
                                children: [],
                                index: 0
                            }), p.children[p.index] = q.children, p = q);
                        }
                        return code[0].children;
                    }
                    function decodeScan(data, offset, frame, components, resetInterval, spectralStart, spectralEnd, successivePrev, successive, opts) {
                        frame.precision, frame.samplesPerLine, frame.scanLines;
                        var mcusPerLine = frame.mcusPerLine, progressive = frame.progressive;
                        frame.maxH, frame.maxV;
                        var startOffset = offset, bitsData = 0, bitsCount = 0;
                        function readBit() {
                            if (bitsCount > 0) return bitsCount--, bitsData >> bitsCount & 1;
                            if (0xFF == (bitsData = data[offset++])) {
                                var nextByte = data[offset++];
                                if (nextByte) throw new Error("unexpected marker: " + (bitsData << 8 | nextByte).toString(16));
                            }
                            return bitsCount = 7, bitsData >>> 7;
                        }
                        function decodeHuffman(tree) {
                            for (var bit, node = tree; null !== (bit = readBit()); ) {
                                if ("number" == typeof (node = node[bit])) return node;
                                if ("object" != typeof node) throw new Error("invalid huffman sequence");
                            }
                            return null;
                        }
                        function receive(length) {
                            for (var n = 0; length > 0; ) {
                                var bit = readBit();
                                if (null === bit) return;
                                n = n << 1 | bit, length--;
                            }
                            return n;
                        }
                        function receiveAndExtend(length) {
                            var n = receive(length);
                            return n >= 1 << length - 1 ? n : n + (-1 << length) + 1;
                        }
                        var successiveACNextValue, eobrun = 0, successiveACState = 0;
                        function decodeMcu(component, decode, mcu, row, col) {
                            var mcuCol = mcu % mcusPerLine, blockRow = (mcu / mcusPerLine | 0) * component.v + row, blockCol = mcuCol * component.h + col;
                            void 0 === component.blocks[blockRow] && opts.tolerantDecoding || decode(component, component.blocks[blockRow][blockCol]);
                        }
                        function decodeBlock(component, decode, mcu) {
                            var blockRow = mcu / component.blocksPerLine | 0, blockCol = mcu % component.blocksPerLine;
                            void 0 === component.blocks[blockRow] && opts.tolerantDecoding || decode(component, component.blocks[blockRow][blockCol]);
                        }
                        var component, i, j, k, n, decodeFn, componentsLength = components.length;
                        decodeFn = progressive ? 0 === spectralStart ? 0 === successivePrev ? function decodeDCFirst(component, zz) {
                            var t = decodeHuffman(component.huffmanTableDC), diff = 0 === t ? 0 : receiveAndExtend(t) << successive;
                            zz[0] = component.pred += diff;
                        } : function decodeDCSuccessive(component, zz) {
                            zz[0] |= readBit() << successive;
                        } : 0 === successivePrev ? function decodeACFirst(component, zz) {
                            if (eobrun > 0) eobrun--; else for (var k = spectralStart, e = spectralEnd; k <= e; ) {
                                var rs = decodeHuffman(component.huffmanTableAC), s = 15 & rs, r = rs >> 4;
                                if (0 !== s) zz[dctZigZag[k += r]] = receiveAndExtend(s) * (1 << successive), k++; else {
                                    if (r < 15) {
                                        eobrun = receive(r) + (1 << r) - 1;
                                        break;
                                    }
                                    k += 16;
                                }
                            }
                        } : function decodeACSuccessive(component, zz) {
                            for (var k = spectralStart, e = spectralEnd, r = 0; k <= e; ) {
                                var z = dctZigZag[k], direction = zz[z] < 0 ? -1 : 1;
                                switch (successiveACState) {
                                  case 0:
                                    var rs = decodeHuffman(component.huffmanTableAC), s = 15 & rs;
                                    if (r = rs >> 4, 0 === s) r < 15 ? (eobrun = receive(r) + (1 << r), successiveACState = 4) : (r = 16, 
                                    successiveACState = 1); else {
                                        if (1 !== s) throw new Error("invalid ACn encoding");
                                        successiveACNextValue = receiveAndExtend(s), successiveACState = r ? 2 : 3;
                                    }
                                    continue;

                                  case 1:
                                  case 2:
                                    zz[z] ? zz[z] += (readBit() << successive) * direction : 0 == --r && (successiveACState = 2 == successiveACState ? 3 : 0);
                                    break;

                                  case 3:
                                    zz[z] ? zz[z] += (readBit() << successive) * direction : (zz[z] = successiveACNextValue << successive, 
                                    successiveACState = 0);
                                    break;

                                  case 4:
                                    zz[z] && (zz[z] += (readBit() << successive) * direction);
                                }
                                k++;
                            }
                            4 === successiveACState && 0 == --eobrun && (successiveACState = 0);
                        } : function decodeBaseline(component, zz) {
                            var t = decodeHuffman(component.huffmanTableDC), diff = 0 === t ? 0 : receiveAndExtend(t);
                            zz[0] = component.pred += diff;
                            for (var k = 1; k < 64; ) {
                                var rs = decodeHuffman(component.huffmanTableAC), s = 15 & rs, r = rs >> 4;
                                if (0 !== s) zz[dctZigZag[k += r]] = receiveAndExtend(s), k++; else {
                                    if (r < 15) break;
                                    k += 16;
                                }
                            }
                        };
                        var marker, mcuExpected, h, v, mcu = 0;
                        for (mcuExpected = 1 == componentsLength ? components[0].blocksPerLine * components[0].blocksPerColumn : mcusPerLine * frame.mcusPerColumn, 
                        resetInterval || (resetInterval = mcuExpected); mcu < mcuExpected; ) {
                            for (i = 0; i < componentsLength; i++) components[i].pred = 0;
                            if (eobrun = 0, 1 == componentsLength) for (component = components[0], n = 0; n < resetInterval; n++) decodeBlock(component, decodeFn, mcu), 
                            mcu++; else for (n = 0; n < resetInterval; n++) {
                                for (i = 0; i < componentsLength; i++) for (h = (component = components[i]).h, v = component.v, 
                                j = 0; j < v; j++) for (k = 0; k < h; k++) decodeMcu(component, decodeFn, mcu, j, k);
                                if (++mcu === mcuExpected) break;
                            }
                            if (mcu === mcuExpected) do {
                                if (0xFF === data[offset] && 0x00 !== data[offset + 1]) break;
                                offset += 1;
                            } while (offset < data.length - 2);
                            if (bitsCount = 0, (marker = data[offset] << 8 | data[offset + 1]) < 0xFF00) throw new Error("marker was not found");
                            if (!(marker >= 0xFFD0 && marker <= 0xFFD7)) break;
                            offset += 2;
                        }
                        return offset - startOffset;
                    }
                    function buildComponentData(frame, component) {
                        var i, j, lines = [], blocksPerLine = component.blocksPerLine, blocksPerColumn = component.blocksPerColumn, samplesPerLine = blocksPerLine << 3, R = new Int32Array(64), r = new Uint8Array(64);
                        function quantizeAndInverse(zz, dataOut, dataIn) {
                            var v0, v1, v2, v3, v4, v5, v6, v7, t, i, qt = component.quantizationTable, p = dataIn;
                            for (i = 0; i < 64; i++) p[i] = zz[i] * qt[i];
                            for (i = 0; i < 8; ++i) {
                                var row = 8 * i;
                                0 != p[1 + row] || 0 != p[2 + row] || 0 != p[3 + row] || 0 != p[4 + row] || 0 != p[5 + row] || 0 != p[6 + row] || 0 != p[7 + row] ? (v0 = 5793 * p[0 + row] + 128 >> 8, 
                                v1 = 5793 * p[4 + row] + 128 >> 8, v2 = p[2 + row], v3 = p[6 + row], v4 = 2896 * (p[1 + row] - p[7 + row]) + 128 >> 8, 
                                v7 = 2896 * (p[1 + row] + p[7 + row]) + 128 >> 8, v5 = p[3 + row] << 4, t = v0 - v1 + 1 >> 1, 
                                v0 = v0 + v1 + 1 >> 1, v1 = t, t = 3784 * v2 + 1567 * v3 + 128 >> 8, v2 = 1567 * v2 - 3784 * v3 + 128 >> 8, 
                                v3 = t, t = v4 - (v6 = p[5 + row] << 4) + 1 >> 1, v4 = v4 + v6 + 1 >> 1, v6 = t, 
                                t = v7 + v5 + 1 >> 1, v5 = v7 - v5 + 1 >> 1, v7 = t, t = v0 - v3 + 1 >> 1, v0 = v0 + v3 + 1 >> 1, 
                                v3 = t, t = v1 - v2 + 1 >> 1, v1 = v1 + v2 + 1 >> 1, v2 = t, t = 2276 * v4 + 3406 * v7 + 2048 >> 12, 
                                v4 = 3406 * v4 - 2276 * v7 + 2048 >> 12, v7 = t, t = 799 * v5 + 4017 * v6 + 2048 >> 12, 
                                v5 = 4017 * v5 - 799 * v6 + 2048 >> 12, v6 = t, p[0 + row] = v0 + v7, p[7 + row] = v0 - v7, 
                                p[1 + row] = v1 + v6, p[6 + row] = v1 - v6, p[2 + row] = v2 + v5, p[5 + row] = v2 - v5, 
                                p[3 + row] = v3 + v4, p[4 + row] = v3 - v4) : (t = 5793 * p[0 + row] + 512 >> 10, 
                                p[0 + row] = t, p[1 + row] = t, p[2 + row] = t, p[3 + row] = t, p[4 + row] = t, 
                                p[5 + row] = t, p[6 + row] = t, p[7 + row] = t);
                            }
                            for (i = 0; i < 8; ++i) {
                                var col = i;
                                0 != p[8 + col] || 0 != p[16 + col] || 0 != p[24 + col] || 0 != p[32 + col] || 0 != p[40 + col] || 0 != p[48 + col] || 0 != p[56 + col] ? (v0 = 5793 * p[0 + col] + 2048 >> 12, 
                                v1 = 5793 * p[32 + col] + 2048 >> 12, v2 = p[16 + col], v3 = p[48 + col], v4 = 2896 * (p[8 + col] - p[56 + col]) + 2048 >> 12, 
                                v7 = 2896 * (p[8 + col] + p[56 + col]) + 2048 >> 12, v5 = p[24 + col], t = v0 - v1 + 1 >> 1, 
                                v0 = v0 + v1 + 1 >> 1, v1 = t, t = 3784 * v2 + 1567 * v3 + 2048 >> 12, v2 = 1567 * v2 - 3784 * v3 + 2048 >> 12, 
                                v3 = t, t = v4 - (v6 = p[40 + col]) + 1 >> 1, v4 = v4 + v6 + 1 >> 1, v6 = t, t = v7 + v5 + 1 >> 1, 
                                v5 = v7 - v5 + 1 >> 1, v7 = t, t = v0 - v3 + 1 >> 1, v0 = v0 + v3 + 1 >> 1, v3 = t, 
                                t = v1 - v2 + 1 >> 1, v1 = v1 + v2 + 1 >> 1, v2 = t, t = 2276 * v4 + 3406 * v7 + 2048 >> 12, 
                                v4 = 3406 * v4 - 2276 * v7 + 2048 >> 12, v7 = t, t = 799 * v5 + 4017 * v6 + 2048 >> 12, 
                                v5 = 4017 * v5 - 799 * v6 + 2048 >> 12, v6 = t, p[0 + col] = v0 + v7, p[56 + col] = v0 - v7, 
                                p[8 + col] = v1 + v6, p[48 + col] = v1 - v6, p[16 + col] = v2 + v5, p[40 + col] = v2 - v5, 
                                p[24 + col] = v3 + v4, p[32 + col] = v3 - v4) : (t = 5793 * dataIn[i + 0] + 8192 >> 14, 
                                p[0 + col] = t, p[8 + col] = t, p[16 + col] = t, p[24 + col] = t, p[32 + col] = t, 
                                p[40 + col] = t, p[48 + col] = t, p[56 + col] = t);
                            }
                            for (i = 0; i < 64; ++i) {
                                var sample = 128 + (p[i] + 8 >> 4);
                                dataOut[i] = sample < 0 ? 0 : sample > 0xFF ? 0xFF : sample;
                            }
                        }
                        requestMemoryAllocation(samplesPerLine * blocksPerColumn * 8);
                        for (var blockRow = 0; blockRow < blocksPerColumn; blockRow++) {
                            var scanLine = blockRow << 3;
                            for (i = 0; i < 8; i++) lines.push(new Uint8Array(samplesPerLine));
                            for (var blockCol = 0; blockCol < blocksPerLine; blockCol++) {
                                quantizeAndInverse(component.blocks[blockRow][blockCol], r, R);
                                var offset = 0, sample = blockCol << 3;
                                for (j = 0; j < 8; j++) {
                                    var line = lines[scanLine + j];
                                    for (i = 0; i < 8; i++) line[sample + i] = r[offset++];
                                }
                            }
                        }
                        return lines;
                    }
                    function clampTo8bit(a) {
                        return a < 0 ? 0 : a > 255 ? 255 : a;
                    }
                    constructor.prototype = {
                        load: function load(path) {
                            var xhr = new XMLHttpRequest;
                            xhr.open("GET", path, !0), xhr.responseType = "arraybuffer", xhr.onload = function() {
                                var data = new Uint8Array(xhr.response || xhr.mozResponseArrayBuffer);
                                this.parse(data), this.onload && this.onload();
                            }.bind(this), xhr.send(null);
                        },
                        parse: function parse(data) {
                            var maxResolutionInPixels = 1000 * this.opts.maxResolutionInMP * 1000, offset = 0;
                            function readUint16() {
                                var value = data[offset] << 8 | data[offset + 1];
                                return offset += 2, value;
                            }
                            function prepareComponents(frame) {
                                var component, componentId, maxH = 0, maxV = 0;
                                for (componentId in frame.components) frame.components.hasOwnProperty(componentId) && (maxH < (component = frame.components[componentId]).h && (maxH = component.h), 
                                maxV < component.v && (maxV = component.v));
                                var mcusPerLine = Math.ceil(frame.samplesPerLine / 8 / maxH), mcusPerColumn = Math.ceil(frame.scanLines / 8 / maxV);
                                for (componentId in frame.components) if (frame.components.hasOwnProperty(componentId)) {
                                    component = frame.components[componentId];
                                    var blocksPerLine = Math.ceil(Math.ceil(frame.samplesPerLine / 8) * component.h / maxH), blocksPerColumn = Math.ceil(Math.ceil(frame.scanLines / 8) * component.v / maxV), blocksPerLineForMcu = mcusPerLine * component.h, blocksPerColumnForMcu = mcusPerColumn * component.v, blocks = [];
                                    requestMemoryAllocation(blocksPerColumnForMcu * blocksPerLineForMcu * 256);
                                    for (var i = 0; i < blocksPerColumnForMcu; i++) {
                                        for (var row = [], j = 0; j < blocksPerLineForMcu; j++) row.push(new Int32Array(64));
                                        blocks.push(row);
                                    }
                                    component.blocksPerLine = blocksPerLine, component.blocksPerColumn = blocksPerColumn, 
                                    component.blocks = blocks;
                                }
                                frame.maxH = maxH, frame.maxV = maxV, frame.mcusPerLine = mcusPerLine, frame.mcusPerColumn = mcusPerColumn;
                            }
                            data.length;
                            var frame, resetInterval, length, array, jfif = null, adobe = null, quantizationTables = [], frames = [], huffmanTablesAC = [], huffmanTablesDC = [], fileMarker = readUint16();
                            if (this.comments = [], 0xFFD8 != fileMarker) throw new Error("SOI not found");
                            for (fileMarker = readUint16(); 0xFFD9 != fileMarker; ) {
                                switch (fileMarker) {
                                  case 0xFF00:
                                    break;

                                  case 0xFFE0:
                                  case 0xFFE1:
                                  case 0xFFE2:
                                  case 0xFFE3:
                                  case 0xFFE4:
                                  case 0xFFE5:
                                  case 0xFFE6:
                                  case 0xFFE7:
                                  case 0xFFE8:
                                  case 0xFFE9:
                                  case 0xFFEA:
                                  case 0xFFEB:
                                  case 0xFFEC:
                                  case 0xFFED:
                                  case 0xFFEE:
                                  case 0xFFEF:
                                  case 0xFFFE:
                                    var appData = (void 0, void 0, length = readUint16(), array = data.subarray(offset, offset + length - 2), 
                                    offset += array.length, array);
                                    if (0xFFFE === fileMarker) {
                                        var comment = String.fromCharCode.apply(null, appData);
                                        this.comments.push(comment);
                                    }
                                    0xFFE0 === fileMarker && 0x4A === appData[0] && 0x46 === appData[1] && 0x49 === appData[2] && 0x46 === appData[3] && 0 === appData[4] && (jfif = {
                                        version: {
                                            major: appData[5],
                                            minor: appData[6]
                                        },
                                        densityUnits: appData[7],
                                        xDensity: appData[8] << 8 | appData[9],
                                        yDensity: appData[10] << 8 | appData[11],
                                        thumbWidth: appData[12],
                                        thumbHeight: appData[13],
                                        thumbData: appData.subarray(14, 14 + 3 * appData[12] * appData[13])
                                    }), 0xFFE1 === fileMarker && 0x45 === appData[0] && 0x78 === appData[1] && 0x69 === appData[2] && 0x66 === appData[3] && 0 === appData[4] && (this.exifBuffer = appData.subarray(5, appData.length)), 
                                    0xFFEE === fileMarker && 0x41 === appData[0] && 0x64 === appData[1] && 0x6F === appData[2] && 0x62 === appData[3] && 0x65 === appData[4] && 0 === appData[5] && (adobe = {
                                        version: appData[6],
                                        flags0: appData[7] << 8 | appData[8],
                                        flags1: appData[9] << 8 | appData[10],
                                        transformCode: appData[11]
                                    });
                                    break;

                                  case 0xFFDB:
                                    for (var quantizationTablesEnd = readUint16() + offset - 2; offset < quantizationTablesEnd; ) {
                                        var quantizationTableSpec = data[offset++];
                                        requestMemoryAllocation(256);
                                        var tableData = new Int32Array(64);
                                        if (quantizationTableSpec >> 4 == 0) for (j = 0; j < 64; j++) tableData[dctZigZag[j]] = data[offset++]; else {
                                            if (quantizationTableSpec >> 4 != 1) throw new Error("DQT: invalid table spec");
                                            for (j = 0; j < 64; j++) tableData[dctZigZag[j]] = readUint16();
                                        }
                                        quantizationTables[15 & quantizationTableSpec] = tableData;
                                    }
                                    break;

                                  case 0xFFC0:
                                  case 0xFFC1:
                                  case 0xFFC2:
                                    readUint16(), (frame = {}).extended = 0xFFC1 === fileMarker, frame.progressive = 0xFFC2 === fileMarker, 
                                    frame.precision = data[offset++], frame.scanLines = readUint16(), frame.samplesPerLine = readUint16(), 
                                    frame.components = {}, frame.componentsOrder = [];
                                    var pixelsInFrame = frame.scanLines * frame.samplesPerLine;
                                    if (pixelsInFrame > maxResolutionInPixels) {
                                        var exceededAmount = Math.ceil((pixelsInFrame - maxResolutionInPixels) / 1e6);
                                        throw new Error(`maxResolutionInMP limit exceeded by ${exceededAmount}MP`);
                                    }
                                    var componentId, componentsCount = data[offset++];
                                    for (i = 0; i < componentsCount; i++) {
                                        componentId = data[offset];
                                        var h = data[offset + 1] >> 4, v = 15 & data[offset + 1], qId = data[offset + 2];
                                        frame.componentsOrder.push(componentId), frame.components[componentId] = {
                                            h,
                                            v,
                                            quantizationIdx: qId
                                        }, offset += 3;
                                    }
                                    prepareComponents(frame), frames.push(frame);
                                    break;

                                  case 0xFFC4:
                                    var huffmanLength = readUint16();
                                    for (i = 2; i < huffmanLength; ) {
                                        var huffmanTableSpec = data[offset++], codeLengths = new Uint8Array(16), codeLengthSum = 0;
                                        for (j = 0; j < 16; j++, offset++) codeLengthSum += codeLengths[j] = data[offset];
                                        requestMemoryAllocation(16 + codeLengthSum);
                                        var huffmanValues = new Uint8Array(codeLengthSum);
                                        for (j = 0; j < codeLengthSum; j++, offset++) huffmanValues[j] = data[offset];
                                        i += 17 + codeLengthSum, (huffmanTableSpec >> 4 == 0 ? huffmanTablesDC : huffmanTablesAC)[15 & huffmanTableSpec] = buildHuffmanTable(codeLengths, huffmanValues);
                                    }
                                    break;

                                  case 0xFFDD:
                                    readUint16(), resetInterval = readUint16();
                                    break;

                                  case 0xFFDC:
                                    readUint16(), readUint16();
                                    break;

                                  case 0xFFDA:
                                    readUint16();
                                    var selectorsCount = data[offset++], components = [];
                                    for (i = 0; i < selectorsCount; i++) {
                                        component = frame.components[data[offset++]];
                                        var tableSpec = data[offset++];
                                        component.huffmanTableDC = huffmanTablesDC[tableSpec >> 4], component.huffmanTableAC = huffmanTablesAC[15 & tableSpec], 
                                        components.push(component);
                                    }
                                    var spectralStart = data[offset++], spectralEnd = data[offset++], successiveApproximation = data[offset++], processed = decodeScan(data, offset, frame, components, resetInterval, spectralStart, spectralEnd, successiveApproximation >> 4, 15 & successiveApproximation, this.opts);
                                    offset += processed;
                                    break;

                                  case 0xFFFF:
                                    0xFF !== data[offset] && offset--;
                                    break;

                                  default:
                                    if (0xFF == data[offset - 3] && data[offset - 2] >= 0xC0 && data[offset - 2] <= 0xFE) {
                                        offset -= 3;
                                        break;
                                    }
                                    throw new Error("unknown JPEG marker " + fileMarker.toString(16));
                                }
                                fileMarker = readUint16();
                            }
                            if (1 != frames.length) throw new Error("only single frame JPEGs supported");
                            for (var i = 0; i < frames.length; i++) {
                                var cp = frames[i].components;
                                for (var j in cp) cp[j].quantizationTable = quantizationTables[cp[j].quantizationIdx], 
                                delete cp[j].quantizationIdx;
                            }
                            for (this.width = frame.samplesPerLine, this.height = frame.scanLines, this.jfif = jfif, 
                            this.adobe = adobe, this.components = [], i = 0; i < frame.componentsOrder.length; i++) {
                                var component = frame.components[frame.componentsOrder[i]];
                                this.components.push({
                                    lines: buildComponentData(0, component),
                                    scaleX: component.h / frame.maxH,
                                    scaleY: component.v / frame.maxV
                                });
                            }
                        },
                        getData: function getData(width, height) {
                            var component1, component2, component3, component4, component1Line, component2Line, component3Line, component4Line, x, y, Y, Cb, Cr, K, C, M, Ye, R, G, B, colorTransform, scaleX = this.width / width, scaleY = this.height / height, offset = 0, dataLength = width * height * this.components.length;
                            requestMemoryAllocation(dataLength);
                            var data = new Uint8Array(dataLength);
                            switch (this.components.length) {
                              case 1:
                                for (component1 = this.components[0], y = 0; y < height; y++) for (component1Line = component1.lines[0 | y * component1.scaleY * scaleY], 
                                x = 0; x < width; x++) Y = component1Line[0 | x * component1.scaleX * scaleX], data[offset++] = Y;
                                break;

                              case 2:
                                for (component1 = this.components[0], component2 = this.components[1], y = 0; y < height; y++) for (component1Line = component1.lines[0 | y * component1.scaleY * scaleY], 
                                component2Line = component2.lines[0 | y * component2.scaleY * scaleY], x = 0; x < width; x++) Y = component1Line[0 | x * component1.scaleX * scaleX], 
                                data[offset++] = Y, Y = component2Line[0 | x * component2.scaleX * scaleX], data[offset++] = Y;
                                break;

                              case 3:
                                for (colorTransform = !0, this.adobe && this.adobe.transformCode ? colorTransform = !0 : void 0 !== this.opts.colorTransform && (colorTransform = !!this.opts.colorTransform), 
                                component1 = this.components[0], component2 = this.components[1], component3 = this.components[2], 
                                y = 0; y < height; y++) for (component1Line = component1.lines[0 | y * component1.scaleY * scaleY], 
                                component2Line = component2.lines[0 | y * component2.scaleY * scaleY], component3Line = component3.lines[0 | y * component3.scaleY * scaleY], 
                                x = 0; x < width; x++) colorTransform ? (Y = component1Line[0 | x * component1.scaleX * scaleX], 
                                Cb = component2Line[0 | x * component2.scaleX * scaleX], R = clampTo8bit(Y + 1.402 * ((Cr = component3Line[0 | x * component3.scaleX * scaleX]) - 128)), 
                                G = clampTo8bit(Y - 0.3441363 * (Cb - 128) - 0.71413636 * (Cr - 128)), B = clampTo8bit(Y + 1.772 * (Cb - 128))) : (R = component1Line[0 | x * component1.scaleX * scaleX], 
                                G = component2Line[0 | x * component2.scaleX * scaleX], B = component3Line[0 | x * component3.scaleX * scaleX]), 
                                data[offset++] = R, data[offset++] = G, data[offset++] = B;
                                break;

                              case 4:
                                if (!this.adobe) throw new Error("Unsupported color mode (4 components)");
                                for (colorTransform = !1, this.adobe && this.adobe.transformCode ? colorTransform = !0 : void 0 !== this.opts.colorTransform && (colorTransform = !!this.opts.colorTransform), 
                                component1 = this.components[0], component2 = this.components[1], component3 = this.components[2], 
                                component4 = this.components[3], y = 0; y < height; y++) for (component1Line = component1.lines[0 | y * component1.scaleY * scaleY], 
                                component2Line = component2.lines[0 | y * component2.scaleY * scaleY], component3Line = component3.lines[0 | y * component3.scaleY * scaleY], 
                                component4Line = component4.lines[0 | y * component4.scaleY * scaleY], x = 0; x < width; x++) colorTransform ? (Y = component1Line[0 | x * component1.scaleX * scaleX], 
                                Cb = component2Line[0 | x * component2.scaleX * scaleX], Cr = component3Line[0 | x * component3.scaleX * scaleX], 
                                K = component4Line[0 | x * component4.scaleX * scaleX], C = 255 - clampTo8bit(Y + 1.402 * (Cr - 128)), 
                                M = 255 - clampTo8bit(Y - 0.3441363 * (Cb - 128) - 0.71413636 * (Cr - 128)), Ye = 255 - clampTo8bit(Y + 1.772 * (Cb - 128))) : (C = component1Line[0 | x * component1.scaleX * scaleX], 
                                M = component2Line[0 | x * component2.scaleX * scaleX], Ye = component3Line[0 | x * component3.scaleX * scaleX], 
                                K = component4Line[0 | x * component4.scaleX * scaleX]), data[offset++] = 255 - C, 
                                data[offset++] = 255 - M, data[offset++] = 255 - Ye, data[offset++] = 255 - K;
                                break;

                              default:
                                throw new Error("Unsupported color mode");
                            }
                            return data;
                        },
                        copyToImageData: function copyToImageData(imageData, formatAsRGBA) {
                            var x, y, Y, K, C, M, R, G, B, width = imageData.width, height = imageData.height, imageDataArray = imageData.data, data = this.getData(width, height), i = 0, j = 0;
                            switch (this.components.length) {
                              case 1:
                                for (y = 0; y < height; y++) for (x = 0; x < width; x++) Y = data[i++], imageDataArray[j++] = Y, 
                                imageDataArray[j++] = Y, imageDataArray[j++] = Y, formatAsRGBA && (imageDataArray[j++] = 255);
                                break;

                              case 3:
                                for (y = 0; y < height; y++) for (x = 0; x < width; x++) R = data[i++], G = data[i++], 
                                B = data[i++], imageDataArray[j++] = R, imageDataArray[j++] = G, imageDataArray[j++] = B, 
                                formatAsRGBA && (imageDataArray[j++] = 255);
                                break;

                              case 4:
                                for (y = 0; y < height; y++) for (x = 0; x < width; x++) C = data[i++], M = data[i++], 
                                Y = data[i++], R = 255 - clampTo8bit(C * (1 - (K = data[i++]) / 255) + K), G = 255 - clampTo8bit(M * (1 - K / 255) + K), 
                                B = 255 - clampTo8bit(Y * (1 - K / 255) + K), imageDataArray[j++] = R, imageDataArray[j++] = G, 
                                imageDataArray[j++] = B, formatAsRGBA && (imageDataArray[j++] = 255);
                                break;

                              default:
                                throw new Error("Unsupported color mode");
                            }
                        }
                    };
                    var totalBytesAllocated = 0, maxMemoryUsageBytes = 0;
                    function requestMemoryAllocation(increaseAmount = 0) {
                        var totalMemoryImpactBytes = totalBytesAllocated + increaseAmount;
                        if (totalMemoryImpactBytes > maxMemoryUsageBytes) {
                            var exceededAmount = Math.ceil((totalMemoryImpactBytes - maxMemoryUsageBytes) / 1024 / 1024);
                            throw new Error(`maxMemoryUsageInMB limit exceeded by at least ${exceededAmount}MB`);
                        }
                        totalBytesAllocated = totalMemoryImpactBytes;
                    }
                    return constructor.resetMaxMemoryUsage = function(maxMemoryUsageBytes_) {
                        totalBytesAllocated = 0, maxMemoryUsageBytes = maxMemoryUsageBytes_;
                    }, constructor.getBytesAllocated = function() {
                        return totalBytesAllocated;
                    }, constructor.requestMemoryAllocation = requestMemoryAllocation, constructor;
                }();
                function decode(jpegData, userOpts = {}) {
                    var opts = {
                        colorTransform: void 0,
                        useTArray: !1,
                        formatAsRGBA: !0,
                        tolerantDecoding: !0,
                        maxResolutionInMP: 100,
                        maxMemoryUsageInMB: 512,
                        ...userOpts
                    }, arr = new Uint8Array(jpegData), decoder = new JpegImage;
                    decoder.opts = opts, JpegImage.resetMaxMemoryUsage(1024 * opts.maxMemoryUsageInMB * 1024), 
                    decoder.parse(arr);
                    var channels = opts.formatAsRGBA ? 4 : 3, bytesNeeded = decoder.width * decoder.height * channels;
                    try {
                        JpegImage.requestMemoryAllocation(bytesNeeded);
                        var image = {
                            width: decoder.width,
                            height: decoder.height,
                            exifBuffer: decoder.exifBuffer,
                            data: opts.useTArray ? new Uint8Array(bytesNeeded) : Buffer.alloc(bytesNeeded)
                        };
                        decoder.comments.length > 0 && (image.comments = decoder.comments);
                    } catch (err) {
                        throw err instanceof RangeError ? new Error("Could not allocate enough memory for the image. Required: " + bytesNeeded) : err;
                    }
                    return decoder.copyToImageData(image, opts.formatAsRGBA), image;
                }
                void 0 !== module ? module.exports = decode : void 0 !== window && (window["jpeg-js"] = window["jpeg-js"] || {}, 
                window["jpeg-js"].decode = decode);
            }).call(this, require("buffer").Buffer);
        }, {
            buffer: 48
        } ],
        82: [ function(require, module, exports) {
            (function(Buffer) {
                function JPEGEncoder(quality) {
                    var YDC_HT, UVDC_HT, YAC_HT, UVAC_HT, currentQuality, ffloor = Math.floor, YTable = new Array(64), UVTable = new Array(64), fdtbl_Y = new Array(64), fdtbl_UV = new Array(64), bitcode = new Array(65535), category = new Array(65535), outputfDCTQuant = new Array(64), DU = new Array(64), byteout = [], bytenew = 0, bytepos = 7, YDU = new Array(64), UDU = new Array(64), VDU = new Array(64), clt = new Array(256), RGB_YUV_TABLE = new Array(2048), ZigZag = [ 0, 1, 5, 6, 14, 15, 27, 28, 2, 4, 7, 13, 16, 26, 29, 42, 3, 8, 12, 17, 25, 30, 41, 43, 9, 11, 18, 24, 31, 40, 44, 53, 10, 19, 23, 32, 39, 45, 52, 54, 20, 22, 33, 38, 46, 51, 55, 60, 21, 34, 37, 47, 50, 56, 59, 61, 35, 36, 48, 49, 57, 58, 62, 63 ], std_dc_luminance_nrcodes = [ 0, 0, 1, 5, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0 ], std_dc_luminance_values = [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11 ], std_ac_luminance_nrcodes = [ 0, 0, 2, 1, 3, 3, 2, 4, 3, 5, 5, 4, 4, 0, 0, 1, 0x7d ], std_ac_luminance_values = [ 0x01, 0x02, 0x03, 0x00, 0x04, 0x11, 0x05, 0x12, 0x21, 0x31, 0x41, 0x06, 0x13, 0x51, 0x61, 0x07, 0x22, 0x71, 0x14, 0x32, 0x81, 0x91, 0xa1, 0x08, 0x23, 0x42, 0xb1, 0xc1, 0x15, 0x52, 0xd1, 0xf0, 0x24, 0x33, 0x62, 0x72, 0x82, 0x09, 0x0a, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa ], std_dc_chrominance_nrcodes = [ 0, 0, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0 ], std_dc_chrominance_values = [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11 ], std_ac_chrominance_nrcodes = [ 0, 0, 2, 1, 2, 4, 4, 3, 4, 7, 5, 4, 4, 0, 1, 2, 0x77 ], std_ac_chrominance_values = [ 0x00, 0x01, 0x02, 0x03, 0x11, 0x04, 0x05, 0x21, 0x31, 0x06, 0x12, 0x41, 0x51, 0x07, 0x61, 0x71, 0x13, 0x22, 0x32, 0x81, 0x08, 0x14, 0x42, 0x91, 0xa1, 0xb1, 0xc1, 0x09, 0x23, 0x33, 0x52, 0xf0, 0x15, 0x62, 0x72, 0xd1, 0x0a, 0x16, 0x24, 0x34, 0xe1, 0x25, 0xf1, 0x17, 0x18, 0x19, 0x1a, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa ];
                    function computeHuffmanTbl(nrcodes, std_table) {
                        for (var codevalue = 0, pos_in_table = 0, HT = new Array, k = 1; k <= 16; k++) {
                            for (var j = 1; j <= nrcodes[k]; j++) HT[std_table[pos_in_table]] = [], HT[std_table[pos_in_table]][0] = codevalue, 
                            HT[std_table[pos_in_table]][1] = k, pos_in_table++, codevalue++;
                            codevalue *= 2;
                        }
                        return HT;
                    }
                    function writeBits(bs) {
                        for (var value = bs[0], posval = bs[1] - 1; posval >= 0; ) value & 1 << posval && (bytenew |= 1 << bytepos), 
                        posval--, --bytepos < 0 && (0xFF == bytenew ? (writeByte(0xFF), writeByte(0)) : writeByte(bytenew), 
                        bytepos = 7, bytenew = 0);
                    }
                    function writeByte(value) {
                        byteout.push(value);
                    }
                    function writeWord(value) {
                        writeByte(value >> 8 & 0xFF), writeByte(0xFF & value);
                    }
                    function processDU(CDU, fdtbl, DC, HTDC, HTAC) {
                        for (var pos, EOB = HTAC[0x00], M16zeroes = HTAC[0xF0], DU_DCT = function fDCTQuant(data, fdtbl) {
                            var d0, d1, d2, d3, d4, d5, d6, d7, i, fDCTQuant, dataOff = 0;
                            for (i = 0; i < 8; ++i) {
                                d0 = data[dataOff], d1 = data[dataOff + 1], d2 = data[dataOff + 2], d3 = data[dataOff + 3], 
                                d4 = data[dataOff + 4], d5 = data[dataOff + 5], d6 = data[dataOff + 6];
                                var tmp0 = d0 + (d7 = data[dataOff + 7]), tmp7 = d0 - d7, tmp1 = d1 + d6, tmp6 = d1 - d6, tmp2 = d2 + d5, tmp5 = d2 - d5, tmp3 = d3 + d4, tmp4 = d3 - d4, tmp10 = tmp0 + tmp3, tmp13 = tmp0 - tmp3, tmp11 = tmp1 + tmp2, tmp12 = tmp1 - tmp2;
                                data[dataOff] = tmp10 + tmp11, data[dataOff + 4] = tmp10 - tmp11;
                                var z1 = 0.707106781 * (tmp12 + tmp13);
                                data[dataOff + 2] = tmp13 + z1, data[dataOff + 6] = tmp13 - z1;
                                var z5 = 0.382683433 * ((tmp10 = tmp4 + tmp5) - (tmp12 = tmp6 + tmp7)), z2 = 0.541196100 * tmp10 + z5, z4 = 1.306562965 * tmp12 + z5, z3 = 0.707106781 * (tmp11 = tmp5 + tmp6), z11 = tmp7 + z3, z13 = tmp7 - z3;
                                data[dataOff + 5] = z13 + z2, data[dataOff + 3] = z13 - z2, data[dataOff + 1] = z11 + z4, 
                                data[dataOff + 7] = z11 - z4, dataOff += 8;
                            }
                            for (dataOff = 0, i = 0; i < 8; ++i) {
                                d0 = data[dataOff], d1 = data[dataOff + 8], d2 = data[dataOff + 16], d3 = data[dataOff + 24], 
                                d4 = data[dataOff + 32], d5 = data[dataOff + 40], d6 = data[dataOff + 48];
                                var tmp0p2 = d0 + (d7 = data[dataOff + 56]), tmp7p2 = d0 - d7, tmp1p2 = d1 + d6, tmp6p2 = d1 - d6, tmp2p2 = d2 + d5, tmp5p2 = d2 - d5, tmp3p2 = d3 + d4, tmp4p2 = d3 - d4, tmp10p2 = tmp0p2 + tmp3p2, tmp13p2 = tmp0p2 - tmp3p2, tmp11p2 = tmp1p2 + tmp2p2, tmp12p2 = tmp1p2 - tmp2p2;
                                data[dataOff] = tmp10p2 + tmp11p2, data[dataOff + 32] = tmp10p2 - tmp11p2;
                                var z1p2 = 0.707106781 * (tmp12p2 + tmp13p2);
                                data[dataOff + 16] = tmp13p2 + z1p2, data[dataOff + 48] = tmp13p2 - z1p2;
                                var z5p2 = 0.382683433 * ((tmp10p2 = tmp4p2 + tmp5p2) - (tmp12p2 = tmp6p2 + tmp7p2)), z2p2 = 0.541196100 * tmp10p2 + z5p2, z4p2 = 1.306562965 * tmp12p2 + z5p2, z3p2 = 0.707106781 * (tmp11p2 = tmp5p2 + tmp6p2), z11p2 = tmp7p2 + z3p2, z13p2 = tmp7p2 - z3p2;
                                data[dataOff + 40] = z13p2 + z2p2, data[dataOff + 24] = z13p2 - z2p2, data[dataOff + 8] = z11p2 + z4p2, 
                                data[dataOff + 56] = z11p2 - z4p2, dataOff++;
                            }
                            for (i = 0; i < 64; ++i) fDCTQuant = data[i] * fdtbl[i], outputfDCTQuant[i] = fDCTQuant > 0.0 ? fDCTQuant + 0.5 | 0 : fDCTQuant - 0.5 | 0;
                            return outputfDCTQuant;
                        }(CDU, fdtbl), j = 0; j < 64; ++j) DU[ZigZag[j]] = DU_DCT[j];
                        var Diff = DU[0] - DC;
                        DC = DU[0], 0 == Diff ? writeBits(HTDC[0]) : (writeBits(HTDC[category[pos = 32767 + Diff]]), 
                        writeBits(bitcode[pos]));
                        for (var end0pos = 63; end0pos > 0 && 0 == DU[end0pos]; end0pos--) ;
                        if (0 == end0pos) return writeBits(EOB), DC;
                        for (var lng, i = 1; i <= end0pos; ) {
                            for (var startpos = i; 0 == DU[i] && i <= end0pos; ++i) ;
                            var nrzeroes = i - startpos;
                            if (nrzeroes >= 16) {
                                lng = nrzeroes >> 4;
                                for (var nrmarker = 1; nrmarker <= lng; ++nrmarker) writeBits(M16zeroes);
                                nrzeroes &= 0xF;
                            }
                            pos = 32767 + DU[i], writeBits(HTAC[(nrzeroes << 4) + category[pos]]), writeBits(bitcode[pos]), 
                            i++;
                        }
                        return 63 != end0pos && writeBits(EOB), DC;
                    }
                    function setQuality(quality) {
                        quality <= 0 && (quality = 1), quality > 100 && (quality = 100), currentQuality != quality && (function initQuantTables(sf) {
                            for (var YQT = [ 16, 11, 10, 16, 24, 40, 51, 61, 12, 12, 14, 19, 26, 58, 60, 55, 14, 13, 16, 24, 40, 57, 69, 56, 14, 17, 22, 29, 51, 87, 80, 62, 18, 22, 37, 56, 68, 109, 103, 77, 24, 35, 55, 64, 81, 104, 113, 92, 49, 64, 78, 87, 103, 121, 120, 101, 72, 92, 95, 98, 112, 100, 103, 99 ], i = 0; i < 64; i++) {
                                var t = ffloor((YQT[i] * sf + 50) / 100);
                                t < 1 ? t = 1 : t > 255 && (t = 255), YTable[ZigZag[i]] = t;
                            }
                            for (var UVQT = [ 17, 18, 24, 47, 99, 99, 99, 99, 18, 21, 26, 66, 99, 99, 99, 99, 24, 26, 56, 99, 99, 99, 99, 99, 47, 66, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99 ], j = 0; j < 64; j++) {
                                var u = ffloor((UVQT[j] * sf + 50) / 100);
                                u < 1 ? u = 1 : u > 255 && (u = 255), UVTable[ZigZag[j]] = u;
                            }
                            for (var aasf = [ 1.0, 1.387039845, 1.306562965, 1.175875602, 1.0, 0.785694958, 0.541196100, 0.275899379 ], k = 0, row = 0; row < 8; row++) for (var col = 0; col < 8; col++) fdtbl_Y[k] = 1.0 / (YTable[ZigZag[k]] * aasf[row] * aasf[col] * 8.0), 
                            fdtbl_UV[k] = 1.0 / (UVTable[ZigZag[k]] * aasf[row] * aasf[col] * 8.0), k++;
                        }(quality < 50 ? Math.floor(5000 / quality) : Math.floor(200 - 2 * quality)), currentQuality = quality);
                    }
                    this.encode = function(image, quality) {
                        (new Date).getTime(), quality && setQuality(quality), byteout = new Array, bytenew = 0, 
                        bytepos = 7, writeWord(0xFFD8), function writeAPP0() {
                            writeWord(0xFFE0), writeWord(16), writeByte(0x4A), writeByte(0x46), writeByte(0x49), 
                            writeByte(0x46), writeByte(0), writeByte(1), writeByte(1), writeByte(0), writeWord(1), 
                            writeWord(1), writeByte(0), writeByte(0);
                        }(), function writeAPP1(exifBuffer) {
                            if (exifBuffer) {
                                writeWord(0xFFE1), 0x45 === exifBuffer[0] && 0x78 === exifBuffer[1] && 0x69 === exifBuffer[2] && 0x66 === exifBuffer[3] ? writeWord(exifBuffer.length + 2) : (writeWord(exifBuffer.length + 5 + 2), 
                                writeByte(0x45), writeByte(0x78), writeByte(0x69), writeByte(0x66), writeByte(0));
                                for (var i = 0; i < exifBuffer.length; i++) writeByte(exifBuffer[i]);
                            }
                        }(image.exifBuffer), function writeDQT() {
                            writeWord(0xFFDB), writeWord(132), writeByte(0);
                            for (var i = 0; i < 64; i++) writeByte(YTable[i]);
                            writeByte(1);
                            for (var j = 0; j < 64; j++) writeByte(UVTable[j]);
                        }(), function writeSOF0(width, height) {
                            writeWord(0xFFC0), writeWord(17), writeByte(8), writeWord(height), writeWord(width), 
                            writeByte(3), writeByte(1), writeByte(0x11), writeByte(0), writeByte(2), writeByte(0x11), 
                            writeByte(1), writeByte(3), writeByte(0x11), writeByte(1);
                        }(image.width, image.height), function writeDHT() {
                            writeWord(0xFFC4), writeWord(0x01A2), writeByte(0);
                            for (var i = 0; i < 16; i++) writeByte(std_dc_luminance_nrcodes[i + 1]);
                            for (var j = 0; j <= 11; j++) writeByte(std_dc_luminance_values[j]);
                            writeByte(0x10);
                            for (var k = 0; k < 16; k++) writeByte(std_ac_luminance_nrcodes[k + 1]);
                            for (var l = 0; l <= 161; l++) writeByte(std_ac_luminance_values[l]);
                            writeByte(1);
                            for (var m = 0; m < 16; m++) writeByte(std_dc_chrominance_nrcodes[m + 1]);
                            for (var n = 0; n <= 11; n++) writeByte(std_dc_chrominance_values[n]);
                            writeByte(0x11);
                            for (var o = 0; o < 16; o++) writeByte(std_ac_chrominance_nrcodes[o + 1]);
                            for (var p = 0; p <= 161; p++) writeByte(std_ac_chrominance_values[p]);
                        }(), function writeSOS() {
                            writeWord(0xFFDA), writeWord(12), writeByte(3), writeByte(1), writeByte(0), writeByte(2), 
                            writeByte(0x11), writeByte(3), writeByte(0x11), writeByte(0), writeByte(0x3f), writeByte(0);
                        }();
                        var DCY = 0, DCU = 0, DCV = 0;
                        bytenew = 0, bytepos = 7, this.encode.displayName = "_encode_";
                        for (var x, r, g, b, start, p, col, row, pos, imageData = image.data, width = image.width, height = image.height, quadWidth = 4 * width, y = 0; y < height; ) {
                            for (x = 0; x < quadWidth; ) {
                                for (p = start = quadWidth * y + x, col = -1, row = 0, pos = 0; pos < 64; pos++) p = start + (row = pos >> 3) * quadWidth + (col = 4 * (7 & pos)), 
                                y + row >= height && (p -= quadWidth * (y + 1 + row - height)), x + col >= quadWidth && (p -= x + col - quadWidth + 4), 
                                r = imageData[p++], g = imageData[p++], b = imageData[p++], YDU[pos] = (RGB_YUV_TABLE[r] + RGB_YUV_TABLE[g + 256 >> 0] + RGB_YUV_TABLE[b + 512 >> 0] >> 16) - 128, 
                                UDU[pos] = (RGB_YUV_TABLE[r + 768 >> 0] + RGB_YUV_TABLE[g + 1024 >> 0] + RGB_YUV_TABLE[b + 1280 >> 0] >> 16) - 128, 
                                VDU[pos] = (RGB_YUV_TABLE[r + 1280 >> 0] + RGB_YUV_TABLE[g + 1536 >> 0] + RGB_YUV_TABLE[b + 1792 >> 0] >> 16) - 128;
                                DCY = processDU(YDU, fdtbl_Y, DCY, YDC_HT, YAC_HT), DCU = processDU(UDU, fdtbl_UV, DCU, UVDC_HT, UVAC_HT), 
                                DCV = processDU(VDU, fdtbl_UV, DCV, UVDC_HT, UVAC_HT), x += 32;
                            }
                            y += 8;
                        }
                        if (bytepos >= 0) {
                            var fillbits = [];
                            fillbits[1] = bytepos + 1, fillbits[0] = (1 << bytepos + 1) - 1, writeBits(fillbits);
                        }
                        return writeWord(0xFFD9), void 0 === module ? new Uint8Array(byteout) : Buffer.from(byteout);
                    }, function init() {
                        (new Date).getTime(), quality || (quality = 50), function initCharLookupTable() {
                            for (var sfcc = String.fromCharCode, i = 0; i < 256; i++) clt[i] = sfcc(i);
                        }(), function initHuffmanTbl() {
                            YDC_HT = computeHuffmanTbl(std_dc_luminance_nrcodes, std_dc_luminance_values), UVDC_HT = computeHuffmanTbl(std_dc_chrominance_nrcodes, std_dc_chrominance_values), 
                            YAC_HT = computeHuffmanTbl(std_ac_luminance_nrcodes, std_ac_luminance_values), UVAC_HT = computeHuffmanTbl(std_ac_chrominance_nrcodes, std_ac_chrominance_values);
                        }(), function initCategoryNumber() {
                            for (var nrlower = 1, nrupper = 2, cat = 1; cat <= 15; cat++) {
                                for (var nr = nrlower; nr < nrupper; nr++) category[32767 + nr] = cat, bitcode[32767 + nr] = [], 
                                bitcode[32767 + nr][1] = cat, bitcode[32767 + nr][0] = nr;
                                for (var nrneg = -(nrupper - 1); nrneg <= -nrlower; nrneg++) category[32767 + nrneg] = cat, 
                                bitcode[32767 + nrneg] = [], bitcode[32767 + nrneg][1] = cat, bitcode[32767 + nrneg][0] = nrupper - 1 + nrneg;
                                nrlower <<= 1, nrupper <<= 1;
                            }
                        }(), function initRGBYUVTable() {
                            for (var i = 0; i < 256; i++) RGB_YUV_TABLE[i] = 19595 * i, RGB_YUV_TABLE[i + 256 >> 0] = 38470 * i, 
                            RGB_YUV_TABLE[i + 512 >> 0] = 7471 * i + 0x8000, RGB_YUV_TABLE[i + 768 >> 0] = -11059 * i, 
                            RGB_YUV_TABLE[i + 1024 >> 0] = -21709 * i, RGB_YUV_TABLE[i + 1280 >> 0] = 32768 * i + 0x807FFF, 
                            RGB_YUV_TABLE[i + 1536 >> 0] = -27439 * i, RGB_YUV_TABLE[i + 1792 >> 0] = -5329 * i;
                        }(), setQuality(quality), (new Date).getTime();
                    }();
                }
                function encode(imgData, qu) {
                    return void 0 === qu && (qu = 50), {
                        data: new JPEGEncoder(qu).encode(imgData, qu),
                        width: imgData.width,
                        height: imgData.height
                    };
                }
                void 0 !== module ? module.exports = encode : void 0 !== window && (window["jpeg-js"] = window["jpeg-js"] || {}, 
                window["jpeg-js"].encode = encode);
            }).call(this, require("buffer").Buffer);
        }, {
            buffer: 48
        } ],
        83: [ function(require, module, exports) {
            (function(process) {
                var path = require("path"), fs = require("fs"), _0777 = parseInt("0777", 8);
                function mkdirP(p, opts, f, made) {
                    "function" == typeof opts ? (f = opts, opts = {}) : opts && "object" == typeof opts || (opts = {
                        mode: opts
                    });
                    var mode = opts.mode, xfs = opts.fs || fs;
                    void 0 === mode && (mode = _0777 & ~process.umask()), made || (made = null);
                    var cb = f || function() {};
                    p = path.resolve(p), xfs.mkdir(p, mode, (function(er) {
                        if (!er) return cb(null, made = made || p);
                        "ENOENT" === er.code ? mkdirP(path.dirname(p), opts, (function(er, made) {
                            er ? cb(er, made) : mkdirP(p, opts, cb, made);
                        })) : xfs.stat(p, (function(er2, stat) {
                            er2 || !stat.isDirectory() ? cb(er, made) : cb(null, made);
                        }));
                    }));
                }
                module.exports = mkdirP.mkdirp = mkdirP.mkdirP = mkdirP, mkdirP.sync = function sync(p, opts, made) {
                    opts && "object" == typeof opts || (opts = {
                        mode: opts
                    });
                    var mode = opts.mode, xfs = opts.fs || fs;
                    void 0 === mode && (mode = _0777 & ~process.umask()), made || (made = null), p = path.resolve(p);
                    try {
                        xfs.mkdirSync(p, mode), made = made || p;
                    } catch (err0) {
                        if ("ENOENT" === err0.code) made = sync(path.dirname(p), opts, made), sync(p, opts, made); else {
                            var stat;
                            try {
                                stat = xfs.statSync(p);
                            } catch (err1) {
                                throw err0;
                            }
                            if (!stat.isDirectory()) throw err0;
                        }
                    }
                    return made;
                };
            }).call(this, require("_process"));
        }, {
            _process: 133,
            fs: 47,
            path: 107
        } ],
        84: [ function(require, module, exports) {
            var getOwnPropertySymbols = Object.getOwnPropertySymbols, hasOwnProperty = Object.prototype.hasOwnProperty, propIsEnumerable = Object.prototype.propertyIsEnumerable;
            function toObject(val) {
                if (null == val) throw new TypeError("Object.assign cannot be called with null or undefined");
                return Object(val);
            }
            module.exports = function shouldUseNative() {
                try {
                    if (!Object.assign) return !1;
                    var test1 = new String("abc");
                    if (test1[5] = "de", "5" === Object.getOwnPropertyNames(test1)[0]) return !1;
                    for (var test2 = {}, i = 0; i < 10; i++) test2["_" + String.fromCharCode(i)] = i;
                    if ("0123456789" !== Object.getOwnPropertyNames(test2).map((function(n) {
                        return test2[n];
                    })).join("")) return !1;
                    var test3 = {};
                    return "abcdefghijklmnopqrst".split("").forEach((function(letter) {
                        test3[letter] = letter;
                    })), "abcdefghijklmnopqrst" === Object.keys(Object.assign({}, test3)).join("");
                } catch (err) {
                    return !1;
                }
            }() ? Object.assign : function(target, source) {
                for (var from, symbols, to = toObject(target), s = 1; s < arguments.length; s++) {
                    for (var key in from = Object(arguments[s])) hasOwnProperty.call(from, key) && (to[key] = from[key]);
                    if (getOwnPropertySymbols) {
                        symbols = getOwnPropertySymbols(from);
                        for (var i = 0; i < symbols.length; i++) propIsEnumerable.call(from, symbols[i]) && (to[symbols[i]] = from[symbols[i]]);
                    }
                }
                return to;
            };
        }, {} ],
        85: [ function(require, module, exports) {
            arguments[4][64][0].apply(exports, arguments);
        }, {
            dup: 64
        } ],
        86: [ function(require, module, exports) {
            var pako = {};
            (0, require("./lib/utils/common").assign)(pako, require("./lib/deflate"), require("./lib/inflate"), require("./lib/zlib/constants")), 
            module.exports = pako;
        }, {
            "./lib/deflate": 87,
            "./lib/inflate": 88,
            "./lib/utils/common": 89,
            "./lib/zlib/constants": 92
        } ],
        87: [ function(require, module, exports) {
            var zlib_deflate = require("./zlib/deflate"), utils = require("./utils/common"), strings = require("./utils/strings"), msg = require("./zlib/messages"), ZStream = require("./zlib/zstream"), toString = Object.prototype.toString;
            function Deflate(options) {
                if (!(this instanceof Deflate)) return new Deflate(options);
                this.options = utils.assign({
                    level: -1,
                    method: 8,
                    chunkSize: 16384,
                    windowBits: 15,
                    memLevel: 8,
                    strategy: 0,
                    to: ""
                }, options || {});
                var opt = this.options;
                opt.raw && opt.windowBits > 0 ? opt.windowBits = -opt.windowBits : opt.gzip && opt.windowBits > 0 && opt.windowBits < 16 && (opt.windowBits += 16), 
                this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new ZStream, 
                this.strm.avail_out = 0;
                var status = zlib_deflate.deflateInit2(this.strm, opt.level, opt.method, opt.windowBits, opt.memLevel, opt.strategy);
                if (0 !== status) throw new Error(msg[status]);
                if (opt.header && zlib_deflate.deflateSetHeader(this.strm, opt.header), opt.dictionary) {
                    var dict;
                    if (dict = "string" == typeof opt.dictionary ? strings.string2buf(opt.dictionary) : "[object ArrayBuffer]" === toString.call(opt.dictionary) ? new Uint8Array(opt.dictionary) : opt.dictionary, 
                    0 !== (status = zlib_deflate.deflateSetDictionary(this.strm, dict))) throw new Error(msg[status]);
                    this._dict_set = !0;
                }
            }
            function deflate(input, options) {
                var deflator = new Deflate(options);
                if (deflator.push(input, !0), deflator.err) throw deflator.msg || msg[deflator.err];
                return deflator.result;
            }
            Deflate.prototype.push = function(data, mode) {
                var status, _mode, strm = this.strm, chunkSize = this.options.chunkSize;
                if (this.ended) return !1;
                _mode = mode === ~~mode ? mode : !0 === mode ? 4 : 0, "string" == typeof data ? strm.input = strings.string2buf(data) : "[object ArrayBuffer]" === toString.call(data) ? strm.input = new Uint8Array(data) : strm.input = data, 
                strm.next_in = 0, strm.avail_in = strm.input.length;
                do {
                    if (0 === strm.avail_out && (strm.output = new utils.Buf8(chunkSize), strm.next_out = 0, 
                    strm.avail_out = chunkSize), 1 !== (status = zlib_deflate.deflate(strm, _mode)) && 0 !== status) return this.onEnd(status), 
                    this.ended = !0, !1;
                    0 !== strm.avail_out && (0 !== strm.avail_in || 4 !== _mode && 2 !== _mode) || ("string" === this.options.to ? this.onData(strings.buf2binstring(utils.shrinkBuf(strm.output, strm.next_out))) : this.onData(utils.shrinkBuf(strm.output, strm.next_out)));
                } while ((strm.avail_in > 0 || 0 === strm.avail_out) && 1 !== status);
                return 4 === _mode ? (status = zlib_deflate.deflateEnd(this.strm), this.onEnd(status), 
                this.ended = !0, 0 === status) : 2 !== _mode || (this.onEnd(0), strm.avail_out = 0, 
                !0);
            }, Deflate.prototype.onData = function(chunk) {
                this.chunks.push(chunk);
            }, Deflate.prototype.onEnd = function(status) {
                0 === status && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = utils.flattenChunks(this.chunks)), 
                this.chunks = [], this.err = status, this.msg = this.strm.msg;
            }, exports.Deflate = Deflate, exports.deflate = deflate, exports.deflateRaw = function deflateRaw(input, options) {
                return (options = options || {}).raw = !0, deflate(input, options);
            }, exports.gzip = function gzip(input, options) {
                return (options = options || {}).gzip = !0, deflate(input, options);
            };
        }, {
            "./utils/common": 89,
            "./utils/strings": 90,
            "./zlib/deflate": 94,
            "./zlib/messages": 99,
            "./zlib/zstream": 101
        } ],
        88: [ function(require, module, exports) {
            var zlib_inflate = require("./zlib/inflate"), utils = require("./utils/common"), strings = require("./utils/strings"), c = require("./zlib/constants"), msg = require("./zlib/messages"), ZStream = require("./zlib/zstream"), GZheader = require("./zlib/gzheader"), toString = Object.prototype.toString;
            function Inflate(options) {
                if (!(this instanceof Inflate)) return new Inflate(options);
                this.options = utils.assign({
                    chunkSize: 16384,
                    windowBits: 0,
                    to: ""
                }, options || {});
                var opt = this.options;
                opt.raw && opt.windowBits >= 0 && opt.windowBits < 16 && (opt.windowBits = -opt.windowBits, 
                0 === opt.windowBits && (opt.windowBits = -15)), !(opt.windowBits >= 0 && opt.windowBits < 16) || options && options.windowBits || (opt.windowBits += 32), 
                opt.windowBits > 15 && opt.windowBits < 48 && 0 == (15 & opt.windowBits) && (opt.windowBits |= 15), 
                this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new ZStream, 
                this.strm.avail_out = 0;
                var status = zlib_inflate.inflateInit2(this.strm, opt.windowBits);
                if (status !== c.Z_OK) throw new Error(msg[status]);
                this.header = new GZheader, zlib_inflate.inflateGetHeader(this.strm, this.header);
            }
            function inflate(input, options) {
                var inflator = new Inflate(options);
                if (inflator.push(input, !0), inflator.err) throw inflator.msg || msg[inflator.err];
                return inflator.result;
            }
            Inflate.prototype.push = function(data, mode) {
                var status, _mode, next_out_utf8, tail, utf8str, dict, strm = this.strm, chunkSize = this.options.chunkSize, dictionary = this.options.dictionary, allowBufError = !1;
                if (this.ended) return !1;
                _mode = mode === ~~mode ? mode : !0 === mode ? c.Z_FINISH : c.Z_NO_FLUSH, "string" == typeof data ? strm.input = strings.binstring2buf(data) : "[object ArrayBuffer]" === toString.call(data) ? strm.input = new Uint8Array(data) : strm.input = data, 
                strm.next_in = 0, strm.avail_in = strm.input.length;
                do {
                    if (0 === strm.avail_out && (strm.output = new utils.Buf8(chunkSize), strm.next_out = 0, 
                    strm.avail_out = chunkSize), (status = zlib_inflate.inflate(strm, c.Z_NO_FLUSH)) === c.Z_NEED_DICT && dictionary && (dict = "string" == typeof dictionary ? strings.string2buf(dictionary) : "[object ArrayBuffer]" === toString.call(dictionary) ? new Uint8Array(dictionary) : dictionary, 
                    status = zlib_inflate.inflateSetDictionary(this.strm, dict)), status === c.Z_BUF_ERROR && !0 === allowBufError && (status = c.Z_OK, 
                    allowBufError = !1), status !== c.Z_STREAM_END && status !== c.Z_OK) return this.onEnd(status), 
                    this.ended = !0, !1;
                    strm.next_out && (0 !== strm.avail_out && status !== c.Z_STREAM_END && (0 !== strm.avail_in || _mode !== c.Z_FINISH && _mode !== c.Z_SYNC_FLUSH) || ("string" === this.options.to ? (next_out_utf8 = strings.utf8border(strm.output, strm.next_out), 
                    tail = strm.next_out - next_out_utf8, utf8str = strings.buf2string(strm.output, next_out_utf8), 
                    strm.next_out = tail, strm.avail_out = chunkSize - tail, tail && utils.arraySet(strm.output, strm.output, next_out_utf8, tail, 0), 
                    this.onData(utf8str)) : this.onData(utils.shrinkBuf(strm.output, strm.next_out)))), 
                    0 === strm.avail_in && 0 === strm.avail_out && (allowBufError = !0);
                } while ((strm.avail_in > 0 || 0 === strm.avail_out) && status !== c.Z_STREAM_END);
                return status === c.Z_STREAM_END && (_mode = c.Z_FINISH), _mode === c.Z_FINISH ? (status = zlib_inflate.inflateEnd(this.strm), 
                this.onEnd(status), this.ended = !0, status === c.Z_OK) : _mode !== c.Z_SYNC_FLUSH || (this.onEnd(c.Z_OK), 
                strm.avail_out = 0, !0);
            }, Inflate.prototype.onData = function(chunk) {
                this.chunks.push(chunk);
            }, Inflate.prototype.onEnd = function(status) {
                status === c.Z_OK && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = utils.flattenChunks(this.chunks)), 
                this.chunks = [], this.err = status, this.msg = this.strm.msg;
            }, exports.Inflate = Inflate, exports.inflate = inflate, exports.inflateRaw = function inflateRaw(input, options) {
                return (options = options || {}).raw = !0, inflate(input, options);
            }, exports.ungzip = inflate;
        }, {
            "./utils/common": 89,
            "./utils/strings": 90,
            "./zlib/constants": 92,
            "./zlib/gzheader": 95,
            "./zlib/inflate": 97,
            "./zlib/messages": 99,
            "./zlib/zstream": 101
        } ],
        89: [ function(require, module, exports) {
            arguments[4][36][0].apply(exports, arguments);
        }, {
            dup: 36
        } ],
        90: [ function(require, module, exports) {
            var utils = require("./common"), STR_APPLY_OK = !0, STR_APPLY_UIA_OK = !0;
            try {
                String.fromCharCode.apply(null, [ 0 ]);
            } catch (__) {
                STR_APPLY_OK = !1;
            }
            try {
                String.fromCharCode.apply(null, new Uint8Array(1));
            } catch (__) {
                STR_APPLY_UIA_OK = !1;
            }
            for (var _utf8len = new utils.Buf8(256), q = 0; q < 256; q++) _utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;
            function buf2binstring(buf, len) {
                if (len < 65537 && (buf.subarray && STR_APPLY_UIA_OK || !buf.subarray && STR_APPLY_OK)) return String.fromCharCode.apply(null, utils.shrinkBuf(buf, len));
                for (var result = "", i = 0; i < len; i++) result += String.fromCharCode(buf[i]);
                return result;
            }
            _utf8len[254] = _utf8len[254] = 1, exports.string2buf = function(str) {
                var buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;
                for (m_pos = 0; m_pos < str_len; m_pos++) 0xd800 == (0xfc00 & (c = str.charCodeAt(m_pos))) && m_pos + 1 < str_len && 0xdc00 == (0xfc00 & (c2 = str.charCodeAt(m_pos + 1))) && (c = 0x10000 + (c - 0xd800 << 10) + (c2 - 0xdc00), 
                m_pos++), buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;
                for (buf = new utils.Buf8(buf_len), i = 0, m_pos = 0; i < buf_len; m_pos++) 0xd800 == (0xfc00 & (c = str.charCodeAt(m_pos))) && m_pos + 1 < str_len && 0xdc00 == (0xfc00 & (c2 = str.charCodeAt(m_pos + 1))) && (c = 0x10000 + (c - 0xd800 << 10) + (c2 - 0xdc00), 
                m_pos++), c < 0x80 ? buf[i++] = c : c < 0x800 ? (buf[i++] = 0xC0 | c >>> 6, buf[i++] = 0x80 | 0x3f & c) : c < 0x10000 ? (buf[i++] = 0xE0 | c >>> 12, 
                buf[i++] = 0x80 | c >>> 6 & 0x3f, buf[i++] = 0x80 | 0x3f & c) : (buf[i++] = 0xf0 | c >>> 18, 
                buf[i++] = 0x80 | c >>> 12 & 0x3f, buf[i++] = 0x80 | c >>> 6 & 0x3f, buf[i++] = 0x80 | 0x3f & c);
                return buf;
            }, exports.buf2binstring = function(buf) {
                return buf2binstring(buf, buf.length);
            }, exports.binstring2buf = function(str) {
                for (var buf = new utils.Buf8(str.length), i = 0, len = buf.length; i < len; i++) buf[i] = str.charCodeAt(i);
                return buf;
            }, exports.buf2string = function(buf, max) {
                var i, out, c, c_len, len = max || buf.length, utf16buf = new Array(2 * len);
                for (out = 0, i = 0; i < len; ) if ((c = buf[i++]) < 0x80) utf16buf[out++] = c; else if ((c_len = _utf8len[c]) > 4) utf16buf[out++] = 0xfffd, 
                i += c_len - 1; else {
                    for (c &= 2 === c_len ? 0x1f : 3 === c_len ? 0x0f : 0x07; c_len > 1 && i < len; ) c = c << 6 | 0x3f & buf[i++], 
                    c_len--;
                    c_len > 1 ? utf16buf[out++] = 0xfffd : c < 0x10000 ? utf16buf[out++] = c : (c -= 0x10000, 
                    utf16buf[out++] = 0xd800 | c >> 10 & 0x3ff, utf16buf[out++] = 0xdc00 | 0x3ff & c);
                }
                return buf2binstring(utf16buf, out);
            }, exports.utf8border = function(buf, max) {
                var pos;
                for ((max = max || buf.length) > buf.length && (max = buf.length), pos = max - 1; pos >= 0 && 0x80 == (0xC0 & buf[pos]); ) pos--;
                return pos < 0 || 0 === pos ? max : pos + _utf8len[buf[pos]] > max ? pos : max;
            };
        }, {
            "./common": 89
        } ],
        91: [ function(require, module, exports) {
            arguments[4][37][0].apply(exports, arguments);
        }, {
            dup: 37
        } ],
        92: [ function(require, module, exports) {
            arguments[4][38][0].apply(exports, arguments);
        }, {
            dup: 38
        } ],
        93: [ function(require, module, exports) {
            arguments[4][39][0].apply(exports, arguments);
        }, {
            dup: 39
        } ],
        94: [ function(require, module, exports) {
            var configuration_table, utils = require("../utils/common"), trees = require("./trees"), adler32 = require("./adler32"), crc32 = require("./crc32"), msg = require("./messages");
            function err(strm, errorCode) {
                return strm.msg = msg[errorCode], errorCode;
            }
            function rank(f) {
                return (f << 1) - (f > 4 ? 9 : 0);
            }
            function zero(buf) {
                for (var len = buf.length; --len >= 0; ) buf[len] = 0;
            }
            function flush_pending(strm) {
                var s = strm.state, len = s.pending;
                len > strm.avail_out && (len = strm.avail_out), 0 !== len && (utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out), 
                strm.next_out += len, s.pending_out += len, strm.total_out += len, strm.avail_out -= len, 
                s.pending -= len, 0 === s.pending && (s.pending_out = 0));
            }
            function flush_block_only(s, last) {
                trees._tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last), 
                s.block_start = s.strstart, flush_pending(s.strm);
            }
            function put_byte(s, b) {
                s.pending_buf[s.pending++] = b;
            }
            function putShortMSB(s, b) {
                s.pending_buf[s.pending++] = b >>> 8 & 0xff, s.pending_buf[s.pending++] = 0xff & b;
            }
            function longest_match(s, cur_match) {
                var match, len, chain_length = s.max_chain_length, scan = s.strstart, best_len = s.prev_length, nice_match = s.nice_match, limit = s.strstart > s.w_size - 262 ? s.strstart - (s.w_size - 262) : 0, _win = s.window, wmask = s.w_mask, prev = s.prev, strend = s.strstart + 258, scan_end1 = _win[scan + best_len - 1], scan_end = _win[scan + best_len];
                s.prev_length >= s.good_match && (chain_length >>= 2), nice_match > s.lookahead && (nice_match = s.lookahead);
                do {
                    if (_win[(match = cur_match) + best_len] === scan_end && _win[match + best_len - 1] === scan_end1 && _win[match] === _win[scan] && _win[++match] === _win[scan + 1]) {
                        scan += 2, match++;
                        do {} while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
                        if (len = 258 - (strend - scan), scan = strend - 258, len > best_len) {
                            if (s.match_start = cur_match, best_len = len, len >= nice_match) break;
                            scan_end1 = _win[scan + best_len - 1], scan_end = _win[scan + best_len];
                        }
                    }
                } while ((cur_match = prev[cur_match & wmask]) > limit && 0 != --chain_length);
                return best_len <= s.lookahead ? best_len : s.lookahead;
            }
            function fill_window(s) {
                var p, n, m, more, str, strm, buf, start, size, len, _w_size = s.w_size;
                do {
                    if (more = s.window_size - s.lookahead - s.strstart, s.strstart >= _w_size + (_w_size - 262)) {
                        utils.arraySet(s.window, s.window, _w_size, _w_size, 0), s.match_start -= _w_size, 
                        s.strstart -= _w_size, s.block_start -= _w_size, p = n = s.hash_size;
                        do {
                            m = s.head[--p], s.head[p] = m >= _w_size ? m - _w_size : 0;
                        } while (--n);
                        p = n = _w_size;
                        do {
                            m = s.prev[--p], s.prev[p] = m >= _w_size ? m - _w_size : 0;
                        } while (--n);
                        more += _w_size;
                    }
                    if (0 === s.strm.avail_in) break;
                    if (strm = s.strm, buf = s.window, start = s.strstart + s.lookahead, size = more, 
                    len = void 0, (len = strm.avail_in) > size && (len = size), n = 0 === len ? 0 : (strm.avail_in -= len, 
                    utils.arraySet(buf, strm.input, strm.next_in, len, start), 1 === strm.state.wrap ? strm.adler = adler32(strm.adler, buf, len, start) : 2 === strm.state.wrap && (strm.adler = crc32(strm.adler, buf, len, start)), 
                    strm.next_in += len, strm.total_in += len, len), s.lookahead += n, s.lookahead + s.insert >= 3) for (str = s.strstart - s.insert, 
                    s.ins_h = s.window[str], s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + 1]) & s.hash_mask; s.insert && (s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + 3 - 1]) & s.hash_mask, 
                    s.prev[str & s.w_mask] = s.head[s.ins_h], s.head[s.ins_h] = str, str++, s.insert--, 
                    !(s.lookahead + s.insert < 3)); ) ;
                } while (s.lookahead < 262 && 0 !== s.strm.avail_in);
            }
            function deflate_fast(s, flush) {
                for (var hash_head, bflush; ;) {
                    if (s.lookahead < 262) {
                        if (fill_window(s), s.lookahead < 262 && 0 === flush) return 1;
                        if (0 === s.lookahead) break;
                    }
                    if (hash_head = 0, s.lookahead >= 3 && (s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + 3 - 1]) & s.hash_mask, 
                    hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h], s.head[s.ins_h] = s.strstart), 
                    0 !== hash_head && s.strstart - hash_head <= s.w_size - 262 && (s.match_length = longest_match(s, hash_head)), 
                    s.match_length >= 3) if (bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - 3), 
                    s.lookahead -= s.match_length, s.match_length <= s.max_lazy_match && s.lookahead >= 3) {
                        s.match_length--;
                        do {
                            s.strstart++, s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + 3 - 1]) & s.hash_mask, 
                            hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h], s.head[s.ins_h] = s.strstart;
                        } while (0 != --s.match_length);
                        s.strstart++;
                    } else s.strstart += s.match_length, s.match_length = 0, s.ins_h = s.window[s.strstart], 
                    s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + 1]) & s.hash_mask; else bflush = trees._tr_tally(s, 0, s.window[s.strstart]), 
                    s.lookahead--, s.strstart++;
                    if (bflush && (flush_block_only(s, !1), 0 === s.strm.avail_out)) return 1;
                }
                return s.insert = s.strstart < 2 ? s.strstart : 2, 4 === flush ? (flush_block_only(s, !0), 
                0 === s.strm.avail_out ? 3 : 4) : s.last_lit && (flush_block_only(s, !1), 0 === s.strm.avail_out) ? 1 : 2;
            }
            function deflate_slow(s, flush) {
                for (var hash_head, bflush, max_insert; ;) {
                    if (s.lookahead < 262) {
                        if (fill_window(s), s.lookahead < 262 && 0 === flush) return 1;
                        if (0 === s.lookahead) break;
                    }
                    if (hash_head = 0, s.lookahead >= 3 && (s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + 3 - 1]) & s.hash_mask, 
                    hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h], s.head[s.ins_h] = s.strstart), 
                    s.prev_length = s.match_length, s.prev_match = s.match_start, s.match_length = 2, 
                    0 !== hash_head && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - 262 && (s.match_length = longest_match(s, hash_head), 
                    s.match_length <= 5 && (1 === s.strategy || 3 === s.match_length && s.strstart - s.match_start > 4096) && (s.match_length = 2)), 
                    s.prev_length >= 3 && s.match_length <= s.prev_length) {
                        max_insert = s.strstart + s.lookahead - 3, bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - 3), 
                        s.lookahead -= s.prev_length - 1, s.prev_length -= 2;
                        do {
                            ++s.strstart <= max_insert && (s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + 3 - 1]) & s.hash_mask, 
                            hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h], s.head[s.ins_h] = s.strstart);
                        } while (0 != --s.prev_length);
                        if (s.match_available = 0, s.match_length = 2, s.strstart++, bflush && (flush_block_only(s, !1), 
                        0 === s.strm.avail_out)) return 1;
                    } else if (s.match_available) {
                        if ((bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1])) && flush_block_only(s, !1), 
                        s.strstart++, s.lookahead--, 0 === s.strm.avail_out) return 1;
                    } else s.match_available = 1, s.strstart++, s.lookahead--;
                }
                return s.match_available && (bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]), 
                s.match_available = 0), s.insert = s.strstart < 2 ? s.strstart : 2, 4 === flush ? (flush_block_only(s, !0), 
                0 === s.strm.avail_out ? 3 : 4) : s.last_lit && (flush_block_only(s, !1), 0 === s.strm.avail_out) ? 1 : 2;
            }
            function Config(good_length, max_lazy, nice_length, max_chain, func) {
                this.good_length = good_length, this.max_lazy = max_lazy, this.nice_length = nice_length, 
                this.max_chain = max_chain, this.func = func;
            }
            function DeflateState() {
                this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, 
                this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, 
                this.method = 8, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, 
                this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, 
                this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, 
                this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, 
                this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, 
                this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, 
                this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new utils.Buf16(1146), 
                this.dyn_dtree = new utils.Buf16(122), this.bl_tree = new utils.Buf16(78), zero(this.dyn_ltree), 
                zero(this.dyn_dtree), zero(this.bl_tree), this.l_desc = null, this.d_desc = null, 
                this.bl_desc = null, this.bl_count = new utils.Buf16(16), this.heap = new utils.Buf16(573), 
                zero(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new utils.Buf16(573), 
                zero(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, 
                this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, 
                this.bi_valid = 0;
            }
            function deflateResetKeep(strm) {
                var s;
                return strm && strm.state ? (strm.total_in = strm.total_out = 0, strm.data_type = 2, 
                (s = strm.state).pending = 0, s.pending_out = 0, s.wrap < 0 && (s.wrap = -s.wrap), 
                s.status = s.wrap ? 42 : 113, strm.adler = 2 === s.wrap ? 0 : 1, s.last_flush = 0, 
                trees._tr_init(s), 0) : err(strm, -2);
            }
            function deflateReset(strm) {
                var ret = deflateResetKeep(strm);
                return 0 === ret && function lm_init(s) {
                    s.window_size = 2 * s.w_size, zero(s.head), s.max_lazy_match = configuration_table[s.level].max_lazy, 
                    s.good_match = configuration_table[s.level].good_length, s.nice_match = configuration_table[s.level].nice_length, 
                    s.max_chain_length = configuration_table[s.level].max_chain, s.strstart = 0, s.block_start = 0, 
                    s.lookahead = 0, s.insert = 0, s.match_length = s.prev_length = 2, s.match_available = 0, 
                    s.ins_h = 0;
                }(strm.state), ret;
            }
            function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
                if (!strm) return -2;
                var wrap = 1;
                if (-1 === level && (level = 6), windowBits < 0 ? (wrap = 0, windowBits = -windowBits) : windowBits > 15 && (wrap = 2, 
                windowBits -= 16), memLevel < 1 || memLevel > 9 || 8 !== method || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > 4) return err(strm, -2);
                8 === windowBits && (windowBits = 9);
                var s = new DeflateState;
                return strm.state = s, s.strm = strm, s.wrap = wrap, s.gzhead = null, s.w_bits = windowBits, 
                s.w_size = 1 << s.w_bits, s.w_mask = s.w_size - 1, s.hash_bits = memLevel + 7, s.hash_size = 1 << s.hash_bits, 
                s.hash_mask = s.hash_size - 1, s.hash_shift = ~~((s.hash_bits + 3 - 1) / 3), s.window = new utils.Buf8(2 * s.w_size), 
                s.head = new utils.Buf16(s.hash_size), s.prev = new utils.Buf16(s.w_size), s.lit_bufsize = 1 << memLevel + 6, 
                s.pending_buf_size = 4 * s.lit_bufsize, s.pending_buf = new utils.Buf8(s.pending_buf_size), 
                s.d_buf = 1 * s.lit_bufsize, s.l_buf = 3 * s.lit_bufsize, s.level = level, s.strategy = strategy, 
                s.method = method, deflateReset(strm);
            }
            configuration_table = [ new Config(0, 0, 0, 0, (function deflate_stored(s, flush) {
                var max_block_size = 0xffff;
                for (max_block_size > s.pending_buf_size - 5 && (max_block_size = s.pending_buf_size - 5); ;) {
                    if (s.lookahead <= 1) {
                        if (fill_window(s), 0 === s.lookahead && 0 === flush) return 1;
                        if (0 === s.lookahead) break;
                    }
                    s.strstart += s.lookahead, s.lookahead = 0;
                    var max_start = s.block_start + max_block_size;
                    if ((0 === s.strstart || s.strstart >= max_start) && (s.lookahead = s.strstart - max_start, 
                    s.strstart = max_start, flush_block_only(s, !1), 0 === s.strm.avail_out)) return 1;
                    if (s.strstart - s.block_start >= s.w_size - 262 && (flush_block_only(s, !1), 0 === s.strm.avail_out)) return 1;
                }
                return s.insert = 0, 4 === flush ? (flush_block_only(s, !0), 0 === s.strm.avail_out ? 3 : 4) : (s.strstart > s.block_start && (flush_block_only(s, !1), 
                s.strm.avail_out), 1);
            })), new Config(4, 4, 8, 4, deflate_fast), new Config(4, 5, 16, 8, deflate_fast), new Config(4, 6, 32, 32, deflate_fast), new Config(4, 4, 16, 16, deflate_slow), new Config(8, 16, 32, 32, deflate_slow), new Config(8, 16, 128, 128, deflate_slow), new Config(8, 32, 128, 256, deflate_slow), new Config(32, 128, 258, 1024, deflate_slow), new Config(32, 258, 258, 4096, deflate_slow) ], 
            exports.deflateInit = function deflateInit(strm, level) {
                return deflateInit2(strm, level, 8, 15, 8, 0);
            }, exports.deflateInit2 = deflateInit2, exports.deflateReset = deflateReset, exports.deflateResetKeep = deflateResetKeep, 
            exports.deflateSetHeader = function deflateSetHeader(strm, head) {
                return strm && strm.state ? 2 !== strm.state.wrap ? -2 : (strm.state.gzhead = head, 
                0) : -2;
            }, exports.deflate = function deflate(strm, flush) {
                var old_flush, s, beg, val;
                if (!strm || !strm.state || flush > 5 || flush < 0) return strm ? err(strm, -2) : -2;
                if (s = strm.state, !strm.output || !strm.input && 0 !== strm.avail_in || 666 === s.status && 4 !== flush) return err(strm, 0 === strm.avail_out ? -5 : -2);
                if (s.strm = strm, old_flush = s.last_flush, s.last_flush = flush, 42 === s.status) if (2 === s.wrap) strm.adler = 0, 
                put_byte(s, 31), put_byte(s, 139), put_byte(s, 8), s.gzhead ? (put_byte(s, (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (s.gzhead.extra ? 4 : 0) + (s.gzhead.name ? 8 : 0) + (s.gzhead.comment ? 16 : 0)), 
                put_byte(s, 0xff & s.gzhead.time), put_byte(s, s.gzhead.time >> 8 & 0xff), put_byte(s, s.gzhead.time >> 16 & 0xff), 
                put_byte(s, s.gzhead.time >> 24 & 0xff), put_byte(s, 9 === s.level ? 2 : s.strategy >= 2 || s.level < 2 ? 4 : 0), 
                put_byte(s, 0xff & s.gzhead.os), s.gzhead.extra && s.gzhead.extra.length && (put_byte(s, 0xff & s.gzhead.extra.length), 
                put_byte(s, s.gzhead.extra.length >> 8 & 0xff)), s.gzhead.hcrc && (strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0)), 
                s.gzindex = 0, s.status = 69) : (put_byte(s, 0), put_byte(s, 0), put_byte(s, 0), 
                put_byte(s, 0), put_byte(s, 0), put_byte(s, 9 === s.level ? 2 : s.strategy >= 2 || s.level < 2 ? 4 : 0), 
                put_byte(s, 3), s.status = 113); else {
                    var header = 8 + (s.w_bits - 8 << 4) << 8;
                    header |= (s.strategy >= 2 || s.level < 2 ? 0 : s.level < 6 ? 1 : 6 === s.level ? 2 : 3) << 6, 
                    0 !== s.strstart && (header |= 32), header += 31 - header % 31, s.status = 113, 
                    putShortMSB(s, header), 0 !== s.strstart && (putShortMSB(s, strm.adler >>> 16), 
                    putShortMSB(s, 0xffff & strm.adler)), strm.adler = 1;
                }
                if (69 === s.status) if (s.gzhead.extra) {
                    for (beg = s.pending; s.gzindex < (0xffff & s.gzhead.extra.length) && (s.pending !== s.pending_buf_size || (s.gzhead.hcrc && s.pending > beg && (strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg)), 
                    flush_pending(strm), beg = s.pending, s.pending !== s.pending_buf_size)); ) put_byte(s, 0xff & s.gzhead.extra[s.gzindex]), 
                    s.gzindex++;
                    s.gzhead.hcrc && s.pending > beg && (strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg)), 
                    s.gzindex === s.gzhead.extra.length && (s.gzindex = 0, s.status = 73);
                } else s.status = 73;
                if (73 === s.status) if (s.gzhead.name) {
                    beg = s.pending;
                    do {
                        if (s.pending === s.pending_buf_size && (s.gzhead.hcrc && s.pending > beg && (strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg)), 
                        flush_pending(strm), beg = s.pending, s.pending === s.pending_buf_size)) {
                            val = 1;
                            break;
                        }
                        val = s.gzindex < s.gzhead.name.length ? 0xff & s.gzhead.name.charCodeAt(s.gzindex++) : 0, 
                        put_byte(s, val);
                    } while (0 !== val);
                    s.gzhead.hcrc && s.pending > beg && (strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg)), 
                    0 === val && (s.gzindex = 0, s.status = 91);
                } else s.status = 91;
                if (91 === s.status) if (s.gzhead.comment) {
                    beg = s.pending;
                    do {
                        if (s.pending === s.pending_buf_size && (s.gzhead.hcrc && s.pending > beg && (strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg)), 
                        flush_pending(strm), beg = s.pending, s.pending === s.pending_buf_size)) {
                            val = 1;
                            break;
                        }
                        val = s.gzindex < s.gzhead.comment.length ? 0xff & s.gzhead.comment.charCodeAt(s.gzindex++) : 0, 
                        put_byte(s, val);
                    } while (0 !== val);
                    s.gzhead.hcrc && s.pending > beg && (strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg)), 
                    0 === val && (s.status = 103);
                } else s.status = 103;
                if (103 === s.status && (s.gzhead.hcrc ? (s.pending + 2 > s.pending_buf_size && flush_pending(strm), 
                s.pending + 2 <= s.pending_buf_size && (put_byte(s, 0xff & strm.adler), put_byte(s, strm.adler >> 8 & 0xff), 
                strm.adler = 0, s.status = 113)) : s.status = 113), 0 !== s.pending) {
                    if (flush_pending(strm), 0 === strm.avail_out) return s.last_flush = -1, 0;
                } else if (0 === strm.avail_in && rank(flush) <= rank(old_flush) && 4 !== flush) return err(strm, -5);
                if (666 === s.status && 0 !== strm.avail_in) return err(strm, -5);
                if (0 !== strm.avail_in || 0 !== s.lookahead || 0 !== flush && 666 !== s.status) {
                    var bstate = 2 === s.strategy ? function deflate_huff(s, flush) {
                        for (var bflush; ;) {
                            if (0 === s.lookahead && (fill_window(s), 0 === s.lookahead)) {
                                if (0 === flush) return 1;
                                break;
                            }
                            if (s.match_length = 0, bflush = trees._tr_tally(s, 0, s.window[s.strstart]), s.lookahead--, 
                            s.strstart++, bflush && (flush_block_only(s, !1), 0 === s.strm.avail_out)) return 1;
                        }
                        return s.insert = 0, 4 === flush ? (flush_block_only(s, !0), 0 === s.strm.avail_out ? 3 : 4) : s.last_lit && (flush_block_only(s, !1), 
                        0 === s.strm.avail_out) ? 1 : 2;
                    }(s, flush) : 3 === s.strategy ? function deflate_rle(s, flush) {
                        for (var bflush, prev, scan, strend, _win = s.window; ;) {
                            if (s.lookahead <= 258) {
                                if (fill_window(s), s.lookahead <= 258 && 0 === flush) return 1;
                                if (0 === s.lookahead) break;
                            }
                            if (s.match_length = 0, s.lookahead >= 3 && s.strstart > 0 && (prev = _win[scan = s.strstart - 1]) === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
                                strend = s.strstart + 258;
                                do {} while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
                                s.match_length = 258 - (strend - scan), s.match_length > s.lookahead && (s.match_length = s.lookahead);
                            }
                            if (s.match_length >= 3 ? (bflush = trees._tr_tally(s, 1, s.match_length - 3), s.lookahead -= s.match_length, 
                            s.strstart += s.match_length, s.match_length = 0) : (bflush = trees._tr_tally(s, 0, s.window[s.strstart]), 
                            s.lookahead--, s.strstart++), bflush && (flush_block_only(s, !1), 0 === s.strm.avail_out)) return 1;
                        }
                        return s.insert = 0, 4 === flush ? (flush_block_only(s, !0), 0 === s.strm.avail_out ? 3 : 4) : s.last_lit && (flush_block_only(s, !1), 
                        0 === s.strm.avail_out) ? 1 : 2;
                    }(s, flush) : configuration_table[s.level].func(s, flush);
                    if (3 !== bstate && 4 !== bstate || (s.status = 666), 1 === bstate || 3 === bstate) return 0 === strm.avail_out && (s.last_flush = -1), 
                    0;
                    if (2 === bstate && (1 === flush ? trees._tr_align(s) : 5 !== flush && (trees._tr_stored_block(s, 0, 0, !1), 
                    3 === flush && (zero(s.head), 0 === s.lookahead && (s.strstart = 0, s.block_start = 0, 
                    s.insert = 0))), flush_pending(strm), 0 === strm.avail_out)) return s.last_flush = -1, 
                    0;
                }
                return 4 !== flush ? 0 : s.wrap <= 0 ? 1 : (2 === s.wrap ? (put_byte(s, 0xff & strm.adler), 
                put_byte(s, strm.adler >> 8 & 0xff), put_byte(s, strm.adler >> 16 & 0xff), put_byte(s, strm.adler >> 24 & 0xff), 
                put_byte(s, 0xff & strm.total_in), put_byte(s, strm.total_in >> 8 & 0xff), put_byte(s, strm.total_in >> 16 & 0xff), 
                put_byte(s, strm.total_in >> 24 & 0xff)) : (putShortMSB(s, strm.adler >>> 16), putShortMSB(s, 0xffff & strm.adler)), 
                flush_pending(strm), s.wrap > 0 && (s.wrap = -s.wrap), 0 !== s.pending ? 0 : 1);
            }, exports.deflateEnd = function deflateEnd(strm) {
                var status;
                return strm && strm.state ? 42 !== (status = strm.state.status) && 69 !== status && 73 !== status && 91 !== status && 103 !== status && 113 !== status && 666 !== status ? err(strm, -2) : (strm.state = null, 
                113 === status ? err(strm, -3) : 0) : -2;
            }, exports.deflateSetDictionary = function deflateSetDictionary(strm, dictionary) {
                var s, str, n, wrap, avail, next, input, tmpDict, dictLength = dictionary.length;
                if (!strm || !strm.state) return -2;
                if (2 === (wrap = (s = strm.state).wrap) || 1 === wrap && 42 !== s.status || s.lookahead) return -2;
                for (1 === wrap && (strm.adler = adler32(strm.adler, dictionary, dictLength, 0)), 
                s.wrap = 0, dictLength >= s.w_size && (0 === wrap && (zero(s.head), s.strstart = 0, 
                s.block_start = 0, s.insert = 0), tmpDict = new utils.Buf8(s.w_size), utils.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0), 
                dictionary = tmpDict, dictLength = s.w_size), avail = strm.avail_in, next = strm.next_in, 
                input = strm.input, strm.avail_in = dictLength, strm.next_in = 0, strm.input = dictionary, 
                fill_window(s); s.lookahead >= 3; ) {
                    str = s.strstart, n = s.lookahead - 2;
                    do {
                        s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + 3 - 1]) & s.hash_mask, s.prev[str & s.w_mask] = s.head[s.ins_h], 
                        s.head[s.ins_h] = str, str++;
                    } while (--n);
                    s.strstart = str, s.lookahead = 2, fill_window(s);
                }
                return s.strstart += s.lookahead, s.block_start = s.strstart, s.insert = s.lookahead, 
                s.lookahead = 0, s.match_length = s.prev_length = 2, s.match_available = 0, strm.next_in = next, 
                strm.input = input, strm.avail_in = avail, s.wrap = wrap, 0;
            }, exports.deflateInfo = "pako deflate (from Nodeca project)";
        }, {
            "../utils/common": 89,
            "./adler32": 91,
            "./crc32": 93,
            "./messages": 99,
            "./trees": 100
        } ],
        95: [ function(require, module, exports) {
            module.exports = function GZheader() {
                this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, 
                this.name = "", this.comment = "", this.hcrc = 0, this.done = !1;
            };
        }, {} ],
        96: [ function(require, module, exports) {
            arguments[4][41][0].apply(exports, arguments);
        }, {
            dup: 41
        } ],
        97: [ function(require, module, exports) {
            arguments[4][42][0].apply(exports, arguments);
        }, {
            "../utils/common": 89,
            "./adler32": 91,
            "./crc32": 93,
            "./inffast": 96,
            "./inftrees": 98,
            dup: 42
        } ],
        98: [ function(require, module, exports) {
            arguments[4][43][0].apply(exports, arguments);
        }, {
            "../utils/common": 89,
            dup: 43
        } ],
        99: [ function(require, module, exports) {
            arguments[4][44][0].apply(exports, arguments);
        }, {
            dup: 44
        } ],
        100: [ function(require, module, exports) {
            var utils = require("../utils/common");
            function zero(buf) {
                for (var len = buf.length; --len >= 0; ) buf[len] = 0;
            }
            var extra_lbits = [ 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0 ], extra_dbits = [ 0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13 ], extra_blbits = [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7 ], bl_order = [ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ], static_ltree = new Array(576);
            zero(static_ltree);
            var static_dtree = new Array(60);
            zero(static_dtree);
            var _dist_code = new Array(512);
            zero(_dist_code);
            var _length_code = new Array(256);
            zero(_length_code);
            var base_length = new Array(29);
            zero(base_length);
            var static_l_desc, static_d_desc, static_bl_desc, base_dist = new Array(30);
            function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
                this.static_tree = static_tree, this.extra_bits = extra_bits, this.extra_base = extra_base, 
                this.elems = elems, this.max_length = max_length, this.has_stree = static_tree && static_tree.length;
            }
            function TreeDesc(dyn_tree, stat_desc) {
                this.dyn_tree = dyn_tree, this.max_code = 0, this.stat_desc = stat_desc;
            }
            function d_code(dist) {
                return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
            }
            function put_short(s, w) {
                s.pending_buf[s.pending++] = 0xff & w, s.pending_buf[s.pending++] = w >>> 8 & 0xff;
            }
            function send_bits(s, value, length) {
                s.bi_valid > 16 - length ? (s.bi_buf |= value << s.bi_valid & 0xffff, put_short(s, s.bi_buf), 
                s.bi_buf = value >> 16 - s.bi_valid, s.bi_valid += length - 16) : (s.bi_buf |= value << s.bi_valid & 0xffff, 
                s.bi_valid += length);
            }
            function send_code(s, c, tree) {
                send_bits(s, tree[2 * c], tree[2 * c + 1]);
            }
            function bi_reverse(code, len) {
                var res = 0;
                do {
                    res |= 1 & code, code >>>= 1, res <<= 1;
                } while (--len > 0);
                return res >>> 1;
            }
            function gen_codes(tree, max_code, bl_count) {
                var bits, n, next_code = new Array(16), code = 0;
                for (bits = 1; bits <= 15; bits++) next_code[bits] = code = code + bl_count[bits - 1] << 1;
                for (n = 0; n <= max_code; n++) {
                    var len = tree[2 * n + 1];
                    0 !== len && (tree[2 * n] = bi_reverse(next_code[len]++, len));
                }
            }
            function init_block(s) {
                var n;
                for (n = 0; n < 286; n++) s.dyn_ltree[2 * n] = 0;
                for (n = 0; n < 30; n++) s.dyn_dtree[2 * n] = 0;
                for (n = 0; n < 19; n++) s.bl_tree[2 * n] = 0;
                s.dyn_ltree[512] = 1, s.opt_len = s.static_len = 0, s.last_lit = s.matches = 0;
            }
            function bi_windup(s) {
                s.bi_valid > 8 ? put_short(s, s.bi_buf) : s.bi_valid > 0 && (s.pending_buf[s.pending++] = s.bi_buf), 
                s.bi_buf = 0, s.bi_valid = 0;
            }
            function smaller(tree, n, m, depth) {
                var _n2 = 2 * n, _m2 = 2 * m;
                return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n] <= depth[m];
            }
            function pqdownheap(s, tree, k) {
                for (var v = s.heap[k], j = k << 1; j <= s.heap_len && (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth) && j++, 
                !smaller(tree, v, s.heap[j], s.depth)); ) s.heap[k] = s.heap[j], k = j, j <<= 1;
                s.heap[k] = v;
            }
            function compress_block(s, ltree, dtree) {
                var dist, lc, code, extra, lx = 0;
                if (0 !== s.last_lit) do {
                    dist = s.pending_buf[s.d_buf + 2 * lx] << 8 | s.pending_buf[s.d_buf + 2 * lx + 1], 
                    lc = s.pending_buf[s.l_buf + lx], lx++, 0 === dist ? send_code(s, lc, ltree) : (send_code(s, (code = _length_code[lc]) + 256 + 1, ltree), 
                    0 !== (extra = extra_lbits[code]) && send_bits(s, lc -= base_length[code], extra), 
                    send_code(s, code = d_code(--dist), dtree), 0 !== (extra = extra_dbits[code]) && send_bits(s, dist -= base_dist[code], extra));
                } while (lx < s.last_lit);
                send_code(s, 256, ltree);
            }
            function build_tree(s, desc) {
                var n, m, node, tree = desc.dyn_tree, stree = desc.stat_desc.static_tree, has_stree = desc.stat_desc.has_stree, elems = desc.stat_desc.elems, max_code = -1;
                for (s.heap_len = 0, s.heap_max = 573, n = 0; n < elems; n++) 0 !== tree[2 * n] ? (s.heap[++s.heap_len] = max_code = n, 
                s.depth[n] = 0) : tree[2 * n + 1] = 0;
                for (;s.heap_len < 2; ) tree[2 * (node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0)] = 1, 
                s.depth[node] = 0, s.opt_len--, has_stree && (s.static_len -= stree[2 * node + 1]);
                for (desc.max_code = max_code, n = s.heap_len >> 1; n >= 1; n--) pqdownheap(s, tree, n);
                node = elems;
                do {
                    n = s.heap[1], s.heap[1] = s.heap[s.heap_len--], pqdownheap(s, tree, 1), m = s.heap[1], 
                    s.heap[--s.heap_max] = n, s.heap[--s.heap_max] = m, tree[2 * node] = tree[2 * n] + tree[2 * m], 
                    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1, tree[2 * n + 1] = tree[2 * m + 1] = node, 
                    s.heap[1] = node++, pqdownheap(s, tree, 1);
                } while (s.heap_len >= 2);
                s.heap[--s.heap_max] = s.heap[1], function gen_bitlen(s, desc) {
                    var h, n, m, bits, xbits, f, tree = desc.dyn_tree, max_code = desc.max_code, stree = desc.stat_desc.static_tree, has_stree = desc.stat_desc.has_stree, extra = desc.stat_desc.extra_bits, base = desc.stat_desc.extra_base, max_length = desc.stat_desc.max_length, overflow = 0;
                    for (bits = 0; bits <= 15; bits++) s.bl_count[bits] = 0;
                    for (tree[2 * s.heap[s.heap_max] + 1] = 0, h = s.heap_max + 1; h < 573; h++) (bits = tree[2 * tree[2 * (n = s.heap[h]) + 1] + 1] + 1) > max_length && (bits = max_length, 
                    overflow++), tree[2 * n + 1] = bits, n > max_code || (s.bl_count[bits]++, xbits = 0, 
                    n >= base && (xbits = extra[n - base]), f = tree[2 * n], s.opt_len += f * (bits + xbits), 
                    has_stree && (s.static_len += f * (stree[2 * n + 1] + xbits)));
                    if (0 !== overflow) {
                        do {
                            for (bits = max_length - 1; 0 === s.bl_count[bits]; ) bits--;
                            s.bl_count[bits]--, s.bl_count[bits + 1] += 2, s.bl_count[max_length]--, overflow -= 2;
                        } while (overflow > 0);
                        for (bits = max_length; 0 !== bits; bits--) for (n = s.bl_count[bits]; 0 !== n; ) (m = s.heap[--h]) > max_code || (tree[2 * m + 1] !== bits && (s.opt_len += (bits - tree[2 * m + 1]) * tree[2 * m], 
                        tree[2 * m + 1] = bits), n--);
                    }
                }(s, desc), gen_codes(tree, max_code, s.bl_count);
            }
            function scan_tree(s, tree, max_code) {
                var n, curlen, prevlen = -1, nextlen = tree[1], count = 0, max_count = 7, min_count = 4;
                for (0 === nextlen && (max_count = 138, min_count = 3), tree[2 * (max_code + 1) + 1] = 0xffff, 
                n = 0; n <= max_code; n++) curlen = nextlen, nextlen = tree[2 * (n + 1) + 1], ++count < max_count && curlen === nextlen || (count < min_count ? s.bl_tree[2 * curlen] += count : 0 !== curlen ? (curlen !== prevlen && s.bl_tree[2 * curlen]++, 
                s.bl_tree[32]++) : count <= 10 ? s.bl_tree[34]++ : s.bl_tree[36]++, count = 0, prevlen = curlen, 
                0 === nextlen ? (max_count = 138, min_count = 3) : curlen === nextlen ? (max_count = 6, 
                min_count = 3) : (max_count = 7, min_count = 4));
            }
            function send_tree(s, tree, max_code) {
                var n, curlen, prevlen = -1, nextlen = tree[1], count = 0, max_count = 7, min_count = 4;
                for (0 === nextlen && (max_count = 138, min_count = 3), n = 0; n <= max_code; n++) if (curlen = nextlen, 
                nextlen = tree[2 * (n + 1) + 1], !(++count < max_count && curlen === nextlen)) {
                    if (count < min_count) do {
                        send_code(s, curlen, s.bl_tree);
                    } while (0 != --count); else 0 !== curlen ? (curlen !== prevlen && (send_code(s, curlen, s.bl_tree), 
                    count--), send_code(s, 16, s.bl_tree), send_bits(s, count - 3, 2)) : count <= 10 ? (send_code(s, 17, s.bl_tree), 
                    send_bits(s, count - 3, 3)) : (send_code(s, 18, s.bl_tree), send_bits(s, count - 11, 7));
                    count = 0, prevlen = curlen, 0 === nextlen ? (max_count = 138, min_count = 3) : curlen === nextlen ? (max_count = 6, 
                    min_count = 3) : (max_count = 7, min_count = 4);
                }
            }
            zero(base_dist);
            var static_init_done = !1;
            function _tr_stored_block(s, buf, stored_len, last) {
                send_bits(s, 0 + (last ? 1 : 0), 3), function copy_block(s, buf, len, header) {
                    bi_windup(s), header && (put_short(s, len), put_short(s, ~len)), utils.arraySet(s.pending_buf, s.window, buf, len, s.pending), 
                    s.pending += len;
                }(s, buf, stored_len, !0);
            }
            exports._tr_init = function _tr_init(s) {
                static_init_done || (function tr_static_init() {
                    var n, bits, length, code, dist, bl_count = new Array(16);
                    for (length = 0, code = 0; code < 28; code++) for (base_length[code] = length, n = 0; n < 1 << extra_lbits[code]; n++) _length_code[length++] = code;
                    for (_length_code[length - 1] = code, dist = 0, code = 0; code < 16; code++) for (base_dist[code] = dist, 
                    n = 0; n < 1 << extra_dbits[code]; n++) _dist_code[dist++] = code;
                    for (dist >>= 7; code < 30; code++) for (base_dist[code] = dist << 7, n = 0; n < 1 << extra_dbits[code] - 7; n++) _dist_code[256 + dist++] = code;
                    for (bits = 0; bits <= 15; bits++) bl_count[bits] = 0;
                    for (n = 0; n <= 143; ) static_ltree[2 * n + 1] = 8, n++, bl_count[8]++;
                    for (;n <= 255; ) static_ltree[2 * n + 1] = 9, n++, bl_count[9]++;
                    for (;n <= 279; ) static_ltree[2 * n + 1] = 7, n++, bl_count[7]++;
                    for (;n <= 287; ) static_ltree[2 * n + 1] = 8, n++, bl_count[8]++;
                    for (gen_codes(static_ltree, 287, bl_count), n = 0; n < 30; n++) static_dtree[2 * n + 1] = 5, 
                    static_dtree[2 * n] = bi_reverse(n, 5);
                    static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, 257, 286, 15), static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, 30, 15), 
                    static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, 19, 7);
                }(), static_init_done = !0), s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc), 
                s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc), s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc), 
                s.bi_buf = 0, s.bi_valid = 0, init_block(s);
            }, exports._tr_stored_block = _tr_stored_block, exports._tr_flush_block = function _tr_flush_block(s, buf, stored_len, last) {
                var opt_lenb, static_lenb, max_blindex = 0;
                s.level > 0 ? (2 === s.strm.data_type && (s.strm.data_type = function detect_data_type(s) {
                    var n, black_mask = 0xf3ffc07f;
                    for (n = 0; n <= 31; n++, black_mask >>>= 1) if (1 & black_mask && 0 !== s.dyn_ltree[2 * n]) return 0;
                    if (0 !== s.dyn_ltree[18] || 0 !== s.dyn_ltree[20] || 0 !== s.dyn_ltree[26]) return 1;
                    for (n = 32; n < 256; n++) if (0 !== s.dyn_ltree[2 * n]) return 1;
                    return 0;
                }(s)), build_tree(s, s.l_desc), build_tree(s, s.d_desc), max_blindex = function build_bl_tree(s) {
                    var max_blindex;
                    for (scan_tree(s, s.dyn_ltree, s.l_desc.max_code), scan_tree(s, s.dyn_dtree, s.d_desc.max_code), 
                    build_tree(s, s.bl_desc), max_blindex = 18; max_blindex >= 3 && 0 === s.bl_tree[2 * bl_order[max_blindex] + 1]; max_blindex--) ;
                    return s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4, max_blindex;
                }(s), opt_lenb = s.opt_len + 3 + 7 >>> 3, (static_lenb = s.static_len + 3 + 7 >>> 3) <= opt_lenb && (opt_lenb = static_lenb)) : opt_lenb = static_lenb = stored_len + 5, 
                stored_len + 4 <= opt_lenb && -1 !== buf ? _tr_stored_block(s, buf, stored_len, last) : 4 === s.strategy || static_lenb === opt_lenb ? (send_bits(s, 2 + (last ? 1 : 0), 3), 
                compress_block(s, static_ltree, static_dtree)) : (send_bits(s, 4 + (last ? 1 : 0), 3), 
                function send_all_trees(s, lcodes, dcodes, blcodes) {
                    var rank;
                    for (send_bits(s, lcodes - 257, 5), send_bits(s, dcodes - 1, 5), send_bits(s, blcodes - 4, 4), 
                    rank = 0; rank < blcodes; rank++) send_bits(s, s.bl_tree[2 * bl_order[rank] + 1], 3);
                    send_tree(s, s.dyn_ltree, lcodes - 1), send_tree(s, s.dyn_dtree, dcodes - 1);
                }(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1), compress_block(s, s.dyn_ltree, s.dyn_dtree)), 
                init_block(s), last && bi_windup(s);
            }, exports._tr_tally = function _tr_tally(s, dist, lc) {
                return s.pending_buf[s.d_buf + 2 * s.last_lit] = dist >>> 8 & 0xff, s.pending_buf[s.d_buf + 2 * s.last_lit + 1] = 0xff & dist, 
                s.pending_buf[s.l_buf + s.last_lit] = 0xff & lc, s.last_lit++, 0 === dist ? s.dyn_ltree[2 * lc]++ : (s.matches++, 
                dist--, s.dyn_ltree[2 * (_length_code[lc] + 256 + 1)]++, s.dyn_dtree[2 * d_code(dist)]++), 
                s.last_lit === s.lit_bufsize - 1;
            }, exports._tr_align = function _tr_align(s) {
                send_bits(s, 2, 3), send_code(s, 256, static_ltree), function bi_flush(s) {
                    16 === s.bi_valid ? (put_short(s, s.bi_buf), s.bi_buf = 0, s.bi_valid = 0) : s.bi_valid >= 8 && (s.pending_buf[s.pending++] = 0xff & s.bi_buf, 
                    s.bi_buf >>= 8, s.bi_valid -= 8);
                }(s);
            };
        }, {
            "../utils/common": 89
        } ],
        101: [ function(require, module, exports) {
            arguments[4][46][0].apply(exports, arguments);
        }, {
            dup: 46
        } ],
        102: [ function(require, module, exports) {
            function splitLine(line, idx) {
                if (!(line = line.replace(/\t+/g, " ").trim())) return null;
                var space = line.indexOf(" ");
                if (-1 === space) throw new Error("no named row at line " + idx);
                var key = line.substring(0, space);
                line = (line = (line = (line = line.substring(space + 1)).replace(/letter=[\'\"]\S+[\'\"]/gi, "")).split("=")).map((function(str) {
                    return str.trim().match(/(".*?"|[^"\s]+)+(?=\s*|\s*$)/g);
                }));
                for (var data = [], i = 0; i < line.length; i++) {
                    var dt = line[i];
                    0 === i ? data.push({
                        key: dt[0],
                        data: ""
                    }) : i === line.length - 1 ? data[data.length - 1].data = parseData(dt[0]) : (data[data.length - 1].data = parseData(dt[0]), 
                    data.push({
                        key: dt[1],
                        data: ""
                    }));
                }
                var out = {
                    key,
                    data: {}
                };
                return data.forEach((function(v) {
                    out.data[v.key] = v.data;
                })), out;
            }
            function parseData(data) {
                return data && 0 !== data.length ? 0 === data.indexOf('"') || 0 === data.indexOf("'") ? data.substring(1, data.length - 1) : -1 !== data.indexOf(",") ? function parseIntList(data) {
                    return data.split(",").map((function(val) {
                        return parseInt(val, 10);
                    }));
                }(data) : parseInt(data, 10) : "";
            }
            module.exports = function parseBMFontAscii(data) {
                if (!data) throw new Error("no data provided");
                var output = {
                    pages: [],
                    chars: [],
                    kernings: []
                }, lines = (data = data.toString().trim()).split(/\r\n?|\n/g);
                if (0 === lines.length) throw new Error("no data in BMFont file");
                for (var i = 0; i < lines.length; i++) {
                    var lineData = splitLine(lines[i], i);
                    if (lineData) if ("page" === lineData.key) {
                        if ("number" != typeof lineData.data.id) throw new Error("malformed file at line " + i + " -- needs page id=N");
                        if ("string" != typeof lineData.data.file) throw new Error("malformed file at line " + i + ' -- needs page file="path"');
                        output.pages[lineData.data.id] = lineData.data.file;
                    } else "chars" === lineData.key || "kernings" === lineData.key || ("char" === lineData.key ? output.chars.push(lineData.data) : "kerning" === lineData.key ? output.kernings.push(lineData.data) : output[lineData.key] = lineData.data);
                }
                return output;
            };
        }, {} ],
        103: [ function(require, module, exports) {
            var HEADER = [ 66, 77, 70 ];
            function readBlock(target, buf, i) {
                if (i > buf.length - 1) return 0;
                var blockID = buf.readUInt8(i++), blockSize = buf.readInt32LE(i);
                switch (i += 4, blockID) {
                  case 1:
                    target.info = function readInfo(buf, i) {
                        var info = {};
                        info.size = buf.readInt16LE(i);
                        var bitField = buf.readUInt8(i + 2);
                        return info.smooth = bitField >> 7 & 1, info.unicode = bitField >> 6 & 1, info.italic = bitField >> 5 & 1, 
                        info.bold = bitField >> 4 & 1, bitField >> 3 & 1 && (info.fixedHeight = 1), info.charset = buf.readUInt8(i + 3) || "", 
                        info.stretchH = buf.readUInt16LE(i + 4), info.aa = buf.readUInt8(i + 6), info.padding = [ buf.readInt8(i + 7), buf.readInt8(i + 8), buf.readInt8(i + 9), buf.readInt8(i + 10) ], 
                        info.spacing = [ buf.readInt8(i + 11), buf.readInt8(i + 12) ], info.outline = buf.readUInt8(i + 13), 
                        info.face = function readStringNT(buf, offset) {
                            return readNameNT(buf, offset).toString("utf8");
                        }(buf, i + 14), info;
                    }(buf, i);
                    break;

                  case 2:
                    target.common = function readCommon(buf, i) {
                        var common = {};
                        return common.lineHeight = buf.readUInt16LE(i), common.base = buf.readUInt16LE(i + 2), 
                        common.scaleW = buf.readUInt16LE(i + 4), common.scaleH = buf.readUInt16LE(i + 6), 
                        common.pages = buf.readUInt16LE(i + 8), buf.readUInt8(i + 10), common.packed = 0, 
                        common.alphaChnl = buf.readUInt8(i + 11), common.redChnl = buf.readUInt8(i + 12), 
                        common.greenChnl = buf.readUInt8(i + 13), common.blueChnl = buf.readUInt8(i + 14), 
                        common;
                    }(buf, i);
                    break;

                  case 3:
                    target.pages = function readPages(buf, i, size) {
                        for (var pages = [], text = readNameNT(buf, i), len = text.length + 1, count = size / len, c = 0; c < count; c++) pages[c] = buf.slice(i, i + text.length).toString("utf8"), 
                        i += len;
                        return pages;
                    }(buf, i, blockSize);
                    break;

                  case 4:
                    target.chars = function readChars(buf, i, blockSize) {
                        for (var chars = [], count = blockSize / 20, c = 0; c < count; c++) {
                            var char = {}, off = 20 * c;
                            char.id = buf.readUInt32LE(i + 0 + off), char.x = buf.readUInt16LE(i + 4 + off), 
                            char.y = buf.readUInt16LE(i + 6 + off), char.width = buf.readUInt16LE(i + 8 + off), 
                            char.height = buf.readUInt16LE(i + 10 + off), char.xoffset = buf.readInt16LE(i + 12 + off), 
                            char.yoffset = buf.readInt16LE(i + 14 + off), char.xadvance = buf.readInt16LE(i + 16 + off), 
                            char.page = buf.readUInt8(i + 18 + off), char.chnl = buf.readUInt8(i + 19 + off), 
                            chars[c] = char;
                        }
                        return chars;
                    }(buf, i, blockSize);
                    break;

                  case 5:
                    target.kernings = function readKernings(buf, i, blockSize) {
                        for (var kernings = [], count = blockSize / 10, c = 0; c < count; c++) {
                            var kern = {}, off = 10 * c;
                            kern.first = buf.readUInt32LE(i + 0 + off), kern.second = buf.readUInt32LE(i + 4 + off), 
                            kern.amount = buf.readInt16LE(i + 8 + off), kernings[c] = kern;
                        }
                        return kernings;
                    }(buf, i, blockSize);
                }
                return 5 + blockSize;
            }
            function readNameNT(buf, offset) {
                for (var pos = offset; pos < buf.length && 0x00 !== buf[pos]; pos++) ;
                return buf.slice(offset, pos);
            }
            module.exports = function readBMFontBinary(buf) {
                if (buf.length < 6) throw new Error("invalid buffer length for BMFont");
                var header = HEADER.every((function(byte, i) {
                    return buf.readUInt8(i) === byte;
                }));
                if (!header) throw new Error("BMFont missing BMF byte header");
                var i = 3;
                if (buf.readUInt8(i++) > 3) throw new Error("Only supports BMFont Binary v3 (BMFont App v1.10)");
                for (var target = {
                    kernings: [],
                    chars: []
                }, b = 0; b < 5; b++) i += readBlock(target, buf, i);
                return target;
            };
        }, {} ],
        104: [ function(require, module, exports) {
            var parseAttributes = require("./parse-attribs"), parseFromString = require("xml-parse-from-string"), NAME_MAP = {
                scaleh: "scaleH",
                scalew: "scaleW",
                stretchh: "stretchH",
                lineheight: "lineHeight",
                alphachnl: "alphaChnl",
                redchnl: "redChnl",
                greenchnl: "greenChnl",
                bluechnl: "blueChnl"
            };
            function getAttribs(element) {
                return function getAttribList(element) {
                    for (var attribs = [], i = 0; i < element.attributes.length; i++) attribs.push(element.attributes[i]);
                    return attribs;
                }(element).reduce((function(dict, attrib) {
                    return dict[function mapName(nodeName) {
                        return NAME_MAP[nodeName.toLowerCase()] || nodeName;
                    }(attrib.nodeName)] = attrib.nodeValue, dict;
                }), {});
            }
            module.exports = function parse(data) {
                data = data.toString();
                var xmlRoot = parseFromString(data), output = {
                    pages: [],
                    chars: [],
                    kernings: []
                };
                [ "info", "common" ].forEach((function(key) {
                    var element = xmlRoot.getElementsByTagName(key)[0];
                    element && (output[key] = parseAttributes(getAttribs(element)));
                }));
                var pageRoot = xmlRoot.getElementsByTagName("pages")[0];
                if (!pageRoot) throw new Error("malformed file -- no <pages> element");
                for (var pages = pageRoot.getElementsByTagName("page"), i = 0; i < pages.length; i++) {
                    var p = pages[i], id = parseInt(p.getAttribute("id"), 10), file = p.getAttribute("file");
                    if (isNaN(id)) throw new Error('malformed file -- page "id" attribute is NaN');
                    if (!file) throw new Error('malformed file -- needs page "file" attribute');
                    output.pages[parseInt(id, 10)] = file;
                }
                return [ "chars", "kernings" ].forEach((function(key) {
                    var element = xmlRoot.getElementsByTagName(key)[0];
                    if (element) for (var childTag = key.substring(0, key.length - 1), children = element.getElementsByTagName(childTag), i = 0; i < children.length; i++) {
                        var child = children[i];
                        output[key].push(parseAttributes(getAttribs(child)));
                    }
                })), output;
            };
        }, {
            "./parse-attribs": 105,
            "xml-parse-from-string": 188
        } ],
        105: [ function(require, module, exports) {
            module.exports = function parseAttributes(obj) {
                for (var k in "chasrset" in obj && (obj.charset = obj.chasrset, delete obj.chasrset), 
                obj) "face" !== k && "charset" !== k && (obj[k] = "padding" === k || "spacing" === k ? obj[k].split(",").map((function(val) {
                    return parseInt(val, 10);
                })) : parseInt(obj[k], 10));
                return obj;
            };
        }, {} ],
        106: [ function(require, module, exports) {
            var trim = require("trim"), forEach = require("for-each");
            module.exports = function(headers) {
                if (!headers) return {};
                var result = {};
                return forEach(trim(headers).split("\n"), (function(row) {
                    var arg, index = row.indexOf(":"), key = trim(row.slice(0, index)).toLowerCase(), value = trim(row.slice(index + 1));
                    void 0 === result[key] ? result[key] = value : (arg = result[key], "[object Array]" === Object.prototype.toString.call(arg) ? result[key].push(value) : result[key] = [ result[key], value ]);
                })), result;
            };
        }, {
            "for-each": 63,
            trim: 179
        } ],
        107: [ function(require, module, exports) {
            (function(process) {
                function normalizeArray(parts, allowAboveRoot) {
                    for (var up = 0, i = parts.length - 1; i >= 0; i--) {
                        var last = parts[i];
                        "." === last ? parts.splice(i, 1) : ".." === last ? (parts.splice(i, 1), up++) : up && (parts.splice(i, 1), 
                        up--);
                    }
                    if (allowAboveRoot) for (;up--; up) parts.unshift("..");
                    return parts;
                }
                function filter(xs, f) {
                    if (xs.filter) return xs.filter(f);
                    for (var res = [], i = 0; i < xs.length; i++) f(xs[i], i, xs) && res.push(xs[i]);
                    return res;
                }
                exports.resolve = function() {
                    for (var resolvedPath = "", resolvedAbsolute = !1, i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
                        var path = i >= 0 ? arguments[i] : process.cwd();
                        if ("string" != typeof path) throw new TypeError("Arguments to path.resolve must be strings");
                        path && (resolvedPath = path + "/" + resolvedPath, resolvedAbsolute = "/" === path.charAt(0));
                    }
                    return (resolvedAbsolute ? "/" : "") + (resolvedPath = normalizeArray(filter(resolvedPath.split("/"), (function(p) {
                        return !!p;
                    })), !resolvedAbsolute).join("/")) || ".";
                }, exports.normalize = function(path) {
                    var isAbsolute = exports.isAbsolute(path), trailingSlash = "/" === substr(path, -1);
                    return (path = normalizeArray(filter(path.split("/"), (function(p) {
                        return !!p;
                    })), !isAbsolute).join("/")) || isAbsolute || (path = "."), path && trailingSlash && (path += "/"), 
                    (isAbsolute ? "/" : "") + path;
                }, exports.isAbsolute = function(path) {
                    return "/" === path.charAt(0);
                }, exports.join = function() {
                    var paths = Array.prototype.slice.call(arguments, 0);
                    return exports.normalize(filter(paths, (function(p, index) {
                        if ("string" != typeof p) throw new TypeError("Arguments to path.join must be strings");
                        return p;
                    })).join("/"));
                }, exports.relative = function(from, to) {
                    function trim(arr) {
                        for (var start = 0; start < arr.length && "" === arr[start]; start++) ;
                        for (var end = arr.length - 1; end >= 0 && "" === arr[end]; end--) ;
                        return start > end ? [] : arr.slice(start, end - start + 1);
                    }
                    from = exports.resolve(from).substr(1), to = exports.resolve(to).substr(1);
                    for (var fromParts = trim(from.split("/")), toParts = trim(to.split("/")), length = Math.min(fromParts.length, toParts.length), samePartsLength = length, i = 0; i < length; i++) if (fromParts[i] !== toParts[i]) {
                        samePartsLength = i;
                        break;
                    }
                    var outputParts = [];
                    for (i = samePartsLength; i < fromParts.length; i++) outputParts.push("..");
                    return (outputParts = outputParts.concat(toParts.slice(samePartsLength))).join("/");
                }, exports.sep = "/", exports.delimiter = ":", exports.dirname = function(path) {
                    if ("string" != typeof path && (path += ""), 0 === path.length) return ".";
                    for (var code = path.charCodeAt(0), hasRoot = 47 === code, end = -1, matchedSlash = !0, i = path.length - 1; i >= 1; --i) if (47 === (code = path.charCodeAt(i))) {
                        if (!matchedSlash) {
                            end = i;
                            break;
                        }
                    } else matchedSlash = !1;
                    return -1 === end ? hasRoot ? "/" : "." : hasRoot && 1 === end ? "/" : path.slice(0, end);
                }, exports.basename = function(path, ext) {
                    var f = function basename(path) {
                        "string" != typeof path && (path += "");
                        var i, start = 0, end = -1, matchedSlash = !0;
                        for (i = path.length - 1; i >= 0; --i) if (47 === path.charCodeAt(i)) {
                            if (!matchedSlash) {
                                start = i + 1;
                                break;
                            }
                        } else -1 === end && (matchedSlash = !1, end = i + 1);
                        return -1 === end ? "" : path.slice(start, end);
                    }(path);
                    return ext && f.substr(-1 * ext.length) === ext && (f = f.substr(0, f.length - ext.length)), 
                    f;
                }, exports.extname = function(path) {
                    "string" != typeof path && (path += "");
                    for (var startDot = -1, startPart = 0, end = -1, matchedSlash = !0, preDotState = 0, i = path.length - 1; i >= 0; --i) {
                        var code = path.charCodeAt(i);
                        if (47 !== code) -1 === end && (matchedSlash = !1, end = i + 1), 46 === code ? -1 === startDot ? startDot = i : 1 !== preDotState && (preDotState = 1) : -1 !== startDot && (preDotState = -1); else if (!matchedSlash) {
                            startPart = i + 1;
                            break;
                        }
                    }
                    return -1 === startDot || -1 === end || 0 === preDotState || 1 === preDotState && startDot === end - 1 && startDot === startPart + 1 ? "" : path.slice(startDot, end);
                };
                var substr = "b" === "ab".substr(-1) ? function(str, start, len) {
                    return str.substr(start, len);
                } : function(str, start, len) {
                    return start < 0 && (start = str.length + start), str.substr(start, len);
                };
            }).call(this, require("_process"));
        }, {
            _process: 133
        } ],
        108: [ function(require, module, exports) {
            (function(Buffer) {
                var _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj) {
                    return typeof obj;
                } : function(obj) {
                    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
                }, http = require("http"), https = require("https"), url = require("url"), qs = require("querystring"), zlib = require("zlib"), util = require("util"), phin = function phin(opts, cb) {
                    if ("string" != typeof opts && !opts.hasOwnProperty("url")) throw new Error("Missing url option from options for request method.");
                    var addr = "object" === (void 0 === opts ? "undefined" : _typeof(opts)) ? url.parse(opts.url) : url.parse(opts), options = {
                        hostname: addr.hostname,
                        port: addr.port || ("http:" === addr.protocol.toLowerCase() ? 80 : 443),
                        path: addr.path,
                        method: "GET",
                        headers: {},
                        auth: addr.auth || null,
                        parse: "none",
                        stream: !1
                    };
                    if ("object" === (void 0 === opts ? "undefined" : _typeof(opts)) && (options = Object.assign(options, opts)), 
                    options.port = Number(options.port), options.hasOwnProperty("timeout") && delete options.timeout, 
                    !0 === options.compressed && (options.headers["accept-encoding"] = "gzip, deflate"), 
                    opts.hasOwnProperty("form")) {
                        if ("object" !== _typeof(opts.form)) throw new Error("phin 'form' option must be of type Object if present.");
                        var formDataString = qs.stringify(opts.form);
                        options.headers["Content-Type"] = "application/x-www-form-urlencoded", options.headers["Content-Length"] = Buffer.byteLength(formDataString), 
                        opts.data = formDataString;
                    }
                    var req = void 0, resHandler = function resHandler(res) {
                        var stream = res;
                        !0 === options.compressed && ("gzip" === res.headers["content-encoding"] ? stream = res.pipe(zlib.createGunzip()) : "deflate" === res.headers["content-encoding"] && (stream = res.pipe(zlib.createInflate()))), 
                        !0 === options.stream ? (res.stream = stream, cb(null, res)) : (res.body = new Buffer([]), 
                        stream.on("data", (function(chunk) {
                            res.body = Buffer.concat([ res.body, chunk ]);
                        })), stream.on("end", (function() {
                            if (cb) {
                                if ("json" === options.parse) try {
                                    res.body = JSON.parse(res.body.toString());
                                } catch (err) {
                                    return void cb("Invalid JSON received.", res);
                                }
                                cb(null, res);
                            }
                        })));
                    };
                    switch (addr.protocol.toLowerCase()) {
                      case "http:":
                        req = http.request(options, resHandler);
                        break;

                      case "https:":
                        req = https.request(options, resHandler);
                        break;

                      default:
                        return void (cb && cb(new Error("Invalid / unknown URL protocol. Expected HTTP or HTTPS."), null));
                    }
                    if ("number" == typeof opts.timeout && req.setTimeout(opts.timeout, (function() {
                        req.abort(), cb(new Error("Timeout has been reached."), null), cb = null;
                    })), req.on("error", (function(err) {
                        cb && cb(err, null);
                    })), opts.hasOwnProperty("data")) {
                        var postData = opts.data;
                        if (!(opts.data instanceof Buffer) && "object" === _typeof(opts.data)) if ("application/x-www-form-urlencoded" === (options.headers["content-type"] || options.headers["Content-Type"])) postData = qs.stringify(opts.data); else try {
                            postData = JSON.stringify(opts.data);
                        } catch (err) {
                            cb(new Error("Couldn't stringify object. (Likely due to a circular reference.)"), null);
                        }
                        req.write(postData);
                    }
                    req.end();
                };
                phin.promisified = function(opts, http) {
                    return new Promise((function(resolve, reject) {
                        phin(opts, (function(err, res) {
                            err ? reject(err) : resolve(res);
                        }));
                    }));
                }, util.promisify && (phin[util.promisify.custom] = phin.promisified), module.exports = phin;
            }).call(this, require("buffer").Buffer);
        }, {
            buffer: 48,
            http: 156,
            https: 72,
            querystring: 137,
            url: 180,
            util: 186,
            zlib: 35
        } ],
        109: [ function(require, module, exports) {
            function antialiased(img, x1, y1, width, height, img2) {
                for (var minX, minY, maxX, maxY, x0 = Math.max(x1 - 1, 0), y0 = Math.max(y1 - 1, 0), x2 = Math.min(x1 + 1, width - 1), y2 = Math.min(y1 + 1, height - 1), pos = 4 * (y1 * width + x1), zeroes = 0, positives = 0, negatives = 0, min = 0, max = 0, x = x0; x <= x2; x++) for (var y = y0; y <= y2; y++) if (x !== x1 || y !== y1) {
                    var delta = colorDelta(img, img, pos, 4 * (y * width + x), !0);
                    if (0 === delta ? zeroes++ : delta < 0 ? negatives++ : delta > 0 && positives++, 
                    zeroes > 2) return !1;
                    img2 && (delta < min && (min = delta, minX = x, minY = y), delta > max && (max = delta, 
                    maxX = x, maxY = y));
                }
                return !img2 || 0 !== negatives && 0 !== positives && (!antialiased(img, minX, minY, width, height) && !antialiased(img2, minX, minY, width, height) || !antialiased(img, maxX, maxY, width, height) && !antialiased(img2, maxX, maxY, width, height));
            }
            function colorDelta(img1, img2, k, m, yOnly) {
                var a1 = img1[k + 3] / 255, a2 = img2[m + 3] / 255, r1 = blend(img1[k + 0], a1), g1 = blend(img1[k + 1], a1), b1 = blend(img1[k + 2], a1), r2 = blend(img2[m + 0], a2), g2 = blend(img2[m + 1], a2), b2 = blend(img2[m + 2], a2), y = rgb2y(r1, g1, b1) - rgb2y(r2, g2, b2);
                if (yOnly) return y;
                var i = rgb2i(r1, g1, b1) - rgb2i(r2, g2, b2), q = rgb2q(r1, g1, b1) - rgb2q(r2, g2, b2);
                return 0.5053 * y * y + 0.299 * i * i + 0.1957 * q * q;
            }
            function rgb2y(r, g, b) {
                return 0.29889531 * r + 0.58662247 * g + 0.11448223 * b;
            }
            function rgb2i(r, g, b) {
                return 0.59597799 * r - 0.27417610 * g - 0.32180189 * b;
            }
            function rgb2q(r, g, b) {
                return 0.21147017 * r - 0.52261711 * g + 0.31114694 * b;
            }
            function blend(c, a) {
                return 255 + (c - 255) * a;
            }
            function drawPixel(output, pos, r, g, b) {
                output[pos + 0] = r, output[pos + 1] = g, output[pos + 2] = b, output[pos + 3] = 255;
            }
            module.exports = function pixelmatch(img1, img2, output, width, height, options) {
                options || (options = {});
                for (var threshold = void 0 === options.threshold ? 0.1 : options.threshold, maxDelta = 35215 * threshold * threshold, diff = 0, y = 0; y < height; y++) for (var x = 0; x < width; x++) {
                    var pos = 4 * (y * width + x);
                    if (colorDelta(img1, img2, pos, pos) > maxDelta) options.includeAA || !antialiased(img1, x, y, width, height, img2) && !antialiased(img2, x, y, width, height, img1) ? (output && drawPixel(output, pos, 255, 0, 0), 
                    diff++) : output && drawPixel(output, pos, 255, 255, 0); else if (output) {
                        var val = blend((void 0, a = (img = img1)[(i = pos) + 3] / 255, rgb2y(blend(img[i + 0], a), blend(img[i + 1], a), blend(img[i + 2], a))), 0.1);
                        drawPixel(output, pos, val, val, val);
                    }
                }
                var img, i, a;
                return diff;
            };
        }, {} ],
        110: [ function(require, module, exports) {
            (function(Buffer) {
                var interlaceUtils = require("./interlace"), pixelBppMap = {
                    1: {
                        0: 0,
                        1: 0,
                        2: 0,
                        3: 0xff
                    },
                    2: {
                        0: 0,
                        1: 0,
                        2: 0,
                        3: 1
                    },
                    3: {
                        0: 0,
                        1: 1,
                        2: 2,
                        3: 0xff
                    },
                    4: {
                        0: 0,
                        1: 1,
                        2: 2,
                        3: 3
                    }
                };
                function mapImage8Bit(image, pxData, getPxPos, bpp, data, rawPos) {
                    for (var imageWidth = image.width, imageHeight = image.height, imagePass = image.index, y = 0; y < imageHeight; y++) for (var x = 0; x < imageWidth; x++) {
                        for (var pxPos = getPxPos(x, y, imagePass), i = 0; i < 4; i++) {
                            var idx = pixelBppMap[bpp][i];
                            if (0xff === idx) pxData[pxPos + i] = 0xff; else {
                                var dataPos = idx + rawPos;
                                if (dataPos === data.length) throw new Error("Ran out of data");
                                pxData[pxPos + i] = data[dataPos];
                            }
                        }
                        rawPos += bpp;
                    }
                    return rawPos;
                }
                function mapImageCustomBit(image, pxData, getPxPos, bpp, bits, maxBit) {
                    for (var imageWidth = image.width, imageHeight = image.height, imagePass = image.index, y = 0; y < imageHeight; y++) {
                        for (var x = 0; x < imageWidth; x++) for (var pixelData = bits.get(bpp), pxPos = getPxPos(x, y, imagePass), i = 0; i < 4; i++) {
                            var idx = pixelBppMap[bpp][i];
                            pxData[pxPos + i] = 0xff !== idx ? pixelData[idx] : maxBit;
                        }
                        bits.resetAfterLine();
                    }
                }
                exports.dataToBitMap = function(data, bitmapInfo) {
                    var pxData, width = bitmapInfo.width, height = bitmapInfo.height, depth = bitmapInfo.depth, bpp = bitmapInfo.bpp, interlace = bitmapInfo.interlace;
                    if (8 !== depth) var bits = function bitRetriever(data, depth) {
                        var leftOver = [], i = 0;
                        function split() {
                            if (i === data.length) throw new Error("Ran out of data");
                            var byte8, byte7, byte6, byte5, byte4, byte3, byte2, byte1, byte = data[i];
                            switch (i++, depth) {
                              default:
                                throw new Error("unrecognised depth");

                              case 16:
                                byte2 = data[i], i++, leftOver.push((byte << 8) + byte2);
                                break;

                              case 4:
                                byte2 = 0x0f & byte, byte1 = byte >> 4, leftOver.push(byte1, byte2);
                                break;

                              case 2:
                                byte4 = 3 & byte, byte3 = byte >> 2 & 3, byte2 = byte >> 4 & 3, byte1 = byte >> 6 & 3, 
                                leftOver.push(byte1, byte2, byte3, byte4);
                                break;

                              case 1:
                                byte8 = 1 & byte, byte7 = byte >> 1 & 1, byte6 = byte >> 2 & 1, byte5 = byte >> 3 & 1, 
                                byte4 = byte >> 4 & 1, byte3 = byte >> 5 & 1, byte2 = byte >> 6 & 1, byte1 = byte >> 7 & 1, 
                                leftOver.push(byte1, byte2, byte3, byte4, byte5, byte6, byte7, byte8);
                            }
                        }
                        return {
                            get: function(count) {
                                for (;leftOver.length < count; ) split();
                                var returner = leftOver.slice(0, count);
                                return leftOver = leftOver.slice(count), returner;
                            },
                            resetAfterLine: function() {
                                leftOver.length = 0;
                            },
                            end: function() {
                                if (i !== data.length) throw new Error("extra data found");
                            }
                        };
                    }(data, depth);
                    pxData = depth <= 8 ? new Buffer(width * height * 4) : new Uint16Array(width * height * 4);
                    var images, getPxPos, maxBit = Math.pow(2, depth) - 1, rawPos = 0;
                    if (interlace) images = interlaceUtils.getImagePasses(width, height), getPxPos = interlaceUtils.getInterlaceIterator(width, height); else {
                        var nonInterlacedPxPos = 0;
                        getPxPos = function() {
                            var returner = nonInterlacedPxPos;
                            return nonInterlacedPxPos += 4, returner;
                        }, images = [ {
                            width,
                            height
                        } ];
                    }
                    for (var imageIndex = 0; imageIndex < images.length; imageIndex++) 8 === depth ? rawPos = mapImage8Bit(images[imageIndex], pxData, getPxPos, bpp, data, rawPos) : mapImageCustomBit(images[imageIndex], pxData, getPxPos, bpp, bits, maxBit);
                    if (8 === depth) {
                        if (rawPos !== data.length) throw new Error("extra data found");
                    } else bits.end();
                    return pxData;
                };
            }).call(this, require("buffer").Buffer);
        }, {
            "./interlace": 120,
            buffer: 48
        } ],
        111: [ function(require, module, exports) {
            (function(Buffer) {
                var constants = require("./constants");
                module.exports = function(dataIn, width, height, options) {
                    var buffer, outHasAlpha = -1 !== [ constants.COLORTYPE_COLOR_ALPHA, constants.COLORTYPE_ALPHA ].indexOf(options.colorType);
                    if (options.colorType === options.inputColorType) {
                        var bigEndian = (buffer = new ArrayBuffer(2), new DataView(buffer).setInt16(0, 256, !0), 
                        256 !== new Int16Array(buffer)[0]);
                        if (8 === options.bitDepth || 16 === options.bitDepth && bigEndian) return dataIn;
                    }
                    var data = 16 !== options.bitDepth ? dataIn : new Uint16Array(dataIn.buffer), maxValue = 255, inBpp = constants.COLORTYPE_TO_BPP_MAP[options.inputColorType];
                    4 != inBpp || options.inputHasAlpha || (inBpp = 3);
                    var outBpp = constants.COLORTYPE_TO_BPP_MAP[options.colorType];
                    16 === options.bitDepth && (maxValue = 65535, outBpp *= 2);
                    var outData = new Buffer(width * height * outBpp), inIndex = 0, outIndex = 0, bgColor = options.bgColor || {};
                    function getRGBA(data, inIndex) {
                        var red, green, blue, alpha = maxValue;
                        switch (options.inputColorType) {
                          case constants.COLORTYPE_COLOR_ALPHA:
                            alpha = data[inIndex + 3], red = data[inIndex], green = data[inIndex + 1], blue = data[inIndex + 2];
                            break;

                          case constants.COLORTYPE_COLOR:
                            red = data[inIndex], green = data[inIndex + 1], blue = data[inIndex + 2];
                            break;

                          case constants.COLORTYPE_ALPHA:
                            alpha = data[inIndex + 1], green = red = data[inIndex], blue = red;
                            break;

                          case constants.COLORTYPE_GRAYSCALE:
                            green = red = data[inIndex], blue = red;
                            break;

                          default:
                            throw new Error("input color type:" + options.inputColorType + " is not supported at present");
                        }
                        return options.inputHasAlpha && (outHasAlpha || (alpha /= maxValue, red = Math.min(Math.max(Math.round((1 - alpha) * bgColor.red + alpha * red), 0), maxValue), 
                        green = Math.min(Math.max(Math.round((1 - alpha) * bgColor.green + alpha * green), 0), maxValue), 
                        blue = Math.min(Math.max(Math.round((1 - alpha) * bgColor.blue + alpha * blue), 0), maxValue))), 
                        {
                            red,
                            green,
                            blue,
                            alpha
                        };
                    }
                    void 0 === bgColor.red && (bgColor.red = maxValue), void 0 === bgColor.green && (bgColor.green = maxValue), 
                    void 0 === bgColor.blue && (bgColor.blue = maxValue);
                    for (var y = 0; y < height; y++) for (var x = 0; x < width; x++) {
                        var rgba = getRGBA(data, inIndex);
                        switch (options.colorType) {
                          case constants.COLORTYPE_COLOR_ALPHA:
                          case constants.COLORTYPE_COLOR:
                            8 === options.bitDepth ? (outData[outIndex] = rgba.red, outData[outIndex + 1] = rgba.green, 
                            outData[outIndex + 2] = rgba.blue, outHasAlpha && (outData[outIndex + 3] = rgba.alpha)) : (outData.writeUInt16BE(rgba.red, outIndex), 
                            outData.writeUInt16BE(rgba.green, outIndex + 2), outData.writeUInt16BE(rgba.blue, outIndex + 4), 
                            outHasAlpha && outData.writeUInt16BE(rgba.alpha, outIndex + 6));
                            break;

                          case constants.COLORTYPE_ALPHA:
                          case constants.COLORTYPE_GRAYSCALE:
                            var grayscale = (rgba.red + rgba.green + rgba.blue) / 3;
                            8 === options.bitDepth ? (outData[outIndex] = grayscale, outHasAlpha && (outData[outIndex + 1] = rgba.alpha)) : (outData.writeUInt16BE(grayscale, outIndex), 
                            outHasAlpha && outData.writeUInt16BE(rgba.alpha, outIndex + 2));
                        }
                        inIndex += inBpp, outIndex += outBpp;
                    }
                    return outData;
                };
            }).call(this, require("buffer").Buffer);
        }, {
            "./constants": 113,
            buffer: 48
        } ],
        112: [ function(require, module, exports) {
            (function(process, Buffer) {
                var util = require("util"), Stream = require("stream"), ChunkStream = module.exports = function() {
                    Stream.call(this), this._buffers = [], this._buffered = 0, this._reads = [], this._paused = !1, 
                    this._encoding = "utf8", this.writable = !0;
                };
                util.inherits(ChunkStream, Stream), ChunkStream.prototype.read = function(length, callback) {
                    this._reads.push({
                        length: Math.abs(length),
                        allowLess: length < 0,
                        func: callback
                    }), process.nextTick(function() {
                        this._process(), this._paused && this._reads.length > 0 && (this._paused = !1, this.emit("drain"));
                    }.bind(this));
                }, ChunkStream.prototype.write = function(data, encoding) {
                    return this.writable ? (dataBuffer = Buffer.isBuffer(data) ? data : new Buffer(data, encoding || this._encoding), 
                    this._buffers.push(dataBuffer), this._buffered += dataBuffer.length, this._process(), 
                    this._reads && 0 === this._reads.length && (this._paused = !0), this.writable && !this._paused) : (this.emit("error", new Error("Stream not writable")), 
                    !1);
                    var dataBuffer;
                }, ChunkStream.prototype.end = function(data, encoding) {
                    data && this.write(data, encoding), this.writable = !1, this._buffers && (0 === this._buffers.length ? this._end() : (this._buffers.push(null), 
                    this._process()));
                }, ChunkStream.prototype.destroySoon = ChunkStream.prototype.end, ChunkStream.prototype._end = function() {
                    this._reads.length > 0 && this.emit("error", new Error("There are some read requests waiting on finished stream")), 
                    this.destroy();
                }, ChunkStream.prototype.destroy = function() {
                    this._buffers && (this.writable = !1, this._reads = null, this._buffers = null, 
                    this.emit("close"));
                }, ChunkStream.prototype._processReadAllowingLess = function(read) {
                    this._reads.shift();
                    var smallerBuf = this._buffers[0];
                    smallerBuf.length > read.length ? (this._buffered -= read.length, this._buffers[0] = smallerBuf.slice(read.length), 
                    read.func.call(this, smallerBuf.slice(0, read.length))) : (this._buffered -= smallerBuf.length, 
                    this._buffers.shift(), read.func.call(this, smallerBuf));
                }, ChunkStream.prototype._processRead = function(read) {
                    this._reads.shift();
                    for (var pos = 0, count = 0, data = new Buffer(read.length); pos < read.length; ) {
                        var buf = this._buffers[count++], len = Math.min(buf.length, read.length - pos);
                        buf.copy(data, pos, 0, len), pos += len, len !== buf.length && (this._buffers[--count] = buf.slice(len));
                    }
                    count > 0 && this._buffers.splice(0, count), this._buffered -= read.length, read.func.call(this, data);
                }, ChunkStream.prototype._process = function() {
                    try {
                        for (;this._buffered > 0 && this._reads && this._reads.length > 0; ) {
                            var read = this._reads[0];
                            if (read.allowLess) this._processReadAllowingLess(read); else {
                                if (!(this._buffered >= read.length)) break;
                                this._processRead(read);
                            }
                        }
                        this._buffers && this._buffers.length > 0 && null === this._buffers[0] && this._end();
                    } catch (ex) {
                        this.emit("error", ex);
                    }
                };
            }).call(this, require("_process"), require("buffer").Buffer);
        }, {
            _process: 133,
            buffer: 48,
            stream: 155,
            util: 186
        } ],
        113: [ function(require, module, exports) {
            module.exports = {
                PNG_SIGNATURE: [ 0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a ],
                TYPE_IHDR: 0x49484452,
                TYPE_IEND: 0x49454e44,
                TYPE_IDAT: 0x49444154,
                TYPE_PLTE: 0x504c5445,
                TYPE_tRNS: 0x74524e53,
                TYPE_gAMA: 0x67414d41,
                COLORTYPE_GRAYSCALE: 0,
                COLORTYPE_PALETTE: 1,
                COLORTYPE_COLOR: 2,
                COLORTYPE_ALPHA: 4,
                COLORTYPE_PALETTE_COLOR: 3,
                COLORTYPE_COLOR_ALPHA: 6,
                COLORTYPE_TO_BPP_MAP: {
                    0: 1,
                    2: 3,
                    3: 1,
                    4: 2,
                    6: 4
                },
                GAMMA_DIVISION: 100000
            };
        }, {} ],
        114: [ function(require, module, exports) {
            var crcTable = [];
            !function() {
                for (var i = 0; i < 256; i++) {
                    for (var currentCrc = i, j = 0; j < 8; j++) 1 & currentCrc ? currentCrc = 0xedb88320 ^ currentCrc >>> 1 : currentCrc >>>= 1;
                    crcTable[i] = currentCrc;
                }
            }();
            var CrcCalculator = module.exports = function() {
                this._crc = -1;
            };
            CrcCalculator.prototype.write = function(data) {
                for (var i = 0; i < data.length; i++) this._crc = crcTable[0xff & (this._crc ^ data[i])] ^ this._crc >>> 8;
                return !0;
            }, CrcCalculator.prototype.crc32 = function() {
                return -1 ^ this._crc;
            }, CrcCalculator.crc32 = function(buf) {
                for (var crc = -1, i = 0; i < buf.length; i++) crc = crcTable[0xff & (crc ^ buf[i])] ^ crc >>> 8;
                return -1 ^ crc;
            };
        }, {} ],
        115: [ function(require, module, exports) {
            (function(Buffer) {
                var paethPredictor = require("./paeth-predictor"), filters = {
                    0: function filterNone(pxData, pxPos, byteWidth, rawData, rawPos) {
                        for (var x = 0; x < byteWidth; x++) rawData[rawPos + x] = pxData[pxPos + x];
                    },
                    1: function filterSub(pxData, pxPos, byteWidth, rawData, rawPos, bpp) {
                        for (var x = 0; x < byteWidth; x++) {
                            var left = x >= bpp ? pxData[pxPos + x - bpp] : 0, val = pxData[pxPos + x] - left;
                            rawData[rawPos + x] = val;
                        }
                    },
                    2: function filterUp(pxData, pxPos, byteWidth, rawData, rawPos) {
                        for (var x = 0; x < byteWidth; x++) {
                            var up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0, val = pxData[pxPos + x] - up;
                            rawData[rawPos + x] = val;
                        }
                    },
                    3: function filterAvg(pxData, pxPos, byteWidth, rawData, rawPos, bpp) {
                        for (var x = 0; x < byteWidth; x++) {
                            var left = x >= bpp ? pxData[pxPos + x - bpp] : 0, up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0, val = pxData[pxPos + x] - (left + up >> 1);
                            rawData[rawPos + x] = val;
                        }
                    },
                    4: function filterPaeth(pxData, pxPos, byteWidth, rawData, rawPos, bpp) {
                        for (var x = 0; x < byteWidth; x++) {
                            var left = x >= bpp ? pxData[pxPos + x - bpp] : 0, up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0, upleft = pxPos > 0 && x >= bpp ? pxData[pxPos + x - (byteWidth + bpp)] : 0, val = pxData[pxPos + x] - paethPredictor(left, up, upleft);
                            rawData[rawPos + x] = val;
                        }
                    }
                }, filterSums = {
                    0: function filterSumNone(pxData, pxPos, byteWidth) {
                        for (var sum = 0, length = pxPos + byteWidth, i = pxPos; i < length; i++) sum += Math.abs(pxData[i]);
                        return sum;
                    },
                    1: function filterSumSub(pxData, pxPos, byteWidth, bpp) {
                        for (var sum = 0, x = 0; x < byteWidth; x++) {
                            var left = x >= bpp ? pxData[pxPos + x - bpp] : 0, val = pxData[pxPos + x] - left;
                            sum += Math.abs(val);
                        }
                        return sum;
                    },
                    2: function filterSumUp(pxData, pxPos, byteWidth) {
                        for (var sum = 0, length = pxPos + byteWidth, x = pxPos; x < length; x++) {
                            var up = pxPos > 0 ? pxData[x - byteWidth] : 0, val = pxData[x] - up;
                            sum += Math.abs(val);
                        }
                        return sum;
                    },
                    3: function filterSumAvg(pxData, pxPos, byteWidth, bpp) {
                        for (var sum = 0, x = 0; x < byteWidth; x++) {
                            var left = x >= bpp ? pxData[pxPos + x - bpp] : 0, up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0, val = pxData[pxPos + x] - (left + up >> 1);
                            sum += Math.abs(val);
                        }
                        return sum;
                    },
                    4: function filterSumPaeth(pxData, pxPos, byteWidth, bpp) {
                        for (var sum = 0, x = 0; x < byteWidth; x++) {
                            var left = x >= bpp ? pxData[pxPos + x - bpp] : 0, up = pxPos > 0 ? pxData[pxPos + x - byteWidth] : 0, upleft = pxPos > 0 && x >= bpp ? pxData[pxPos + x - (byteWidth + bpp)] : 0, val = pxData[pxPos + x] - paethPredictor(left, up, upleft);
                            sum += Math.abs(val);
                        }
                        return sum;
                    }
                };
                module.exports = function(pxData, width, height, options, bpp) {
                    var filterTypes;
                    if ("filterType" in options && -1 !== options.filterType) {
                        if ("number" != typeof options.filterType) throw new Error("unrecognised filter types");
                        filterTypes = [ options.filterType ];
                    } else filterTypes = [ 0, 1, 2, 3, 4 ];
                    16 === options.bitDepth && (bpp *= 2);
                    for (var byteWidth = width * bpp, rawPos = 0, pxPos = 0, rawData = new Buffer((byteWidth + 1) * height), sel = filterTypes[0], y = 0; y < height; y++) {
                        if (filterTypes.length > 1) for (var min = 1 / 0, i = 0; i < filterTypes.length; i++) {
                            var sum = filterSums[filterTypes[i]](pxData, pxPos, byteWidth, bpp);
                            sum < min && (sel = filterTypes[i], min = sum);
                        }
                        rawData[rawPos] = sel, rawPos++, filters[sel](pxData, pxPos, byteWidth, rawData, rawPos, bpp), 
                        rawPos += byteWidth, pxPos += byteWidth;
                    }
                    return rawData;
                };
            }).call(this, require("buffer").Buffer);
        }, {
            "./paeth-predictor": 124,
            buffer: 48
        } ],
        116: [ function(require, module, exports) {
            (function(Buffer) {
                var util = require("util"), ChunkStream = require("./chunkstream"), Filter = require("./filter-parse"), FilterAsync = module.exports = function(bitmapInfo) {
                    ChunkStream.call(this);
                    var buffers = [], that = this;
                    this._filter = new Filter(bitmapInfo, {
                        read: this.read.bind(this),
                        write: function(buffer) {
                            buffers.push(buffer);
                        },
                        complete: function() {
                            that.emit("complete", Buffer.concat(buffers));
                        }
                    }), this._filter.start();
                };
                util.inherits(FilterAsync, ChunkStream);
            }).call(this, require("buffer").Buffer);
        }, {
            "./chunkstream": 112,
            "./filter-parse": 118,
            buffer: 48,
            util: 186
        } ],
        117: [ function(require, module, exports) {
            (function(Buffer) {
                var SyncReader = require("./sync-reader"), Filter = require("./filter-parse");
                exports.process = function(inBuffer, bitmapInfo) {
                    var outBuffers = [], reader = new SyncReader(inBuffer);
                    return new Filter(bitmapInfo, {
                        read: reader.read.bind(reader),
                        write: function(bufferPart) {
                            outBuffers.push(bufferPart);
                        },
                        complete: function() {}
                    }).start(), reader.process(), Buffer.concat(outBuffers);
                };
            }).call(this, require("buffer").Buffer);
        }, {
            "./filter-parse": 118,
            "./sync-reader": 131,
            buffer: 48
        } ],
        118: [ function(require, module, exports) {
            (function(Buffer) {
                var interlaceUtils = require("./interlace"), paethPredictor = require("./paeth-predictor");
                function getByteWidth(width, bpp, depth) {
                    var byteWidth = width * bpp;
                    return 8 !== depth && (byteWidth = Math.ceil(byteWidth / (8 / depth))), byteWidth;
                }
                var Filter = module.exports = function(bitmapInfo, dependencies) {
                    var width = bitmapInfo.width, height = bitmapInfo.height, interlace = bitmapInfo.interlace, bpp = bitmapInfo.bpp, depth = bitmapInfo.depth;
                    if (this.read = dependencies.read, this.write = dependencies.write, this.complete = dependencies.complete, 
                    this._imageIndex = 0, this._images = [], interlace) for (var passes = interlaceUtils.getImagePasses(width, height), i = 0; i < passes.length; i++) this._images.push({
                        byteWidth: getByteWidth(passes[i].width, bpp, depth),
                        height: passes[i].height,
                        lineIndex: 0
                    }); else this._images.push({
                        byteWidth: getByteWidth(width, bpp, depth),
                        height,
                        lineIndex: 0
                    });
                    this._xComparison = 8 === depth ? bpp : 16 === depth ? 2 * bpp : 1;
                };
                Filter.prototype.start = function() {
                    this.read(this._images[this._imageIndex].byteWidth + 1, this._reverseFilterLine.bind(this));
                }, Filter.prototype._unFilterType1 = function(rawData, unfilteredLine, byteWidth) {
                    for (var xComparison = this._xComparison, xBiggerThan = xComparison - 1, x = 0; x < byteWidth; x++) {
                        var rawByte = rawData[1 + x], f1Left = x > xBiggerThan ? unfilteredLine[x - xComparison] : 0;
                        unfilteredLine[x] = rawByte + f1Left;
                    }
                }, Filter.prototype._unFilterType2 = function(rawData, unfilteredLine, byteWidth) {
                    for (var lastLine = this._lastLine, x = 0; x < byteWidth; x++) {
                        var rawByte = rawData[1 + x], f2Up = lastLine ? lastLine[x] : 0;
                        unfilteredLine[x] = rawByte + f2Up;
                    }
                }, Filter.prototype._unFilterType3 = function(rawData, unfilteredLine, byteWidth) {
                    for (var xComparison = this._xComparison, xBiggerThan = xComparison - 1, lastLine = this._lastLine, x = 0; x < byteWidth; x++) {
                        var rawByte = rawData[1 + x], f3Up = lastLine ? lastLine[x] : 0, f3Left = x > xBiggerThan ? unfilteredLine[x - xComparison] : 0, f3Add = Math.floor((f3Left + f3Up) / 2);
                        unfilteredLine[x] = rawByte + f3Add;
                    }
                }, Filter.prototype._unFilterType4 = function(rawData, unfilteredLine, byteWidth) {
                    for (var xComparison = this._xComparison, xBiggerThan = xComparison - 1, lastLine = this._lastLine, x = 0; x < byteWidth; x++) {
                        var rawByte = rawData[1 + x], f4Up = lastLine ? lastLine[x] : 0, f4Left = x > xBiggerThan ? unfilteredLine[x - xComparison] : 0, f4UpLeft = x > xBiggerThan && lastLine ? lastLine[x - xComparison] : 0, f4Add = paethPredictor(f4Left, f4Up, f4UpLeft);
                        unfilteredLine[x] = rawByte + f4Add;
                    }
                }, Filter.prototype._reverseFilterLine = function(rawData) {
                    var unfilteredLine, filter = rawData[0], currentImage = this._images[this._imageIndex], byteWidth = currentImage.byteWidth;
                    if (0 === filter) unfilteredLine = rawData.slice(1, byteWidth + 1); else switch (unfilteredLine = new Buffer(byteWidth), 
                    filter) {
                      case 1:
                        this._unFilterType1(rawData, unfilteredLine, byteWidth);
                        break;

                      case 2:
                        this._unFilterType2(rawData, unfilteredLine, byteWidth);
                        break;

                      case 3:
                        this._unFilterType3(rawData, unfilteredLine, byteWidth);
                        break;

                      case 4:
                        this._unFilterType4(rawData, unfilteredLine, byteWidth);
                        break;

                      default:
                        throw new Error("Unrecognised filter type - " + filter);
                    }
                    this.write(unfilteredLine), currentImage.lineIndex++, currentImage.lineIndex >= currentImage.height ? (this._lastLine = null, 
                    this._imageIndex++, currentImage = this._images[this._imageIndex]) : this._lastLine = unfilteredLine, 
                    currentImage ? this.read(currentImage.byteWidth + 1, this._reverseFilterLine.bind(this)) : (this._lastLine = null, 
                    this.complete());
                };
            }).call(this, require("buffer").Buffer);
        }, {
            "./interlace": 120,
            "./paeth-predictor": 124,
            buffer: 48
        } ],
        119: [ function(require, module, exports) {
            (function(Buffer) {
                module.exports = function(indata, imageData) {
                    var depth = imageData.depth, width = imageData.width, height = imageData.height, colorType = imageData.colorType, transColor = imageData.transColor, palette = imageData.palette, outdata = indata;
                    return 3 === colorType ? function dePalette(indata, outdata, width, height, palette) {
                        for (var pxPos = 0, y = 0; y < height; y++) for (var x = 0; x < width; x++) {
                            var color = palette[indata[pxPos]];
                            if (!color) throw new Error("index " + indata[pxPos] + " not in palette");
                            for (var i = 0; i < 4; i++) outdata[pxPos + i] = color[i];
                            pxPos += 4;
                        }
                    }(indata, outdata, width, height, palette) : (transColor && function replaceTransparentColor(indata, outdata, width, height, transColor) {
                        for (var pxPos = 0, y = 0; y < height; y++) for (var x = 0; x < width; x++) {
                            var makeTrans = !1;
                            if (1 === transColor.length ? transColor[0] === indata[pxPos] && (makeTrans = !0) : transColor[0] === indata[pxPos] && transColor[1] === indata[pxPos + 1] && transColor[2] === indata[pxPos + 2] && (makeTrans = !0), 
                            makeTrans) for (var i = 0; i < 4; i++) outdata[pxPos + i] = 0;
                            pxPos += 4;
                        }
                    }(indata, outdata, width, height, transColor), 8 !== depth && (16 === depth && (outdata = new Buffer(width * height * 4)), 
                    function scaleDepth(indata, outdata, width, height, depth) {
                        for (var maxInSample = Math.pow(2, depth) - 1, pxPos = 0, y = 0; y < height; y++) for (var x = 0; x < width; x++) {
                            for (var i = 0; i < 4; i++) outdata[pxPos + i] = Math.floor(255 * indata[pxPos + i] / maxInSample + 0.5);
                            pxPos += 4;
                        }
                    }(indata, outdata, width, height, depth))), outdata;
                };
            }).call(this, require("buffer").Buffer);
        }, {
            buffer: 48
        } ],
        120: [ function(require, module, exports) {
            var imagePasses = [ {
                x: [ 0 ],
                y: [ 0 ]
            }, {
                x: [ 4 ],
                y: [ 0 ]
            }, {
                x: [ 0, 4 ],
                y: [ 4 ]
            }, {
                x: [ 2, 6 ],
                y: [ 0, 4 ]
            }, {
                x: [ 0, 2, 4, 6 ],
                y: [ 2, 6 ]
            }, {
                x: [ 1, 3, 5, 7 ],
                y: [ 0, 2, 4, 6 ]
            }, {
                x: [ 0, 1, 2, 3, 4, 5, 6, 7 ],
                y: [ 1, 3, 5, 7 ]
            } ];
            exports.getImagePasses = function(width, height) {
                for (var images = [], xLeftOver = width % 8, yLeftOver = height % 8, xRepeats = (width - xLeftOver) / 8, yRepeats = (height - yLeftOver) / 8, i = 0; i < imagePasses.length; i++) {
                    for (var pass = imagePasses[i], passWidth = xRepeats * pass.x.length, passHeight = yRepeats * pass.y.length, j = 0; j < pass.x.length && pass.x[j] < xLeftOver; j++) passWidth++;
                    for (j = 0; j < pass.y.length && pass.y[j] < yLeftOver; j++) passHeight++;
                    passWidth > 0 && passHeight > 0 && images.push({
                        width: passWidth,
                        height: passHeight,
                        index: i
                    });
                }
                return images;
            }, exports.getInterlaceIterator = function(width) {
                return function(x, y, pass) {
                    var outerXLeftOver = x % imagePasses[pass].x.length, outerX = (x - outerXLeftOver) / imagePasses[pass].x.length * 8 + imagePasses[pass].x[outerXLeftOver], outerYLeftOver = y % imagePasses[pass].y.length;
                    return 4 * outerX + ((y - outerYLeftOver) / imagePasses[pass].y.length * 8 + imagePasses[pass].y[outerYLeftOver]) * width * 4;
                };
            };
        }, {} ],
        121: [ function(require, module, exports) {
            (function(Buffer) {
                var util = require("util"), Stream = require("stream"), constants = require("./constants"), Packer = require("./packer"), PackerAsync = module.exports = function(opt) {
                    Stream.call(this);
                    var options = opt || {};
                    this._packer = new Packer(options), this._deflate = this._packer.createDeflate(), 
                    this.readable = !0;
                };
                util.inherits(PackerAsync, Stream), PackerAsync.prototype.pack = function(data, width, height, gamma) {
                    this.emit("data", new Buffer(constants.PNG_SIGNATURE)), this.emit("data", this._packer.packIHDR(width, height)), 
                    gamma && this.emit("data", this._packer.packGAMA(gamma));
                    var filteredData = this._packer.filterData(data, width, height);
                    this._deflate.on("error", this.emit.bind(this, "error")), this._deflate.on("data", function(compressedData) {
                        this.emit("data", this._packer.packIDAT(compressedData));
                    }.bind(this)), this._deflate.on("end", function() {
                        this.emit("data", this._packer.packIEND()), this.emit("end");
                    }.bind(this)), this._deflate.end(filteredData);
                };
            }).call(this, require("buffer").Buffer);
        }, {
            "./constants": 113,
            "./packer": 123,
            buffer: 48,
            stream: 155,
            util: 186
        } ],
        122: [ function(require, module, exports) {
            (function(Buffer) {
                var hasSyncZlib = !0, zlib = require("zlib");
                zlib.deflateSync || (hasSyncZlib = !1);
                var constants = require("./constants"), Packer = require("./packer");
                module.exports = function(metaData, opt) {
                    if (!hasSyncZlib) throw new Error("To use the sync capability of this library in old node versions, please pin pngjs to v2.3.0");
                    var packer = new Packer(opt || {}), chunks = [];
                    chunks.push(new Buffer(constants.PNG_SIGNATURE)), chunks.push(packer.packIHDR(metaData.width, metaData.height)), 
                    metaData.gamma && chunks.push(packer.packGAMA(metaData.gamma));
                    var filteredData = packer.filterData(metaData.data, metaData.width, metaData.height), compressedData = zlib.deflateSync(filteredData, packer.getDeflateOptions());
                    if (filteredData = null, !compressedData || !compressedData.length) throw new Error("bad png - invalid compressed data response");
                    return chunks.push(packer.packIDAT(compressedData)), chunks.push(packer.packIEND()), 
                    Buffer.concat(chunks);
                };
            }).call(this, require("buffer").Buffer);
        }, {
            "./constants": 113,
            "./packer": 123,
            buffer: 48,
            zlib: 35
        } ],
        123: [ function(require, module, exports) {
            (function(Buffer) {
                var constants = require("./constants"), CrcStream = require("./crc"), bitPacker = require("./bitpacker"), filter = require("./filter-pack"), zlib = require("zlib"), Packer = module.exports = function(options) {
                    if (this._options = options, options.deflateChunkSize = options.deflateChunkSize || 32768, 
                    options.deflateLevel = null != options.deflateLevel ? options.deflateLevel : 9, 
                    options.deflateStrategy = null != options.deflateStrategy ? options.deflateStrategy : 3, 
                    options.inputHasAlpha = null == options.inputHasAlpha || options.inputHasAlpha, 
                    options.deflateFactory = options.deflateFactory || zlib.createDeflate, options.bitDepth = options.bitDepth || 8, 
                    options.colorType = "number" == typeof options.colorType ? options.colorType : constants.COLORTYPE_COLOR_ALPHA, 
                    options.inputColorType = "number" == typeof options.inputColorType ? options.inputColorType : constants.COLORTYPE_COLOR_ALPHA, 
                    -1 === [ constants.COLORTYPE_GRAYSCALE, constants.COLORTYPE_COLOR, constants.COLORTYPE_COLOR_ALPHA, constants.COLORTYPE_ALPHA ].indexOf(options.colorType)) throw new Error("option color type:" + options.colorType + " is not supported at present");
                    if (-1 === [ constants.COLORTYPE_GRAYSCALE, constants.COLORTYPE_COLOR, constants.COLORTYPE_COLOR_ALPHA, constants.COLORTYPE_ALPHA ].indexOf(options.inputColorType)) throw new Error("option input color type:" + options.inputColorType + " is not supported at present");
                    if (8 !== options.bitDepth && 16 !== options.bitDepth) throw new Error("option bit depth:" + options.bitDepth + " is not supported at present");
                };
                Packer.prototype.getDeflateOptions = function() {
                    return {
                        chunkSize: this._options.deflateChunkSize,
                        level: this._options.deflateLevel,
                        strategy: this._options.deflateStrategy
                    };
                }, Packer.prototype.createDeflate = function() {
                    return this._options.deflateFactory(this.getDeflateOptions());
                }, Packer.prototype.filterData = function(data, width, height) {
                    var packedData = bitPacker(data, width, height, this._options), bpp = constants.COLORTYPE_TO_BPP_MAP[this._options.colorType];
                    return filter(packedData, width, height, this._options, bpp);
                }, Packer.prototype._packChunk = function(type, data) {
                    var len = data ? data.length : 0, buf = new Buffer(len + 12);
                    return buf.writeUInt32BE(len, 0), buf.writeUInt32BE(type, 4), data && data.copy(buf, 8), 
                    buf.writeInt32BE(CrcStream.crc32(buf.slice(4, buf.length - 4)), buf.length - 4), 
                    buf;
                }, Packer.prototype.packGAMA = function(gamma) {
                    var buf = new Buffer(4);
                    return buf.writeUInt32BE(Math.floor(gamma * constants.GAMMA_DIVISION), 0), this._packChunk(constants.TYPE_gAMA, buf);
                }, Packer.prototype.packIHDR = function(width, height) {
                    var buf = new Buffer(13);
                    return buf.writeUInt32BE(width, 0), buf.writeUInt32BE(height, 4), buf[8] = this._options.bitDepth, 
                    buf[9] = this._options.colorType, buf[10] = 0, buf[11] = 0, buf[12] = 0, this._packChunk(constants.TYPE_IHDR, buf);
                }, Packer.prototype.packIDAT = function(data) {
                    return this._packChunk(constants.TYPE_IDAT, data);
                }, Packer.prototype.packIEND = function() {
                    return this._packChunk(constants.TYPE_IEND, null);
                };
            }).call(this, require("buffer").Buffer);
        }, {
            "./bitpacker": 111,
            "./constants": 113,
            "./crc": 114,
            "./filter-pack": 115,
            buffer: 48,
            zlib: 35
        } ],
        124: [ function(require, module, exports) {
            module.exports = function paethPredictor(left, above, upLeft) {
                var paeth = left + above - upLeft, pLeft = Math.abs(paeth - left), pAbove = Math.abs(paeth - above), pUpLeft = Math.abs(paeth - upLeft);
                return pLeft <= pAbove && pLeft <= pUpLeft ? left : pAbove <= pUpLeft ? above : upLeft;
            };
        }, {} ],
        125: [ function(require, module, exports) {
            var util = require("util"), zlib = require("zlib"), ChunkStream = require("./chunkstream"), FilterAsync = require("./filter-parse-async"), Parser = require("./parser"), bitmapper = require("./bitmapper"), formatNormaliser = require("./format-normaliser"), ParserAsync = module.exports = function(options) {
                ChunkStream.call(this), this._parser = new Parser(options, {
                    read: this.read.bind(this),
                    error: this._handleError.bind(this),
                    metadata: this._handleMetaData.bind(this),
                    gamma: this.emit.bind(this, "gamma"),
                    palette: this._handlePalette.bind(this),
                    transColor: this._handleTransColor.bind(this),
                    finished: this._finished.bind(this),
                    inflateData: this._inflateData.bind(this)
                }), this._options = options, this.writable = !0, this._parser.start();
            };
            util.inherits(ParserAsync, ChunkStream), ParserAsync.prototype._handleError = function(err) {
                this.emit("error", err), this.writable = !1, this.destroy(), this._inflate && this._inflate.destroy && this._inflate.destroy(), 
                this._filter && (this._filter.destroy(), this._filter.on("error", (function() {}))), 
                this.errord = !0;
            }, ParserAsync.prototype._inflateData = function(data) {
                if (!this._inflate) if (this._bitmapInfo.interlace) this._inflate = zlib.createInflate(), 
                this._inflate.on("error", this.emit.bind(this, "error")), this._filter.on("complete", this._complete.bind(this)), 
                this._inflate.pipe(this._filter); else {
                    var imageSize = (1 + (this._bitmapInfo.width * this._bitmapInfo.bpp * this._bitmapInfo.depth + 7 >> 3)) * this._bitmapInfo.height, chunkSize = Math.max(imageSize, zlib.Z_MIN_CHUNK);
                    this._inflate = zlib.createInflate({
                        chunkSize
                    });
                    var leftToInflate = imageSize, emitError = this.emit.bind(this, "error");
                    this._inflate.on("error", (function(err) {
                        leftToInflate && emitError(err);
                    })), this._filter.on("complete", this._complete.bind(this));
                    var filterWrite = this._filter.write.bind(this._filter);
                    this._inflate.on("data", (function(chunk) {
                        leftToInflate && (chunk.length > leftToInflate && (chunk = chunk.slice(0, leftToInflate)), 
                        leftToInflate -= chunk.length, filterWrite(chunk));
                    })), this._inflate.on("end", this._filter.end.bind(this._filter));
                }
                this._inflate.write(data);
            }, ParserAsync.prototype._handleMetaData = function(metaData) {
                this.emit("metadata", metaData), this._bitmapInfo = Object.create(metaData), this._filter = new FilterAsync(this._bitmapInfo);
            }, ParserAsync.prototype._handleTransColor = function(transColor) {
                this._bitmapInfo.transColor = transColor;
            }, ParserAsync.prototype._handlePalette = function(palette) {
                this._bitmapInfo.palette = palette;
            }, ParserAsync.prototype._finished = function() {
                this.errord || (this._inflate ? this._inflate.end() : this.emit("error", "No Inflate block"), 
                this.destroySoon());
            }, ParserAsync.prototype._complete = function(filteredData) {
                if (!this.errord) {
                    try {
                        var bitmapData = bitmapper.dataToBitMap(filteredData, this._bitmapInfo), normalisedBitmapData = formatNormaliser(bitmapData, this._bitmapInfo);
                        bitmapData = null;
                    } catch (ex) {
                        return void this._handleError(ex);
                    }
                    this.emit("parsed", normalisedBitmapData);
                }
            };
        }, {
            "./bitmapper": 110,
            "./chunkstream": 112,
            "./filter-parse-async": 116,
            "./format-normaliser": 119,
            "./parser": 127,
            util: 186,
            zlib: 35
        } ],
        126: [ function(require, module, exports) {
            (function(Buffer) {
                var hasSyncZlib = !0, zlib = require("zlib"), inflateSync = require("./sync-inflate");
                zlib.deflateSync || (hasSyncZlib = !1);
                var SyncReader = require("./sync-reader"), FilterSync = require("./filter-parse-sync"), Parser = require("./parser"), bitmapper = require("./bitmapper"), formatNormaliser = require("./format-normaliser");
                module.exports = function(buffer, options) {
                    if (!hasSyncZlib) throw new Error("To use the sync capability of this library in old node versions, please pin pngjs to v2.3.0");
                    var err, metaData, gamma, inflateDataList = [], reader = new SyncReader(buffer);
                    if (new Parser(options, {
                        read: reader.read.bind(reader),
                        error: function handleError(_err_) {
                            err = _err_;
                        },
                        metadata: function handleMetaData(_metaData_) {
                            metaData = _metaData_;
                        },
                        gamma: function handleGamma(_gamma_) {
                            gamma = _gamma_;
                        },
                        palette: function handlePalette(palette) {
                            metaData.palette = palette;
                        },
                        transColor: function handleTransColor(transColor) {
                            metaData.transColor = transColor;
                        },
                        inflateData: function handleInflateData(inflatedData) {
                            inflateDataList.push(inflatedData);
                        }
                    }).start(), reader.process(), err) throw err;
                    var inflatedData, inflateData = Buffer.concat(inflateDataList);
                    if (inflateDataList.length = 0, metaData.interlace) inflatedData = zlib.inflateSync(inflateData); else {
                        var imageSize = (1 + (metaData.width * metaData.bpp * metaData.depth + 7 >> 3)) * metaData.height;
                        inflatedData = inflateSync(inflateData, {
                            chunkSize: imageSize,
                            maxLength: imageSize
                        });
                    }
                    if (inflateData = null, !inflatedData || !inflatedData.length) throw new Error("bad png - invalid inflate data response");
                    var unfilteredData = FilterSync.process(inflatedData, metaData);
                    inflateData = null;
                    var bitmapData = bitmapper.dataToBitMap(unfilteredData, metaData);
                    unfilteredData = null;
                    var normalisedBitmapData = formatNormaliser(bitmapData, metaData);
                    return metaData.data = normalisedBitmapData, metaData.gamma = gamma || 0, metaData;
                };
            }).call(this, require("buffer").Buffer);
        }, {
            "./bitmapper": 110,
            "./filter-parse-sync": 117,
            "./format-normaliser": 119,
            "./parser": 127,
            "./sync-inflate": 130,
            "./sync-reader": 131,
            buffer: 48,
            zlib: 35
        } ],
        127: [ function(require, module, exports) {
            (function(Buffer) {
                var constants = require("./constants"), CrcCalculator = require("./crc"), Parser = module.exports = function(options, dependencies) {
                    this._options = options, options.checkCRC = !1 !== options.checkCRC, this._hasIHDR = !1, 
                    this._hasIEND = !1, this._palette = [], this._colorType = 0, this._chunks = {}, 
                    this._chunks[constants.TYPE_IHDR] = this._handleIHDR.bind(this), this._chunks[constants.TYPE_IEND] = this._handleIEND.bind(this), 
                    this._chunks[constants.TYPE_IDAT] = this._handleIDAT.bind(this), this._chunks[constants.TYPE_PLTE] = this._handlePLTE.bind(this), 
                    this._chunks[constants.TYPE_tRNS] = this._handleTRNS.bind(this), this._chunks[constants.TYPE_gAMA] = this._handleGAMA.bind(this), 
                    this.read = dependencies.read, this.error = dependencies.error, this.metadata = dependencies.metadata, 
                    this.gamma = dependencies.gamma, this.transColor = dependencies.transColor, this.palette = dependencies.palette, 
                    this.parsed = dependencies.parsed, this.inflateData = dependencies.inflateData, 
                    this.finished = dependencies.finished;
                };
                Parser.prototype.start = function() {
                    this.read(constants.PNG_SIGNATURE.length, this._parseSignature.bind(this));
                }, Parser.prototype._parseSignature = function(data) {
                    for (var signature = constants.PNG_SIGNATURE, i = 0; i < signature.length; i++) if (data[i] !== signature[i]) return void this.error(new Error("Invalid file signature"));
                    this.read(8, this._parseChunkBegin.bind(this));
                }, Parser.prototype._parseChunkBegin = function(data) {
                    for (var length = data.readUInt32BE(0), type = data.readUInt32BE(4), name = "", i = 4; i < 8; i++) name += String.fromCharCode(data[i]);
                    var ancillary = Boolean(0x20 & data[4]);
                    if (this._hasIHDR || type === constants.TYPE_IHDR) {
                        if (this._crc = new CrcCalculator, this._crc.write(new Buffer(name)), this._chunks[type]) return this._chunks[type](length);
                        ancillary ? this.read(length + 4, this._skipChunk.bind(this)) : this.error(new Error("Unsupported critical chunk type " + name));
                    } else this.error(new Error("Expected IHDR on beggining"));
                }, Parser.prototype._skipChunk = function() {
                    this.read(8, this._parseChunkBegin.bind(this));
                }, Parser.prototype._handleChunkEnd = function() {
                    this.read(4, this._parseChunkEnd.bind(this));
                }, Parser.prototype._parseChunkEnd = function(data) {
                    var fileCrc = data.readInt32BE(0), calcCrc = this._crc.crc32();
                    this._options.checkCRC && calcCrc !== fileCrc ? this.error(new Error("Crc error - " + fileCrc + " - " + calcCrc)) : this._hasIEND || this.read(8, this._parseChunkBegin.bind(this));
                }, Parser.prototype._handleIHDR = function(length) {
                    this.read(length, this._parseIHDR.bind(this));
                }, Parser.prototype._parseIHDR = function(data) {
                    this._crc.write(data);
                    var width = data.readUInt32BE(0), height = data.readUInt32BE(4), depth = data[8], colorType = data[9], compr = data[10], filter = data[11], interlace = data[12];
                    if (8 === depth || 4 === depth || 2 === depth || 1 === depth || 16 === depth) if (colorType in constants.COLORTYPE_TO_BPP_MAP) if (0 === compr) if (0 === filter) if (0 === interlace || 1 === interlace) {
                        this._colorType = colorType;
                        var bpp = constants.COLORTYPE_TO_BPP_MAP[this._colorType];
                        this._hasIHDR = !0, this.metadata({
                            width,
                            height,
                            depth,
                            interlace: Boolean(interlace),
                            palette: Boolean(colorType & constants.COLORTYPE_PALETTE),
                            color: Boolean(colorType & constants.COLORTYPE_COLOR),
                            alpha: Boolean(colorType & constants.COLORTYPE_ALPHA),
                            bpp,
                            colorType
                        }), this._handleChunkEnd();
                    } else this.error(new Error("Unsupported interlace method")); else this.error(new Error("Unsupported filter method")); else this.error(new Error("Unsupported compression method")); else this.error(new Error("Unsupported color type")); else this.error(new Error("Unsupported bit depth " + depth));
                }, Parser.prototype._handlePLTE = function(length) {
                    this.read(length, this._parsePLTE.bind(this));
                }, Parser.prototype._parsePLTE = function(data) {
                    this._crc.write(data);
                    for (var entries = Math.floor(data.length / 3), i = 0; i < entries; i++) this._palette.push([ data[3 * i], data[3 * i + 1], data[3 * i + 2], 0xff ]);
                    this.palette(this._palette), this._handleChunkEnd();
                }, Parser.prototype._handleTRNS = function(length) {
                    this.read(length, this._parseTRNS.bind(this));
                }, Parser.prototype._parseTRNS = function(data) {
                    if (this._crc.write(data), this._colorType === constants.COLORTYPE_PALETTE_COLOR) {
                        if (0 === this._palette.length) return void this.error(new Error("Transparency chunk must be after palette"));
                        if (data.length > this._palette.length) return void this.error(new Error("More transparent colors than palette size"));
                        for (var i = 0; i < data.length; i++) this._palette[i][3] = data[i];
                        this.palette(this._palette);
                    }
                    this._colorType === constants.COLORTYPE_GRAYSCALE && this.transColor([ data.readUInt16BE(0) ]), 
                    this._colorType === constants.COLORTYPE_COLOR && this.transColor([ data.readUInt16BE(0), data.readUInt16BE(2), data.readUInt16BE(4) ]), 
                    this._handleChunkEnd();
                }, Parser.prototype._handleGAMA = function(length) {
                    this.read(length, this._parseGAMA.bind(this));
                }, Parser.prototype._parseGAMA = function(data) {
                    this._crc.write(data), this.gamma(data.readUInt32BE(0) / constants.GAMMA_DIVISION), 
                    this._handleChunkEnd();
                }, Parser.prototype._handleIDAT = function(length) {
                    this.read(-length, this._parseIDAT.bind(this, length));
                }, Parser.prototype._parseIDAT = function(length, data) {
                    if (this._crc.write(data), this._colorType === constants.COLORTYPE_PALETTE_COLOR && 0 === this._palette.length) throw new Error("Expected palette not found");
                    this.inflateData(data);
                    var leftOverLength = length - data.length;
                    leftOverLength > 0 ? this._handleIDAT(leftOverLength) : this._handleChunkEnd();
                }, Parser.prototype._handleIEND = function(length) {
                    this.read(length, this._parseIEND.bind(this));
                }, Parser.prototype._parseIEND = function(data) {
                    this._crc.write(data), this._hasIEND = !0, this._handleChunkEnd(), this.finished && this.finished();
                };
            }).call(this, require("buffer").Buffer);
        }, {
            "./constants": 113,
            "./crc": 114,
            buffer: 48
        } ],
        128: [ function(require, module, exports) {
            var parse = require("./parser-sync"), pack = require("./packer-sync");
            exports.read = function(buffer, options) {
                return parse(buffer, options || {});
            }, exports.write = function(png, options) {
                return pack(png, options);
            };
        }, {
            "./packer-sync": 122,
            "./parser-sync": 126
        } ],
        129: [ function(require, module, exports) {
            (function(process, Buffer) {
                var util = require("util"), Stream = require("stream"), Parser = require("./parser-async"), Packer = require("./packer-async"), PNGSync = require("./png-sync"), PNG = exports.PNG = function(options) {
                    Stream.call(this), options = options || {}, this.width = 0 | options.width, this.height = 0 | options.height, 
                    this.data = this.width > 0 && this.height > 0 ? new Buffer(4 * this.width * this.height) : null, 
                    options.fill && this.data && this.data.fill(0), this.gamma = 0, this.readable = this.writable = !0, 
                    this._parser = new Parser(options), this._parser.on("error", this.emit.bind(this, "error")), 
                    this._parser.on("close", this._handleClose.bind(this)), this._parser.on("metadata", this._metadata.bind(this)), 
                    this._parser.on("gamma", this._gamma.bind(this)), this._parser.on("parsed", function(data) {
                        this.data = data, this.emit("parsed", data);
                    }.bind(this)), this._packer = new Packer(options), this._packer.on("data", this.emit.bind(this, "data")), 
                    this._packer.on("end", this.emit.bind(this, "end")), this._parser.on("close", this._handleClose.bind(this)), 
                    this._packer.on("error", this.emit.bind(this, "error"));
                };
                util.inherits(PNG, Stream), PNG.sync = PNGSync, PNG.prototype.pack = function() {
                    return this.data && this.data.length ? (process.nextTick(function() {
                        this._packer.pack(this.data, this.width, this.height, this.gamma);
                    }.bind(this)), this) : (this.emit("error", "No data provided"), this);
                }, PNG.prototype.parse = function(data, callback) {
                    var onParsed, onError;
                    return callback && (onParsed = function(parsedData) {
                        this.removeListener("error", onError), this.data = parsedData, callback(null, this);
                    }.bind(this), onError = function(err) {
                        this.removeListener("parsed", onParsed), callback(err, null);
                    }.bind(this), this.once("parsed", onParsed), this.once("error", onError)), this.end(data), 
                    this;
                }, PNG.prototype.write = function(data) {
                    return this._parser.write(data), !0;
                }, PNG.prototype.end = function(data) {
                    this._parser.end(data);
                }, PNG.prototype._metadata = function(metadata) {
                    this.width = metadata.width, this.height = metadata.height, this.emit("metadata", metadata);
                }, PNG.prototype._gamma = function(gamma) {
                    this.gamma = gamma;
                }, PNG.prototype._handleClose = function() {
                    this._parser.writable || this._packer.readable || this.emit("close");
                }, PNG.bitblt = function(src, dst, srcX, srcY, width, height, deltaX, deltaY) {
                    if (srcY |= 0, width |= 0, height |= 0, deltaX |= 0, deltaY |= 0, (srcX |= 0) > src.width || srcY > src.height || srcX + width > src.width || srcY + height > src.height) throw new Error("bitblt reading outside image");
                    if (deltaX > dst.width || deltaY > dst.height || deltaX + width > dst.width || deltaY + height > dst.height) throw new Error("bitblt writing outside image");
                    for (var y = 0; y < height; y++) src.data.copy(dst.data, (deltaY + y) * dst.width + deltaX << 2, (srcY + y) * src.width + srcX << 2, (srcY + y) * src.width + srcX + width << 2);
                }, PNG.prototype.bitblt = function(dst, srcX, srcY, width, height, deltaX, deltaY) {
                    return PNG.bitblt(this, dst, srcX, srcY, width, height, deltaX, deltaY), this;
                }, PNG.adjustGamma = function(src) {
                    if (src.gamma) {
                        for (var y = 0; y < src.height; y++) for (var x = 0; x < src.width; x++) for (var idx = src.width * y + x << 2, i = 0; i < 3; i++) {
                            var sample = src.data[idx + i] / 255;
                            sample = Math.pow(sample, 1 / 2.2 / src.gamma), src.data[idx + i] = Math.round(255 * sample);
                        }
                        src.gamma = 0;
                    }
                }, PNG.prototype.adjustGamma = function() {
                    PNG.adjustGamma(this);
                };
            }).call(this, require("_process"), require("buffer").Buffer);
        }, {
            "./packer-async": 121,
            "./parser-async": 125,
            "./png-sync": 128,
            _process: 133,
            buffer: 48,
            stream: 155,
            util: 186
        } ],
        130: [ function(require, module, exports) {
            (function(process, Buffer) {
                var assert = require("assert").ok, zlib = require("zlib"), util = require("util"), kMaxLength = require("buffer").kMaxLength;
                function Inflate(opts) {
                    if (!(this instanceof Inflate)) return new Inflate(opts);
                    opts && opts.chunkSize < zlib.Z_MIN_CHUNK && (opts.chunkSize = zlib.Z_MIN_CHUNK), 
                    zlib.Inflate.call(this, opts), this._offset = void 0 === this._offset ? this._outOffset : this._offset, 
                    this._buffer = this._buffer || this._outBuffer, opts && null != opts.maxLength && (this._maxLength = opts.maxLength);
                }
                function _close(engine, callback) {
                    callback && process.nextTick(callback), engine._handle && (engine._handle.close(), 
                    engine._handle = null);
                }
                function inflateSync(buffer, opts) {
                    return function zlibBufferSync(engine, buffer) {
                        if ("string" == typeof buffer && (buffer = Buffer.from(buffer)), !(buffer instanceof Buffer)) throw new TypeError("Not a string or buffer");
                        var flushFlag = engine._finishFlushFlag;
                        return null == flushFlag && (flushFlag = zlib.Z_FINISH), engine._processChunk(buffer, flushFlag);
                    }(new Inflate(opts), buffer);
                }
                Inflate.prototype._processChunk = function(chunk, flushFlag, asyncCb) {
                    if ("function" == typeof asyncCb) return zlib.Inflate._processChunk.call(this, chunk, flushFlag, asyncCb);
                    var error, self = this, availInBefore = chunk && chunk.length, availOutBefore = this._chunkSize - this._offset, leftToInflate = this._maxLength, inOff = 0, buffers = [], nread = 0;
                    function handleChunk(availInAfter, availOutAfter) {
                        if (!self._hadError) {
                            var have = availOutBefore - availOutAfter;
                            if (assert(have >= 0, "have should not go down"), have > 0) {
                                var out = self._buffer.slice(self._offset, self._offset + have);
                                if (self._offset += have, out.length > leftToInflate && (out = out.slice(0, leftToInflate)), 
                                buffers.push(out), nread += out.length, 0 == (leftToInflate -= out.length)) return !1;
                            }
                            return (0 === availOutAfter || self._offset >= self._chunkSize) && (availOutBefore = self._chunkSize, 
                            self._offset = 0, self._buffer = Buffer.allocUnsafe(self._chunkSize)), 0 === availOutAfter && (inOff += availInBefore - availInAfter, 
                            availInBefore = availInAfter, !0);
                        }
                    }
                    this.on("error", (function(err) {
                        error = err;
                    })), assert(this._handle, "zlib binding closed");
                    do {
                        var res = this._handle.writeSync(flushFlag, chunk, inOff, availInBefore, this._buffer, this._offset, availOutBefore);
                        res = res || this._writeState;
                    } while (!this._hadError && handleChunk(res[0], res[1]));
                    if (this._hadError) throw error;
                    if (nread >= kMaxLength) throw _close(this), new RangeError("Cannot create final Buffer. It would be larger than 0x" + kMaxLength.toString(16) + " bytes");
                    var buf = Buffer.concat(buffers, nread);
                    return _close(this), buf;
                }, util.inherits(Inflate, zlib.Inflate), module.exports = exports = inflateSync, 
                exports.Inflate = Inflate, exports.createInflate = function createInflate(opts) {
                    return new Inflate(opts);
                }, exports.inflateSync = inflateSync;
            }).call(this, require("_process"), require("buffer").Buffer);
        }, {
            _process: 133,
            assert: 25,
            buffer: 48,
            util: 186,
            zlib: 35
        } ],
        131: [ function(require, module, exports) {
            var SyncReader = module.exports = function(buffer) {
                this._buffer = buffer, this._reads = [];
            };
            SyncReader.prototype.read = function(length, callback) {
                this._reads.push({
                    length: Math.abs(length),
                    allowLess: length < 0,
                    func: callback
                });
            }, SyncReader.prototype.process = function() {
                for (;this._reads.length > 0 && this._buffer.length; ) {
                    var read = this._reads[0];
                    if (!this._buffer.length || !(this._buffer.length >= read.length || read.allowLess)) break;
                    this._reads.shift();
                    var buf = this._buffer;
                    this._buffer = buf.slice(read.length), read.func.call(this, buf.slice(0, read.length));
                }
                return this._reads.length > 0 ? new Error("There are some read requests waitng on finished stream") : this._buffer.length > 0 ? new Error("unrecognised content at end of stream") : void 0;
            };
        }, {} ],
        132: [ function(require, module, exports) {
            (function(process) {
                void 0 === process || !process.version || 0 === process.version.indexOf("v0.") || 0 === process.version.indexOf("v1.") && 0 !== process.version.indexOf("v1.8.") ? module.exports = {
                    nextTick: function nextTick(fn, arg1, arg2, arg3) {
                        if ("function" != typeof fn) throw new TypeError('"callback" argument must be a function');
                        var args, i, len = arguments.length;
                        switch (len) {
                          case 0:
                          case 1:
                            return process.nextTick(fn);

                          case 2:
                            return process.nextTick((function afterTickOne() {
                                fn.call(null, arg1);
                            }));

                          case 3:
                            return process.nextTick((function afterTickTwo() {
                                fn.call(null, arg1, arg2);
                            }));

                          case 4:
                            return process.nextTick((function afterTickThree() {
                                fn.call(null, arg1, arg2, arg3);
                            }));

                          default:
                            for (args = new Array(len - 1), i = 0; i < args.length; ) args[i++] = arguments[i];
                            return process.nextTick((function afterTick() {
                                fn.apply(null, args);
                            }));
                        }
                    }
                } : module.exports = process;
            }).call(this, require("_process"));
        }, {
            _process: 133
        } ],
        133: [ function(require, module, exports) {
            var cachedSetTimeout, cachedClearTimeout, process = module.exports = {};
            function defaultSetTimout() {
                throw new Error("setTimeout has not been defined");
            }
            function defaultClearTimeout() {
                throw new Error("clearTimeout has not been defined");
            }
            function runTimeout(fun) {
                if (cachedSetTimeout === setTimeout) return setTimeout(fun, 0);
                if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) return cachedSetTimeout = setTimeout, 
                setTimeout(fun, 0);
                try {
                    return cachedSetTimeout(fun, 0);
                } catch (e) {
                    try {
                        return cachedSetTimeout.call(null, fun, 0);
                    } catch (e) {
                        return cachedSetTimeout.call(this, fun, 0);
                    }
                }
            }
            !function() {
                try {
                    cachedSetTimeout = "function" == typeof setTimeout ? setTimeout : defaultSetTimout;
                } catch (e) {
                    cachedSetTimeout = defaultSetTimout;
                }
                try {
                    cachedClearTimeout = "function" == typeof clearTimeout ? clearTimeout : defaultClearTimeout;
                } catch (e) {
                    cachedClearTimeout = defaultClearTimeout;
                }
            }();
            var currentQueue, queue = [], draining = !1, queueIndex = -1;
            function cleanUpNextTick() {
                draining && currentQueue && (draining = !1, currentQueue.length ? queue = currentQueue.concat(queue) : queueIndex = -1, 
                queue.length && drainQueue());
            }
            function drainQueue() {
                if (!draining) {
                    var timeout = runTimeout(cleanUpNextTick);
                    draining = !0;
                    for (var len = queue.length; len; ) {
                        for (currentQueue = queue, queue = []; ++queueIndex < len; ) currentQueue && currentQueue[queueIndex].run();
                        queueIndex = -1, len = queue.length;
                    }
                    currentQueue = null, draining = !1, function runClearTimeout(marker) {
                        if (cachedClearTimeout === clearTimeout) return clearTimeout(marker);
                        if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) return cachedClearTimeout = clearTimeout, 
                        clearTimeout(marker);
                        try {
                            cachedClearTimeout(marker);
                        } catch (e) {
                            try {
                                return cachedClearTimeout.call(null, marker);
                            } catch (e) {
                                return cachedClearTimeout.call(this, marker);
                            }
                        }
                    }(timeout);
                }
            }
            function Item(fun, array) {
                this.fun = fun, this.array = array;
            }
            function noop() {}
            process.nextTick = function(fun) {
                var args = new Array(arguments.length - 1);
                if (arguments.length > 1) for (var i = 1; i < arguments.length; i++) args[i - 1] = arguments[i];
                queue.push(new Item(fun, args)), 1 !== queue.length || draining || runTimeout(drainQueue);
            }, Item.prototype.run = function() {
                this.fun.apply(null, this.array);
            }, process.title = "browser", process.browser = !0, process.env = {}, process.argv = [], 
            process.version = "", process.versions = {}, process.on = noop, process.addListener = noop, 
            process.once = noop, process.off = noop, process.removeListener = noop, process.removeAllListeners = noop, 
            process.emit = noop, process.prependListener = noop, process.prependOnceListener = noop, 
            process.listeners = function(name) {
                return [];
            }, process.binding = function(name) {
                throw new Error("process.binding is not supported");
            }, process.cwd = function() {
                return "/";
            }, process.chdir = function(dir) {
                throw new Error("process.chdir is not supported");
            }, process.umask = function() {
                return 0;
            };
        }, {} ],
        134: [ function(require, module, exports) {
            (function(global) {
                !function(root) {
                    var freeExports = "object" == typeof exports && exports && !exports.nodeType && exports, freeModule = "object" == typeof module && module && !module.nodeType && module, freeGlobal = "object" == typeof global && global;
                    freeGlobal.global !== freeGlobal && freeGlobal.window !== freeGlobal && freeGlobal.self !== freeGlobal || (root = freeGlobal);
                    var punycode, key, maxInt = 2147483647, regexPunycode = /^xn--/, regexNonASCII = /[^\x20-\x7E]/, regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, errors = {
                        overflow: "Overflow: input needs wider integers to process",
                        "not-basic": "Illegal input >= 0x80 (not a basic code point)",
                        "invalid-input": "Invalid input"
                    }, floor = Math.floor, stringFromCharCode = String.fromCharCode;
                    function error(type) {
                        throw new RangeError(errors[type]);
                    }
                    function map(array, fn) {
                        for (var length = array.length, result = []; length--; ) result[length] = fn(array[length]);
                        return result;
                    }
                    function mapDomain(string, fn) {
                        var parts = string.split("@"), result = "";
                        return parts.length > 1 && (result = parts[0] + "@", string = parts[1]), result + map((string = string.replace(regexSeparators, ".")).split("."), fn).join(".");
                    }
                    function ucs2decode(string) {
                        for (var value, extra, output = [], counter = 0, length = string.length; counter < length; ) (value = string.charCodeAt(counter++)) >= 0xD800 && value <= 0xDBFF && counter < length ? 0xDC00 == (0xFC00 & (extra = string.charCodeAt(counter++))) ? output.push(((0x3FF & value) << 10) + (0x3FF & extra) + 0x10000) : (output.push(value), 
                        counter--) : output.push(value);
                        return output;
                    }
                    function ucs2encode(array) {
                        return map(array, (function(value) {
                            var output = "";
                            return value > 0xFFFF && (output += stringFromCharCode((value -= 0x10000) >>> 10 & 0x3FF | 0xD800), 
                            value = 0xDC00 | 0x3FF & value), output + stringFromCharCode(value);
                        })).join("");
                    }
                    function digitToBasic(digit, flag) {
                        return digit + 22 + 75 * (digit < 26) - ((0 != flag) << 5);
                    }
                    function adapt(delta, numPoints, firstTime) {
                        var k = 0;
                        for (delta = firstTime ? floor(delta / 700) : delta >> 1, delta += floor(delta / numPoints); delta > 455; k += 36) delta = floor(delta / 35);
                        return floor(k + 36 * delta / (delta + 38));
                    }
                    function decode(input) {
                        var out, basic, j, index, oldi, w, k, digit, t, baseMinusT, codePoint, output = [], inputLength = input.length, i = 0, n = 128, bias = 72;
                        for ((basic = input.lastIndexOf("-")) < 0 && (basic = 0), j = 0; j < basic; ++j) input.charCodeAt(j) >= 0x80 && error("not-basic"), 
                        output.push(input.charCodeAt(j));
                        for (index = basic > 0 ? basic + 1 : 0; index < inputLength; ) {
                            for (oldi = i, w = 1, k = 36; index >= inputLength && error("invalid-input"), ((digit = (codePoint = input.charCodeAt(index++)) - 48 < 10 ? codePoint - 22 : codePoint - 65 < 26 ? codePoint - 65 : codePoint - 97 < 26 ? codePoint - 97 : 36) >= 36 || digit > floor((maxInt - i) / w)) && error("overflow"), 
                            i += digit * w, !(digit < (t = k <= bias ? 1 : k >= bias + 26 ? 26 : k - bias)); k += 36) w > floor(maxInt / (baseMinusT = 36 - t)) && error("overflow"), 
                            w *= baseMinusT;
                            bias = adapt(i - oldi, out = output.length + 1, 0 == oldi), floor(i / out) > maxInt - n && error("overflow"), 
                            n += floor(i / out), i %= out, output.splice(i++, 0, n);
                        }
                        return ucs2encode(output);
                    }
                    function encode(input) {
                        var n, delta, handledCPCount, basicLength, bias, j, m, q, k, t, currentValue, inputLength, handledCPCountPlusOne, baseMinusT, qMinusT, output = [];
                        for (inputLength = (input = ucs2decode(input)).length, n = 128, delta = 0, bias = 72, 
                        j = 0; j < inputLength; ++j) (currentValue = input[j]) < 0x80 && output.push(stringFromCharCode(currentValue));
                        for (handledCPCount = basicLength = output.length, basicLength && output.push("-"); handledCPCount < inputLength; ) {
                            for (m = maxInt, j = 0; j < inputLength; ++j) (currentValue = input[j]) >= n && currentValue < m && (m = currentValue);
                            for (m - n > floor((maxInt - delta) / (handledCPCountPlusOne = handledCPCount + 1)) && error("overflow"), 
                            delta += (m - n) * handledCPCountPlusOne, n = m, j = 0; j < inputLength; ++j) if ((currentValue = input[j]) < n && ++delta > maxInt && error("overflow"), 
                            currentValue == n) {
                                for (q = delta, k = 36; !(q < (t = k <= bias ? 1 : k >= bias + 26 ? 26 : k - bias)); k += 36) qMinusT = q - t, 
                                baseMinusT = 36 - t, output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))), 
                                q = floor(qMinusT / baseMinusT);
                                output.push(stringFromCharCode(digitToBasic(q, 0))), bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength), 
                                delta = 0, ++handledCPCount;
                            }
                            ++delta, ++n;
                        }
                        return output.join("");
                    }
                    if (punycode = {
                        version: "1.4.1",
                        ucs2: {
                            decode: ucs2decode,
                            encode: ucs2encode
                        },
                        decode,
                        encode,
                        toASCII: function toASCII(input) {
                            return mapDomain(input, (function(string) {
                                return regexNonASCII.test(string) ? "xn--" + encode(string) : string;
                            }));
                        },
                        toUnicode: function toUnicode(input) {
                            return mapDomain(input, (function(string) {
                                return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
                            }));
                        }
                    }, freeExports && freeModule) if (module.exports == freeExports) freeModule.exports = punycode; else for (key in punycode) punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]); else root.punycode = punycode;
                }(this);
            }).call(this, void 0 !== commonjsGlobal ? commonjsGlobal : "undefined" != typeof self ? self : void 0 !== window ? window : {});
        }, {} ],
        135: [ function(require, module, exports) {
            function hasOwnProperty(obj, prop) {
                return Object.prototype.hasOwnProperty.call(obj, prop);
            }
            module.exports = function(qs, sep, eq, options) {
                sep = sep || "&", eq = eq || "=";
                var obj = {};
                if ("string" != typeof qs || 0 === qs.length) return obj;
                var regexp = /\+/g;
                qs = qs.split(sep);
                var maxKeys = 1000;
                options && "number" == typeof options.maxKeys && (maxKeys = options.maxKeys);
                var len = qs.length;
                maxKeys > 0 && len > maxKeys && (len = maxKeys);
                for (var i = 0; i < len; ++i) {
                    var kstr, vstr, k, v, x = qs[i].replace(regexp, "%20"), idx = x.indexOf(eq);
                    idx >= 0 ? (kstr = x.substr(0, idx), vstr = x.substr(idx + 1)) : (kstr = x, vstr = ""), 
                    k = decodeURIComponent(kstr), v = decodeURIComponent(vstr), hasOwnProperty(obj, k) ? isArray(obj[k]) ? obj[k].push(v) : obj[k] = [ obj[k], v ] : obj[k] = v;
                }
                return obj;
            };
            var isArray = Array.isArray || function(xs) {
                return "[object Array]" === Object.prototype.toString.call(xs);
            };
        }, {} ],
        136: [ function(require, module, exports) {
            var stringifyPrimitive = function(v) {
                switch (typeof v) {
                  case "string":
                    return v;

                  case "boolean":
                    return v ? "true" : "false";

                  case "number":
                    return isFinite(v) ? v : "";

                  default:
                    return "";
                }
            };
            module.exports = function(obj, sep, eq, name) {
                return sep = sep || "&", eq = eq || "=", null === obj && (obj = void 0), "object" == typeof obj ? map(objectKeys(obj), (function(k) {
                    var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
                    return isArray(obj[k]) ? map(obj[k], (function(v) {
                        return ks + encodeURIComponent(stringifyPrimitive(v));
                    })).join(sep) : ks + encodeURIComponent(stringifyPrimitive(obj[k]));
                })).join(sep) : name ? encodeURIComponent(stringifyPrimitive(name)) + eq + encodeURIComponent(stringifyPrimitive(obj)) : "";
            };
            var isArray = Array.isArray || function(xs) {
                return "[object Array]" === Object.prototype.toString.call(xs);
            };
            function map(xs, f) {
                if (xs.map) return xs.map(f);
                for (var res = [], i = 0; i < xs.length; i++) res.push(f(xs[i], i));
                return res;
            }
            var objectKeys = Object.keys || function(obj) {
                var res = [];
                for (var key in obj) Object.prototype.hasOwnProperty.call(obj, key) && res.push(key);
                return res;
            };
        }, {} ],
        137: [ function(require, module, exports) {
            exports.decode = exports.parse = require("./decode"), exports.encode = exports.stringify = require("./encode");
        }, {
            "./decode": 135,
            "./encode": 136
        } ],
        138: [ function(require, module, exports) {
            module.exports = require("./lib/_stream_duplex.js");
        }, {
            "./lib/_stream_duplex.js": 139
        } ],
        139: [ function(require, module, exports) {
            var pna = require("process-nextick-args"), objectKeys = Object.keys || function(obj) {
                var keys = [];
                for (var key in obj) keys.push(key);
                return keys;
            };
            module.exports = Duplex;
            var util = require("core-util-is");
            util.inherits = require("inherits");
            var Readable = require("./_stream_readable"), Writable = require("./_stream_writable");
            util.inherits(Duplex, Readable);
            for (var keys = objectKeys(Writable.prototype), v = 0; v < keys.length; v++) {
                var method = keys[v];
                Duplex.prototype[method] || (Duplex.prototype[method] = Writable.prototype[method]);
            }
            function Duplex(options) {
                if (!(this instanceof Duplex)) return new Duplex(options);
                Readable.call(this, options), Writable.call(this, options), options && !1 === options.readable && (this.readable = !1), 
                options && !1 === options.writable && (this.writable = !1), this.allowHalfOpen = !0, 
                options && !1 === options.allowHalfOpen && (this.allowHalfOpen = !1), this.once("end", onend);
            }
            function onend() {
                this.allowHalfOpen || this._writableState.ended || pna.nextTick(onEndNT, this);
            }
            function onEndNT(self) {
                self.end();
            }
            Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
                enumerable: !1,
                get: function() {
                    return this._writableState.highWaterMark;
                }
            }), Object.defineProperty(Duplex.prototype, "destroyed", {
                get: function() {
                    return void 0 !== this._readableState && void 0 !== this._writableState && this._readableState.destroyed && this._writableState.destroyed;
                },
                set: function(value) {
                    void 0 !== this._readableState && void 0 !== this._writableState && (this._readableState.destroyed = value, 
                    this._writableState.destroyed = value);
                }
            }), Duplex.prototype._destroy = function(err, cb) {
                this.push(null), this.end(), pna.nextTick(cb, err);
            };
        }, {
            "./_stream_readable": 141,
            "./_stream_writable": 143,
            "core-util-is": 51,
            inherits: 75,
            "process-nextick-args": 132
        } ],
        140: [ function(require, module, exports) {
            module.exports = PassThrough;
            var Transform = require("./_stream_transform"), util = require("core-util-is");
            function PassThrough(options) {
                if (!(this instanceof PassThrough)) return new PassThrough(options);
                Transform.call(this, options);
            }
            util.inherits = require("inherits"), util.inherits(PassThrough, Transform), PassThrough.prototype._transform = function(chunk, encoding, cb) {
                cb(null, chunk);
            };
        }, {
            "./_stream_transform": 142,
            "core-util-is": 51,
            inherits: 75
        } ],
        141: [ function(require, module, exports) {
            (function(process, global) {
                var pna = require("process-nextick-args");
                module.exports = Readable;
                var Duplex, isArray = require("isarray");
                Readable.ReadableState = ReadableState, require("events").EventEmitter;
                var EElistenerCount = function(emitter, type) {
                    return emitter.listeners(type).length;
                }, Stream = require("./internal/streams/stream"), Buffer = require("safe-buffer").Buffer, OurUint8Array = global.Uint8Array || function() {}, util = require("core-util-is");
                util.inherits = require("inherits");
                var debugUtil = require("util"), debug = void 0;
                debug = debugUtil && debugUtil.debuglog ? debugUtil.debuglog("stream") : function() {};
                var StringDecoder, BufferList = require("./internal/streams/BufferList"), destroyImpl = require("./internal/streams/destroy");
                util.inherits(Readable, Stream);
                var kProxyEvents = [ "error", "close", "destroy", "pause", "resume" ];
                function ReadableState(options, stream) {
                    options = options || {};
                    var isDuplex = stream instanceof (Duplex = Duplex || require("./_stream_duplex"));
                    this.objectMode = !!options.objectMode, isDuplex && (this.objectMode = this.objectMode || !!options.readableObjectMode);
                    var hwm = options.highWaterMark, readableHwm = options.readableHighWaterMark, defaultHwm = this.objectMode ? 16 : 16384;
                    this.highWaterMark = hwm || 0 === hwm ? hwm : isDuplex && (readableHwm || 0 === readableHwm) ? readableHwm : defaultHwm, 
                    this.highWaterMark = Math.floor(this.highWaterMark), this.buffer = new BufferList, 
                    this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, 
                    this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, 
                    this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, 
                    this.destroyed = !1, this.defaultEncoding = options.defaultEncoding || "utf8", this.awaitDrain = 0, 
                    this.readingMore = !1, this.decoder = null, this.encoding = null, options.encoding && (StringDecoder || (StringDecoder = require("string_decoder/").StringDecoder), 
                    this.decoder = new StringDecoder(options.encoding), this.encoding = options.encoding);
                }
                function Readable(options) {
                    if (Duplex = Duplex || require("./_stream_duplex"), !(this instanceof Readable)) return new Readable(options);
                    this._readableState = new ReadableState(options, this), this.readable = !0, options && ("function" == typeof options.read && (this._read = options.read), 
                    "function" == typeof options.destroy && (this._destroy = options.destroy)), Stream.call(this);
                }
                function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
                    var er, state = stream._readableState;
                    return null === chunk ? (state.reading = !1, function onEofChunk(stream, state) {
                        if (!state.ended) {
                            if (state.decoder) {
                                var chunk = state.decoder.end();
                                chunk && chunk.length && (state.buffer.push(chunk), state.length += state.objectMode ? 1 : chunk.length);
                            }
                            state.ended = !0, emitReadable(stream);
                        }
                    }(stream, state)) : (skipChunkCheck || (er = function chunkInvalid(state, chunk) {
                        var er;
                        return function _isUint8Array(obj) {
                            return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
                        }(chunk) || "string" == typeof chunk || void 0 === chunk || state.objectMode || (er = new TypeError("Invalid non-string/buffer chunk")), 
                        er;
                    }(state, chunk)), er ? stream.emit("error", er) : state.objectMode || chunk && chunk.length > 0 ? ("string" == typeof chunk || state.objectMode || Object.getPrototypeOf(chunk) === Buffer.prototype || (chunk = function _uint8ArrayToBuffer(chunk) {
                        return Buffer.from(chunk);
                    }(chunk)), addToFront ? state.endEmitted ? stream.emit("error", new Error("stream.unshift() after end event")) : addChunk(stream, state, chunk, !0) : state.ended ? stream.emit("error", new Error("stream.push() after EOF")) : (state.reading = !1, 
                    state.decoder && !encoding ? (chunk = state.decoder.write(chunk), state.objectMode || 0 !== chunk.length ? addChunk(stream, state, chunk, !1) : maybeReadMore(stream, state)) : addChunk(stream, state, chunk, !1))) : addToFront || (state.reading = !1)), 
                    function needMoreData(state) {
                        return !state.ended && (state.needReadable || state.length < state.highWaterMark || 0 === state.length);
                    }(state);
                }
                function addChunk(stream, state, chunk, addToFront) {
                    state.flowing && 0 === state.length && !state.sync ? (stream.emit("data", chunk), 
                    stream.read(0)) : (state.length += state.objectMode ? 1 : chunk.length, addToFront ? state.buffer.unshift(chunk) : state.buffer.push(chunk), 
                    state.needReadable && emitReadable(stream)), maybeReadMore(stream, state);
                }
                function howMuchToRead(n, state) {
                    return n <= 0 || 0 === state.length && state.ended ? 0 : state.objectMode ? 1 : n != n ? state.flowing && state.length ? state.buffer.head.data.length : state.length : (n > state.highWaterMark && (state.highWaterMark = function computeNewHighWaterMark(n) {
                        return n >= 8388608 ? n = 8388608 : (n--, n |= n >>> 1, n |= n >>> 2, n |= n >>> 4, 
                        n |= n >>> 8, n |= n >>> 16, n++), n;
                    }(n)), n <= state.length ? n : state.ended ? state.length : (state.needReadable = !0, 
                    0));
                }
                function emitReadable(stream) {
                    var state = stream._readableState;
                    state.needReadable = !1, state.emittedReadable || (debug("emitReadable", state.flowing), 
                    state.emittedReadable = !0, state.sync ? pna.nextTick(emitReadable_, stream) : emitReadable_(stream));
                }
                function emitReadable_(stream) {
                    debug("emit readable"), stream.emit("readable"), flow(stream);
                }
                function maybeReadMore(stream, state) {
                    state.readingMore || (state.readingMore = !0, pna.nextTick(maybeReadMore_, stream, state));
                }
                function maybeReadMore_(stream, state) {
                    for (var len = state.length; !state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark && (debug("maybeReadMore read 0"), 
                    stream.read(0), len !== state.length); ) len = state.length;
                    state.readingMore = !1;
                }
                function nReadingNextTick(self) {
                    debug("readable nexttick read 0"), self.read(0);
                }
                function resume_(stream, state) {
                    state.reading || (debug("resume read 0"), stream.read(0)), state.resumeScheduled = !1, 
                    state.awaitDrain = 0, stream.emit("resume"), flow(stream), state.flowing && !state.reading && stream.read(0);
                }
                function flow(stream) {
                    var state = stream._readableState;
                    for (debug("flow", state.flowing); state.flowing && null !== stream.read(); ) ;
                }
                function fromList(n, state) {
                    return 0 === state.length ? null : (state.objectMode ? ret = state.buffer.shift() : !n || n >= state.length ? (ret = state.decoder ? state.buffer.join("") : 1 === state.buffer.length ? state.buffer.head.data : state.buffer.concat(state.length), 
                    state.buffer.clear()) : ret = function fromListPartial(n, list, hasStrings) {
                        var ret;
                        return n < list.head.data.length ? (ret = list.head.data.slice(0, n), list.head.data = list.head.data.slice(n)) : ret = n === list.head.data.length ? list.shift() : hasStrings ? function copyFromBufferString(n, list) {
                            var p = list.head, c = 1, ret = p.data;
                            for (n -= ret.length; p = p.next; ) {
                                var str = p.data, nb = n > str.length ? str.length : n;
                                if (nb === str.length ? ret += str : ret += str.slice(0, n), 0 == (n -= nb)) {
                                    nb === str.length ? (++c, p.next ? list.head = p.next : list.head = list.tail = null) : (list.head = p, 
                                    p.data = str.slice(nb));
                                    break;
                                }
                                ++c;
                            }
                            return list.length -= c, ret;
                        }(n, list) : function copyFromBuffer(n, list) {
                            var ret = Buffer.allocUnsafe(n), p = list.head, c = 1;
                            for (p.data.copy(ret), n -= p.data.length; p = p.next; ) {
                                var buf = p.data, nb = n > buf.length ? buf.length : n;
                                if (buf.copy(ret, ret.length - n, 0, nb), 0 == (n -= nb)) {
                                    nb === buf.length ? (++c, p.next ? list.head = p.next : list.head = list.tail = null) : (list.head = p, 
                                    p.data = buf.slice(nb));
                                    break;
                                }
                                ++c;
                            }
                            return list.length -= c, ret;
                        }(n, list), ret;
                    }(n, state.buffer, state.decoder), ret);
                    var ret;
                }
                function endReadable(stream) {
                    var state = stream._readableState;
                    if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');
                    state.endEmitted || (state.ended = !0, pna.nextTick(endReadableNT, state, stream));
                }
                function endReadableNT(state, stream) {
                    state.endEmitted || 0 !== state.length || (state.endEmitted = !0, stream.readable = !1, 
                    stream.emit("end"));
                }
                function indexOf(xs, x) {
                    for (var i = 0, l = xs.length; i < l; i++) if (xs[i] === x) return i;
                    return -1;
                }
                Object.defineProperty(Readable.prototype, "destroyed", {
                    get: function() {
                        return void 0 !== this._readableState && this._readableState.destroyed;
                    },
                    set: function(value) {
                        this._readableState && (this._readableState.destroyed = value);
                    }
                }), Readable.prototype.destroy = destroyImpl.destroy, Readable.prototype._undestroy = destroyImpl.undestroy, 
                Readable.prototype._destroy = function(err, cb) {
                    this.push(null), cb(err);
                }, Readable.prototype.push = function(chunk, encoding) {
                    var skipChunkCheck, state = this._readableState;
                    return state.objectMode ? skipChunkCheck = !0 : "string" == typeof chunk && ((encoding = encoding || state.defaultEncoding) !== state.encoding && (chunk = Buffer.from(chunk, encoding), 
                    encoding = ""), skipChunkCheck = !0), readableAddChunk(this, chunk, encoding, !1, skipChunkCheck);
                }, Readable.prototype.unshift = function(chunk) {
                    return readableAddChunk(this, chunk, null, !0, !1);
                }, Readable.prototype.isPaused = function() {
                    return !1 === this._readableState.flowing;
                }, Readable.prototype.setEncoding = function(enc) {
                    return StringDecoder || (StringDecoder = require("string_decoder/").StringDecoder), 
                    this._readableState.decoder = new StringDecoder(enc), this._readableState.encoding = enc, 
                    this;
                }, Readable.prototype.read = function(n) {
                    debug("read", n), n = parseInt(n, 10);
                    var state = this._readableState, nOrig = n;
                    if (0 !== n && (state.emittedReadable = !1), 0 === n && state.needReadable && (state.length >= state.highWaterMark || state.ended)) return debug("read: emitReadable", state.length, state.ended), 
                    0 === state.length && state.ended ? endReadable(this) : emitReadable(this), null;
                    if (0 === (n = howMuchToRead(n, state)) && state.ended) return 0 === state.length && endReadable(this), 
                    null;
                    var ret, doRead = state.needReadable;
                    return debug("need readable", doRead), (0 === state.length || state.length - n < state.highWaterMark) && debug("length less than watermark", doRead = !0), 
                    state.ended || state.reading ? debug("reading or ended", doRead = !1) : doRead && (debug("do read"), 
                    state.reading = !0, state.sync = !0, 0 === state.length && (state.needReadable = !0), 
                    this._read(state.highWaterMark), state.sync = !1, state.reading || (n = howMuchToRead(nOrig, state))), 
                    null === (ret = n > 0 ? fromList(n, state) : null) ? (state.needReadable = !0, n = 0) : state.length -= n, 
                    0 === state.length && (state.ended || (state.needReadable = !0), nOrig !== n && state.ended && endReadable(this)), 
                    null !== ret && this.emit("data", ret), ret;
                }, Readable.prototype._read = function(n) {
                    this.emit("error", new Error("_read() is not implemented"));
                }, Readable.prototype.pipe = function(dest, pipeOpts) {
                    var src = this, state = this._readableState;
                    switch (state.pipesCount) {
                      case 0:
                        state.pipes = dest;
                        break;

                      case 1:
                        state.pipes = [ state.pipes, dest ];
                        break;

                      default:
                        state.pipes.push(dest);
                    }
                    state.pipesCount += 1, debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
                    var endFn = pipeOpts && !1 === pipeOpts.end || dest === process.stdout || dest === process.stderr ? unpipe : onend;
                    function onend() {
                        debug("onend"), dest.end();
                    }
                    state.endEmitted ? pna.nextTick(endFn) : src.once("end", endFn), dest.on("unpipe", (function onunpipe(readable, unpipeInfo) {
                        debug("onunpipe"), readable === src && unpipeInfo && !1 === unpipeInfo.hasUnpiped && (unpipeInfo.hasUnpiped = !0, 
                        function cleanup() {
                            debug("cleanup"), dest.removeListener("close", onclose), dest.removeListener("finish", onfinish), 
                            dest.removeListener("drain", ondrain), dest.removeListener("error", onerror), dest.removeListener("unpipe", onunpipe), 
                            src.removeListener("end", onend), src.removeListener("end", unpipe), src.removeListener("data", ondata), 
                            cleanedUp = !0, !state.awaitDrain || dest._writableState && !dest._writableState.needDrain || ondrain();
                        }());
                    }));
                    var ondrain = function pipeOnDrain(src) {
                        return function() {
                            var state = src._readableState;
                            debug("pipeOnDrain", state.awaitDrain), state.awaitDrain && state.awaitDrain--, 
                            0 === state.awaitDrain && EElistenerCount(src, "data") && (state.flowing = !0, flow(src));
                        };
                    }(src);
                    dest.on("drain", ondrain);
                    var cleanedUp = !1, increasedAwaitDrain = !1;
                    function ondata(chunk) {
                        debug("ondata"), increasedAwaitDrain = !1, !1 !== dest.write(chunk) || increasedAwaitDrain || ((1 === state.pipesCount && state.pipes === dest || state.pipesCount > 1 && -1 !== indexOf(state.pipes, dest)) && !cleanedUp && (debug("false write response, pause", src._readableState.awaitDrain), 
                        src._readableState.awaitDrain++, increasedAwaitDrain = !0), src.pause());
                    }
                    function onerror(er) {
                        debug("onerror", er), unpipe(), dest.removeListener("error", onerror), 0 === EElistenerCount(dest, "error") && dest.emit("error", er);
                    }
                    function onclose() {
                        dest.removeListener("finish", onfinish), unpipe();
                    }
                    function onfinish() {
                        debug("onfinish"), dest.removeListener("close", onclose), unpipe();
                    }
                    function unpipe() {
                        debug("unpipe"), src.unpipe(dest);
                    }
                    return src.on("data", ondata), function prependListener(emitter, event, fn) {
                        if ("function" == typeof emitter.prependListener) return emitter.prependListener(event, fn);
                        emitter._events && emitter._events[event] ? isArray(emitter._events[event]) ? emitter._events[event].unshift(fn) : emitter._events[event] = [ fn, emitter._events[event] ] : emitter.on(event, fn);
                    }(dest, "error", onerror), dest.once("close", onclose), dest.once("finish", onfinish), 
                    dest.emit("pipe", src), state.flowing || (debug("pipe resume"), src.resume()), dest;
                }, Readable.prototype.unpipe = function(dest) {
                    var state = this._readableState, unpipeInfo = {
                        hasUnpiped: !1
                    };
                    if (0 === state.pipesCount) return this;
                    if (1 === state.pipesCount) return dest && dest !== state.pipes || (dest || (dest = state.pipes), 
                    state.pipes = null, state.pipesCount = 0, state.flowing = !1, dest && dest.emit("unpipe", this, unpipeInfo)), 
                    this;
                    if (!dest) {
                        var dests = state.pipes, len = state.pipesCount;
                        state.pipes = null, state.pipesCount = 0, state.flowing = !1;
                        for (var i = 0; i < len; i++) dests[i].emit("unpipe", this, unpipeInfo);
                        return this;
                    }
                    var index = indexOf(state.pipes, dest);
                    return -1 === index || (state.pipes.splice(index, 1), state.pipesCount -= 1, 1 === state.pipesCount && (state.pipes = state.pipes[0]), 
                    dest.emit("unpipe", this, unpipeInfo)), this;
                }, Readable.prototype.on = function(ev, fn) {
                    var res = Stream.prototype.on.call(this, ev, fn);
                    if ("data" === ev) !1 !== this._readableState.flowing && this.resume(); else if ("readable" === ev) {
                        var state = this._readableState;
                        state.endEmitted || state.readableListening || (state.readableListening = state.needReadable = !0, 
                        state.emittedReadable = !1, state.reading ? state.length && emitReadable(this) : pna.nextTick(nReadingNextTick, this));
                    }
                    return res;
                }, Readable.prototype.addListener = Readable.prototype.on, Readable.prototype.resume = function() {
                    var state = this._readableState;
                    return state.flowing || (debug("resume"), state.flowing = !0, function resume(stream, state) {
                        state.resumeScheduled || (state.resumeScheduled = !0, pna.nextTick(resume_, stream, state));
                    }(this, state)), this;
                }, Readable.prototype.pause = function() {
                    return debug("call pause flowing=%j", this._readableState.flowing), !1 !== this._readableState.flowing && (debug("pause"), 
                    this._readableState.flowing = !1, this.emit("pause")), this;
                }, Readable.prototype.wrap = function(stream) {
                    var _this = this, state = this._readableState, paused = !1;
                    for (var i in stream.on("end", (function() {
                        if (debug("wrapped end"), state.decoder && !state.ended) {
                            var chunk = state.decoder.end();
                            chunk && chunk.length && _this.push(chunk);
                        }
                        _this.push(null);
                    })), stream.on("data", (function(chunk) {
                        debug("wrapped data"), state.decoder && (chunk = state.decoder.write(chunk)), state.objectMode && null == chunk || (state.objectMode || chunk && chunk.length) && (_this.push(chunk) || (paused = !0, 
                        stream.pause()));
                    })), stream) void 0 === this[i] && "function" == typeof stream[i] && (this[i] = function(method) {
                        return function() {
                            return stream[method].apply(stream, arguments);
                        };
                    }(i));
                    for (var n = 0; n < kProxyEvents.length; n++) stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
                    return this._read = function(n) {
                        debug("wrapped _read", n), paused && (paused = !1, stream.resume());
                    }, this;
                }, Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
                    enumerable: !1,
                    get: function() {
                        return this._readableState.highWaterMark;
                    }
                }), Readable._fromList = fromList;
            }).call(this, require("_process"), void 0 !== commonjsGlobal ? commonjsGlobal : "undefined" != typeof self ? self : void 0 !== window ? window : {});
        }, {
            "./_stream_duplex": 139,
            "./internal/streams/BufferList": 144,
            "./internal/streams/destroy": 145,
            "./internal/streams/stream": 146,
            _process: 133,
            "core-util-is": 51,
            events: 52,
            inherits: 75,
            isarray: 79,
            "process-nextick-args": 132,
            "safe-buffer": 147,
            "string_decoder/": 148,
            util: 33
        } ],
        142: [ function(require, module, exports) {
            module.exports = Transform;
            var Duplex = require("./_stream_duplex"), util = require("core-util-is");
            function afterTransform(er, data) {
                var ts = this._transformState;
                ts.transforming = !1;
                var cb = ts.writecb;
                if (!cb) return this.emit("error", new Error("write callback called multiple times"));
                ts.writechunk = null, ts.writecb = null, null != data && this.push(data), cb(er);
                var rs = this._readableState;
                rs.reading = !1, (rs.needReadable || rs.length < rs.highWaterMark) && this._read(rs.highWaterMark);
            }
            function Transform(options) {
                if (!(this instanceof Transform)) return new Transform(options);
                Duplex.call(this, options), this._transformState = {
                    afterTransform: afterTransform.bind(this),
                    needTransform: !1,
                    transforming: !1,
                    writecb: null,
                    writechunk: null,
                    writeencoding: null
                }, this._readableState.needReadable = !0, this._readableState.sync = !1, options && ("function" == typeof options.transform && (this._transform = options.transform), 
                "function" == typeof options.flush && (this._flush = options.flush)), this.on("prefinish", prefinish);
            }
            function prefinish() {
                var _this = this;
                "function" == typeof this._flush ? this._flush((function(er, data) {
                    done(_this, er, data);
                })) : done(this, null, null);
            }
            function done(stream, er, data) {
                if (er) return stream.emit("error", er);
                if (null != data && stream.push(data), stream._writableState.length) throw new Error("Calling transform done when ws.length != 0");
                if (stream._transformState.transforming) throw new Error("Calling transform done when still transforming");
                return stream.push(null);
            }
            util.inherits = require("inherits"), util.inherits(Transform, Duplex), Transform.prototype.push = function(chunk, encoding) {
                return this._transformState.needTransform = !1, Duplex.prototype.push.call(this, chunk, encoding);
            }, Transform.prototype._transform = function(chunk, encoding, cb) {
                throw new Error("_transform() is not implemented");
            }, Transform.prototype._write = function(chunk, encoding, cb) {
                var ts = this._transformState;
                if (ts.writecb = cb, ts.writechunk = chunk, ts.writeencoding = encoding, !ts.transforming) {
                    var rs = this._readableState;
                    (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) && this._read(rs.highWaterMark);
                }
            }, Transform.prototype._read = function(n) {
                var ts = this._transformState;
                null !== ts.writechunk && ts.writecb && !ts.transforming ? (ts.transforming = !0, 
                this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform)) : ts.needTransform = !0;
            }, Transform.prototype._destroy = function(err, cb) {
                var _this2 = this;
                Duplex.prototype._destroy.call(this, err, (function(err2) {
                    cb(err2), _this2.emit("close");
                }));
            };
        }, {
            "./_stream_duplex": 139,
            "core-util-is": 51,
            inherits: 75
        } ],
        143: [ function(require, module, exports) {
            (function(process, global, setImmediate) {
                var pna = require("process-nextick-args");
                function CorkedRequest(state) {
                    var _this = this;
                    this.next = null, this.entry = null, this.finish = function() {
                        !function onCorkedFinish(corkReq, state, err) {
                            var entry = corkReq.entry;
                            for (corkReq.entry = null; entry; ) {
                                var cb = entry.callback;
                                state.pendingcb--, cb(err), entry = entry.next;
                            }
                            state.corkedRequestsFree ? state.corkedRequestsFree.next = corkReq : state.corkedRequestsFree = corkReq;
                        }(_this, state);
                    };
                }
                module.exports = Writable;
                var Duplex, asyncWrite = !process.browser && [ "v0.10", "v0.9." ].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
                Writable.WritableState = WritableState;
                var util = require("core-util-is");
                util.inherits = require("inherits");
                var realHasInstance, internalUtil = {
                    deprecate: require("util-deprecate")
                }, Stream = require("./internal/streams/stream"), Buffer = require("safe-buffer").Buffer, OurUint8Array = global.Uint8Array || function() {}, destroyImpl = require("./internal/streams/destroy");
                function nop() {}
                function WritableState(options, stream) {
                    Duplex = Duplex || require("./_stream_duplex"), options = options || {};
                    var isDuplex = stream instanceof Duplex;
                    this.objectMode = !!options.objectMode, isDuplex && (this.objectMode = this.objectMode || !!options.writableObjectMode);
                    var hwm = options.highWaterMark, writableHwm = options.writableHighWaterMark, defaultHwm = this.objectMode ? 16 : 16384;
                    this.highWaterMark = hwm || 0 === hwm ? hwm : isDuplex && (writableHwm || 0 === writableHwm) ? writableHwm : defaultHwm, 
                    this.highWaterMark = Math.floor(this.highWaterMark), this.finalCalled = !1, this.needDrain = !1, 
                    this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
                    var noDecode = !1 === options.decodeStrings;
                    this.decodeStrings = !noDecode, this.defaultEncoding = options.defaultEncoding || "utf8", 
                    this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, 
                    this.onwrite = function(er) {
                        !function onwrite(stream, er) {
                            var state = stream._writableState, sync = state.sync, cb = state.writecb;
                            if (function onwriteStateUpdate(state) {
                                state.writing = !1, state.writecb = null, state.length -= state.writelen, state.writelen = 0;
                            }(state), er) !function onwriteError(stream, state, sync, er, cb) {
                                --state.pendingcb, sync ? (pna.nextTick(cb, er), pna.nextTick(finishMaybe, stream, state), 
                                stream._writableState.errorEmitted = !0, stream.emit("error", er)) : (cb(er), stream._writableState.errorEmitted = !0, 
                                stream.emit("error", er), finishMaybe(stream, state));
                            }(stream, state, sync, er, cb); else {
                                var finished = needFinish(state);
                                finished || state.corked || state.bufferProcessing || !state.bufferedRequest || clearBuffer(stream, state), 
                                sync ? asyncWrite(afterWrite, stream, state, finished, cb) : afterWrite(stream, state, finished, cb);
                            }
                        }(stream, er);
                    }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, 
                    this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.bufferedRequestCount = 0, 
                    this.corkedRequestsFree = new CorkedRequest(this);
                }
                function Writable(options) {
                    if (Duplex = Duplex || require("./_stream_duplex"), !(realHasInstance.call(Writable, this) || this instanceof Duplex)) return new Writable(options);
                    this._writableState = new WritableState(options, this), this.writable = !0, options && ("function" == typeof options.write && (this._write = options.write), 
                    "function" == typeof options.writev && (this._writev = options.writev), "function" == typeof options.destroy && (this._destroy = options.destroy), 
                    "function" == typeof options.final && (this._final = options.final)), Stream.call(this);
                }
                function doWrite(stream, state, writev, len, chunk, encoding, cb) {
                    state.writelen = len, state.writecb = cb, state.writing = !0, state.sync = !0, writev ? stream._writev(chunk, state.onwrite) : stream._write(chunk, encoding, state.onwrite), 
                    state.sync = !1;
                }
                function afterWrite(stream, state, finished, cb) {
                    finished || function onwriteDrain(stream, state) {
                        0 === state.length && state.needDrain && (state.needDrain = !1, stream.emit("drain"));
                    }(stream, state), state.pendingcb--, cb(), finishMaybe(stream, state);
                }
                function clearBuffer(stream, state) {
                    state.bufferProcessing = !0;
                    var entry = state.bufferedRequest;
                    if (stream._writev && entry && entry.next) {
                        var l = state.bufferedRequestCount, buffer = new Array(l), holder = state.corkedRequestsFree;
                        holder.entry = entry;
                        for (var count = 0, allBuffers = !0; entry; ) buffer[count] = entry, entry.isBuf || (allBuffers = !1), 
                        entry = entry.next, count += 1;
                        buffer.allBuffers = allBuffers, doWrite(stream, state, !0, state.length, buffer, "", holder.finish), 
                        state.pendingcb++, state.lastBufferedRequest = null, holder.next ? (state.corkedRequestsFree = holder.next, 
                        holder.next = null) : state.corkedRequestsFree = new CorkedRequest(state), state.bufferedRequestCount = 0;
                    } else {
                        for (;entry; ) {
                            var chunk = entry.chunk, encoding = entry.encoding, cb = entry.callback;
                            if (doWrite(stream, state, !1, state.objectMode ? 1 : chunk.length, chunk, encoding, cb), 
                            entry = entry.next, state.bufferedRequestCount--, state.writing) break;
                        }
                        null === entry && (state.lastBufferedRequest = null);
                    }
                    state.bufferedRequest = entry, state.bufferProcessing = !1;
                }
                function needFinish(state) {
                    return state.ending && 0 === state.length && null === state.bufferedRequest && !state.finished && !state.writing;
                }
                function callFinal(stream, state) {
                    stream._final((function(err) {
                        state.pendingcb--, err && stream.emit("error", err), state.prefinished = !0, stream.emit("prefinish"), 
                        finishMaybe(stream, state);
                    }));
                }
                function finishMaybe(stream, state) {
                    var need = needFinish(state);
                    return need && (function prefinish(stream, state) {
                        state.prefinished || state.finalCalled || ("function" == typeof stream._final ? (state.pendingcb++, 
                        state.finalCalled = !0, pna.nextTick(callFinal, stream, state)) : (state.prefinished = !0, 
                        stream.emit("prefinish")));
                    }(stream, state), 0 === state.pendingcb && (state.finished = !0, stream.emit("finish"))), 
                    need;
                }
                util.inherits(Writable, Stream), WritableState.prototype.getBuffer = function getBuffer() {
                    for (var current = this.bufferedRequest, out = []; current; ) out.push(current), 
                    current = current.next;
                    return out;
                }, function() {
                    try {
                        Object.defineProperty(WritableState.prototype, "buffer", {
                            get: internalUtil.deprecate((function() {
                                return this.getBuffer();
                            }), "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
                        });
                    } catch (_) {}
                }(), "function" == typeof Symbol && Symbol.hasInstance && "function" == typeof Function.prototype[Symbol.hasInstance] ? (realHasInstance = Function.prototype[Symbol.hasInstance], 
                Object.defineProperty(Writable, Symbol.hasInstance, {
                    value: function(object) {
                        return !!realHasInstance.call(this, object) || this === Writable && object && object._writableState instanceof WritableState;
                    }
                })) : realHasInstance = function(object) {
                    return object instanceof this;
                }, Writable.prototype.pipe = function() {
                    this.emit("error", new Error("Cannot pipe, not readable"));
                }, Writable.prototype.write = function(chunk, encoding, cb) {
                    var state = this._writableState, ret = !1, isBuf = !state.objectMode && function _isUint8Array(obj) {
                        return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
                    }(chunk);
                    return isBuf && !Buffer.isBuffer(chunk) && (chunk = function _uint8ArrayToBuffer(chunk) {
                        return Buffer.from(chunk);
                    }(chunk)), "function" == typeof encoding && (cb = encoding, encoding = null), isBuf ? encoding = "buffer" : encoding || (encoding = state.defaultEncoding), 
                    "function" != typeof cb && (cb = nop), state.ended ? function writeAfterEnd(stream, cb) {
                        var er = new Error("write after end");
                        stream.emit("error", er), pna.nextTick(cb, er);
                    }(this, cb) : (isBuf || function validChunk(stream, state, chunk, cb) {
                        var valid = !0, er = !1;
                        return null === chunk ? er = new TypeError("May not write null values to stream") : "string" == typeof chunk || void 0 === chunk || state.objectMode || (er = new TypeError("Invalid non-string/buffer chunk")), 
                        er && (stream.emit("error", er), pna.nextTick(cb, er), valid = !1), valid;
                    }(this, state, chunk, cb)) && (state.pendingcb++, ret = function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
                        if (!isBuf) {
                            var newChunk = function decodeChunk(state, chunk, encoding) {
                                return state.objectMode || !1 === state.decodeStrings || "string" != typeof chunk || (chunk = Buffer.from(chunk, encoding)), 
                                chunk;
                            }(state, chunk, encoding);
                            chunk !== newChunk && (isBuf = !0, encoding = "buffer", chunk = newChunk);
                        }
                        var len = state.objectMode ? 1 : chunk.length;
                        state.length += len;
                        var ret = state.length < state.highWaterMark;
                        if (ret || (state.needDrain = !0), state.writing || state.corked) {
                            var last = state.lastBufferedRequest;
                            state.lastBufferedRequest = {
                                chunk,
                                encoding,
                                isBuf,
                                callback: cb,
                                next: null
                            }, last ? last.next = state.lastBufferedRequest : state.bufferedRequest = state.lastBufferedRequest, 
                            state.bufferedRequestCount += 1;
                        } else doWrite(stream, state, !1, len, chunk, encoding, cb);
                        return ret;
                    }(this, state, isBuf, chunk, encoding, cb)), ret;
                }, Writable.prototype.cork = function() {
                    this._writableState.corked++;
                }, Writable.prototype.uncork = function() {
                    var state = this._writableState;
                    state.corked && (state.corked--, state.writing || state.corked || state.finished || state.bufferProcessing || !state.bufferedRequest || clearBuffer(this, state));
                }, Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
                    if ("string" == typeof encoding && (encoding = encoding.toLowerCase()), !([ "hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw" ].indexOf((encoding + "").toLowerCase()) > -1)) throw new TypeError("Unknown encoding: " + encoding);
                    return this._writableState.defaultEncoding = encoding, this;
                }, Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
                    enumerable: !1,
                    get: function() {
                        return this._writableState.highWaterMark;
                    }
                }), Writable.prototype._write = function(chunk, encoding, cb) {
                    cb(new Error("_write() is not implemented"));
                }, Writable.prototype._writev = null, Writable.prototype.end = function(chunk, encoding, cb) {
                    var state = this._writableState;
                    "function" == typeof chunk ? (cb = chunk, chunk = null, encoding = null) : "function" == typeof encoding && (cb = encoding, 
                    encoding = null), null != chunk && this.write(chunk, encoding), state.corked && (state.corked = 1, 
                    this.uncork()), state.ending || state.finished || function endWritable(stream, state, cb) {
                        state.ending = !0, finishMaybe(stream, state), cb && (state.finished ? pna.nextTick(cb) : stream.once("finish", cb)), 
                        state.ended = !0, stream.writable = !1;
                    }(this, state, cb);
                }, Object.defineProperty(Writable.prototype, "destroyed", {
                    get: function() {
                        return void 0 !== this._writableState && this._writableState.destroyed;
                    },
                    set: function(value) {
                        this._writableState && (this._writableState.destroyed = value);
                    }
                }), Writable.prototype.destroy = destroyImpl.destroy, Writable.prototype._undestroy = destroyImpl.undestroy, 
                Writable.prototype._destroy = function(err, cb) {
                    this.end(), cb(err);
                };
            }).call(this, require("_process"), void 0 !== commonjsGlobal ? commonjsGlobal : "undefined" != typeof self ? self : void 0 !== window ? window : {}, require("timers").setImmediate);
        }, {
            "./_stream_duplex": 139,
            "./internal/streams/destroy": 145,
            "./internal/streams/stream": 146,
            _process: 133,
            "core-util-is": 51,
            inherits: 75,
            "process-nextick-args": 132,
            "safe-buffer": 147,
            timers: 176,
            "util-deprecate": 183
        } ],
        144: [ function(require, module, exports) {
            var Buffer = require("safe-buffer").Buffer, util = require("util");
            function copyBuffer(src, target, offset) {
                src.copy(target, offset);
            }
            module.exports = function() {
                function BufferList() {
                    (function _classCallCheck(instance, Constructor) {
                        if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function");
                    })(this, BufferList), this.head = null, this.tail = null, this.length = 0;
                }
                return BufferList.prototype.push = function push(v) {
                    var entry = {
                        data: v,
                        next: null
                    };
                    this.length > 0 ? this.tail.next = entry : this.head = entry, this.tail = entry, 
                    ++this.length;
                }, BufferList.prototype.unshift = function unshift(v) {
                    var entry = {
                        data: v,
                        next: this.head
                    };
                    0 === this.length && (this.tail = entry), this.head = entry, ++this.length;
                }, BufferList.prototype.shift = function shift() {
                    if (0 !== this.length) {
                        var ret = this.head.data;
                        return 1 === this.length ? this.head = this.tail = null : this.head = this.head.next, 
                        --this.length, ret;
                    }
                }, BufferList.prototype.clear = function clear() {
                    this.head = this.tail = null, this.length = 0;
                }, BufferList.prototype.join = function join(s) {
                    if (0 === this.length) return "";
                    for (var p = this.head, ret = "" + p.data; p = p.next; ) ret += s + p.data;
                    return ret;
                }, BufferList.prototype.concat = function concat(n) {
                    if (0 === this.length) return Buffer.alloc(0);
                    if (1 === this.length) return this.head.data;
                    for (var ret = Buffer.allocUnsafe(n >>> 0), p = this.head, i = 0; p; ) copyBuffer(p.data, ret, i), 
                    i += p.data.length, p = p.next;
                    return ret;
                }, BufferList;
            }(), util && util.inspect && util.inspect.custom && (module.exports.prototype[util.inspect.custom] = function() {
                var obj = util.inspect({
                    length: this.length
                });
                return this.constructor.name + " " + obj;
            });
        }, {
            "safe-buffer": 147,
            util: 33
        } ],
        145: [ function(require, module, exports) {
            var pna = require("process-nextick-args");
            function emitErrorNT(self, err) {
                self.emit("error", err);
            }
            module.exports = {
                destroy: function destroy(err, cb) {
                    var _this = this, readableDestroyed = this._readableState && this._readableState.destroyed, writableDestroyed = this._writableState && this._writableState.destroyed;
                    return readableDestroyed || writableDestroyed ? (cb ? cb(err) : !err || this._writableState && this._writableState.errorEmitted || pna.nextTick(emitErrorNT, this, err), 
                    this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), 
                    this._destroy(err || null, (function(err) {
                        !cb && err ? (pna.nextTick(emitErrorNT, _this, err), _this._writableState && (_this._writableState.errorEmitted = !0)) : cb && cb(err);
                    })), this);
                },
                undestroy: function undestroy() {
                    this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, 
                    this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, 
                    this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finished = !1, 
                    this._writableState.errorEmitted = !1);
                }
            };
        }, {
            "process-nextick-args": 132
        } ],
        146: [ function(require, module, exports) {
            module.exports = require("events").EventEmitter;
        }, {
            events: 52
        } ],
        147: [ function(require, module, exports) {
            var buffer = require("buffer"), Buffer = buffer.Buffer;
            function copyProps(src, dst) {
                for (var key in src) dst[key] = src[key];
            }
            function SafeBuffer(arg, encodingOrOffset, length) {
                return Buffer(arg, encodingOrOffset, length);
            }
            Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow ? module.exports = buffer : (copyProps(buffer, exports), 
            exports.Buffer = SafeBuffer), copyProps(Buffer, SafeBuffer), SafeBuffer.from = function(arg, encodingOrOffset, length) {
                if ("number" == typeof arg) throw new TypeError("Argument must not be a number");
                return Buffer(arg, encodingOrOffset, length);
            }, SafeBuffer.alloc = function(size, fill, encoding) {
                if ("number" != typeof size) throw new TypeError("Argument must be a number");
                var buf = Buffer(size);
                return void 0 !== fill ? "string" == typeof encoding ? buf.fill(fill, encoding) : buf.fill(fill) : buf.fill(0), 
                buf;
            }, SafeBuffer.allocUnsafe = function(size) {
                if ("number" != typeof size) throw new TypeError("Argument must be a number");
                return Buffer(size);
            }, SafeBuffer.allocUnsafeSlow = function(size) {
                if ("number" != typeof size) throw new TypeError("Argument must be a number");
                return buffer.SlowBuffer(size);
            };
        }, {
            buffer: 48
        } ],
        148: [ function(require, module, exports) {
            var Buffer = require("safe-buffer").Buffer, isEncoding = Buffer.isEncoding || function(encoding) {
                switch ((encoding = "" + encoding) && encoding.toLowerCase()) {
                  case "hex":
                  case "utf8":
                  case "utf-8":
                  case "ascii":
                  case "binary":
                  case "base64":
                  case "ucs2":
                  case "ucs-2":
                  case "utf16le":
                  case "utf-16le":
                  case "raw":
                    return !0;

                  default:
                    return !1;
                }
            };
            function StringDecoder(encoding) {
                var nb;
                switch (this.encoding = function normalizeEncoding(enc) {
                    var nenc = function _normalizeEncoding(enc) {
                        if (!enc) return "utf8";
                        for (var retried; ;) switch (enc) {
                          case "utf8":
                          case "utf-8":
                            return "utf8";

                          case "ucs2":
                          case "ucs-2":
                          case "utf16le":
                          case "utf-16le":
                            return "utf16le";

                          case "latin1":
                          case "binary":
                            return "latin1";

                          case "base64":
                          case "ascii":
                          case "hex":
                            return enc;

                          default:
                            if (retried) return;
                            enc = ("" + enc).toLowerCase(), retried = !0;
                        }
                    }(enc);
                    if ("string" != typeof nenc && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error("Unknown encoding: " + enc);
                    return nenc || enc;
                }(encoding), this.encoding) {
                  case "utf16le":
                    this.text = utf16Text, this.end = utf16End, nb = 4;
                    break;

                  case "utf8":
                    this.fillLast = utf8FillLast, nb = 4;
                    break;

                  case "base64":
                    this.text = base64Text, this.end = base64End, nb = 3;
                    break;

                  default:
                    return this.write = simpleWrite, void (this.end = simpleEnd);
                }
                this.lastNeed = 0, this.lastTotal = 0, this.lastChar = Buffer.allocUnsafe(nb);
            }
            function utf8CheckByte(byte) {
                return byte <= 0x7F ? 0 : byte >> 5 == 0x06 ? 2 : byte >> 4 == 0x0E ? 3 : byte >> 3 == 0x1E ? 4 : byte >> 6 == 0x02 ? -1 : -2;
            }
            function utf8FillLast(buf) {
                var p = this.lastTotal - this.lastNeed, r = function utf8CheckExtraBytes(self, buf, p) {
                    if (0x80 != (0xC0 & buf[0])) return self.lastNeed = 0, "";
                    if (self.lastNeed > 1 && buf.length > 1) {
                        if (0x80 != (0xC0 & buf[1])) return self.lastNeed = 1, "";
                        if (self.lastNeed > 2 && buf.length > 2 && 0x80 != (0xC0 & buf[2])) return self.lastNeed = 2, 
                        "";
                    }
                }(this, buf);
                return void 0 !== r ? r : this.lastNeed <= buf.length ? (buf.copy(this.lastChar, p, 0, this.lastNeed), 
                this.lastChar.toString(this.encoding, 0, this.lastTotal)) : (buf.copy(this.lastChar, p, 0, buf.length), 
                void (this.lastNeed -= buf.length));
            }
            function utf16Text(buf, i) {
                if ((buf.length - i) % 2 == 0) {
                    var r = buf.toString("utf16le", i);
                    if (r) {
                        var c = r.charCodeAt(r.length - 1);
                        if (c >= 0xD800 && c <= 0xDBFF) return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = buf[buf.length - 2], 
                        this.lastChar[1] = buf[buf.length - 1], r.slice(0, -1);
                    }
                    return r;
                }
                return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = buf[buf.length - 1], 
                buf.toString("utf16le", i, buf.length - 1);
            }
            function utf16End(buf) {
                var r = buf && buf.length ? this.write(buf) : "";
                if (this.lastNeed) {
                    var end = this.lastTotal - this.lastNeed;
                    return r + this.lastChar.toString("utf16le", 0, end);
                }
                return r;
            }
            function base64Text(buf, i) {
                var n = (buf.length - i) % 3;
                return 0 === n ? buf.toString("base64", i) : (this.lastNeed = 3 - n, this.lastTotal = 3, 
                1 === n ? this.lastChar[0] = buf[buf.length - 1] : (this.lastChar[0] = buf[buf.length - 2], 
                this.lastChar[1] = buf[buf.length - 1]), buf.toString("base64", i, buf.length - n));
            }
            function base64End(buf) {
                var r = buf && buf.length ? this.write(buf) : "";
                return this.lastNeed ? r + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : r;
            }
            function simpleWrite(buf) {
                return buf.toString(this.encoding);
            }
            function simpleEnd(buf) {
                return buf && buf.length ? this.write(buf) : "";
            }
            exports.StringDecoder = StringDecoder, StringDecoder.prototype.write = function(buf) {
                if (0 === buf.length) return "";
                var r, i;
                if (this.lastNeed) {
                    if (void 0 === (r = this.fillLast(buf))) return "";
                    i = this.lastNeed, this.lastNeed = 0;
                } else i = 0;
                return i < buf.length ? r ? r + this.text(buf, i) : this.text(buf, i) : r || "";
            }, StringDecoder.prototype.end = function utf8End(buf) {
                var r = buf && buf.length ? this.write(buf) : "";
                return this.lastNeed ? r + "" : r;
            }, StringDecoder.prototype.text = function utf8Text(buf, i) {
                var total = function utf8CheckIncomplete(self, buf, i) {
                    var j = buf.length - 1;
                    if (j < i) return 0;
                    var nb = utf8CheckByte(buf[j]);
                    return nb >= 0 ? (nb > 0 && (self.lastNeed = nb - 1), nb) : --j < i || -2 === nb ? 0 : (nb = utf8CheckByte(buf[j])) >= 0 ? (nb > 0 && (self.lastNeed = nb - 2), 
                    nb) : --j < i || -2 === nb ? 0 : (nb = utf8CheckByte(buf[j])) >= 0 ? (nb > 0 && (2 === nb ? nb = 0 : self.lastNeed = nb - 3), 
                    nb) : 0;
                }(this, buf, i);
                if (!this.lastNeed) return buf.toString("utf8", i);
                this.lastTotal = total;
                var end = buf.length - (total - this.lastNeed);
                return buf.copy(this.lastChar, 0, end), buf.toString("utf8", i, end);
            }, StringDecoder.prototype.fillLast = function(buf) {
                if (this.lastNeed <= buf.length) return buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), 
                this.lastChar.toString(this.encoding, 0, this.lastTotal);
                buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length), this.lastNeed -= buf.length;
            };
        }, {
            "safe-buffer": 147
        } ],
        149: [ function(require, module, exports) {
            module.exports = require("./readable").PassThrough;
        }, {
            "./readable": 150
        } ],
        150: [ function(require, module, exports) {
            (exports = module.exports = require("./lib/_stream_readable.js")).Stream = exports, 
            exports.Readable = exports, exports.Writable = require("./lib/_stream_writable.js"), 
            exports.Duplex = require("./lib/_stream_duplex.js"), exports.Transform = require("./lib/_stream_transform.js"), 
            exports.PassThrough = require("./lib/_stream_passthrough.js");
        }, {
            "./lib/_stream_duplex.js": 139,
            "./lib/_stream_passthrough.js": 140,
            "./lib/_stream_readable.js": 141,
            "./lib/_stream_transform.js": 142,
            "./lib/_stream_writable.js": 143
        } ],
        151: [ function(require, module, exports) {
            module.exports = require("./readable").Transform;
        }, {
            "./readable": 150
        } ],
        152: [ function(require, module, exports) {
            module.exports = require("./lib/_stream_writable.js");
        }, {
            "./lib/_stream_writable.js": 143
        } ],
        153: [ function(require, module, exports) {
            var runtime = function(exports) {
                var Op = Object.prototype, hasOwn = Op.hasOwnProperty, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
                function wrap(innerFn, outerFn, self, tryLocsList) {
                    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []);
                    return generator._invoke = function makeInvokeMethod(innerFn, self, context) {
                        var state = "suspendedStart";
                        return function invoke(method, arg) {
                            if ("executing" === state) throw new Error("Generator is already running");
                            if ("completed" === state) {
                                if ("throw" === method) throw arg;
                                return {
                                    value: void 0,
                                    done: !0
                                };
                            }
                            for (context.method = method, context.arg = arg; ;) {
                                var delegate = context.delegate;
                                if (delegate) {
                                    var delegateResult = maybeInvokeDelegate(delegate, context);
                                    if (delegateResult) {
                                        if (delegateResult === ContinueSentinel) continue;
                                        return delegateResult;
                                    }
                                }
                                if ("next" === context.method) context.sent = context._sent = context.arg; else if ("throw" === context.method) {
                                    if ("suspendedStart" === state) throw state = "completed", context.arg;
                                    context.dispatchException(context.arg);
                                } else "return" === context.method && context.abrupt("return", context.arg);
                                state = "executing";
                                var record = tryCatch(innerFn, self, context);
                                if ("normal" === record.type) {
                                    if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue;
                                    return {
                                        value: record.arg,
                                        done: context.done
                                    };
                                }
                                "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg);
                            }
                        };
                    }(innerFn, self, context), generator;
                }
                function tryCatch(fn, obj, arg) {
                    try {
                        return {
                            type: "normal",
                            arg: fn.call(obj, arg)
                        };
                    } catch (err) {
                        return {
                            type: "throw",
                            arg: err
                        };
                    }
                }
                exports.wrap = wrap;
                var ContinueSentinel = {};
                function Generator() {}
                function GeneratorFunction() {}
                function GeneratorFunctionPrototype() {}
                var IteratorPrototype = {};
                IteratorPrototype[iteratorSymbol] = function() {
                    return this;
                };
                var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([])));
                NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);
                var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
                function defineIteratorMethods(prototype) {
                    [ "next", "throw", "return" ].forEach((function(method) {
                        prototype[method] = function(arg) {
                            return this._invoke(method, arg);
                        };
                    }));
                }
                function AsyncIterator(generator) {
                    function invoke(method, arg, resolve, reject) {
                        var record = tryCatch(generator[method], generator, arg);
                        if ("throw" !== record.type) {
                            var result = record.arg, value = result.value;
                            return value && "object" == typeof value && hasOwn.call(value, "__await") ? Promise.resolve(value.__await).then((function(value) {
                                invoke("next", value, resolve, reject);
                            }), (function(err) {
                                invoke("throw", err, resolve, reject);
                            })) : Promise.resolve(value).then((function(unwrapped) {
                                result.value = unwrapped, resolve(result);
                            }), (function(error) {
                                return invoke("throw", error, resolve, reject);
                            }));
                        }
                        reject(record.arg);
                    }
                    var previousPromise;
                    this._invoke = function enqueue(method, arg) {
                        function callInvokeWithMethodAndArg() {
                            return new Promise((function(resolve, reject) {
                                invoke(method, arg, resolve, reject);
                            }));
                        }
                        return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
                    };
                }
                function maybeInvokeDelegate(delegate, context) {
                    var method = delegate.iterator[context.method];
                    if (void 0 === method) {
                        if (context.delegate = null, "throw" === context.method) {
                            if (delegate.iterator.return && (context.method = "return", context.arg = void 0, 
                            maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel;
                            context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method");
                        }
                        return ContinueSentinel;
                    }
                    var record = tryCatch(method, delegate.iterator, context.arg);
                    if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, 
                    context.delegate = null, ContinueSentinel;
                    var info = record.arg;
                    return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, 
                    "return" !== context.method && (context.method = "next", context.arg = void 0), 
                    context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), 
                    context.delegate = null, ContinueSentinel);
                }
                function pushTryEntry(locs) {
                    var entry = {
                        tryLoc: locs[0]
                    };
                    1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], 
                    entry.afterLoc = locs[3]), this.tryEntries.push(entry);
                }
                function resetTryEntry(entry) {
                    var record = entry.completion || {};
                    record.type = "normal", delete record.arg, entry.completion = record;
                }
                function Context(tryLocsList) {
                    this.tryEntries = [ {
                        tryLoc: "root"
                    } ], tryLocsList.forEach(pushTryEntry, this), this.reset(!0);
                }
                function values(iterable) {
                    if (iterable) {
                        var iteratorMethod = iterable[iteratorSymbol];
                        if (iteratorMethod) return iteratorMethod.call(iterable);
                        if ("function" == typeof iterable.next) return iterable;
                        if (!isNaN(iterable.length)) {
                            var i = -1, next = function next() {
                                for (;++i < iterable.length; ) if (hasOwn.call(iterable, i)) return next.value = iterable[i], 
                                next.done = !1, next;
                                return next.value = void 0, next.done = !0, next;
                            };
                            return next.next = next;
                        }
                    }
                    return {
                        next: doneResult
                    };
                }
                function doneResult() {
                    return {
                        value: void 0,
                        done: !0
                    };
                }
                return GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype, 
                GeneratorFunctionPrototype.constructor = GeneratorFunction, GeneratorFunctionPrototype[toStringTagSymbol] = GeneratorFunction.displayName = "GeneratorFunction", 
                exports.isGeneratorFunction = function(genFun) {
                    var ctor = "function" == typeof genFun && genFun.constructor;
                    return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name));
                }, exports.mark = function(genFun) {
                    return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, 
                    toStringTagSymbol in genFun || (genFun[toStringTagSymbol] = "GeneratorFunction")), 
                    genFun.prototype = Object.create(Gp), genFun;
                }, exports.awrap = function(arg) {
                    return {
                        __await: arg
                    };
                }, defineIteratorMethods(AsyncIterator.prototype), AsyncIterator.prototype[asyncIteratorSymbol] = function() {
                    return this;
                }, exports.AsyncIterator = AsyncIterator, exports.async = function(innerFn, outerFn, self, tryLocsList) {
                    var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList));
                    return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then((function(result) {
                        return result.done ? result.value : iter.next();
                    }));
                }, defineIteratorMethods(Gp), Gp[toStringTagSymbol] = "Generator", Gp[iteratorSymbol] = function() {
                    return this;
                }, Gp.toString = function() {
                    return "[object Generator]";
                }, exports.keys = function(object) {
                    var keys = [];
                    for (var key in object) keys.push(key);
                    return keys.reverse(), function next() {
                        for (;keys.length; ) {
                            var key = keys.pop();
                            if (key in object) return next.value = key, next.done = !1, next;
                        }
                        return next.done = !0, next;
                    };
                }, exports.values = values, Context.prototype = {
                    constructor: Context,
                    reset: function(skipTempReset) {
                        if (this.prev = 0, this.next = 0, this.sent = this._sent = void 0, this.done = !1, 
                        this.delegate = null, this.method = "next", this.arg = void 0, this.tryEntries.forEach(resetTryEntry), 
                        !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = void 0);
                    },
                    stop: function() {
                        this.done = !0;
                        var rootRecord = this.tryEntries[0].completion;
                        if ("throw" === rootRecord.type) throw rootRecord.arg;
                        return this.rval;
                    },
                    dispatchException: function(exception) {
                        if (this.done) throw exception;
                        var context = this;
                        function handle(loc, caught) {
                            return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", 
                            context.arg = void 0), !!caught;
                        }
                        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
                            var entry = this.tryEntries[i], record = entry.completion;
                            if ("root" === entry.tryLoc) return handle("end");
                            if (entry.tryLoc <= this.prev) {
                                var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc");
                                if (hasCatch && hasFinally) {
                                    if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
                                    if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
                                } else if (hasCatch) {
                                    if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
                                } else {
                                    if (!hasFinally) throw new Error("try statement without catch or finally");
                                    if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
                                }
                            }
                        }
                    },
                    abrupt: function(type, arg) {
                        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
                            var entry = this.tryEntries[i];
                            if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
                                var finallyEntry = entry;
                                break;
                            }
                        }
                        finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);
                        var record = finallyEntry ? finallyEntry.completion : {};
                        return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", 
                        this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);
                    },
                    complete: function(record, afterLoc) {
                        if ("throw" === record.type) throw record.arg;
                        return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, 
                        this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), 
                        ContinueSentinel;
                    },
                    finish: function(finallyLoc) {
                        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
                            var entry = this.tryEntries[i];
                            if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), 
                            resetTryEntry(entry), ContinueSentinel;
                        }
                    },
                    catch: function(tryLoc) {
                        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
                            var entry = this.tryEntries[i];
                            if (entry.tryLoc === tryLoc) {
                                var record = entry.completion;
                                if ("throw" === record.type) {
                                    var thrown = record.arg;
                                    resetTryEntry(entry);
                                }
                                return thrown;
                            }
                        }
                        throw new Error("illegal catch attempt");
                    },
                    delegateYield: function(iterable, resultName, nextLoc) {
                        return this.delegate = {
                            iterator: values(iterable),
                            resultName,
                            nextLoc
                        }, "next" === this.method && (this.arg = void 0), ContinueSentinel;
                    }
                }, exports;
            }("object" == typeof module ? module.exports : {});
            try {
                regeneratorRuntime = runtime;
            } catch (accidentalStrictMode) {
                Function("r", "regeneratorRuntime = r")(runtime);
            }
        }, {} ],
        154: [ function(require, module, exports) {
            var buffer = require("buffer"), Buffer = buffer.Buffer;
            function copyProps(src, dst) {
                for (var key in src) dst[key] = src[key];
            }
            function SafeBuffer(arg, encodingOrOffset, length) {
                return Buffer(arg, encodingOrOffset, length);
            }
            Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow ? module.exports = buffer : (copyProps(buffer, exports), 
            exports.Buffer = SafeBuffer), SafeBuffer.prototype = Object.create(Buffer.prototype), 
            copyProps(Buffer, SafeBuffer), SafeBuffer.from = function(arg, encodingOrOffset, length) {
                if ("number" == typeof arg) throw new TypeError("Argument must not be a number");
                return Buffer(arg, encodingOrOffset, length);
            }, SafeBuffer.alloc = function(size, fill, encoding) {
                if ("number" != typeof size) throw new TypeError("Argument must be a number");
                var buf = Buffer(size);
                return void 0 !== fill ? "string" == typeof encoding ? buf.fill(fill, encoding) : buf.fill(fill) : buf.fill(0), 
                buf;
            }, SafeBuffer.allocUnsafe = function(size) {
                if ("number" != typeof size) throw new TypeError("Argument must be a number");
                return Buffer(size);
            }, SafeBuffer.allocUnsafeSlow = function(size) {
                if ("number" != typeof size) throw new TypeError("Argument must be a number");
                return buffer.SlowBuffer(size);
            };
        }, {
            buffer: 48
        } ],
        155: [ function(require, module, exports) {
            module.exports = Stream;
            var EE = require("events").EventEmitter;
            function Stream() {
                EE.call(this);
            }
            require("inherits")(Stream, EE), Stream.Readable = require("readable-stream/readable.js"), 
            Stream.Writable = require("readable-stream/writable.js"), Stream.Duplex = require("readable-stream/duplex.js"), 
            Stream.Transform = require("readable-stream/transform.js"), Stream.PassThrough = require("readable-stream/passthrough.js"), 
            Stream.Stream = Stream, Stream.prototype.pipe = function(dest, options) {
                var source = this;
                function ondata(chunk) {
                    dest.writable && !1 === dest.write(chunk) && source.pause && source.pause();
                }
                function ondrain() {
                    source.readable && source.resume && source.resume();
                }
                source.on("data", ondata), dest.on("drain", ondrain), dest._isStdio || options && !1 === options.end || (source.on("end", onend), 
                source.on("close", onclose));
                var didOnEnd = !1;
                function onend() {
                    didOnEnd || (didOnEnd = !0, dest.end());
                }
                function onclose() {
                    didOnEnd || (didOnEnd = !0, "function" == typeof dest.destroy && dest.destroy());
                }
                function onerror(er) {
                    if (cleanup(), 0 === EE.listenerCount(this, "error")) throw er;
                }
                function cleanup() {
                    source.removeListener("data", ondata), dest.removeListener("drain", ondrain), source.removeListener("end", onend), 
                    source.removeListener("close", onclose), source.removeListener("error", onerror), 
                    dest.removeListener("error", onerror), source.removeListener("end", cleanup), source.removeListener("close", cleanup), 
                    dest.removeListener("close", cleanup);
                }
                return source.on("error", onerror), dest.on("error", onerror), source.on("end", cleanup), 
                source.on("close", cleanup), dest.on("close", cleanup), dest.emit("pipe", source), 
                dest;
            };
        }, {
            events: 52,
            inherits: 75,
            "readable-stream/duplex.js": 138,
            "readable-stream/passthrough.js": 149,
            "readable-stream/readable.js": 150,
            "readable-stream/transform.js": 151,
            "readable-stream/writable.js": 152
        } ],
        156: [ function(require, module, exports) {
            (function(global) {
                var ClientRequest = require("./lib/request"), response = require("./lib/response"), extend = require("xtend"), statusCodes = require("builtin-status-codes"), url = require("url"), http = exports;
                http.request = function(opts, cb) {
                    opts = "string" == typeof opts ? url.parse(opts) : extend(opts);
                    var defaultProtocol = -1 === global.location.protocol.search(/^https?:$/) ? "http:" : "", protocol = opts.protocol || defaultProtocol, host = opts.hostname || opts.host, port = opts.port, path = opts.path || "/";
                    host && -1 !== host.indexOf(":") && (host = "[" + host + "]"), opts.url = (host ? protocol + "//" + host : "") + (port ? ":" + port : "") + path, 
                    opts.method = (opts.method || "GET").toUpperCase(), opts.headers = opts.headers || {};
                    var req = new ClientRequest(opts);
                    return cb && req.on("response", cb), req;
                }, http.get = function get(opts, cb) {
                    var req = http.request(opts, cb);
                    return req.end(), req;
                }, http.ClientRequest = ClientRequest, http.IncomingMessage = response.IncomingMessage, 
                http.Agent = function() {}, http.Agent.defaultMaxSockets = 4, http.globalAgent = new http.Agent, 
                http.STATUS_CODES = statusCodes, http.METHODS = [ "CHECKOUT", "CONNECT", "COPY", "DELETE", "GET", "HEAD", "LOCK", "M-SEARCH", "MERGE", "MKACTIVITY", "MKCOL", "MOVE", "NOTIFY", "OPTIONS", "PATCH", "POST", "PROPFIND", "PROPPATCH", "PURGE", "PUT", "REPORT", "SEARCH", "SUBSCRIBE", "TRACE", "UNLOCK", "UNSUBSCRIBE" ];
            }).call(this, void 0 !== commonjsGlobal ? commonjsGlobal : "undefined" != typeof self ? self : void 0 !== window ? window : {});
        }, {
            "./lib/request": 158,
            "./lib/response": 159,
            "builtin-status-codes": 50,
            url: 180,
            xtend: 189
        } ],
        157: [ function(require, module, exports) {
            (function(global) {
                var xhr;
                function getXHR() {
                    if (void 0 !== xhr) return xhr;
                    if (global.XMLHttpRequest) {
                        xhr = new global.XMLHttpRequest;
                        try {
                            xhr.open("GET", global.XDomainRequest ? "/" : "https://example.com");
                        } catch (e) {
                            xhr = null;
                        }
                    } else xhr = null;
                    return xhr;
                }
                function checkTypeSupport(type) {
                    var xhr = getXHR();
                    if (!xhr) return !1;
                    try {
                        return xhr.responseType = type, xhr.responseType === type;
                    } catch (e) {}
                    return !1;
                }
                function isFunction(value) {
                    return "function" == typeof value;
                }
                exports.fetch = isFunction(global.fetch) && isFunction(global.ReadableStream), exports.writableStream = isFunction(global.WritableStream), 
                exports.abortController = isFunction(global.AbortController), exports.arraybuffer = exports.fetch || checkTypeSupport("arraybuffer"), 
                exports.msstream = !exports.fetch && checkTypeSupport("ms-stream"), exports.mozchunkedarraybuffer = !exports.fetch && checkTypeSupport("moz-chunked-arraybuffer"), 
                exports.overrideMimeType = exports.fetch || !!getXHR() && isFunction(getXHR().overrideMimeType), 
                xhr = null;
            }).call(this, void 0 !== commonjsGlobal ? commonjsGlobal : "undefined" != typeof self ? self : void 0 !== window ? window : {});
        }, {} ],
        158: [ function(require, module, exports) {
            (function(process, global, Buffer) {
                var capability = require("./capability"), inherits = require("inherits"), response = require("./response"), stream = require("readable-stream"), IncomingMessage = response.IncomingMessage, rStates = response.readyStates, ClientRequest = module.exports = function(opts) {
                    var preferBinary, self = this;
                    stream.Writable.call(self), self._opts = opts, self._body = [], self._headers = {}, 
                    opts.auth && self.setHeader("Authorization", "Basic " + Buffer.from(opts.auth).toString("base64")), 
                    Object.keys(opts.headers).forEach((function(name) {
                        self.setHeader(name, opts.headers[name]);
                    }));
                    var useFetch = !0;
                    if ("disable-fetch" === opts.mode || "requestTimeout" in opts && !capability.abortController) useFetch = !1, 
                    preferBinary = !0; else if ("prefer-streaming" === opts.mode) preferBinary = !1; else if ("allow-wrong-content-type" === opts.mode) preferBinary = !capability.overrideMimeType; else {
                        if (opts.mode && "default" !== opts.mode && "prefer-fast" !== opts.mode) throw new Error("Invalid value for opts.mode");
                        preferBinary = !0;
                    }
                    self._mode = function decideMode(preferBinary, useFetch) {
                        return capability.fetch && useFetch ? "fetch" : capability.mozchunkedarraybuffer ? "moz-chunked-arraybuffer" : capability.msstream ? "ms-stream" : capability.arraybuffer && preferBinary ? "arraybuffer" : "text";
                    }(preferBinary, useFetch), self._fetchTimer = null, self.on("finish", (function() {
                        self._onFinish();
                    }));
                };
                inherits(ClientRequest, stream.Writable), ClientRequest.prototype.setHeader = function(name, value) {
                    var lowerName = name.toLowerCase();
                    -1 === unsafeHeaders.indexOf(lowerName) && (this._headers[lowerName] = {
                        name,
                        value
                    });
                }, ClientRequest.prototype.getHeader = function(name) {
                    var header = this._headers[name.toLowerCase()];
                    return header ? header.value : null;
                }, ClientRequest.prototype.removeHeader = function(name) {
                    delete this._headers[name.toLowerCase()];
                }, ClientRequest.prototype._onFinish = function() {
                    var self = this;
                    if (!self._destroyed) {
                        var opts = self._opts, headersObj = self._headers, body = null;
                        "GET" !== opts.method && "HEAD" !== opts.method && (body = new Blob(self._body, {
                            type: (headersObj["content-type"] || {}).value || ""
                        }));
                        var headersList = [];
                        if (Object.keys(headersObj).forEach((function(keyName) {
                            var name = headersObj[keyName].name, value = headersObj[keyName].value;
                            Array.isArray(value) ? value.forEach((function(v) {
                                headersList.push([ name, v ]);
                            })) : headersList.push([ name, value ]);
                        })), "fetch" === self._mode) {
                            var signal = null;
                            if (capability.abortController) {
                                var controller = new AbortController;
                                signal = controller.signal, self._fetchAbortController = controller, "requestTimeout" in opts && 0 !== opts.requestTimeout && (self._fetchTimer = global.setTimeout((function() {
                                    self.emit("requestTimeout"), self._fetchAbortController && self._fetchAbortController.abort();
                                }), opts.requestTimeout));
                            }
                            global.fetch(self._opts.url, {
                                method: self._opts.method,
                                headers: headersList,
                                body: body || void 0,
                                mode: "cors",
                                credentials: opts.withCredentials ? "include" : "same-origin",
                                signal
                            }).then((function(response) {
                                self._fetchResponse = response, self._connect();
                            }), (function(reason) {
                                global.clearTimeout(self._fetchTimer), self._destroyed || self.emit("error", reason);
                            }));
                        } else {
                            var xhr = self._xhr = new global.XMLHttpRequest;
                            try {
                                xhr.open(self._opts.method, self._opts.url, !0);
                            } catch (err) {
                                return void process.nextTick((function() {
                                    self.emit("error", err);
                                }));
                            }
                            "responseType" in xhr && (xhr.responseType = self._mode), "withCredentials" in xhr && (xhr.withCredentials = !!opts.withCredentials), 
                            "text" === self._mode && "overrideMimeType" in xhr && xhr.overrideMimeType("text/plain; charset=x-user-defined"), 
                            "requestTimeout" in opts && (xhr.timeout = opts.requestTimeout, xhr.ontimeout = function() {
                                self.emit("requestTimeout");
                            }), headersList.forEach((function(header) {
                                xhr.setRequestHeader(header[0], header[1]);
                            })), self._response = null, xhr.onreadystatechange = function() {
                                switch (xhr.readyState) {
                                  case rStates.LOADING:
                                  case rStates.DONE:
                                    self._onXHRProgress();
                                }
                            }, "moz-chunked-arraybuffer" === self._mode && (xhr.onprogress = function() {
                                self._onXHRProgress();
                            }), xhr.onerror = function() {
                                self._destroyed || self.emit("error", new Error("XHR error"));
                            };
                            try {
                                xhr.send(body);
                            } catch (err) {
                                return void process.nextTick((function() {
                                    self.emit("error", err);
                                }));
                            }
                        }
                    }
                }, ClientRequest.prototype._onXHRProgress = function() {
                    (function statusValid(xhr) {
                        try {
                            var status = xhr.status;
                            return null !== status && 0 !== status;
                        } catch (e) {
                            return !1;
                        }
                    })(this._xhr) && !this._destroyed && (this._response || this._connect(), this._response._onXHRProgress());
                }, ClientRequest.prototype._connect = function() {
                    var self = this;
                    self._destroyed || (self._response = new IncomingMessage(self._xhr, self._fetchResponse, self._mode, self._fetchTimer), 
                    self._response.on("error", (function(err) {
                        self.emit("error", err);
                    })), self.emit("response", self._response));
                }, ClientRequest.prototype._write = function(chunk, encoding, cb) {
                    this._body.push(chunk), cb();
                }, ClientRequest.prototype.abort = ClientRequest.prototype.destroy = function() {
                    this._destroyed = !0, global.clearTimeout(this._fetchTimer), this._response && (this._response._destroyed = !0), 
                    this._xhr ? this._xhr.abort() : this._fetchAbortController && this._fetchAbortController.abort();
                }, ClientRequest.prototype.end = function(data, encoding, cb) {
                    "function" == typeof data && (cb = data, data = void 0), stream.Writable.prototype.end.call(this, data, encoding, cb);
                }, ClientRequest.prototype.flushHeaders = function() {}, ClientRequest.prototype.setTimeout = function() {}, 
                ClientRequest.prototype.setNoDelay = function() {}, ClientRequest.prototype.setSocketKeepAlive = function() {};
                var unsafeHeaders = [ "accept-charset", "accept-encoding", "access-control-request-headers", "access-control-request-method", "connection", "content-length", "cookie", "cookie2", "date", "dnt", "expect", "host", "keep-alive", "origin", "referer", "te", "trailer", "transfer-encoding", "upgrade", "via" ];
            }).call(this, require("_process"), void 0 !== commonjsGlobal ? commonjsGlobal : "undefined" != typeof self ? self : void 0 !== window ? window : {}, require("buffer").Buffer);
        }, {
            "./capability": 157,
            "./response": 159,
            _process: 133,
            buffer: 48,
            inherits: 75,
            "readable-stream": 174
        } ],
        159: [ function(require, module, exports) {
            (function(process, global, Buffer) {
                var capability = require("./capability"), inherits = require("inherits"), stream = require("readable-stream"), rStates = exports.readyStates = {
                    UNSENT: 0,
                    OPENED: 1,
                    HEADERS_RECEIVED: 2,
                    LOADING: 3,
                    DONE: 4
                }, IncomingMessage = exports.IncomingMessage = function(xhr, response, mode, fetchTimer) {
                    var self = this;
                    if (stream.Readable.call(self), self._mode = mode, self.headers = {}, self.rawHeaders = [], 
                    self.trailers = {}, self.rawTrailers = [], self.on("end", (function() {
                        process.nextTick((function() {
                            self.emit("close");
                        }));
                    })), "fetch" === mode) {
                        if (self._fetchResponse = response, self.url = response.url, self.statusCode = response.status, 
                        self.statusMessage = response.statusText, response.headers.forEach((function(header, key) {
                            self.headers[key.toLowerCase()] = header, self.rawHeaders.push(key, header);
                        })), capability.writableStream) {
                            var writable = new WritableStream({
                                write: function(chunk) {
                                    return new Promise((function(resolve, reject) {
                                        self._destroyed ? reject() : self.push(Buffer.from(chunk)) ? resolve() : self._resumeFetch = resolve;
                                    }));
                                },
                                close: function() {
                                    global.clearTimeout(fetchTimer), self._destroyed || self.push(null);
                                },
                                abort: function(err) {
                                    self._destroyed || self.emit("error", err);
                                }
                            });
                            try {
                                return void response.body.pipeTo(writable).catch((function(err) {
                                    global.clearTimeout(fetchTimer), self._destroyed || self.emit("error", err);
                                }));
                            } catch (e) {}
                        }
                        var reader = response.body.getReader();
                        function read() {
                            reader.read().then((function(result) {
                                if (!self._destroyed) {
                                    if (result.done) return global.clearTimeout(fetchTimer), void self.push(null);
                                    self.push(Buffer.from(result.value)), read();
                                }
                            })).catch((function(err) {
                                global.clearTimeout(fetchTimer), self._destroyed || self.emit("error", err);
                            }));
                        }
                        read();
                    } else if (self._xhr = xhr, self._pos = 0, self.url = xhr.responseURL, self.statusCode = xhr.status, 
                    self.statusMessage = xhr.statusText, xhr.getAllResponseHeaders().split(/\r?\n/).forEach((function(header) {
                        var matches = header.match(/^([^:]+):\s*(.*)/);
                        if (matches) {
                            var key = matches[1].toLowerCase();
                            "set-cookie" === key ? (void 0 === self.headers[key] && (self.headers[key] = []), 
                            self.headers[key].push(matches[2])) : void 0 !== self.headers[key] ? self.headers[key] += ", " + matches[2] : self.headers[key] = matches[2], 
                            self.rawHeaders.push(matches[1], matches[2]);
                        }
                    })), self._charset = "x-user-defined", !capability.overrideMimeType) {
                        var mimeType = self.rawHeaders["mime-type"];
                        if (mimeType) {
                            var charsetMatch = mimeType.match(/;\s*charset=([^;])(;|$)/);
                            charsetMatch && (self._charset = charsetMatch[1].toLowerCase());
                        }
                        self._charset || (self._charset = "utf-8");
                    }
                };
                inherits(IncomingMessage, stream.Readable), IncomingMessage.prototype._read = function() {
                    var resolve = this._resumeFetch;
                    resolve && (this._resumeFetch = null, resolve());
                }, IncomingMessage.prototype._onXHRProgress = function() {
                    var self = this, xhr = self._xhr, response = null;
                    switch (self._mode) {
                      case "text":
                        if ((response = xhr.responseText).length > self._pos) {
                            var newData = response.substr(self._pos);
                            if ("x-user-defined" === self._charset) {
                                for (var buffer = Buffer.alloc(newData.length), i = 0; i < newData.length; i++) buffer[i] = 0xff & newData.charCodeAt(i);
                                self.push(buffer);
                            } else self.push(newData, self._charset);
                            self._pos = response.length;
                        }
                        break;

                      case "arraybuffer":
                        if (xhr.readyState !== rStates.DONE || !xhr.response) break;
                        response = xhr.response, self.push(Buffer.from(new Uint8Array(response)));
                        break;

                      case "moz-chunked-arraybuffer":
                        if (response = xhr.response, xhr.readyState !== rStates.LOADING || !response) break;
                        self.push(Buffer.from(new Uint8Array(response)));
                        break;

                      case "ms-stream":
                        if (response = xhr.response, xhr.readyState !== rStates.LOADING) break;
                        var reader = new global.MSStreamReader;
                        reader.onprogress = function() {
                            reader.result.byteLength > self._pos && (self.push(Buffer.from(new Uint8Array(reader.result.slice(self._pos)))), 
                            self._pos = reader.result.byteLength);
                        }, reader.onload = function() {
                            self.push(null);
                        }, reader.readAsArrayBuffer(response);
                    }
                    self._xhr.readyState === rStates.DONE && "ms-stream" !== self._mode && self.push(null);
                };
            }).call(this, require("_process"), void 0 !== commonjsGlobal ? commonjsGlobal : "undefined" != typeof self ? self : void 0 !== window ? window : {}, require("buffer").Buffer);
        }, {
            "./capability": 157,
            _process: 133,
            buffer: 48,
            inherits: 75,
            "readable-stream": 174
        } ],
        160: [ function(require, module, exports) {
            var codes = {};
            function createErrorType(code, message, Base) {
                Base || (Base = Error);
                var NodeError = function(_Base) {
                    function NodeError(arg1, arg2, arg3) {
                        return _Base.call(this, function getMessage(arg1, arg2, arg3) {
                            return "string" == typeof message ? message : message(arg1, arg2, arg3);
                        }(arg1, arg2, arg3)) || this;
                    }
                    return function _inheritsLoose(subClass, superClass) {
                        subClass.prototype = Object.create(superClass.prototype), subClass.prototype.constructor = subClass, 
                        subClass.__proto__ = superClass;
                    }(NodeError, _Base), NodeError;
                }(Base);
                NodeError.prototype.name = Base.name, NodeError.prototype.code = code, codes[code] = NodeError;
            }
            function oneOf(expected, thing) {
                if (Array.isArray(expected)) {
                    var len = expected.length;
                    return expected = expected.map((function(i) {
                        return String(i);
                    })), len > 2 ? "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(", "), ", or ") + expected[len - 1] : 2 === len ? "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]) : "of ".concat(thing, " ").concat(expected[0]);
                }
                return "of ".concat(thing, " ").concat(String(expected));
            }
            createErrorType("ERR_INVALID_OPT_VALUE", (function(name, value) {
                return 'The value "' + value + '" is invalid for option "' + name + '"';
            }), TypeError), createErrorType("ERR_INVALID_ARG_TYPE", (function(name, expected, actual) {
                var determiner, msg;
                if ("string" == typeof expected && function startsWith(str, search, pos) {
                    return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
                }(expected, "not ") ? (determiner = "must not be", expected = expected.replace(/^not /, "")) : determiner = "must be", 
                function endsWith(str, search, this_len) {
                    return (void 0 === this_len || this_len > str.length) && (this_len = str.length), 
                    str.substring(this_len - search.length, this_len) === search;
                }(name, " argument")) msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, "type")); else {
                    var type = function includes(str, search, start) {
                        return "number" != typeof start && (start = 0), !(start + search.length > str.length) && -1 !== str.indexOf(search, start);
                    }(name, ".") ? "property" : "argument";
                    msg = 'The "'.concat(name, '" ').concat(type, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
                }
                return msg + ". Received type ".concat(typeof actual);
            }), TypeError), createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF"), 
            createErrorType("ERR_METHOD_NOT_IMPLEMENTED", (function(name) {
                return "The " + name + " method is not implemented";
            })), createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close"), createErrorType("ERR_STREAM_DESTROYED", (function(name) {
                return "Cannot call " + name + " after a stream was destroyed";
            })), createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times"), 
            createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable"), createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end"), 
            createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError), 
            createErrorType("ERR_UNKNOWN_ENCODING", (function(arg) {
                return "Unknown encoding: " + arg;
            }), TypeError), createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event"), 
            module.exports.codes = codes;
        }, {} ],
        161: [ function(require, module, exports) {
            (function(process) {
                var experimentalWarnings = new Set;
                module.exports.emitExperimentalWarning = process.emitWarning ? function emitExperimentalWarning(feature) {
                    if (!experimentalWarnings.has(feature)) {
                        var msg = feature + " is an experimental feature. This feature could change at any time";
                        experimentalWarnings.add(feature), process.emitWarning(msg, "ExperimentalWarning");
                    }
                } : function noop() {};
            }).call(this, require("_process"));
        }, {
            _process: 133
        } ],
        162: [ function(require, module, exports) {
            (function(process) {
                var objectKeys = Object.keys || function(obj) {
                    var keys = [];
                    for (var key in obj) keys.push(key);
                    return keys;
                };
                module.exports = Duplex;
                var Readable = require("./_stream_readable"), Writable = require("./_stream_writable");
                require("inherits")(Duplex, Readable);
                for (var keys = objectKeys(Writable.prototype), v = 0; v < keys.length; v++) {
                    var method = keys[v];
                    Duplex.prototype[method] || (Duplex.prototype[method] = Writable.prototype[method]);
                }
                function Duplex(options) {
                    if (!(this instanceof Duplex)) return new Duplex(options);
                    Readable.call(this, options), Writable.call(this, options), this.allowHalfOpen = !0, 
                    options && (!1 === options.readable && (this.readable = !1), !1 === options.writable && (this.writable = !1), 
                    !1 === options.allowHalfOpen && (this.allowHalfOpen = !1, this.once("end", onend)));
                }
                function onend() {
                    this._writableState.ended || process.nextTick(onEndNT, this);
                }
                function onEndNT(self) {
                    self.end();
                }
                Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
                    enumerable: !1,
                    get: function get() {
                        return this._writableState.highWaterMark;
                    }
                }), Object.defineProperty(Duplex.prototype, "writableBuffer", {
                    enumerable: !1,
                    get: function get() {
                        return this._writableState && this._writableState.getBuffer();
                    }
                }), Object.defineProperty(Duplex.prototype, "writableLength", {
                    enumerable: !1,
                    get: function get() {
                        return this._writableState.length;
                    }
                }), Object.defineProperty(Duplex.prototype, "destroyed", {
                    enumerable: !1,
                    get: function get() {
                        return void 0 !== this._readableState && void 0 !== this._writableState && this._readableState.destroyed && this._writableState.destroyed;
                    },
                    set: function set(value) {
                        void 0 !== this._readableState && void 0 !== this._writableState && (this._readableState.destroyed = value, 
                        this._writableState.destroyed = value);
                    }
                });
            }).call(this, require("_process"));
        }, {
            "./_stream_readable": 164,
            "./_stream_writable": 166,
            _process: 133,
            inherits: 75
        } ],
        163: [ function(require, module, exports) {
            module.exports = PassThrough;
            var Transform = require("./_stream_transform");
            function PassThrough(options) {
                if (!(this instanceof PassThrough)) return new PassThrough(options);
                Transform.call(this, options);
            }
            require("inherits")(PassThrough, Transform), PassThrough.prototype._transform = function(chunk, encoding, cb) {
                cb(null, chunk);
            };
        }, {
            "./_stream_transform": 165,
            inherits: 75
        } ],
        164: [ function(require, module, exports) {
            (function(process, global) {
                var Duplex;
                module.exports = Readable, Readable.ReadableState = ReadableState, require("events").EventEmitter;
                var debug, EElistenerCount = function EElistenerCount(emitter, type) {
                    return emitter.listeners(type).length;
                }, Stream = require("./internal/streams/stream"), Buffer = require("buffer").Buffer, OurUint8Array = global.Uint8Array || function() {}, debugUtil = require("util");
                debug = debugUtil && debugUtil.debuglog ? debugUtil.debuglog("stream") : function debug() {};
                var StringDecoder, createReadableStreamAsyncIterator, BufferList = require("./internal/streams/buffer_list"), destroyImpl = require("./internal/streams/destroy"), getHighWaterMark = require("./internal/streams/state").getHighWaterMark, _require$codes = require("../errors").codes, ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE, ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT, emitExperimentalWarning = require("../experimentalWarning").emitExperimentalWarning;
                require("inherits")(Readable, Stream);
                var kProxyEvents = [ "error", "close", "destroy", "pause", "resume" ];
                function ReadableState(options, stream, isDuplex) {
                    Duplex = Duplex || require("./_stream_duplex"), options = options || {}, "boolean" != typeof isDuplex && (isDuplex = stream instanceof Duplex), 
                    this.objectMode = !!options.objectMode, isDuplex && (this.objectMode = this.objectMode || !!options.readableObjectMode), 
                    this.highWaterMark = getHighWaterMark(this, options, "readableHighWaterMark", isDuplex), 
                    this.buffer = new BufferList, this.length = 0, this.pipes = null, this.pipesCount = 0, 
                    this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, 
                    this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, 
                    this.resumeScheduled = !1, this.paused = !0, this.emitClose = !1 !== options.emitClose, 
                    this.destroyed = !1, this.defaultEncoding = options.defaultEncoding || "utf8", this.awaitDrain = 0, 
                    this.readingMore = !1, this.decoder = null, this.encoding = null, options.encoding && (StringDecoder || (StringDecoder = require("string_decoder/").StringDecoder), 
                    this.decoder = new StringDecoder(options.encoding), this.encoding = options.encoding);
                }
                function Readable(options) {
                    if (Duplex = Duplex || require("./_stream_duplex"), !(this instanceof Readable)) return new Readable(options);
                    var isDuplex = this instanceof Duplex;
                    this._readableState = new ReadableState(options, this, isDuplex), this.readable = !0, 
                    options && ("function" == typeof options.read && (this._read = options.read), "function" == typeof options.destroy && (this._destroy = options.destroy)), 
                    Stream.call(this);
                }
                function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
                    debug("readableAddChunk", chunk);
                    var er, state = stream._readableState;
                    if (null === chunk) state.reading = !1, function onEofChunk(stream, state) {
                        if (!state.ended) {
                            if (state.decoder) {
                                var chunk = state.decoder.end();
                                chunk && chunk.length && (state.buffer.push(chunk), state.length += state.objectMode ? 1 : chunk.length);
                            }
                            state.ended = !0, state.sync ? emitReadable(stream) : (state.needReadable = !1, 
                            state.emittedReadable || (state.emittedReadable = !0, emitReadable_(stream)));
                        }
                    }(stream, state); else if (skipChunkCheck || (er = function chunkInvalid(state, chunk) {
                        var er;
                        return function _isUint8Array(obj) {
                            return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
                        }(chunk) || "string" == typeof chunk || void 0 === chunk || state.objectMode || (er = new ERR_INVALID_ARG_TYPE("chunk", [ "string", "Buffer", "Uint8Array" ], chunk)), 
                        er;
                    }(state, chunk)), er) stream.emit("error", er); else if (state.objectMode || chunk && chunk.length > 0) if ("string" == typeof chunk || state.objectMode || Object.getPrototypeOf(chunk) === Buffer.prototype || (chunk = function _uint8ArrayToBuffer(chunk) {
                        return Buffer.from(chunk);
                    }(chunk)), addToFront) state.endEmitted ? stream.emit("error", new ERR_STREAM_UNSHIFT_AFTER_END_EVENT) : addChunk(stream, state, chunk, !0); else if (state.ended) stream.emit("error", new ERR_STREAM_PUSH_AFTER_EOF); else {
                        if (state.destroyed) return !1;
                        state.reading = !1, state.decoder && !encoding ? (chunk = state.decoder.write(chunk), 
                        state.objectMode || 0 !== chunk.length ? addChunk(stream, state, chunk, !1) : maybeReadMore(stream, state)) : addChunk(stream, state, chunk, !1);
                    } else addToFront || (state.reading = !1, maybeReadMore(stream, state));
                    return !state.ended && (state.length < state.highWaterMark || 0 === state.length);
                }
                function addChunk(stream, state, chunk, addToFront) {
                    state.flowing && 0 === state.length && !state.sync ? (state.awaitDrain = 0, stream.emit("data", chunk)) : (state.length += state.objectMode ? 1 : chunk.length, 
                    addToFront ? state.buffer.unshift(chunk) : state.buffer.push(chunk), state.needReadable && emitReadable(stream)), 
                    maybeReadMore(stream, state);
                }
                function howMuchToRead(n, state) {
                    return n <= 0 || 0 === state.length && state.ended ? 0 : state.objectMode ? 1 : n != n ? state.flowing && state.length ? state.buffer.head.data.length : state.length : (n > state.highWaterMark && (state.highWaterMark = function computeNewHighWaterMark(n) {
                        return n >= 8388608 ? n = 8388608 : (n--, n |= n >>> 1, n |= n >>> 2, n |= n >>> 4, 
                        n |= n >>> 8, n |= n >>> 16, n++), n;
                    }(n)), n <= state.length ? n : state.ended ? state.length : (state.needReadable = !0, 
                    0));
                }
                function emitReadable(stream) {
                    var state = stream._readableState;
                    state.needReadable = !1, state.emittedReadable || (debug("emitReadable", state.flowing), 
                    state.emittedReadable = !0, process.nextTick(emitReadable_, stream));
                }
                function emitReadable_(stream) {
                    var state = stream._readableState;
                    debug("emitReadable_", state.destroyed, state.length, state.ended), state.destroyed || !state.length && !state.ended || stream.emit("readable"), 
                    state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark, 
                    flow(stream);
                }
                function maybeReadMore(stream, state) {
                    state.readingMore || (state.readingMore = !0, process.nextTick(maybeReadMore_, stream, state));
                }
                function maybeReadMore_(stream, state) {
                    for (;!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && 0 === state.length); ) {
                        var len = state.length;
                        if (debug("maybeReadMore read 0"), stream.read(0), len === state.length) break;
                    }
                    state.readingMore = !1;
                }
                function updateReadableListening(self) {
                    var state = self._readableState;
                    state.readableListening = self.listenerCount("readable") > 0, state.resumeScheduled && !state.paused ? state.flowing = !0 : self.listenerCount("data") > 0 && self.resume();
                }
                function nReadingNextTick(self) {
                    debug("readable nexttick read 0"), self.read(0);
                }
                function resume_(stream, state) {
                    debug("resume", state.reading), state.reading || stream.read(0), state.resumeScheduled = !1, 
                    stream.emit("resume"), flow(stream), state.flowing && !state.reading && stream.read(0);
                }
                function flow(stream) {
                    var state = stream._readableState;
                    for (debug("flow", state.flowing); state.flowing && null !== stream.read(); ) ;
                }
                function fromList(n, state) {
                    return 0 === state.length ? null : (state.objectMode ? ret = state.buffer.shift() : !n || n >= state.length ? (ret = state.decoder ? state.buffer.join("") : 1 === state.buffer.length ? state.buffer.first() : state.buffer.concat(state.length), 
                    state.buffer.clear()) : ret = state.buffer.consume(n, state.decoder), ret);
                    var ret;
                }
                function endReadable(stream) {
                    var state = stream._readableState;
                    debug("endReadable", state.endEmitted), state.endEmitted || (state.ended = !0, process.nextTick(endReadableNT, state, stream));
                }
                function endReadableNT(state, stream) {
                    debug("endReadableNT", state.endEmitted, state.length), state.endEmitted || 0 !== state.length || (state.endEmitted = !0, 
                    stream.readable = !1, stream.emit("end"));
                }
                function indexOf(xs, x) {
                    for (var i = 0, l = xs.length; i < l; i++) if (xs[i] === x) return i;
                    return -1;
                }
                Object.defineProperty(Readable.prototype, "destroyed", {
                    enumerable: !1,
                    get: function get() {
                        return void 0 !== this._readableState && this._readableState.destroyed;
                    },
                    set: function set(value) {
                        this._readableState && (this._readableState.destroyed = value);
                    }
                }), Readable.prototype.destroy = destroyImpl.destroy, Readable.prototype._undestroy = destroyImpl.undestroy, 
                Readable.prototype._destroy = function(err, cb) {
                    cb(err);
                }, Readable.prototype.push = function(chunk, encoding) {
                    var skipChunkCheck, state = this._readableState;
                    return state.objectMode ? skipChunkCheck = !0 : "string" == typeof chunk && ((encoding = encoding || state.defaultEncoding) !== state.encoding && (chunk = Buffer.from(chunk, encoding), 
                    encoding = ""), skipChunkCheck = !0), readableAddChunk(this, chunk, encoding, !1, skipChunkCheck);
                }, Readable.prototype.unshift = function(chunk) {
                    return readableAddChunk(this, chunk, null, !0, !1);
                }, Readable.prototype.isPaused = function() {
                    return !1 === this._readableState.flowing;
                }, Readable.prototype.setEncoding = function(enc) {
                    return StringDecoder || (StringDecoder = require("string_decoder/").StringDecoder), 
                    this._readableState.decoder = new StringDecoder(enc), this._readableState.encoding = this._readableState.decoder.encoding, 
                    this;
                }, Readable.prototype.read = function(n) {
                    debug("read", n), n = parseInt(n, 10);
                    var state = this._readableState, nOrig = n;
                    if (0 !== n && (state.emittedReadable = !1), 0 === n && state.needReadable && ((0 !== state.highWaterMark ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) return debug("read: emitReadable", state.length, state.ended), 
                    0 === state.length && state.ended ? endReadable(this) : emitReadable(this), null;
                    if (0 === (n = howMuchToRead(n, state)) && state.ended) return 0 === state.length && endReadable(this), 
                    null;
                    var ret, doRead = state.needReadable;
                    return debug("need readable", doRead), (0 === state.length || state.length - n < state.highWaterMark) && debug("length less than watermark", doRead = !0), 
                    state.ended || state.reading ? debug("reading or ended", doRead = !1) : doRead && (debug("do read"), 
                    state.reading = !0, state.sync = !0, 0 === state.length && (state.needReadable = !0), 
                    this._read(state.highWaterMark), state.sync = !1, state.reading || (n = howMuchToRead(nOrig, state))), 
                    null === (ret = n > 0 ? fromList(n, state) : null) ? (state.needReadable = !0, n = 0) : (state.length -= n, 
                    state.awaitDrain = 0), 0 === state.length && (state.ended || (state.needReadable = !0), 
                    nOrig !== n && state.ended && endReadable(this)), null !== ret && this.emit("data", ret), 
                    ret;
                }, Readable.prototype._read = function(n) {
                    this.emit("error", new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
                }, Readable.prototype.pipe = function(dest, pipeOpts) {
                    var src = this, state = this._readableState;
                    switch (state.pipesCount) {
                      case 0:
                        state.pipes = dest;
                        break;

                      case 1:
                        state.pipes = [ state.pipes, dest ];
                        break;

                      default:
                        state.pipes.push(dest);
                    }
                    state.pipesCount += 1, debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
                    var endFn = pipeOpts && !1 === pipeOpts.end || dest === process.stdout || dest === process.stderr ? unpipe : onend;
                    function onend() {
                        debug("onend"), dest.end();
                    }
                    state.endEmitted ? process.nextTick(endFn) : src.once("end", endFn), dest.on("unpipe", (function onunpipe(readable, unpipeInfo) {
                        debug("onunpipe"), readable === src && unpipeInfo && !1 === unpipeInfo.hasUnpiped && (unpipeInfo.hasUnpiped = !0, 
                        function cleanup() {
                            debug("cleanup"), dest.removeListener("close", onclose), dest.removeListener("finish", onfinish), 
                            dest.removeListener("drain", ondrain), dest.removeListener("error", onerror), dest.removeListener("unpipe", onunpipe), 
                            src.removeListener("end", onend), src.removeListener("end", unpipe), src.removeListener("data", ondata), 
                            cleanedUp = !0, !state.awaitDrain || dest._writableState && !dest._writableState.needDrain || ondrain();
                        }());
                    }));
                    var ondrain = function pipeOnDrain(src) {
                        return function pipeOnDrainFunctionResult() {
                            var state = src._readableState;
                            debug("pipeOnDrain", state.awaitDrain), state.awaitDrain && state.awaitDrain--, 
                            0 === state.awaitDrain && EElistenerCount(src, "data") && (state.flowing = !0, flow(src));
                        };
                    }(src);
                    dest.on("drain", ondrain);
                    var cleanedUp = !1;
                    function ondata(chunk) {
                        debug("ondata");
                        var ret = dest.write(chunk);
                        debug("dest.write", ret), !1 === ret && ((1 === state.pipesCount && state.pipes === dest || state.pipesCount > 1 && -1 !== indexOf(state.pipes, dest)) && !cleanedUp && (debug("false write response, pause", state.awaitDrain), 
                        state.awaitDrain++), src.pause());
                    }
                    function onerror(er) {
                        debug("onerror", er), unpipe(), dest.removeListener("error", onerror), 0 === EElistenerCount(dest, "error") && dest.emit("error", er);
                    }
                    function onclose() {
                        dest.removeListener("finish", onfinish), unpipe();
                    }
                    function onfinish() {
                        debug("onfinish"), dest.removeListener("close", onclose), unpipe();
                    }
                    function unpipe() {
                        debug("unpipe"), src.unpipe(dest);
                    }
                    return src.on("data", ondata), function prependListener(emitter, event, fn) {
                        if ("function" == typeof emitter.prependListener) return emitter.prependListener(event, fn);
                        emitter._events && emitter._events[event] ? Array.isArray(emitter._events[event]) ? emitter._events[event].unshift(fn) : emitter._events[event] = [ fn, emitter._events[event] ] : emitter.on(event, fn);
                    }(dest, "error", onerror), dest.once("close", onclose), dest.once("finish", onfinish), 
                    dest.emit("pipe", src), state.flowing || (debug("pipe resume"), src.resume()), dest;
                }, Readable.prototype.unpipe = function(dest) {
                    var state = this._readableState, unpipeInfo = {
                        hasUnpiped: !1
                    };
                    if (0 === state.pipesCount) return this;
                    if (1 === state.pipesCount) return dest && dest !== state.pipes || (dest || (dest = state.pipes), 
                    state.pipes = null, state.pipesCount = 0, state.flowing = !1, dest && dest.emit("unpipe", this, unpipeInfo)), 
                    this;
                    if (!dest) {
                        var dests = state.pipes, len = state.pipesCount;
                        state.pipes = null, state.pipesCount = 0, state.flowing = !1;
                        for (var i = 0; i < len; i++) dests[i].emit("unpipe", this, {
                            hasUnpiped: !1
                        });
                        return this;
                    }
                    var index = indexOf(state.pipes, dest);
                    return -1 === index || (state.pipes.splice(index, 1), state.pipesCount -= 1, 1 === state.pipesCount && (state.pipes = state.pipes[0]), 
                    dest.emit("unpipe", this, unpipeInfo)), this;
                }, Readable.prototype.on = function(ev, fn) {
                    var res = Stream.prototype.on.call(this, ev, fn), state = this._readableState;
                    return "data" === ev ? (state.readableListening = this.listenerCount("readable") > 0, 
                    !1 !== state.flowing && this.resume()) : "readable" === ev && (state.endEmitted || state.readableListening || (state.readableListening = state.needReadable = !0, 
                    state.flowing = !1, state.emittedReadable = !1, debug("on readable", state.length, state.reading), 
                    state.length ? emitReadable(this) : state.reading || process.nextTick(nReadingNextTick, this))), 
                    res;
                }, Readable.prototype.addListener = Readable.prototype.on, Readable.prototype.removeListener = function(ev, fn) {
                    var res = Stream.prototype.removeListener.call(this, ev, fn);
                    return "readable" === ev && process.nextTick(updateReadableListening, this), res;
                }, Readable.prototype.removeAllListeners = function(ev) {
                    var res = Stream.prototype.removeAllListeners.apply(this, arguments);
                    return "readable" !== ev && void 0 !== ev || process.nextTick(updateReadableListening, this), 
                    res;
                }, Readable.prototype.resume = function() {
                    var state = this._readableState;
                    return state.flowing || (debug("resume"), state.flowing = !state.readableListening, 
                    function resume(stream, state) {
                        state.resumeScheduled || (state.resumeScheduled = !0, process.nextTick(resume_, stream, state));
                    }(this, state)), state.paused = !1, this;
                }, Readable.prototype.pause = function() {
                    return debug("call pause flowing=%j", this._readableState.flowing), !1 !== this._readableState.flowing && (debug("pause"), 
                    this._readableState.flowing = !1, this.emit("pause")), this._readableState.paused = !0, 
                    this;
                }, Readable.prototype.wrap = function(stream) {
                    var _this = this, state = this._readableState, paused = !1;
                    for (var i in stream.on("end", (function() {
                        if (debug("wrapped end"), state.decoder && !state.ended) {
                            var chunk = state.decoder.end();
                            chunk && chunk.length && _this.push(chunk);
                        }
                        _this.push(null);
                    })), stream.on("data", (function(chunk) {
                        debug("wrapped data"), state.decoder && (chunk = state.decoder.write(chunk)), state.objectMode && null == chunk || (state.objectMode || chunk && chunk.length) && (_this.push(chunk) || (paused = !0, 
                        stream.pause()));
                    })), stream) void 0 === this[i] && "function" == typeof stream[i] && (this[i] = function methodWrap(method) {
                        return function methodWrapReturnFunction() {
                            return stream[method].apply(stream, arguments);
                        };
                    }(i));
                    for (var n = 0; n < kProxyEvents.length; n++) stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
                    return this._read = function(n) {
                        debug("wrapped _read", n), paused && (paused = !1, stream.resume());
                    }, this;
                }, "function" == typeof Symbol && (Readable.prototype[Symbol.asyncIterator] = function() {
                    return emitExperimentalWarning("Readable[Symbol.asyncIterator]"), void 0 === createReadableStreamAsyncIterator && (createReadableStreamAsyncIterator = require("./internal/streams/async_iterator")), 
                    createReadableStreamAsyncIterator(this);
                }), Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
                    enumerable: !1,
                    get: function get() {
                        return this._readableState.highWaterMark;
                    }
                }), Object.defineProperty(Readable.prototype, "readableBuffer", {
                    enumerable: !1,
                    get: function get() {
                        return this._readableState && this._readableState.buffer;
                    }
                }), Object.defineProperty(Readable.prototype, "readableFlowing", {
                    enumerable: !1,
                    get: function get() {
                        return this._readableState.flowing;
                    },
                    set: function set(state) {
                        this._readableState && (this._readableState.flowing = state);
                    }
                }), Readable._fromList = fromList, Object.defineProperty(Readable.prototype, "readableLength", {
                    enumerable: !1,
                    get: function get() {
                        return this._readableState.length;
                    }
                });
            }).call(this, require("_process"), void 0 !== commonjsGlobal ? commonjsGlobal : "undefined" != typeof self ? self : void 0 !== window ? window : {});
        }, {
            "../errors": 160,
            "../experimentalWarning": 161,
            "./_stream_duplex": 162,
            "./internal/streams/async_iterator": 167,
            "./internal/streams/buffer_list": 168,
            "./internal/streams/destroy": 169,
            "./internal/streams/state": 172,
            "./internal/streams/stream": 173,
            _process: 133,
            buffer: 48,
            events: 52,
            inherits: 75,
            "string_decoder/": 175,
            util: 33
        } ],
        165: [ function(require, module, exports) {
            module.exports = Transform;
            var _require$codes = require("../errors").codes, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK, ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING, ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0, Duplex = require("./_stream_duplex");
            function afterTransform(er, data) {
                var ts = this._transformState;
                ts.transforming = !1;
                var cb = ts.writecb;
                if (null === cb) return this.emit("error", new ERR_MULTIPLE_CALLBACK);
                ts.writechunk = null, ts.writecb = null, null != data && this.push(data), cb(er);
                var rs = this._readableState;
                rs.reading = !1, (rs.needReadable || rs.length < rs.highWaterMark) && this._read(rs.highWaterMark);
            }
            function Transform(options) {
                if (!(this instanceof Transform)) return new Transform(options);
                Duplex.call(this, options), this._transformState = {
                    afterTransform: afterTransform.bind(this),
                    needTransform: !1,
                    transforming: !1,
                    writecb: null,
                    writechunk: null,
                    writeencoding: null
                }, this._readableState.needReadable = !0, this._readableState.sync = !1, options && ("function" == typeof options.transform && (this._transform = options.transform), 
                "function" == typeof options.flush && (this._flush = options.flush)), this.on("prefinish", prefinish);
            }
            function prefinish() {
                var _this = this;
                "function" != typeof this._flush || this._readableState.destroyed ? done(this, null, null) : this._flush((function(er, data) {
                    done(_this, er, data);
                }));
            }
            function done(stream, er, data) {
                if (er) return stream.emit("error", er);
                if (null != data && stream.push(data), stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0;
                if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING;
                return stream.push(null);
            }
            require("inherits")(Transform, Duplex), Transform.prototype.push = function(chunk, encoding) {
                return this._transformState.needTransform = !1, Duplex.prototype.push.call(this, chunk, encoding);
            }, Transform.prototype._transform = function(chunk, encoding, cb) {
                cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
            }, Transform.prototype._write = function(chunk, encoding, cb) {
                var ts = this._transformState;
                if (ts.writecb = cb, ts.writechunk = chunk, ts.writeencoding = encoding, !ts.transforming) {
                    var rs = this._readableState;
                    (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) && this._read(rs.highWaterMark);
                }
            }, Transform.prototype._read = function(n) {
                var ts = this._transformState;
                null === ts.writechunk || ts.transforming ? ts.needTransform = !0 : (ts.transforming = !0, 
                this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform));
            }, Transform.prototype._destroy = function(err, cb) {
                Duplex.prototype._destroy.call(this, err, (function(err2) {
                    cb(err2);
                }));
            };
        }, {
            "../errors": 160,
            "./_stream_duplex": 162,
            inherits: 75
        } ],
        166: [ function(require, module, exports) {
            (function(process, global) {
                function CorkedRequest(state) {
                    var _this = this;
                    this.next = null, this.entry = null, this.finish = function() {
                        !function onCorkedFinish(corkReq, state, err) {
                            var entry = corkReq.entry;
                            for (corkReq.entry = null; entry; ) {
                                var cb = entry.callback;
                                state.pendingcb--, cb(err), entry = entry.next;
                            }
                            state.corkedRequestsFree.next = corkReq;
                        }(_this, state);
                    };
                }
                var Duplex;
                module.exports = Writable, Writable.WritableState = WritableState;
                var realHasInstance, internalUtil = {
                    deprecate: require("util-deprecate")
                }, Stream = require("./internal/streams/stream"), Buffer = require("buffer").Buffer, OurUint8Array = global.Uint8Array || function() {}, destroyImpl = require("./internal/streams/destroy"), getHighWaterMark = require("./internal/streams/state").getHighWaterMark, _require$codes = require("../errors").codes, ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE, ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED, ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK, ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE, ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED, ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES, ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END, ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
                function nop() {}
                function WritableState(options, stream, isDuplex) {
                    Duplex = Duplex || require("./_stream_duplex"), options = options || {}, "boolean" != typeof isDuplex && (isDuplex = stream instanceof Duplex), 
                    this.objectMode = !!options.objectMode, isDuplex && (this.objectMode = this.objectMode || !!options.writableObjectMode), 
                    this.highWaterMark = getHighWaterMark(this, options, "writableHighWaterMark", isDuplex), 
                    this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, 
                    this.destroyed = !1;
                    var noDecode = !1 === options.decodeStrings;
                    this.decodeStrings = !noDecode, this.defaultEncoding = options.defaultEncoding || "utf8", 
                    this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, 
                    this.onwrite = function(er) {
                        !function onwrite(stream, er) {
                            var state = stream._writableState, sync = state.sync, cb = state.writecb;
                            if ("function" != typeof cb) throw new ERR_MULTIPLE_CALLBACK;
                            if (function onwriteStateUpdate(state) {
                                state.writing = !1, state.writecb = null, state.length -= state.writelen, state.writelen = 0;
                            }(state), er) !function onwriteError(stream, state, sync, er, cb) {
                                --state.pendingcb, sync ? (process.nextTick(cb, er), process.nextTick(finishMaybe, stream, state), 
                                stream._writableState.errorEmitted = !0, stream.emit("error", er)) : (cb(er), stream._writableState.errorEmitted = !0, 
                                stream.emit("error", er), finishMaybe(stream, state));
                            }(stream, state, sync, er, cb); else {
                                var finished = needFinish(state) || stream.destroyed;
                                finished || state.corked || state.bufferProcessing || !state.bufferedRequest || clearBuffer(stream, state), 
                                sync ? process.nextTick(afterWrite, stream, state, finished, cb) : afterWrite(stream, state, finished, cb);
                            }
                        }(stream, er);
                    }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, 
                    this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = !1 !== options.emitClose, 
                    this.bufferedRequestCount = 0, this.corkedRequestsFree = new CorkedRequest(this);
                }
                function Writable(options) {
                    var isDuplex = this instanceof (Duplex = Duplex || require("./_stream_duplex"));
                    if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);
                    this._writableState = new WritableState(options, this, isDuplex), this.writable = !0, 
                    options && ("function" == typeof options.write && (this._write = options.write), 
                    "function" == typeof options.writev && (this._writev = options.writev), "function" == typeof options.destroy && (this._destroy = options.destroy), 
                    "function" == typeof options.final && (this._final = options.final)), Stream.call(this);
                }
                function doWrite(stream, state, writev, len, chunk, encoding, cb) {
                    state.writelen = len, state.writecb = cb, state.writing = !0, state.sync = !0, state.destroyed ? state.onwrite(new ERR_STREAM_DESTROYED("write")) : writev ? stream._writev(chunk, state.onwrite) : stream._write(chunk, encoding, state.onwrite), 
                    state.sync = !1;
                }
                function afterWrite(stream, state, finished, cb) {
                    finished || function onwriteDrain(stream, state) {
                        0 === state.length && state.needDrain && (state.needDrain = !1, stream.emit("drain"));
                    }(stream, state), state.pendingcb--, cb(), finishMaybe(stream, state);
                }
                function clearBuffer(stream, state) {
                    state.bufferProcessing = !0;
                    var entry = state.bufferedRequest;
                    if (stream._writev && entry && entry.next) {
                        var l = state.bufferedRequestCount, buffer = new Array(l), holder = state.corkedRequestsFree;
                        holder.entry = entry;
                        for (var count = 0, allBuffers = !0; entry; ) buffer[count] = entry, entry.isBuf || (allBuffers = !1), 
                        entry = entry.next, count += 1;
                        buffer.allBuffers = allBuffers, doWrite(stream, state, !0, state.length, buffer, "", holder.finish), 
                        state.pendingcb++, state.lastBufferedRequest = null, holder.next ? (state.corkedRequestsFree = holder.next, 
                        holder.next = null) : state.corkedRequestsFree = new CorkedRequest(state), state.bufferedRequestCount = 0;
                    } else {
                        for (;entry; ) {
                            var chunk = entry.chunk, encoding = entry.encoding, cb = entry.callback;
                            if (doWrite(stream, state, !1, state.objectMode ? 1 : chunk.length, chunk, encoding, cb), 
                            entry = entry.next, state.bufferedRequestCount--, state.writing) break;
                        }
                        null === entry && (state.lastBufferedRequest = null);
                    }
                    state.bufferedRequest = entry, state.bufferProcessing = !1;
                }
                function needFinish(state) {
                    return state.ending && 0 === state.length && null === state.bufferedRequest && !state.finished && !state.writing;
                }
                function callFinal(stream, state) {
                    stream._final((function(err) {
                        state.pendingcb--, err && stream.emit("error", err), state.prefinished = !0, stream.emit("prefinish"), 
                        finishMaybe(stream, state);
                    }));
                }
                function finishMaybe(stream, state) {
                    var need = needFinish(state);
                    return need && (function prefinish(stream, state) {
                        state.prefinished || state.finalCalled || ("function" != typeof stream._final || state.destroyed ? (state.prefinished = !0, 
                        stream.emit("prefinish")) : (state.pendingcb++, state.finalCalled = !0, process.nextTick(callFinal, stream, state)));
                    }(stream, state), 0 === state.pendingcb && (state.finished = !0, stream.emit("finish"))), 
                    need;
                }
                require("inherits")(Writable, Stream), WritableState.prototype.getBuffer = function getBuffer() {
                    for (var current = this.bufferedRequest, out = []; current; ) out.push(current), 
                    current = current.next;
                    return out;
                }, function() {
                    try {
                        Object.defineProperty(WritableState.prototype, "buffer", {
                            get: internalUtil.deprecate((function writableStateBufferGetter() {
                                return this.getBuffer();
                            }), "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
                        });
                    } catch (_) {}
                }(), "function" == typeof Symbol && Symbol.hasInstance && "function" == typeof Function.prototype[Symbol.hasInstance] ? (realHasInstance = Function.prototype[Symbol.hasInstance], 
                Object.defineProperty(Writable, Symbol.hasInstance, {
                    value: function value(object) {
                        return !!realHasInstance.call(this, object) || this === Writable && object && object._writableState instanceof WritableState;
                    }
                })) : realHasInstance = function realHasInstance(object) {
                    return object instanceof this;
                }, Writable.prototype.pipe = function() {
                    this.emit("error", new ERR_STREAM_CANNOT_PIPE);
                }, Writable.prototype.write = function(chunk, encoding, cb) {
                    var state = this._writableState, ret = !1, isBuf = !state.objectMode && function _isUint8Array(obj) {
                        return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
                    }(chunk);
                    return isBuf && !Buffer.isBuffer(chunk) && (chunk = function _uint8ArrayToBuffer(chunk) {
                        return Buffer.from(chunk);
                    }(chunk)), "function" == typeof encoding && (cb = encoding, encoding = null), isBuf ? encoding = "buffer" : encoding || (encoding = state.defaultEncoding), 
                    "function" != typeof cb && (cb = nop), state.ending ? function writeAfterEnd(stream, cb) {
                        var er = new ERR_STREAM_WRITE_AFTER_END;
                        stream.emit("error", er), process.nextTick(cb, er);
                    }(this, cb) : (isBuf || function validChunk(stream, state, chunk, cb) {
                        var er;
                        return null === chunk ? er = new ERR_STREAM_NULL_VALUES : "string" == typeof chunk || state.objectMode || (er = new ERR_INVALID_ARG_TYPE("chunk", [ "string", "Buffer" ], chunk)), 
                        !er || (stream.emit("error", er), process.nextTick(cb, er), !1);
                    }(this, state, chunk, cb)) && (state.pendingcb++, ret = function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
                        if (!isBuf) {
                            var newChunk = function decodeChunk(state, chunk, encoding) {
                                return state.objectMode || !1 === state.decodeStrings || "string" != typeof chunk || (chunk = Buffer.from(chunk, encoding)), 
                                chunk;
                            }(state, chunk, encoding);
                            chunk !== newChunk && (isBuf = !0, encoding = "buffer", chunk = newChunk);
                        }
                        var len = state.objectMode ? 1 : chunk.length;
                        state.length += len;
                        var ret = state.length < state.highWaterMark;
                        if (ret || (state.needDrain = !0), state.writing || state.corked) {
                            var last = state.lastBufferedRequest;
                            state.lastBufferedRequest = {
                                chunk,
                                encoding,
                                isBuf,
                                callback: cb,
                                next: null
                            }, last ? last.next = state.lastBufferedRequest : state.bufferedRequest = state.lastBufferedRequest, 
                            state.bufferedRequestCount += 1;
                        } else doWrite(stream, state, !1, len, chunk, encoding, cb);
                        return ret;
                    }(this, state, isBuf, chunk, encoding, cb)), ret;
                }, Writable.prototype.cork = function() {
                    this._writableState.corked++;
                }, Writable.prototype.uncork = function() {
                    var state = this._writableState;
                    state.corked && (state.corked--, state.writing || state.corked || state.bufferProcessing || !state.bufferedRequest || clearBuffer(this, state));
                }, Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
                    if ("string" == typeof encoding && (encoding = encoding.toLowerCase()), !([ "hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw" ].indexOf((encoding + "").toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);
                    return this._writableState.defaultEncoding = encoding, this;
                }, Object.defineProperty(Writable.prototype, "writableBuffer", {
                    enumerable: !1,
                    get: function get() {
                        return this._writableState && this._writableState.getBuffer();
                    }
                }), Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
                    enumerable: !1,
                    get: function get() {
                        return this._writableState.highWaterMark;
                    }
                }), Writable.prototype._write = function(chunk, encoding, cb) {
                    cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
                }, Writable.prototype._writev = null, Writable.prototype.end = function(chunk, encoding, cb) {
                    var state = this._writableState;
                    return "function" == typeof chunk ? (cb = chunk, chunk = null, encoding = null) : "function" == typeof encoding && (cb = encoding, 
                    encoding = null), null != chunk && this.write(chunk, encoding), state.corked && (state.corked = 1, 
                    this.uncork()), state.ending || function endWritable(stream, state, cb) {
                        state.ending = !0, finishMaybe(stream, state), cb && (state.finished ? process.nextTick(cb) : stream.once("finish", cb)), 
                        state.ended = !0, stream.writable = !1;
                    }(this, state, cb), this;
                }, Object.defineProperty(Writable.prototype, "writableLength", {
                    enumerable: !1,
                    get: function get() {
                        return this._writableState.length;
                    }
                }), Object.defineProperty(Writable.prototype, "destroyed", {
                    enumerable: !1,
                    get: function get() {
                        return void 0 !== this._writableState && this._writableState.destroyed;
                    },
                    set: function set(value) {
                        this._writableState && (this._writableState.destroyed = value);
                    }
                }), Writable.prototype.destroy = destroyImpl.destroy, Writable.prototype._undestroy = destroyImpl.undestroy, 
                Writable.prototype._destroy = function(err, cb) {
                    cb(err);
                };
            }).call(this, require("_process"), void 0 !== commonjsGlobal ? commonjsGlobal : "undefined" != typeof self ? self : void 0 !== window ? window : {});
        }, {
            "../errors": 160,
            "./_stream_duplex": 162,
            "./internal/streams/destroy": 169,
            "./internal/streams/state": 172,
            "./internal/streams/stream": 173,
            _process: 133,
            buffer: 48,
            inherits: 75,
            "util-deprecate": 183
        } ],
        167: [ function(require, module, exports) {
            (function(process) {
                var _Object$setPrototypeO;
                function _defineProperty(obj, key, value) {
                    return key in obj ? Object.defineProperty(obj, key, {
                        value,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    }) : obj[key] = value, obj;
                }
                var finished = require("./end-of-stream"), kLastResolve = Symbol("lastResolve"), kLastReject = Symbol("lastReject"), kError = Symbol("error"), kEnded = Symbol("ended"), kLastPromise = Symbol("lastPromise"), kHandlePromise = Symbol("handlePromise"), kStream = Symbol("stream");
                function createIterResult(value, done) {
                    return {
                        value,
                        done
                    };
                }
                function readAndResolve(iter) {
                    var resolve = iter[kLastResolve];
                    if (null !== resolve) {
                        var data = iter[kStream].read();
                        null !== data && (iter[kLastPromise] = null, iter[kLastResolve] = null, iter[kLastReject] = null, 
                        resolve(createIterResult(data, !1)));
                    }
                }
                function onReadable(iter) {
                    process.nextTick(readAndResolve, iter);
                }
                var AsyncIteratorPrototype = Object.getPrototypeOf((function() {})), ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_defineProperty(_Object$setPrototypeO = {
                    get stream() {
                        return this[kStream];
                    },
                    next: function next() {
                        var _this = this, error = this[kError];
                        if (null !== error) return Promise.reject(error);
                        if (this[kEnded]) return Promise.resolve(createIterResult(void 0, !0));
                        if (this[kStream].destroyed) return new Promise((function(resolve, reject) {
                            process.nextTick((function() {
                                _this[kError] ? reject(_this[kError]) : resolve(createIterResult(void 0, !0));
                            }));
                        }));
                        var promise, lastPromise = this[kLastPromise];
                        if (lastPromise) promise = new Promise(function wrapForNext(lastPromise, iter) {
                            return function(resolve, reject) {
                                lastPromise.then((function() {
                                    iter[kEnded] ? resolve(createIterResult(void 0, !0)) : iter[kHandlePromise](resolve, reject);
                                }), reject);
                            };
                        }(lastPromise, this)); else {
                            var data = this[kStream].read();
                            if (null !== data) return Promise.resolve(createIterResult(data, !1));
                            promise = new Promise(this[kHandlePromise]);
                        }
                        return this[kLastPromise] = promise, promise;
                    }
                }, Symbol.asyncIterator, (function() {
                    return this;
                })), _defineProperty(_Object$setPrototypeO, "return", (function _return() {
                    var _this2 = this;
                    return new Promise((function(resolve, reject) {
                        _this2[kStream].destroy(null, (function(err) {
                            err ? reject(err) : resolve(createIterResult(void 0, !0));
                        }));
                    }));
                })), _Object$setPrototypeO), AsyncIteratorPrototype);
                module.exports = function createReadableStreamAsyncIterator(stream) {
                    var _Object$create, iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_defineProperty(_Object$create = {}, kStream, {
                        value: stream,
                        writable: !0
                    }), _defineProperty(_Object$create, kLastResolve, {
                        value: null,
                        writable: !0
                    }), _defineProperty(_Object$create, kLastReject, {
                        value: null,
                        writable: !0
                    }), _defineProperty(_Object$create, kError, {
                        value: null,
                        writable: !0
                    }), _defineProperty(_Object$create, kEnded, {
                        value: stream._readableState.endEmitted,
                        writable: !0
                    }), _defineProperty(_Object$create, kHandlePromise, {
                        value: function value(resolve, reject) {
                            var data = iterator[kStream].read();
                            data ? (iterator[kLastPromise] = null, iterator[kLastResolve] = null, iterator[kLastReject] = null, 
                            resolve(createIterResult(data, !1))) : (iterator[kLastResolve] = resolve, iterator[kLastReject] = reject);
                        },
                        writable: !0
                    }), _Object$create));
                    return iterator[kLastPromise] = null, finished(stream, (function(err) {
                        if (err && "ERR_STREAM_PREMATURE_CLOSE" !== err.code) {
                            var reject = iterator[kLastReject];
                            return null !== reject && (iterator[kLastPromise] = null, iterator[kLastResolve] = null, 
                            iterator[kLastReject] = null, reject(err)), void (iterator[kError] = err);
                        }
                        var resolve = iterator[kLastResolve];
                        null !== resolve && (iterator[kLastPromise] = null, iterator[kLastResolve] = null, 
                        iterator[kLastReject] = null, resolve(createIterResult(void 0, !0))), iterator[kEnded] = !0;
                    })), stream.on("readable", onReadable.bind(null, iterator)), iterator;
                };
            }).call(this, require("_process"));
        }, {
            "./end-of-stream": 170,
            _process: 133
        } ],
        168: [ function(require, module, exports) {
            function _defineProperty(obj, key, value) {
                return key in obj ? Object.defineProperty(obj, key, {
                    value,
                    enumerable: !0,
                    configurable: !0,
                    writable: !0
                }) : obj[key] = value, obj;
            }
            var Buffer = require("buffer").Buffer, inspect = require("util").inspect, custom = inspect && inspect.custom || "inspect";
            function copyBuffer(src, target, offset) {
                Buffer.prototype.copy.call(src, target, offset);
            }
            module.exports = function() {
                function BufferList() {
                    this.head = null, this.tail = null, this.length = 0;
                }
                var _proto = BufferList.prototype;
                return _proto.push = function push(v) {
                    var entry = {
                        data: v,
                        next: null
                    };
                    this.length > 0 ? this.tail.next = entry : this.head = entry, this.tail = entry, 
                    ++this.length;
                }, _proto.unshift = function unshift(v) {
                    var entry = {
                        data: v,
                        next: this.head
                    };
                    0 === this.length && (this.tail = entry), this.head = entry, ++this.length;
                }, _proto.shift = function shift() {
                    if (0 !== this.length) {
                        var ret = this.head.data;
                        return 1 === this.length ? this.head = this.tail = null : this.head = this.head.next, 
                        --this.length, ret;
                    }
                }, _proto.clear = function clear() {
                    this.head = this.tail = null, this.length = 0;
                }, _proto.join = function join(s) {
                    if (0 === this.length) return "";
                    for (var p = this.head, ret = "" + p.data; p = p.next; ) ret += s + p.data;
                    return ret;
                }, _proto.concat = function concat(n) {
                    if (0 === this.length) return Buffer.alloc(0);
                    for (var ret = Buffer.allocUnsafe(n >>> 0), p = this.head, i = 0; p; ) copyBuffer(p.data, ret, i), 
                    i += p.data.length, p = p.next;
                    return ret;
                }, _proto.consume = function consume(n, hasStrings) {
                    var ret;
                    return n < this.head.data.length ? (ret = this.head.data.slice(0, n), this.head.data = this.head.data.slice(n)) : ret = n === this.head.data.length ? this.shift() : hasStrings ? this._getString(n) : this._getBuffer(n), 
                    ret;
                }, _proto.first = function first() {
                    return this.head.data;
                }, _proto._getString = function _getString(n) {
                    var p = this.head, c = 1, ret = p.data;
                    for (n -= ret.length; p = p.next; ) {
                        var str = p.data, nb = n > str.length ? str.length : n;
                        if (nb === str.length ? ret += str : ret += str.slice(0, n), 0 == (n -= nb)) {
                            nb === str.length ? (++c, p.next ? this.head = p.next : this.head = this.tail = null) : (this.head = p, 
                            p.data = str.slice(nb));
                            break;
                        }
                        ++c;
                    }
                    return this.length -= c, ret;
                }, _proto._getBuffer = function _getBuffer(n) {
                    var ret = Buffer.allocUnsafe(n), p = this.head, c = 1;
                    for (p.data.copy(ret), n -= p.data.length; p = p.next; ) {
                        var buf = p.data, nb = n > buf.length ? buf.length : n;
                        if (buf.copy(ret, ret.length - n, 0, nb), 0 == (n -= nb)) {
                            nb === buf.length ? (++c, p.next ? this.head = p.next : this.head = this.tail = null) : (this.head = p, 
                            p.data = buf.slice(nb));
                            break;
                        }
                        ++c;
                    }
                    return this.length -= c, ret;
                }, _proto[custom] = function(_, options) {
                    return inspect(this, function _objectSpread(target) {
                        for (var i = 1; i < arguments.length; i++) {
                            var source = null != arguments[i] ? arguments[i] : {}, ownKeys = Object.keys(source);
                            "function" == typeof Object.getOwnPropertySymbols && (ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter((function(sym) {
                                return Object.getOwnPropertyDescriptor(source, sym).enumerable;
                            })))), ownKeys.forEach((function(key) {
                                _defineProperty(target, key, source[key]);
                            }));
                        }
                        return target;
                    }({}, options, {
                        depth: 0,
                        customInspect: !1
                    }));
                }, BufferList;
            }();
        }, {
            buffer: 48,
            util: 33
        } ],
        169: [ function(require, module, exports) {
            (function(process) {
                function emitErrorAndCloseNT(self, err) {
                    emitErrorNT(self, err), emitCloseNT(self);
                }
                function emitCloseNT(self) {
                    self._writableState && !self._writableState.emitClose || self._readableState && !self._readableState.emitClose || self.emit("close");
                }
                function emitErrorNT(self, err) {
                    self.emit("error", err);
                }
                module.exports = {
                    destroy: function destroy(err, cb) {
                        var _this = this, readableDestroyed = this._readableState && this._readableState.destroyed, writableDestroyed = this._writableState && this._writableState.destroyed;
                        return readableDestroyed || writableDestroyed ? (cb ? cb(err) : !err || this._writableState && this._writableState.errorEmitted || process.nextTick(emitErrorNT, this, err), 
                        this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), 
                        this._destroy(err || null, (function(err) {
                            !cb && err ? (process.nextTick(emitErrorAndCloseNT, _this, err), _this._writableState && (_this._writableState.errorEmitted = !0)) : cb ? (process.nextTick(emitCloseNT, _this), 
                            cb(err)) : process.nextTick(emitCloseNT, _this);
                        })), this);
                    },
                    undestroy: function undestroy() {
                        this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, 
                        this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, 
                        this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, 
                        this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
                    }
                };
            }).call(this, require("_process"));
        }, {
            _process: 133
        } ],
        170: [ function(require, module, exports) {
            var ERR_STREAM_PREMATURE_CLOSE = require("../../../errors").codes.ERR_STREAM_PREMATURE_CLOSE;
            function noop() {}
            module.exports = function eos(stream, opts, callback) {
                if ("function" == typeof opts) return eos(stream, null, opts);
                opts || (opts = {}), callback = function once(callback) {
                    var called = !1;
                    return function() {
                        if (!called) {
                            called = !0;
                            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
                            callback.apply(this, args);
                        }
                    };
                }(callback || noop);
                var readable = opts.readable || !1 !== opts.readable && stream.readable, writable = opts.writable || !1 !== opts.writable && stream.writable, onlegacyfinish = function onlegacyfinish() {
                    stream.writable || onfinish();
                }, writableEnded = stream._writableState && stream._writableState.finished, onfinish = function onfinish() {
                    writable = !1, writableEnded = !0, readable || callback.call(stream);
                }, readableEnded = stream._readableState && stream._readableState.endEmitted, onend = function onend() {
                    readable = !1, readableEnded = !0, writable || callback.call(stream);
                }, onerror = function onerror(err) {
                    callback.call(stream, err);
                }, onclose = function onclose() {
                    var err;
                    return readable && !readableEnded ? (stream._readableState && stream._readableState.ended || (err = new ERR_STREAM_PREMATURE_CLOSE), 
                    callback.call(stream, err)) : writable && !writableEnded ? (stream._writableState && stream._writableState.ended || (err = new ERR_STREAM_PREMATURE_CLOSE), 
                    callback.call(stream, err)) : void 0;
                }, onrequest = function onrequest() {
                    stream.req.on("finish", onfinish);
                };
                return function isRequest(stream) {
                    return stream.setHeader && "function" == typeof stream.abort;
                }(stream) ? (stream.on("complete", onfinish), stream.on("abort", onclose), stream.req ? onrequest() : stream.on("request", onrequest)) : writable && !stream._writableState && (stream.on("end", onlegacyfinish), 
                stream.on("close", onlegacyfinish)), stream.on("end", onend), stream.on("finish", onfinish), 
                !1 !== opts.error && stream.on("error", onerror), stream.on("close", onclose), function() {
                    stream.removeListener("complete", onfinish), stream.removeListener("abort", onclose), 
                    stream.removeListener("request", onrequest), stream.req && stream.req.removeListener("finish", onfinish), 
                    stream.removeListener("end", onlegacyfinish), stream.removeListener("close", onlegacyfinish), 
                    stream.removeListener("finish", onfinish), stream.removeListener("end", onend), 
                    stream.removeListener("error", onerror), stream.removeListener("close", onclose);
                };
            };
        }, {
            "../../../errors": 160
        } ],
        171: [ function(require, module, exports) {
            var eos, _require$codes = require("../../../errors").codes, ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS, ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
            function noop(err) {
                if (err) throw err;
            }
            function destroyer(stream, reading, writing, callback) {
                callback = function once(callback) {
                    var called = !1;
                    return function() {
                        called || (called = !0, callback.apply(void 0, arguments));
                    };
                }(callback);
                var closed = !1;
                stream.on("close", (function() {
                    closed = !0;
                })), void 0 === eos && (eos = require("./end-of-stream")), eos(stream, {
                    readable: reading,
                    writable: writing
                }, (function(err) {
                    if (err) return callback(err);
                    closed = !0, callback();
                }));
                var destroyed = !1;
                return function(err) {
                    if (!closed && !destroyed) return destroyed = !0, function isRequest(stream) {
                        return stream.setHeader && "function" == typeof stream.abort;
                    }(stream) ? stream.abort() : "function" == typeof stream.destroy ? stream.destroy() : void callback(err || new ERR_STREAM_DESTROYED("pipe"));
                };
            }
            function call(fn) {
                fn();
            }
            function pipe(from, to) {
                return from.pipe(to);
            }
            function popCallback(streams) {
                return streams.length ? "function" != typeof streams[streams.length - 1] ? noop : streams.pop() : noop;
            }
            module.exports = function pipeline() {
                for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) streams[_key] = arguments[_key];
                var error, callback = popCallback(streams);
                if (Array.isArray(streams[0]) && (streams = streams[0]), streams.length < 2) throw new ERR_MISSING_ARGS("streams");
                var destroys = streams.map((function(stream, i) {
                    var reading = i < streams.length - 1;
                    return destroyer(stream, reading, i > 0, (function(err) {
                        error || (error = err), err && destroys.forEach(call), reading || (destroys.forEach(call), 
                        callback(error));
                    }));
                }));
                return streams.reduce(pipe);
            };
        }, {
            "../../../errors": 160,
            "./end-of-stream": 170
        } ],
        172: [ function(require, module, exports) {
            var ERR_INVALID_OPT_VALUE = require("../../../errors").codes.ERR_INVALID_OPT_VALUE;
            module.exports = {
                getHighWaterMark: function getHighWaterMark(state, options, duplexKey, isDuplex) {
                    var hwm = function highWaterMarkFrom(options, isDuplex, duplexKey) {
                        return null != options.highWaterMark ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
                    }(options, isDuplex, duplexKey);
                    if (null != hwm) {
                        if (!isFinite(hwm) || Math.floor(hwm) !== hwm || hwm < 0) throw new ERR_INVALID_OPT_VALUE(isDuplex ? duplexKey : "highWaterMark", hwm);
                        return Math.floor(hwm);
                    }
                    return state.objectMode ? 16 : 16384;
                }
            };
        }, {
            "../../../errors": 160
        } ],
        173: [ function(require, module, exports) {
            arguments[4][146][0].apply(exports, arguments);
        }, {
            dup: 146,
            events: 52
        } ],
        174: [ function(require, module, exports) {
            (exports = module.exports = require("./lib/_stream_readable.js")).Stream = exports, 
            exports.Readable = exports, exports.Writable = require("./lib/_stream_writable.js"), 
            exports.Duplex = require("./lib/_stream_duplex.js"), exports.Transform = require("./lib/_stream_transform.js"), 
            exports.PassThrough = require("./lib/_stream_passthrough.js"), exports.finished = require("./lib/internal/streams/end-of-stream.js"), 
            exports.pipeline = require("./lib/internal/streams/pipeline.js");
        }, {
            "./lib/_stream_duplex.js": 162,
            "./lib/_stream_passthrough.js": 163,
            "./lib/_stream_readable.js": 164,
            "./lib/_stream_transform.js": 165,
            "./lib/_stream_writable.js": 166,
            "./lib/internal/streams/end-of-stream.js": 170,
            "./lib/internal/streams/pipeline.js": 171
        } ],
        175: [ function(require, module, exports) {
            arguments[4][148][0].apply(exports, arguments);
        }, {
            dup: 148,
            "safe-buffer": 154
        } ],
        176: [ function(require, module, exports) {
            (function(setImmediate, clearImmediate) {
                var nextTick = require("process/browser.js").nextTick, apply = Function.prototype.apply, slice = Array.prototype.slice, immediateIds = {}, nextImmediateId = 0;
                function Timeout(id, clearFn) {
                    this._id = id, this._clearFn = clearFn;
                }
                exports.setTimeout = function() {
                    return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
                }, exports.setInterval = function() {
                    return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
                }, exports.clearTimeout = exports.clearInterval = function(timeout) {
                    timeout.close();
                }, Timeout.prototype.unref = Timeout.prototype.ref = function() {}, Timeout.prototype.close = function() {
                    this._clearFn.call(window, this._id);
                }, exports.enroll = function(item, msecs) {
                    clearTimeout(item._idleTimeoutId), item._idleTimeout = msecs;
                }, exports.unenroll = function(item) {
                    clearTimeout(item._idleTimeoutId), item._idleTimeout = -1;
                }, exports._unrefActive = exports.active = function(item) {
                    clearTimeout(item._idleTimeoutId);
                    var msecs = item._idleTimeout;
                    msecs >= 0 && (item._idleTimeoutId = setTimeout((function onTimeout() {
                        item._onTimeout && item._onTimeout();
                    }), msecs));
                }, exports.setImmediate = "function" == typeof setImmediate ? setImmediate : function(fn) {
                    var id = nextImmediateId++, args = !(arguments.length < 2) && slice.call(arguments, 1);
                    return immediateIds[id] = !0, nextTick((function onNextTick() {
                        immediateIds[id] && (args ? fn.apply(null, args) : fn.call(null), exports.clearImmediate(id));
                    })), id;
                }, exports.clearImmediate = "function" == typeof clearImmediate ? clearImmediate : function(id) {
                    delete immediateIds[id];
                };
            }).call(this, require("timers").setImmediate, require("timers").clearImmediate);
        }, {
            "process/browser.js": 133,
            timers: 176
        } ],
        177: [ function(require, module, exports) {
            (function(process) {
                Object.defineProperty(exports, "__esModule", {
                    value: !0
                });
                var _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj) {
                    return typeof obj;
                } : function(obj) {
                    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
                };
                function throwStr(msg) {
                    throw new Error(msg);
                }
                function getKeysAndSymbols(obj) {
                    var keys = Object.keys(obj);
                    return Object.getOwnPropertySymbols ? keys.concat(Object.getOwnPropertySymbols(obj)) : keys;
                }
                exports.clone = clone, exports.addLast = addLast, exports.addFirst = addFirst, exports.removeLast = removeLast, 
                exports.removeFirst = removeFirst, exports.insert = insert, exports.removeAt = removeAt, 
                exports.replaceAt = replaceAt, exports.getIn = getIn, exports.set = set, exports.setIn = setIn, 
                exports.update = update, exports.updateIn = updateIn, exports.merge = merge, exports.mergeDeep = mergeDeep, 
                exports.mergeIn = mergeIn, exports.omit = omit, exports.addDefaults = addDefaults;
                var hasOwnProperty = {}.hasOwnProperty;
                function clone(obj) {
                    if (Array.isArray(obj)) return obj.slice();
                    for (var keys = getKeysAndSymbols(obj), out = {}, i = 0; i < keys.length; i++) {
                        var key = keys[i];
                        out[key] = obj[key];
                    }
                    return out;
                }
                function doMerge(fAddDefaults, fDeep, first) {
                    var out = first;
                    null == out && throwStr("production" !== process.env.NODE_ENV ? "At least one object should be provided to merge()" : "INVALID_ARGS");
                    for (var fChanged = !1, _len = arguments.length, rest = Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) rest[_key - 3] = arguments[_key];
                    for (var idx = 0; idx < rest.length; idx++) {
                        var obj = rest[idx];
                        if (null != obj) {
                            var keys = getKeysAndSymbols(obj);
                            if (keys.length) for (var j = 0; j <= keys.length; j++) {
                                var key = keys[j];
                                if (!fAddDefaults || void 0 === out[key]) {
                                    var nextVal = obj[key];
                                    fDeep && isObject(out[key]) && isObject(nextVal) && (nextVal = doMerge(fAddDefaults, fDeep, out[key], nextVal)), 
                                    void 0 !== nextVal && nextVal !== out[key] && (fChanged || (fChanged = !0, out = clone(out)), 
                                    out[key] = nextVal);
                                }
                            }
                        }
                    }
                    return out;
                }
                function isObject(o) {
                    var type = void 0 === o ? "undefined" : _typeof(o);
                    return null != o && "object" === type;
                }
                function addLast(array, val) {
                    return Array.isArray(val) ? array.concat(val) : array.concat([ val ]);
                }
                function addFirst(array, val) {
                    return Array.isArray(val) ? val.concat(array) : [ val ].concat(array);
                }
                function removeLast(array) {
                    return array.length ? array.slice(0, array.length - 1) : array;
                }
                function removeFirst(array) {
                    return array.length ? array.slice(1) : array;
                }
                function insert(array, idx, val) {
                    return array.slice(0, idx).concat(Array.isArray(val) ? val : [ val ]).concat(array.slice(idx));
                }
                function removeAt(array, idx) {
                    return idx >= array.length || idx < 0 ? array : array.slice(0, idx).concat(array.slice(idx + 1));
                }
                function replaceAt(array, idx, newItem) {
                    if (array[idx] === newItem) return array;
                    for (var len = array.length, result = Array(len), i = 0; i < len; i++) result[i] = array[i];
                    return result[idx] = newItem, result;
                }
                function getIn(obj, path) {
                    if (!Array.isArray(path) && throwStr("production" !== process.env.NODE_ENV ? "A path array should be provided when calling getIn()" : "INVALID_ARGS"), 
                    null != obj) {
                        for (var ptr = obj, i = 0; i < path.length; i++) {
                            var key = path[i];
                            if (void 0 === (ptr = null != ptr ? ptr[key] : void 0)) return ptr;
                        }
                        return ptr;
                    }
                }
                function set(obj, key, val) {
                    var finalObj = null == obj ? "number" == typeof key ? [] : {} : obj;
                    if (finalObj[key] === val) return finalObj;
                    var obj2 = clone(finalObj);
                    return obj2[key] = val, obj2;
                }
                function doSetIn(obj, path, val, idx) {
                    var key = path[idx];
                    return set(obj, key, idx === path.length - 1 ? val : doSetIn(isObject(obj) && isObject(obj[key]) ? obj[key] : "number" == typeof path[idx + 1] ? [] : {}, path, val, idx + 1));
                }
                function setIn(obj, path, val) {
                    return path.length ? doSetIn(obj, path, val, 0) : val;
                }
                function update(obj, key, fnUpdate) {
                    return set(obj, key, fnUpdate(null == obj ? void 0 : obj[key]));
                }
                function updateIn(obj, path, fnUpdate) {
                    return setIn(obj, path, fnUpdate(getIn(obj, path)));
                }
                function merge(a, b, c, d, e, f) {
                    for (var _len2 = arguments.length, rest = Array(_len2 > 6 ? _len2 - 6 : 0), _key2 = 6; _key2 < _len2; _key2++) rest[_key2 - 6] = arguments[_key2];
                    return rest.length ? doMerge.call.apply(doMerge, [ null, !1, !1, a, b, c, d, e, f ].concat(rest)) : doMerge(!1, !1, a, b, c, d, e, f);
                }
                function mergeDeep(a, b, c, d, e, f) {
                    for (var _len3 = arguments.length, rest = Array(_len3 > 6 ? _len3 - 6 : 0), _key3 = 6; _key3 < _len3; _key3++) rest[_key3 - 6] = arguments[_key3];
                    return rest.length ? doMerge.call.apply(doMerge, [ null, !1, !0, a, b, c, d, e, f ].concat(rest)) : doMerge(!1, !0, a, b, c, d, e, f);
                }
                function mergeIn(a, path, b, c, d, e, f) {
                    var prevVal = getIn(a, path);
                    null == prevVal && (prevVal = {});
                    for (var _len4 = arguments.length, rest = Array(_len4 > 7 ? _len4 - 7 : 0), _key4 = 7; _key4 < _len4; _key4++) rest[_key4 - 7] = arguments[_key4];
                    return setIn(a, path, rest.length ? doMerge.call.apply(doMerge, [ null, !1, !1, prevVal, b, c, d, e, f ].concat(rest)) : doMerge(!1, !1, prevVal, b, c, d, e, f));
                }
                function omit(obj, attrs) {
                    for (var omitList = Array.isArray(attrs) ? attrs : [ attrs ], fDoSomething = !1, i = 0; i < omitList.length; i++) if (hasOwnProperty.call(obj, omitList[i])) {
                        fDoSomething = !0;
                        break;
                    }
                    if (!fDoSomething) return obj;
                    for (var out = {}, keys = getKeysAndSymbols(obj), _i = 0; _i < keys.length; _i++) {
                        var key = keys[_i];
                        omitList.indexOf(key) >= 0 || (out[key] = obj[key]);
                    }
                    return out;
                }
                function addDefaults(a, b, c, d, e, f) {
                    for (var _len5 = arguments.length, rest = Array(_len5 > 6 ? _len5 - 6 : 0), _key5 = 6; _key5 < _len5; _key5++) rest[_key5 - 6] = arguments[_key5];
                    return rest.length ? doMerge.call.apply(doMerge, [ null, !0, !1, a, b, c, d, e, f ].concat(rest)) : doMerge(!0, !1, a, b, c, d, e, f);
                }
                var timm = {
                    clone,
                    addLast,
                    addFirst,
                    removeLast,
                    removeFirst,
                    insert,
                    removeAt,
                    replaceAt,
                    getIn,
                    set,
                    setIn,
                    update,
                    updateIn,
                    merge,
                    mergeDeep,
                    mergeIn,
                    omit,
                    addDefaults
                };
                exports.default = timm;
            }).call(this, require("_process"));
        }, {
            _process: 133
        } ],
        178: [ function(require, module, exports) {
            !function(Math) {
                var trimLeft = /^\s+/, trimRight = /\s+$/, tinyCounter = 0, mathRound = Math.round, mathMin = Math.min, mathMax = Math.max, mathRandom = Math.random;
                function tinycolor(color, opts) {
                    if (opts = opts || {}, (color = color || "") instanceof tinycolor) return color;
                    if (!(this instanceof tinycolor)) return new tinycolor(color, opts);
                    var rgb = function inputToRGB(color) {
                        var rgb = {
                            r: 0,
                            g: 0,
                            b: 0
                        }, a = 1, s = null, v = null, l = null, ok = !1, format = !1;
                        return "string" == typeof color && (color = function stringInputToObject(color) {
                            color = color.replace(trimLeft, "").replace(trimRight, "").toLowerCase();
                            var match, named = !1;
                            if (names[color]) color = names[color], named = !0; else if ("transparent" == color) return {
                                r: 0,
                                g: 0,
                                b: 0,
                                a: 0,
                                format: "name"
                            };
                            return (match = matchers.rgb.exec(color)) ? {
                                r: match[1],
                                g: match[2],
                                b: match[3]
                            } : (match = matchers.rgba.exec(color)) ? {
                                r: match[1],
                                g: match[2],
                                b: match[3],
                                a: match[4]
                            } : (match = matchers.hsl.exec(color)) ? {
                                h: match[1],
                                s: match[2],
                                l: match[3]
                            } : (match = matchers.hsla.exec(color)) ? {
                                h: match[1],
                                s: match[2],
                                l: match[3],
                                a: match[4]
                            } : (match = matchers.hsv.exec(color)) ? {
                                h: match[1],
                                s: match[2],
                                v: match[3]
                            } : (match = matchers.hsva.exec(color)) ? {
                                h: match[1],
                                s: match[2],
                                v: match[3],
                                a: match[4]
                            } : (match = matchers.hex8.exec(color)) ? {
                                r: parseIntFromHex(match[1]),
                                g: parseIntFromHex(match[2]),
                                b: parseIntFromHex(match[3]),
                                a: convertHexToDecimal(match[4]),
                                format: named ? "name" : "hex8"
                            } : (match = matchers.hex6.exec(color)) ? {
                                r: parseIntFromHex(match[1]),
                                g: parseIntFromHex(match[2]),
                                b: parseIntFromHex(match[3]),
                                format: named ? "name" : "hex"
                            } : (match = matchers.hex4.exec(color)) ? {
                                r: parseIntFromHex(match[1] + "" + match[1]),
                                g: parseIntFromHex(match[2] + "" + match[2]),
                                b: parseIntFromHex(match[3] + "" + match[3]),
                                a: convertHexToDecimal(match[4] + "" + match[4]),
                                format: named ? "name" : "hex8"
                            } : !!(match = matchers.hex3.exec(color)) && {
                                r: parseIntFromHex(match[1] + "" + match[1]),
                                g: parseIntFromHex(match[2] + "" + match[2]),
                                b: parseIntFromHex(match[3] + "" + match[3]),
                                format: named ? "name" : "hex"
                            };
                        }(color)), "object" == typeof color && (isValidCSSUnit(color.r) && isValidCSSUnit(color.g) && isValidCSSUnit(color.b) ? (rgb = function rgbToRgb(r, g, b) {
                            return {
                                r: 255 * bound01(r, 255),
                                g: 255 * bound01(g, 255),
                                b: 255 * bound01(b, 255)
                            };
                        }(color.r, color.g, color.b), ok = !0, format = "%" === String(color.r).substr(-1) ? "prgb" : "rgb") : isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.v) ? (s = convertToPercentage(color.s), 
                        v = convertToPercentage(color.v), rgb = function hsvToRgb(h, s, v) {
                            h = 6 * bound01(h, 360), s = bound01(s, 100), v = bound01(v, 100);
                            var i = Math.floor(h), f = h - i, p = v * (1 - s), q = v * (1 - f * s), t = v * (1 - (1 - f) * s), mod = i % 6;
                            return {
                                r: 255 * [ v, q, p, p, t, v ][mod],
                                g: 255 * [ t, v, v, q, p, p ][mod],
                                b: 255 * [ p, p, t, v, v, q ][mod]
                            };
                        }(color.h, s, v), ok = !0, format = "hsv") : isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.l) && (s = convertToPercentage(color.s), 
                        l = convertToPercentage(color.l), rgb = function hslToRgb(h, s, l) {
                            var r, g, b;
                            function hue2rgb(p, q, t) {
                                return t < 0 && (t += 1), t > 1 && (t -= 1), t < 1 / 6 ? p + 6 * (q - p) * t : t < .5 ? q : t < 2 / 3 ? p + (q - p) * (2 / 3 - t) * 6 : p;
                            }
                            if (h = bound01(h, 360), s = bound01(s, 100), l = bound01(l, 100), 0 === s) r = g = b = l; else {
                                var q = l < 0.5 ? l * (1 + s) : l + s - l * s, p = 2 * l - q;
                                r = hue2rgb(p, q, h + 1 / 3), g = hue2rgb(p, q, h), b = hue2rgb(p, q, h - 1 / 3);
                            }
                            return {
                                r: 255 * r,
                                g: 255 * g,
                                b: 255 * b
                            };
                        }(color.h, s, l), ok = !0, format = "hsl"), color.hasOwnProperty("a") && (a = color.a)), 
                        a = boundAlpha(a), {
                            ok,
                            format: color.format || format,
                            r: mathMin(255, mathMax(rgb.r, 0)),
                            g: mathMin(255, mathMax(rgb.g, 0)),
                            b: mathMin(255, mathMax(rgb.b, 0)),
                            a
                        };
                    }(color);
                    this._originalInput = color, this._r = rgb.r, this._g = rgb.g, this._b = rgb.b, 
                    this._a = rgb.a, this._roundA = mathRound(100 * this._a) / 100, this._format = opts.format || rgb.format, 
                    this._gradientType = opts.gradientType, this._r < 1 && (this._r = mathRound(this._r)), 
                    this._g < 1 && (this._g = mathRound(this._g)), this._b < 1 && (this._b = mathRound(this._b)), 
                    this._ok = rgb.ok, this._tc_id = tinyCounter++;
                }
                function rgbToHsl(r, g, b) {
                    r = bound01(r, 255), g = bound01(g, 255), b = bound01(b, 255);
                    var h, s, max = mathMax(r, g, b), min = mathMin(r, g, b), l = (max + min) / 2;
                    if (max == min) h = s = 0; else {
                        var d = max - min;
                        switch (s = l > 0.5 ? d / (2 - max - min) : d / (max + min), max) {
                          case r:
                            h = (g - b) / d + (g < b ? 6 : 0);
                            break;

                          case g:
                            h = (b - r) / d + 2;
                            break;

                          case b:
                            h = (r - g) / d + 4;
                        }
                        h /= 6;
                    }
                    return {
                        h,
                        s,
                        l
                    };
                }
                function rgbToHsv(r, g, b) {
                    r = bound01(r, 255), g = bound01(g, 255), b = bound01(b, 255);
                    var h, s, max = mathMax(r, g, b), min = mathMin(r, g, b), v = max, d = max - min;
                    if (s = 0 === max ? 0 : d / max, max == min) h = 0; else {
                        switch (max) {
                          case r:
                            h = (g - b) / d + (g < b ? 6 : 0);
                            break;

                          case g:
                            h = (b - r) / d + 2;
                            break;

                          case b:
                            h = (r - g) / d + 4;
                        }
                        h /= 6;
                    }
                    return {
                        h,
                        s,
                        v
                    };
                }
                function rgbToHex(r, g, b, allow3Char) {
                    var hex = [ pad2(mathRound(r).toString(16)), pad2(mathRound(g).toString(16)), pad2(mathRound(b).toString(16)) ];
                    return allow3Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1) ? hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0) : hex.join("");
                }
                function rgbaToArgbHex(r, g, b, a) {
                    return [ pad2(convertDecimalToHex(a)), pad2(mathRound(r).toString(16)), pad2(mathRound(g).toString(16)), pad2(mathRound(b).toString(16)) ].join("");
                }
                function desaturate(color, amount) {
                    amount = 0 === amount ? 0 : amount || 10;
                    var hsl = tinycolor(color).toHsl();
                    return hsl.s -= amount / 100, hsl.s = clamp01(hsl.s), tinycolor(hsl);
                }
                function saturate(color, amount) {
                    amount = 0 === amount ? 0 : amount || 10;
                    var hsl = tinycolor(color).toHsl();
                    return hsl.s += amount / 100, hsl.s = clamp01(hsl.s), tinycolor(hsl);
                }
                function greyscale(color) {
                    return tinycolor(color).desaturate(100);
                }
                function lighten(color, amount) {
                    amount = 0 === amount ? 0 : amount || 10;
                    var hsl = tinycolor(color).toHsl();
                    return hsl.l += amount / 100, hsl.l = clamp01(hsl.l), tinycolor(hsl);
                }
                function brighten(color, amount) {
                    amount = 0 === amount ? 0 : amount || 10;
                    var rgb = tinycolor(color).toRgb();
                    return rgb.r = mathMax(0, mathMin(255, rgb.r - mathRound(-amount / 100 * 255))), 
                    rgb.g = mathMax(0, mathMin(255, rgb.g - mathRound(-amount / 100 * 255))), rgb.b = mathMax(0, mathMin(255, rgb.b - mathRound(-amount / 100 * 255))), 
                    tinycolor(rgb);
                }
                function darken(color, amount) {
                    amount = 0 === amount ? 0 : amount || 10;
                    var hsl = tinycolor(color).toHsl();
                    return hsl.l -= amount / 100, hsl.l = clamp01(hsl.l), tinycolor(hsl);
                }
                function spin(color, amount) {
                    var hsl = tinycolor(color).toHsl(), hue = (hsl.h + amount) % 360;
                    return hsl.h = hue < 0 ? 360 + hue : hue, tinycolor(hsl);
                }
                function complement(color) {
                    var hsl = tinycolor(color).toHsl();
                    return hsl.h = (hsl.h + 180) % 360, tinycolor(hsl);
                }
                function triad(color) {
                    var hsl = tinycolor(color).toHsl(), h = hsl.h;
                    return [ tinycolor(color), tinycolor({
                        h: (h + 120) % 360,
                        s: hsl.s,
                        l: hsl.l
                    }), tinycolor({
                        h: (h + 240) % 360,
                        s: hsl.s,
                        l: hsl.l
                    }) ];
                }
                function tetrad(color) {
                    var hsl = tinycolor(color).toHsl(), h = hsl.h;
                    return [ tinycolor(color), tinycolor({
                        h: (h + 90) % 360,
                        s: hsl.s,
                        l: hsl.l
                    }), tinycolor({
                        h: (h + 180) % 360,
                        s: hsl.s,
                        l: hsl.l
                    }), tinycolor({
                        h: (h + 270) % 360,
                        s: hsl.s,
                        l: hsl.l
                    }) ];
                }
                function splitcomplement(color) {
                    var hsl = tinycolor(color).toHsl(), h = hsl.h;
                    return [ tinycolor(color), tinycolor({
                        h: (h + 72) % 360,
                        s: hsl.s,
                        l: hsl.l
                    }), tinycolor({
                        h: (h + 216) % 360,
                        s: hsl.s,
                        l: hsl.l
                    }) ];
                }
                function analogous(color, results, slices) {
                    results = results || 6, slices = slices || 30;
                    var hsl = tinycolor(color).toHsl(), part = 360 / slices, ret = [ tinycolor(color) ];
                    for (hsl.h = (hsl.h - (part * results >> 1) + 720) % 360; --results; ) hsl.h = (hsl.h + part) % 360, 
                    ret.push(tinycolor(hsl));
                    return ret;
                }
                function monochromatic(color, results) {
                    results = results || 6;
                    for (var hsv = tinycolor(color).toHsv(), h = hsv.h, s = hsv.s, v = hsv.v, ret = [], modification = 1 / results; results--; ) ret.push(tinycolor({
                        h,
                        s,
                        v
                    })), v = (v + modification) % 1;
                    return ret;
                }
                tinycolor.prototype = {
                    isDark: function() {
                        return this.getBrightness() < 128;
                    },
                    isLight: function() {
                        return !this.isDark();
                    },
                    isValid: function() {
                        return this._ok;
                    },
                    getOriginalInput: function() {
                        return this._originalInput;
                    },
                    getFormat: function() {
                        return this._format;
                    },
                    getAlpha: function() {
                        return this._a;
                    },
                    getBrightness: function() {
                        var rgb = this.toRgb();
                        return (299 * rgb.r + 587 * rgb.g + 114 * rgb.b) / 1000;
                    },
                    getLuminance: function() {
                        var RsRGB, GsRGB, BsRGB, rgb = this.toRgb();
                        return RsRGB = rgb.r / 255, GsRGB = rgb.g / 255, BsRGB = rgb.b / 255, 0.2126 * (RsRGB <= 0.03928 ? RsRGB / 12.92 : Math.pow((RsRGB + 0.055) / 1.055, 2.4)) + 0.7152 * (GsRGB <= 0.03928 ? GsRGB / 12.92 : Math.pow((GsRGB + 0.055) / 1.055, 2.4)) + 0.0722 * (BsRGB <= 0.03928 ? BsRGB / 12.92 : Math.pow((BsRGB + 0.055) / 1.055, 2.4));
                    },
                    setAlpha: function(value) {
                        return this._a = boundAlpha(value), this._roundA = mathRound(100 * this._a) / 100, 
                        this;
                    },
                    toHsv: function() {
                        var hsv = rgbToHsv(this._r, this._g, this._b);
                        return {
                            h: 360 * hsv.h,
                            s: hsv.s,
                            v: hsv.v,
                            a: this._a
                        };
                    },
                    toHsvString: function() {
                        var hsv = rgbToHsv(this._r, this._g, this._b), h = mathRound(360 * hsv.h), s = mathRound(100 * hsv.s), v = mathRound(100 * hsv.v);
                        return 1 == this._a ? "hsv(" + h + ", " + s + "%, " + v + "%)" : "hsva(" + h + ", " + s + "%, " + v + "%, " + this._roundA + ")";
                    },
                    toHsl: function() {
                        var hsl = rgbToHsl(this._r, this._g, this._b);
                        return {
                            h: 360 * hsl.h,
                            s: hsl.s,
                            l: hsl.l,
                            a: this._a
                        };
                    },
                    toHslString: function() {
                        var hsl = rgbToHsl(this._r, this._g, this._b), h = mathRound(360 * hsl.h), s = mathRound(100 * hsl.s), l = mathRound(100 * hsl.l);
                        return 1 == this._a ? "hsl(" + h + ", " + s + "%, " + l + "%)" : "hsla(" + h + ", " + s + "%, " + l + "%, " + this._roundA + ")";
                    },
                    toHex: function(allow3Char) {
                        return rgbToHex(this._r, this._g, this._b, allow3Char);
                    },
                    toHexString: function(allow3Char) {
                        return "#" + this.toHex(allow3Char);
                    },
                    toHex8: function(allow4Char) {
                        return function rgbaToHex(r, g, b, a, allow4Char) {
                            var hex = [ pad2(mathRound(r).toString(16)), pad2(mathRound(g).toString(16)), pad2(mathRound(b).toString(16)), pad2(convertDecimalToHex(a)) ];
                            return allow4Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1) && hex[3].charAt(0) == hex[3].charAt(1) ? hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0) + hex[3].charAt(0) : hex.join("");
                        }(this._r, this._g, this._b, this._a, allow4Char);
                    },
                    toHex8String: function(allow4Char) {
                        return "#" + this.toHex8(allow4Char);
                    },
                    toRgb: function() {
                        return {
                            r: mathRound(this._r),
                            g: mathRound(this._g),
                            b: mathRound(this._b),
                            a: this._a
                        };
                    },
                    toRgbString: function() {
                        return 1 == this._a ? "rgb(" + mathRound(this._r) + ", " + mathRound(this._g) + ", " + mathRound(this._b) + ")" : "rgba(" + mathRound(this._r) + ", " + mathRound(this._g) + ", " + mathRound(this._b) + ", " + this._roundA + ")";
                    },
                    toPercentageRgb: function() {
                        return {
                            r: mathRound(100 * bound01(this._r, 255)) + "%",
                            g: mathRound(100 * bound01(this._g, 255)) + "%",
                            b: mathRound(100 * bound01(this._b, 255)) + "%",
                            a: this._a
                        };
                    },
                    toPercentageRgbString: function() {
                        return 1 == this._a ? "rgb(" + mathRound(100 * bound01(this._r, 255)) + "%, " + mathRound(100 * bound01(this._g, 255)) + "%, " + mathRound(100 * bound01(this._b, 255)) + "%)" : "rgba(" + mathRound(100 * bound01(this._r, 255)) + "%, " + mathRound(100 * bound01(this._g, 255)) + "%, " + mathRound(100 * bound01(this._b, 255)) + "%, " + this._roundA + ")";
                    },
                    toName: function() {
                        return 0 === this._a ? "transparent" : !(this._a < 1) && (hexNames[rgbToHex(this._r, this._g, this._b, !0)] || !1);
                    },
                    toFilter: function(secondColor) {
                        var hex8String = "#" + rgbaToArgbHex(this._r, this._g, this._b, this._a), secondHex8String = hex8String, gradientType = this._gradientType ? "GradientType = 1, " : "";
                        if (secondColor) {
                            var s = tinycolor(secondColor);
                            secondHex8String = "#" + rgbaToArgbHex(s._r, s._g, s._b, s._a);
                        }
                        return "progid:DXImageTransform.Microsoft.gradient(" + gradientType + "startColorstr=" + hex8String + ",endColorstr=" + secondHex8String + ")";
                    },
                    toString: function(format) {
                        var formatSet = !!format;
                        format = format || this._format;
                        var formattedString = !1, hasAlpha = this._a < 1 && this._a >= 0;
                        return formatSet || !hasAlpha || "hex" !== format && "hex6" !== format && "hex3" !== format && "hex4" !== format && "hex8" !== format && "name" !== format ? ("rgb" === format && (formattedString = this.toRgbString()), 
                        "prgb" === format && (formattedString = this.toPercentageRgbString()), "hex" !== format && "hex6" !== format || (formattedString = this.toHexString()), 
                        "hex3" === format && (formattedString = this.toHexString(!0)), "hex4" === format && (formattedString = this.toHex8String(!0)), 
                        "hex8" === format && (formattedString = this.toHex8String()), "name" === format && (formattedString = this.toName()), 
                        "hsl" === format && (formattedString = this.toHslString()), "hsv" === format && (formattedString = this.toHsvString()), 
                        formattedString || this.toHexString()) : "name" === format && 0 === this._a ? this.toName() : this.toRgbString();
                    },
                    clone: function() {
                        return tinycolor(this.toString());
                    },
                    _applyModification: function(fn, args) {
                        var color = fn.apply(null, [ this ].concat([].slice.call(args)));
                        return this._r = color._r, this._g = color._g, this._b = color._b, this.setAlpha(color._a), 
                        this;
                    },
                    lighten: function() {
                        return this._applyModification(lighten, arguments);
                    },
                    brighten: function() {
                        return this._applyModification(brighten, arguments);
                    },
                    darken: function() {
                        return this._applyModification(darken, arguments);
                    },
                    desaturate: function() {
                        return this._applyModification(desaturate, arguments);
                    },
                    saturate: function() {
                        return this._applyModification(saturate, arguments);
                    },
                    greyscale: function() {
                        return this._applyModification(greyscale, arguments);
                    },
                    spin: function() {
                        return this._applyModification(spin, arguments);
                    },
                    _applyCombination: function(fn, args) {
                        return fn.apply(null, [ this ].concat([].slice.call(args)));
                    },
                    analogous: function() {
                        return this._applyCombination(analogous, arguments);
                    },
                    complement: function() {
                        return this._applyCombination(complement, arguments);
                    },
                    monochromatic: function() {
                        return this._applyCombination(monochromatic, arguments);
                    },
                    splitcomplement: function() {
                        return this._applyCombination(splitcomplement, arguments);
                    },
                    triad: function() {
                        return this._applyCombination(triad, arguments);
                    },
                    tetrad: function() {
                        return this._applyCombination(tetrad, arguments);
                    }
                }, tinycolor.fromRatio = function(color, opts) {
                    if ("object" == typeof color) {
                        var newColor = {};
                        for (var i in color) color.hasOwnProperty(i) && (newColor[i] = "a" === i ? color[i] : convertToPercentage(color[i]));
                        color = newColor;
                    }
                    return tinycolor(color, opts);
                }, tinycolor.equals = function(color1, color2) {
                    return !(!color1 || !color2) && tinycolor(color1).toRgbString() == tinycolor(color2).toRgbString();
                }, tinycolor.random = function() {
                    return tinycolor.fromRatio({
                        r: mathRandom(),
                        g: mathRandom(),
                        b: mathRandom()
                    });
                }, tinycolor.mix = function(color1, color2, amount) {
                    amount = 0 === amount ? 0 : amount || 50;
                    var rgb1 = tinycolor(color1).toRgb(), rgb2 = tinycolor(color2).toRgb(), p = amount / 100;
                    return tinycolor({
                        r: (rgb2.r - rgb1.r) * p + rgb1.r,
                        g: (rgb2.g - rgb1.g) * p + rgb1.g,
                        b: (rgb2.b - rgb1.b) * p + rgb1.b,
                        a: (rgb2.a - rgb1.a) * p + rgb1.a
                    });
                }, tinycolor.readability = function(color1, color2) {
                    var c1 = tinycolor(color1), c2 = tinycolor(color2);
                    return (Math.max(c1.getLuminance(), c2.getLuminance()) + 0.05) / (Math.min(c1.getLuminance(), c2.getLuminance()) + 0.05);
                }, tinycolor.isReadable = function(color1, color2, wcag2) {
                    var wcag2Parms, out, readability = tinycolor.readability(color1, color2);
                    switch (out = !1, (wcag2Parms = function validateWCAG2Parms(parms) {
                        var level, size;
                        return "AA" !== (level = ((parms = parms || {
                            level: "AA",
                            size: "small"
                        }).level || "AA").toUpperCase()) && "AAA" !== level && (level = "AA"), "small" !== (size = (parms.size || "small").toLowerCase()) && "large" !== size && (size = "small"), 
                        {
                            level,
                            size
                        };
                    }(wcag2)).level + wcag2Parms.size) {
                      case "AAsmall":
                      case "AAAlarge":
                        out = readability >= 4.5;
                        break;

                      case "AAlarge":
                        out = readability >= 3;
                        break;

                      case "AAAsmall":
                        out = readability >= 7;
                    }
                    return out;
                }, tinycolor.mostReadable = function(baseColor, colorList, args) {
                    var readability, includeFallbackColors, level, size, bestColor = null, bestScore = 0;
                    includeFallbackColors = (args = args || {}).includeFallbackColors, level = args.level, 
                    size = args.size;
                    for (var i = 0; i < colorList.length; i++) (readability = tinycolor.readability(baseColor, colorList[i])) > bestScore && (bestScore = readability, 
                    bestColor = tinycolor(colorList[i]));
                    return tinycolor.isReadable(baseColor, bestColor, {
                        level,
                        size
                    }) || !includeFallbackColors ? bestColor : (args.includeFallbackColors = !1, tinycolor.mostReadable(baseColor, [ "#fff", "#000" ], args));
                };
                var names = tinycolor.names = {
                    aliceblue: "f0f8ff",
                    antiquewhite: "faebd7",
                    aqua: "0ff",
                    aquamarine: "7fffd4",
                    azure: "f0ffff",
                    beige: "f5f5dc",
                    bisque: "ffe4c4",
                    black: "000",
                    blanchedalmond: "ffebcd",
                    blue: "00f",
                    blueviolet: "8a2be2",
                    brown: "a52a2a",
                    burlywood: "deb887",
                    burntsienna: "ea7e5d",
                    cadetblue: "5f9ea0",
                    chartreuse: "7fff00",
                    chocolate: "d2691e",
                    coral: "ff7f50",
                    cornflowerblue: "6495ed",
                    cornsilk: "fff8dc",
                    crimson: "dc143c",
                    cyan: "0ff",
                    darkblue: "00008b",
                    darkcyan: "008b8b",
                    darkgoldenrod: "b8860b",
                    darkgray: "a9a9a9",
                    darkgreen: "006400",
                    darkgrey: "a9a9a9",
                    darkkhaki: "bdb76b",
                    darkmagenta: "8b008b",
                    darkolivegreen: "556b2f",
                    darkorange: "ff8c00",
                    darkorchid: "9932cc",
                    darkred: "8b0000",
                    darksalmon: "e9967a",
                    darkseagreen: "8fbc8f",
                    darkslateblue: "483d8b",
                    darkslategray: "2f4f4f",
                    darkslategrey: "2f4f4f",
                    darkturquoise: "00ced1",
                    darkviolet: "9400d3",
                    deeppink: "ff1493",
                    deepskyblue: "00bfff",
                    dimgray: "696969",
                    dimgrey: "696969",
                    dodgerblue: "1e90ff",
                    firebrick: "b22222",
                    floralwhite: "fffaf0",
                    forestgreen: "228b22",
                    fuchsia: "f0f",
                    gainsboro: "dcdcdc",
                    ghostwhite: "f8f8ff",
                    gold: "ffd700",
                    goldenrod: "daa520",
                    gray: "808080",
                    green: "008000",
                    greenyellow: "adff2f",
                    grey: "808080",
                    honeydew: "f0fff0",
                    hotpink: "ff69b4",
                    indianred: "cd5c5c",
                    indigo: "4b0082",
                    ivory: "fffff0",
                    khaki: "f0e68c",
                    lavender: "e6e6fa",
                    lavenderblush: "fff0f5",
                    lawngreen: "7cfc00",
                    lemonchiffon: "fffacd",
                    lightblue: "add8e6",
                    lightcoral: "f08080",
                    lightcyan: "e0ffff",
                    lightgoldenrodyellow: "fafad2",
                    lightgray: "d3d3d3",
                    lightgreen: "90ee90",
                    lightgrey: "d3d3d3",
                    lightpink: "ffb6c1",
                    lightsalmon: "ffa07a",
                    lightseagreen: "20b2aa",
                    lightskyblue: "87cefa",
                    lightslategray: "789",
                    lightslategrey: "789",
                    lightsteelblue: "b0c4de",
                    lightyellow: "ffffe0",
                    lime: "0f0",
                    limegreen: "32cd32",
                    linen: "faf0e6",
                    magenta: "f0f",
                    maroon: "800000",
                    mediumaquamarine: "66cdaa",
                    mediumblue: "0000cd",
                    mediumorchid: "ba55d3",
                    mediumpurple: "9370db",
                    mediumseagreen: "3cb371",
                    mediumslateblue: "7b68ee",
                    mediumspringgreen: "00fa9a",
                    mediumturquoise: "48d1cc",
                    mediumvioletred: "c71585",
                    midnightblue: "191970",
                    mintcream: "f5fffa",
                    mistyrose: "ffe4e1",
                    moccasin: "ffe4b5",
                    navajowhite: "ffdead",
                    navy: "000080",
                    oldlace: "fdf5e6",
                    olive: "808000",
                    olivedrab: "6b8e23",
                    orange: "ffa500",
                    orangered: "ff4500",
                    orchid: "da70d6",
                    palegoldenrod: "eee8aa",
                    palegreen: "98fb98",
                    paleturquoise: "afeeee",
                    palevioletred: "db7093",
                    papayawhip: "ffefd5",
                    peachpuff: "ffdab9",
                    peru: "cd853f",
                    pink: "ffc0cb",
                    plum: "dda0dd",
                    powderblue: "b0e0e6",
                    purple: "800080",
                    rebeccapurple: "663399",
                    red: "f00",
                    rosybrown: "bc8f8f",
                    royalblue: "4169e1",
                    saddlebrown: "8b4513",
                    salmon: "fa8072",
                    sandybrown: "f4a460",
                    seagreen: "2e8b57",
                    seashell: "fff5ee",
                    sienna: "a0522d",
                    silver: "c0c0c0",
                    skyblue: "87ceeb",
                    slateblue: "6a5acd",
                    slategray: "708090",
                    slategrey: "708090",
                    snow: "fffafa",
                    springgreen: "00ff7f",
                    steelblue: "4682b4",
                    tan: "d2b48c",
                    teal: "008080",
                    thistle: "d8bfd8",
                    tomato: "ff6347",
                    turquoise: "40e0d0",
                    violet: "ee82ee",
                    wheat: "f5deb3",
                    white: "fff",
                    whitesmoke: "f5f5f5",
                    yellow: "ff0",
                    yellowgreen: "9acd32"
                }, hexNames = tinycolor.hexNames = function flip(o) {
                    var flipped = {};
                    for (var i in o) o.hasOwnProperty(i) && (flipped[o[i]] = i);
                    return flipped;
                }(names);
                function boundAlpha(a) {
                    return a = parseFloat(a), (isNaN(a) || a < 0 || a > 1) && (a = 1), a;
                }
                function bound01(n, max) {
                    (function isOnePointZero(n) {
                        return "string" == typeof n && -1 != n.indexOf(".") && 1 === parseFloat(n);
                    })(n) && (n = "100%");
                    var processPercent = function isPercentage(n) {
                        return "string" == typeof n && -1 != n.indexOf("%");
                    }(n);
                    return n = mathMin(max, mathMax(0, parseFloat(n))), processPercent && (n = parseInt(n * max, 10) / 100), 
                    Math.abs(n - max) < 0.000001 ? 1 : n % max / parseFloat(max);
                }
                function clamp01(val) {
                    return mathMin(1, mathMax(0, val));
                }
                function parseIntFromHex(val) {
                    return parseInt(val, 16);
                }
                function pad2(c) {
                    return 1 == c.length ? "0" + c : "" + c;
                }
                function convertToPercentage(n) {
                    return n <= 1 && (n = 100 * n + "%"), n;
                }
                function convertDecimalToHex(d) {
                    return Math.round(255 * parseFloat(d)).toString(16);
                }
                function convertHexToDecimal(h) {
                    return parseIntFromHex(h) / 255;
                }
                var CSS_UNIT, PERMISSIVE_MATCH3, PERMISSIVE_MATCH4, matchers = (PERMISSIVE_MATCH3 = "[\\s|\\(]+(" + (CSS_UNIT = "(?:[-\\+]?\\d*\\.\\d+%?)|(?:[-\\+]?\\d+%?)") + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?", 
                PERMISSIVE_MATCH4 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?", 
                {
                    CSS_UNIT: new RegExp(CSS_UNIT),
                    rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
                    rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
                    hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
                    hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
                    hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
                    hsva: new RegExp("hsva" + PERMISSIVE_MATCH4),
                    hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
                    hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
                    hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
                    hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
                });
                function isValidCSSUnit(color) {
                    return !!matchers.CSS_UNIT.exec(color);
                }
                void 0 !== module && module.exports ? module.exports = tinycolor : window.tinycolor = tinycolor;
            }(Math);
        }, {} ],
        179: [ function(require, module, exports) {
            (exports = module.exports = function trim(str) {
                return str.replace(/^\s*|\s*$/g, "");
            }).left = function(str) {
                return str.replace(/^\s*/, "");
            }, exports.right = function(str) {
                return str.replace(/\s*$/, "");
            };
        }, {} ],
        180: [ function(require, module, exports) {
            var punycode = require("punycode"), util = require("./util");
            function Url() {
                this.protocol = null, this.slashes = null, this.auth = null, this.host = null, this.port = null, 
                this.hostname = null, this.hash = null, this.search = null, this.query = null, this.pathname = null, 
                this.path = null, this.href = null;
            }
            exports.parse = urlParse, exports.resolve = function urlResolve(source, relative) {
                return urlParse(source, !1, !0).resolve(relative);
            }, exports.resolveObject = function urlResolveObject(source, relative) {
                return source ? urlParse(source, !1, !0).resolveObject(relative) : relative;
            }, exports.format = function urlFormat(obj) {
                return util.isString(obj) && (obj = urlParse(obj)), obj instanceof Url ? obj.format() : Url.prototype.format.call(obj);
            }, exports.Url = Url;
            var protocolPattern = /^([a-z0-9.+-]+:)/i, portPattern = /:[0-9]*$/, simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/, unwise = [ "{", "}", "|", "\\", "^", "`" ].concat([ "<", ">", '"', "`", " ", "\r", "\n", "\t" ]), autoEscape = [ "'" ].concat(unwise), nonHostChars = [ "%", "/", "?", ";", "#" ].concat(autoEscape), hostEndingChars = [ "/", "?", "#" ], hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/, hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, unsafeProtocol = {
                javascript: !0,
                "javascript:": !0
            }, hostlessProtocol = {
                javascript: !0,
                "javascript:": !0
            }, slashedProtocol = {
                http: !0,
                https: !0,
                ftp: !0,
                gopher: !0,
                file: !0,
                "http:": !0,
                "https:": !0,
                "ftp:": !0,
                "gopher:": !0,
                "file:": !0
            }, querystring = require("querystring");
            function urlParse(url, parseQueryString, slashesDenoteHost) {
                if (url && util.isObject(url) && url instanceof Url) return url;
                var u = new Url;
                return u.parse(url, parseQueryString, slashesDenoteHost), u;
            }
            Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
                if (!util.isString(url)) throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
                var queryIndex = url.indexOf("?"), splitter = -1 !== queryIndex && queryIndex < url.indexOf("#") ? "?" : "#", uSplit = url.split(splitter);
                uSplit[0] = uSplit[0].replace(/\\/g, "/");
                var rest = url = uSplit.join(splitter);
                if (rest = rest.trim(), !slashesDenoteHost && 1 === url.split("#").length) {
                    var simplePath = simplePathPattern.exec(rest);
                    if (simplePath) return this.path = rest, this.href = rest, this.pathname = simplePath[1], 
                    simplePath[2] ? (this.search = simplePath[2], this.query = parseQueryString ? querystring.parse(this.search.substr(1)) : this.search.substr(1)) : parseQueryString && (this.search = "", 
                    this.query = {}), this;
                }
                var proto = protocolPattern.exec(rest);
                if (proto) {
                    var lowerProto = (proto = proto[0]).toLowerCase();
                    this.protocol = lowerProto, rest = rest.substr(proto.length);
                }
                if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
                    var slashes = "//" === rest.substr(0, 2);
                    !slashes || proto && hostlessProtocol[proto] || (rest = rest.substr(2), this.slashes = !0);
                }
                if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {
                    for (var auth, atSign, hostEnd = -1, i = 0; i < hostEndingChars.length; i++) -1 !== (hec = rest.indexOf(hostEndingChars[i])) && (-1 === hostEnd || hec < hostEnd) && (hostEnd = hec);
                    for (-1 !== (atSign = -1 === hostEnd ? rest.lastIndexOf("@") : rest.lastIndexOf("@", hostEnd)) && (auth = rest.slice(0, atSign), 
                    rest = rest.slice(atSign + 1), this.auth = decodeURIComponent(auth)), hostEnd = -1, 
                    i = 0; i < nonHostChars.length; i++) {
                        var hec;
                        -1 !== (hec = rest.indexOf(nonHostChars[i])) && (-1 === hostEnd || hec < hostEnd) && (hostEnd = hec);
                    }
                    -1 === hostEnd && (hostEnd = rest.length), this.host = rest.slice(0, hostEnd), rest = rest.slice(hostEnd), 
                    this.parseHost(), this.hostname = this.hostname || "";
                    var ipv6Hostname = "[" === this.hostname[0] && "]" === this.hostname[this.hostname.length - 1];
                    if (!ipv6Hostname) for (var hostparts = this.hostname.split(/\./), l = (i = 0, hostparts.length); i < l; i++) {
                        var part = hostparts[i];
                        if (part && !part.match(hostnamePartPattern)) {
                            for (var newpart = "", j = 0, k = part.length; j < k; j++) part.charCodeAt(j) > 127 ? newpart += "x" : newpart += part[j];
                            if (!newpart.match(hostnamePartPattern)) {
                                var validParts = hostparts.slice(0, i), notHost = hostparts.slice(i + 1), bit = part.match(hostnamePartStart);
                                bit && (validParts.push(bit[1]), notHost.unshift(bit[2])), notHost.length && (rest = "/" + notHost.join(".") + rest), 
                                this.hostname = validParts.join(".");
                                break;
                            }
                        }
                    }
                    this.hostname.length > 255 ? this.hostname = "" : this.hostname = this.hostname.toLowerCase(), 
                    ipv6Hostname || (this.hostname = punycode.toASCII(this.hostname));
                    var p = this.port ? ":" + this.port : "", h = this.hostname || "";
                    this.host = h + p, this.href += this.host, ipv6Hostname && (this.hostname = this.hostname.substr(1, this.hostname.length - 2), 
                    "/" !== rest[0] && (rest = "/" + rest));
                }
                if (!unsafeProtocol[lowerProto]) for (i = 0, l = autoEscape.length; i < l; i++) {
                    var ae = autoEscape[i];
                    if (-1 !== rest.indexOf(ae)) {
                        var esc = encodeURIComponent(ae);
                        esc === ae && (esc = escape(ae)), rest = rest.split(ae).join(esc);
                    }
                }
                var hash = rest.indexOf("#");
                -1 !== hash && (this.hash = rest.substr(hash), rest = rest.slice(0, hash));
                var qm = rest.indexOf("?");
                if (-1 !== qm ? (this.search = rest.substr(qm), this.query = rest.substr(qm + 1), 
                parseQueryString && (this.query = querystring.parse(this.query)), rest = rest.slice(0, qm)) : parseQueryString && (this.search = "", 
                this.query = {}), rest && (this.pathname = rest), slashedProtocol[lowerProto] && this.hostname && !this.pathname && (this.pathname = "/"), 
                this.pathname || this.search) {
                    p = this.pathname || "";
                    var s = this.search || "";
                    this.path = p + s;
                }
                return this.href = this.format(), this;
            }, Url.prototype.format = function() {
                var auth = this.auth || "";
                auth && (auth = (auth = encodeURIComponent(auth)).replace(/%3A/i, ":"), auth += "@");
                var protocol = this.protocol || "", pathname = this.pathname || "", hash = this.hash || "", host = !1, query = "";
                this.host ? host = auth + this.host : this.hostname && (host = auth + (-1 === this.hostname.indexOf(":") ? this.hostname : "[" + this.hostname + "]"), 
                this.port && (host += ":" + this.port)), this.query && util.isObject(this.query) && Object.keys(this.query).length && (query = querystring.stringify(this.query));
                var search = this.search || query && "?" + query || "";
                return protocol && ":" !== protocol.substr(-1) && (protocol += ":"), this.slashes || (!protocol || slashedProtocol[protocol]) && !1 !== host ? (host = "//" + (host || ""), 
                pathname && "/" !== pathname.charAt(0) && (pathname = "/" + pathname)) : host || (host = ""), 
                hash && "#" !== hash.charAt(0) && (hash = "#" + hash), search && "?" !== search.charAt(0) && (search = "?" + search), 
                protocol + host + (pathname = pathname.replace(/[?#]/g, (function(match) {
                    return encodeURIComponent(match);
                }))) + (search = search.replace("#", "%23")) + hash;
            }, Url.prototype.resolve = function(relative) {
                return this.resolveObject(urlParse(relative, !1, !0)).format();
            }, Url.prototype.resolveObject = function(relative) {
                if (util.isString(relative)) {
                    var rel = new Url;
                    rel.parse(relative, !1, !0), relative = rel;
                }
                for (var result = new Url, tkeys = Object.keys(this), tk = 0; tk < tkeys.length; tk++) {
                    var tkey = tkeys[tk];
                    result[tkey] = this[tkey];
                }
                if (result.hash = relative.hash, "" === relative.href) return result.href = result.format(), 
                result;
                if (relative.slashes && !relative.protocol) {
                    for (var rkeys = Object.keys(relative), rk = 0; rk < rkeys.length; rk++) {
                        var rkey = rkeys[rk];
                        "protocol" !== rkey && (result[rkey] = relative[rkey]);
                    }
                    return slashedProtocol[result.protocol] && result.hostname && !result.pathname && (result.path = result.pathname = "/"), 
                    result.href = result.format(), result;
                }
                if (relative.protocol && relative.protocol !== result.protocol) {
                    if (!slashedProtocol[relative.protocol]) {
                        for (var keys = Object.keys(relative), v = 0; v < keys.length; v++) {
                            var k = keys[v];
                            result[k] = relative[k];
                        }
                        return result.href = result.format(), result;
                    }
                    if (result.protocol = relative.protocol, relative.host || hostlessProtocol[relative.protocol]) result.pathname = relative.pathname; else {
                        for (var relPath = (relative.pathname || "").split("/"); relPath.length && !(relative.host = relPath.shift()); ) ;
                        relative.host || (relative.host = ""), relative.hostname || (relative.hostname = ""), 
                        "" !== relPath[0] && relPath.unshift(""), relPath.length < 2 && relPath.unshift(""), 
                        result.pathname = relPath.join("/");
                    }
                    if (result.search = relative.search, result.query = relative.query, result.host = relative.host || "", 
                    result.auth = relative.auth, result.hostname = relative.hostname || relative.host, 
                    result.port = relative.port, result.pathname || result.search) {
                        var p = result.pathname || "", s = result.search || "";
                        result.path = p + s;
                    }
                    return result.slashes = result.slashes || relative.slashes, result.href = result.format(), 
                    result;
                }
                var isSourceAbs = result.pathname && "/" === result.pathname.charAt(0), isRelAbs = relative.host || relative.pathname && "/" === relative.pathname.charAt(0), mustEndAbs = isRelAbs || isSourceAbs || result.host && relative.pathname, removeAllDots = mustEndAbs, srcPath = result.pathname && result.pathname.split("/") || [], psychotic = (relPath = relative.pathname && relative.pathname.split("/") || [], 
                result.protocol && !slashedProtocol[result.protocol]);
                if (psychotic && (result.hostname = "", result.port = null, result.host && ("" === srcPath[0] ? srcPath[0] = result.host : srcPath.unshift(result.host)), 
                result.host = "", relative.protocol && (relative.hostname = null, relative.port = null, 
                relative.host && ("" === relPath[0] ? relPath[0] = relative.host : relPath.unshift(relative.host)), 
                relative.host = null), mustEndAbs = mustEndAbs && ("" === relPath[0] || "" === srcPath[0])), 
                isRelAbs) result.host = relative.host || "" === relative.host ? relative.host : result.host, 
                result.hostname = relative.hostname || "" === relative.hostname ? relative.hostname : result.hostname, 
                result.search = relative.search, result.query = relative.query, srcPath = relPath; else if (relPath.length) srcPath || (srcPath = []), 
                srcPath.pop(), srcPath = srcPath.concat(relPath), result.search = relative.search, 
                result.query = relative.query; else if (!util.isNullOrUndefined(relative.search)) return psychotic && (result.hostname = result.host = srcPath.shift(), 
                (authInHost = !!(result.host && result.host.indexOf("@") > 0) && result.host.split("@")) && (result.auth = authInHost.shift(), 
                result.host = result.hostname = authInHost.shift())), result.search = relative.search, 
                result.query = relative.query, util.isNull(result.pathname) && util.isNull(result.search) || (result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "")), 
                result.href = result.format(), result;
                if (!srcPath.length) return result.pathname = null, result.search ? result.path = "/" + result.search : result.path = null, 
                result.href = result.format(), result;
                for (var last = srcPath.slice(-1)[0], hasTrailingSlash = (result.host || relative.host || srcPath.length > 1) && ("." === last || ".." === last) || "" === last, up = 0, i = srcPath.length; i >= 0; i--) "." === (last = srcPath[i]) ? srcPath.splice(i, 1) : ".." === last ? (srcPath.splice(i, 1), 
                up++) : up && (srcPath.splice(i, 1), up--);
                if (!mustEndAbs && !removeAllDots) for (;up--; up) srcPath.unshift("..");
                !mustEndAbs || "" === srcPath[0] || srcPath[0] && "/" === srcPath[0].charAt(0) || srcPath.unshift(""), 
                hasTrailingSlash && "/" !== srcPath.join("/").substr(-1) && srcPath.push("");
                var authInHost, isAbsolute = "" === srcPath[0] || srcPath[0] && "/" === srcPath[0].charAt(0);
                return psychotic && (result.hostname = result.host = isAbsolute ? "" : srcPath.length ? srcPath.shift() : "", 
                (authInHost = !!(result.host && result.host.indexOf("@") > 0) && result.host.split("@")) && (result.auth = authInHost.shift(), 
                result.host = result.hostname = authInHost.shift())), (mustEndAbs = mustEndAbs || result.host && srcPath.length) && !isAbsolute && srcPath.unshift(""), 
                srcPath.length ? result.pathname = srcPath.join("/") : (result.pathname = null, 
                result.path = null), util.isNull(result.pathname) && util.isNull(result.search) || (result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "")), 
                result.auth = relative.auth || result.auth, result.slashes = result.slashes || relative.slashes, 
                result.href = result.format(), result;
            }, Url.prototype.parseHost = function() {
                var host = this.host, port = portPattern.exec(host);
                port && (":" !== (port = port[0]) && (this.port = port.substr(1)), host = host.substr(0, host.length - port.length)), 
                host && (this.hostname = host);
            };
        }, {
            "./util": 181,
            punycode: 134,
            querystring: 137
        } ],
        181: [ function(require, module, exports) {
            module.exports = {
                isString: function(arg) {
                    return "string" == typeof arg;
                },
                isObject: function(arg) {
                    return "object" == typeof arg && null !== arg;
                },
                isNull: function(arg) {
                    return null === arg;
                },
                isNullOrUndefined: function(arg) {
                    return null == arg;
                }
            };
        }, {} ],
        182: [ function(require, module, exports) {
            (function(process) {
                !function() {
                    var UTIF = {};
                    function log() {
                        void 0 !== process && "development" != process.env.NODE_ENV || console.log.apply(console, arguments);
                    }
                    "object" == typeof module ? module.exports = UTIF : self.UTIF = UTIF, function(UTIF, pako) {
                        var V, D, P;
                        V = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(g) {
                            return typeof g;
                        } : function(g) {
                            return g && "function" == typeof Symbol && g.constructor === Symbol && g !== Symbol.prototype ? "symbol" : typeof g;
                        }, D = function() {
                            function g(g) {
                                this.message = "JPEG error: " + g;
                            }
                            return g.prototype = Error(), g.prototype.name = "JpegError", g.constructor = g;
                        }(), P = function() {
                            function g(g, D) {
                                this.message = g, this.g = D;
                            }
                            return g.prototype = Error(), g.prototype.name = "DNLMarkerError", g.constructor = g;
                        }(), function() {
                            function g() {
                                this.M = null, this.B = -1;
                            }
                            function W(a, d) {
                                for (var b, B, f = 0, e = [], k = 16; 0 < k && !a[k - 1]; ) k--;
                                e.push({
                                    children: [],
                                    index: 0
                                });
                                var r, l = e[0];
                                for (b = 0; b < k; b++) {
                                    for (B = 0; B < a[b]; B++) {
                                        for ((l = e.pop()).children[l.index] = d[f]; 0 < l.index; ) l = e.pop();
                                        for (l.index++, e.push(l); e.length <= b; ) e.push(r = {
                                            children: [],
                                            index: 0
                                        }), l.children[l.index] = r.children, l = r;
                                        f++;
                                    }
                                    b + 1 < k && (e.push(r = {
                                        children: [],
                                        index: 0
                                    }), l.children[l.index] = r.children, l = r);
                                }
                                return e[0].children;
                            }
                            function X(a, d, f, e, b, B, k, l, r) {
                                function n() {
                                    if (0 < x) return x--, z >> x & 1;
                                    if (255 === (z = a[d++])) {
                                        var c = a[d++];
                                        if (c) {
                                            if (220 === c && g) {
                                                d += 2;
                                                var b = a[d++] << 8 | a[d++];
                                                if (0 < b && b !== f.g) throw new P("Found DNL marker (0xFFDC) while parsing scan data", b);
                                            }
                                            throw new D("unexpected marker " + (z << 8 | c).toString(16));
                                        }
                                    }
                                    return x = 7, z >>> 7;
                                }
                                function q(a) {
                                    for (;;) {
                                        if ("number" == typeof (a = a[n()])) return a;
                                        if ("object" !== (void 0 === a ? "undefined" : V(a))) throw new D("invalid huffman sequence");
                                    }
                                }
                                function h(a) {
                                    for (var c = 0; 0 < a; ) c = c << 1 | n(), a--;
                                    return c;
                                }
                                function c(a) {
                                    if (1 === a) return 1 === n() ? 1 : -1;
                                    var c = h(a);
                                    return c >= 1 << a - 1 ? c : c + (-1 << a) + 1;
                                }
                                function C(a, b) {
                                    var d = q(a.D);
                                    for (d = 0 === d ? 0 : c(d), a.a[b] = a.m += d, d = 1; 64 > d; ) {
                                        var h = q(a.o), k = 15 & h;
                                        if (h >>= 4, 0 === k) {
                                            if (15 > h) break;
                                            d += 16;
                                        } else d += h, a.a[b + J[d]] = c(k), d++;
                                    }
                                }
                                function w(a, d) {
                                    var b = q(a.D);
                                    b = 0 === b ? 0 : c(b) << r, a.a[d] = a.m += b;
                                }
                                function p(a, c) {
                                    a.a[c] |= n() << r;
                                }
                                function m(a, b) {
                                    if (0 < A) A--; else for (var d = B; d <= k; ) {
                                        var e = q(a.o), f = 15 & e;
                                        if (e >>= 4, 0 === f) {
                                            if (15 > e) {
                                                A = h(e) + (1 << e) - 1;
                                                break;
                                            }
                                            d += 16;
                                        } else d += e, a.a[b + J[d]] = c(f) * (1 << r), d++;
                                    }
                                }
                                function t(a, d) {
                                    for (var f, b = B, e = 0; b <= k; ) {
                                        f = d + J[b];
                                        var l = 0 > a.a[f] ? -1 : 1;
                                        switch (E) {
                                          case 0:
                                            if (f = 15 & (e = q(a.o)), e >>= 4, 0 === f) 15 > e ? (A = h(e) + (1 << e), E = 4) : (e = 16, 
                                            E = 1); else {
                                                if (1 !== f) throw new D("invalid ACn encoding");
                                                Q = c(f), E = e ? 2 : 3;
                                            }
                                            continue;

                                          case 1:
                                          case 2:
                                            a.a[f] ? a.a[f] += l * (n() << r) : 0 == --e && (E = 2 === E ? 3 : 0);
                                            break;

                                          case 3:
                                            a.a[f] ? a.a[f] += l * (n() << r) : (a.a[f] = Q << r, E = 0);
                                            break;

                                          case 4:
                                            a.a[f] && (a.a[f] += l * (n() << r));
                                        }
                                        b++;
                                    }
                                    4 === E && 0 == --A && (E = 0);
                                }
                                for (var Q, F, L, M, I, S, T, g = 9 < arguments.length && void 0 !== arguments[9] && arguments[9], u = f.P, v = d, z = 0, x = 0, A = 0, E = 0, K = e.length, R = f.S ? 0 === B ? 0 === l ? w : p : 0 === l ? m : t : C, G = 0, O = 1 === K ? e[0].c * e[0].l : u * f.O; G < O; ) {
                                    var U = b ? Math.min(O - G, b) : O;
                                    for (F = 0; F < K; F++) e[F].m = 0;
                                    if (A = 0, 1 === K) {
                                        var y = e[0];
                                        for (I = 0; I < U; I++) R(y, 64 * ((y.c + 1) * (G / y.c | 0) + G % y.c)), G++;
                                    } else for (I = 0; I < U; I++) {
                                        for (F = 0; F < K; F++) for (S = (y = e[F]).h, T = y.j, L = 0; L < T; L++) for (M = 0; M < S; M++) R(y, 64 * ((y.c + 1) * ((G / u | 0) * y.j + L) + (G % u * y.h + M)));
                                        G++;
                                    }
                                    if (x = 0, (y = N(a, d)) && y.f && ((0, _util.warn)("decodeScan - unexpected MCU data, current marker is: " + y.f), 
                                    d = y.offset), !(y = y && y.F) || 65280 >= y) throw new D("marker was not found");
                                    if (!(65488 <= y && 65495 >= y)) break;
                                    d += 2;
                                }
                                return (y = N(a, d)) && y.f && ((0, _util.warn)("decodeScan - unexpected Scan data, current marker is: " + y.f), 
                                d = y.offset), d - v;
                            }
                            function Y(a, d) {
                                for (var f = d.c, e = d.l, b = new Int16Array(64), B = 0; B < e; B++) for (var k = 0; k < f; k++) {
                                    var l = 64 * ((d.c + 1) * B + k), r = b, n = d.G, q = d.a;
                                    if (!n) throw new D("missing required Quantization Table.");
                                    for (var h = 0; 64 > h; h += 8) {
                                        var c = q[l + h], C = q[l + h + 1], w = q[l + h + 2], p = q[l + h + 3], m = q[l + h + 4], t = q[l + h + 5], g = q[l + h + 6], u = q[l + h + 7];
                                        if (c *= n[h], 0 == (C | w | p | m | t | g | u)) c = 5793 * c + 512 >> 10, r[h] = c, 
                                        r[h + 1] = c, r[h + 2] = c, r[h + 3] = c, r[h + 4] = c, r[h + 5] = c, r[h + 6] = c, 
                                        r[h + 7] = c; else {
                                            C *= n[h + 1], w *= n[h + 2], p *= n[h + 3], m *= n[h + 4], t *= n[h + 5];
                                            var v = 5793 * c + 128 >> 8, z = 5793 * m + 128 >> 8, x = w, A = g *= n[h + 6];
                                            z = (v = v + z + 1 >> 1) - z, c = 3784 * x + 1567 * A + 128 >> 8, x = 1567 * x - 3784 * A + 128 >> 8, 
                                            t = (m = (m = 2896 * (C - (u *= n[h + 7])) + 128 >> 8) + (t <<= 4) + 1 >> 1) - t, 
                                            p = (u = (u = 2896 * (C + u) + 128 >> 8) + (p <<= 4) + 1 >> 1) - p, A = (v = v + (A = c) + 1 >> 1) - A, 
                                            x = (z = z + x + 1 >> 1) - x, c = 2276 * m + 3406 * u + 2048 >> 12, m = 3406 * m - 2276 * u + 2048 >> 12, 
                                            u = c, c = 799 * p + 4017 * t + 2048 >> 12, p = 4017 * p - 799 * t + 2048 >> 12, 
                                            t = c, r[h] = v + u, r[h + 7] = v - u, r[h + 1] = z + t, r[h + 6] = z - t, r[h + 2] = x + p, 
                                            r[h + 5] = x - p, r[h + 3] = A + m, r[h + 4] = A - m;
                                        }
                                    }
                                    for (n = 0; 8 > n; ++n) c = r[n], 0 == ((C = r[n + 8]) | (w = r[n + 16]) | (p = r[n + 24]) | (m = r[n + 32]) | (t = r[n + 40]) | (g = r[n + 48]) | (u = r[n + 56])) ? (c = -2040 > (c = 5793 * c + 8192 >> 14) ? 0 : 2024 <= c ? 255 : c + 2056 >> 4, 
                                    q[l + n] = c, q[l + n + 8] = c, q[l + n + 16] = c, q[l + n + 24] = c, q[l + n + 32] = c, 
                                    q[l + n + 40] = c, q[l + n + 48] = c, q[l + n + 56] = c) : (v = 5793 * c + 2048 >> 12, 
                                    z = 5793 * m + 2048 >> 12, c = 3784 * (x = w) + 1567 * (A = g) + 2048 >> 12, x = 1567 * x - 3784 * A + 2048 >> 12, 
                                    A = c, t = (m = (m = 2896 * (C - u) + 2048 >> 12) + t + 1 >> 1) - t, p = (u = (u = 2896 * (C + u) + 2048 >> 12) + p + 1 >> 1) - p, 
                                    c = 2276 * m + 3406 * u + 2048 >> 12, m = 3406 * m - 2276 * u + 2048 >> 12, u = c, 
                                    c = 799 * p + 4017 * t + 2048 >> 12, p = 4017 * p - 799 * t + 2048 >> 12, C = (z = (z = (v = 4112 + (v + z + 1 >> 1)) - z) + x + 1 >> 1) + (t = c), 
                                    g = z - t, t = (x = z - x) - p, c = 16 > (c = (v = v + A + 1 >> 1) + u) ? 0 : 4080 <= c ? 255 : c >> 4, 
                                    C = 16 > C ? 0 : 4080 <= C ? 255 : C >> 4, w = 16 > (w = x + p) ? 0 : 4080 <= w ? 255 : w >> 4, 
                                    p = 16 > (p = (A = v - A) + m) ? 0 : 4080 <= p ? 255 : p >> 4, m = 16 > (m = A - m) ? 0 : 4080 <= m ? 255 : m >> 4, 
                                    t = 16 > t ? 0 : 4080 <= t ? 255 : t >> 4, g = 16 > g ? 0 : 4080 <= g ? 255 : g >> 4, 
                                    u = 16 > (u = v - u) ? 0 : 4080 <= u ? 255 : u >> 4, q[l + n] = c, q[l + n + 8] = C, 
                                    q[l + n + 16] = w, q[l + n + 24] = p, q[l + n + 32] = m, q[l + n + 40] = t, q[l + n + 48] = g, 
                                    q[l + n + 56] = u);
                                }
                                return d.a;
                            }
                            function N(a, d) {
                                var f = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : d, e = a.length - 1;
                                if (f = f < d ? f : d, d >= e) return null;
                                var b = a[d] << 8 | a[d + 1];
                                if (65472 <= b && 65534 >= b) return {
                                    f: null,
                                    F: b,
                                    offset: d
                                };
                                for (var B = a[f] << 8 | a[f + 1]; !(65472 <= B && 65534 >= B); ) {
                                    if (++f >= e) return null;
                                    B = a[f] << 8 | a[f + 1];
                                }
                                return {
                                    f: b.toString(16),
                                    F: B,
                                    offset: f
                                };
                            }
                            var J = new Uint8Array([ 0, 1, 8, 16, 9, 2, 3, 10, 17, 24, 32, 25, 18, 11, 4, 5, 12, 19, 26, 33, 40, 48, 41, 34, 27, 20, 13, 6, 7, 14, 21, 28, 35, 42, 49, 56, 57, 50, 43, 36, 29, 22, 15, 23, 30, 37, 44, 51, 58, 59, 52, 45, 38, 31, 39, 46, 53, 60, 61, 54, 47, 55, 62, 63 ]);
                            g.prototype = {
                                parse: function(a) {
                                    function d() {
                                        var d = a[k] << 8 | a[k + 1];
                                        return k += 2, d;
                                    }
                                    function f() {
                                        var b = d(), c = N(a, b = k + b - 2, k);
                                        return c && c.f && ((0, _util.warn)("readDataBlock - incorrect length, current marker is: " + c.f), 
                                        b = c.offset), b = a.subarray(k, b), k += b.length, b;
                                    }
                                    function e(a) {
                                        for (var b = Math.ceil(a.v / 8 / a.s), c = Math.ceil(a.g / 8 / a.u), d = 0; d < a.b.length; d++) {
                                            v = a.b[d];
                                            var e = Math.ceil(Math.ceil(a.v / 8) * v.h / a.s), f = Math.ceil(Math.ceil(a.g / 8) * v.j / a.u);
                                            v.a = new Int16Array(64 * c * v.j * (b * v.h + 1)), v.c = e, v.l = f;
                                        }
                                        a.P = b, a.O = c;
                                    }
                                    var b = (1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : {}).N, B = void 0 === b ? null : b, k = 0, l = null, r = 0;
                                    b = [];
                                    var n = [], q = [], h = d();
                                    if (65496 !== h) throw new D("SOI not found");
                                    for (h = d(); 65497 !== h; ) {
                                        switch (h) {
                                          case 65504:
                                          case 65505:
                                          case 65506:
                                          case 65507:
                                          case 65508:
                                          case 65509:
                                          case 65510:
                                          case 65511:
                                          case 65512:
                                          case 65513:
                                          case 65514:
                                          case 65515:
                                          case 65516:
                                          case 65517:
                                          case 65518:
                                          case 65519:
                                          case 65534:
                                            var c = f();
                                            65518 === h && 65 === c[0] && 100 === c[1] && 111 === c[2] && 98 === c[3] && 101 === c[4] && (l = {
                                                version: c[5] << 8 | c[6],
                                                Y: c[7] << 8 | c[8],
                                                Z: c[9] << 8 | c[10],
                                                W: c[11]
                                            });
                                            break;

                                          case 65499:
                                            h = d() + k - 2;
                                            for (var g; k < h; ) {
                                                var w = a[k++], p = new Uint16Array(64);
                                                if (0 == w >> 4) for (c = 0; 64 > c; c++) p[g = J[c]] = a[k++]; else {
                                                    if (1 != w >> 4) throw new D("DQT - invalid table spec");
                                                    for (c = 0; 64 > c; c++) p[g = J[c]] = d();
                                                }
                                                b[15 & w] = p;
                                            }
                                            break;

                                          case 65472:
                                          case 65473:
                                          case 65474:
                                            if (m) throw new D("Only single frame JPEGs supported");
                                            d();
                                            var m = {};
                                            for (m.X = 65473 === h, m.S = 65474 === h, m.precision = a[k++], h = d(), m.g = B || h, 
                                            m.v = d(), m.b = [], m.C = {}, c = a[k++], h = p = w = 0; h < c; h++) {
                                                g = a[k];
                                                var t = a[k + 1] >> 4, H = 15 & a[k + 1];
                                                w < t && (w = t), p < H && (p = H), t = m.b.push({
                                                    h: t,
                                                    j: H,
                                                    T: a[k + 2],
                                                    G: null
                                                }), m.C[g] = t - 1, k += 3;
                                            }
                                            m.s = w, m.u = p, e(m);
                                            break;

                                          case 65476:
                                            for (g = d(), h = 2; h < g; ) {
                                                for (w = a[k++], p = new Uint8Array(16), c = t = 0; 16 > c; c++, k++) t += p[c] = a[k];
                                                for (H = new Uint8Array(t), c = 0; c < t; c++, k++) H[c] = a[k];
                                                h += 17 + t, (0 == w >> 4 ? q : n)[15 & w] = W(p, H);
                                            }
                                            break;

                                          case 65501:
                                            d();
                                            var u = d();
                                            break;

                                          case 65498:
                                            for (c = 1 == ++r && !B, d(), w = a[k++], g = [], h = 0; h < w; h++) {
                                                p = m.C[a[k++]];
                                                var v = m.b[p];
                                                p = a[k++], v.D = q[p >> 4], v.o = n[15 & p], g.push(v);
                                            }
                                            h = a[k++], w = a[k++], p = a[k++];
                                            try {
                                                var z = X(a, k, m, g, u, h, w, p >> 4, 15 & p, c);
                                                k += z;
                                            } catch (x) {
                                                if (x instanceof P) return (0, _util.warn)('Attempting to re-parse JPEG image using "scanLines" parameter found in DNL marker (0xFFDC) segment.'), 
                                                this.parse(a, {
                                                    N: x.g
                                                });
                                                throw x;
                                            }
                                            break;

                                          case 65500:
                                            k += 4;
                                            break;

                                          case 65535:
                                            255 !== a[k] && k--;
                                            break;

                                          default:
                                            if (255 === a[k - 3] && 192 <= a[k - 2] && 254 >= a[k - 2]) k -= 3; else {
                                                if (!(c = N(a, k - 2)) || !c.f) throw new D("unknown marker " + h.toString(16));
                                                (0, _util.warn)("JpegImage.parse - unexpected data, current marker is: " + c.f), 
                                                k = c.offset;
                                            }
                                        }
                                        h = d();
                                    }
                                    for (this.width = m.v, this.height = m.g, this.A = l, this.b = [], h = 0; h < m.b.length; h++) (u = b[(v = m.b[h]).T]) && (v.G = u), 
                                    this.b.push({
                                        R: Y(0, v),
                                        U: v.h / m.s,
                                        V: v.j / m.u,
                                        c: v.c,
                                        l: v.l
                                    });
                                    this.i = this.b.length;
                                },
                                L: function(a, d) {
                                    var b, g, f = this.width / a, e = this.height / d, k = this.b.length, l = a * d * k, r = new Uint8ClampedArray(l), n = new Uint32Array(a);
                                    for (g = 0; g < k; g++) {
                                        var q = this.b[g], h = q.U * f, c = q.V * e, C = g, w = q.R, p = q.c + 1 << 3;
                                        for (b = 0; b < a; b++) q = 0 | b * h, n[b] = (4294967288 & q) << 3 | 7 & q;
                                        for (h = 0; h < d; h++) for (q = p * (4294967288 & (q = 0 | h * c)) | (7 & q) << 3, 
                                        b = 0; b < a; b++) r[C] = w[q + n[b]], C += k;
                                    }
                                    if (e = this.M) for (g = 0; g < l; ) for (f = q = 0; q < k; q++, g++, f += 2) r[g] = (r[g] * e[f] >> 8) + e[f + 1];
                                    return r;
                                },
                                w: function() {
                                    return this.A ? !!this.A.W : 3 === this.i ? 0 !== this.B : 1 === this.B;
                                },
                                I: function(a) {
                                    for (var d, f, e, b = 0, g = a.length; b < g; b += 3) d = a[b], f = a[b + 1], e = a[b + 2], 
                                    a[b] = d - 179.456 + 1.402 * e, a[b + 1] = d + 135.459 - .344 * f - .714 * e, a[b + 2] = d - 226.816 + 1.772 * f;
                                    return a;
                                },
                                K: function(a) {
                                    for (var d, f, e, b, g = 0, k = 0, l = a.length; k < l; k += 4) d = a[k], f = a[k + 1], 
                                    e = a[k + 2], b = a[k + 3], a[g++] = f * (-6.60635669420364E-5 * f + 4.37130475926232E-4 * e - 5.4080610064599E-5 * d + 4.8449797120281E-4 * b - .154362151871126) - 122.67195406894 + e * (-9.57964378445773E-4 * e + 8.17076911346625E-4 * d - .00477271405408747 * b + 1.53380253221734) + d * (9.61250184130688E-4 * d - .00266257332283933 * b + .48357088451265) + b * (-3.36197177618394E-4 * b + .484791561490776), 
                                    a[g++] = 107.268039397724 + f * (2.19927104525741E-5 * f - 6.40992018297945E-4 * e + 6.59397001245577E-4 * d + 4.26105652938837E-4 * b - .176491792462875) + e * (-7.78269941513683E-4 * e + .00130872261408275 * d + 7.70482631801132E-4 * b - .151051492775562) + d * (.00126935368114843 * d - .00265090189010898 * b + .25802910206845) + b * (-3.18913117588328E-4 * b - .213742400323665), 
                                    a[g++] = f * (-5.70115196973677E-4 * f - 2.63409051004589E-5 * e + .0020741088115012 * d - .00288260236853442 * b + .814272968359295) - 20.810012546947 + e * (-1.53496057440975E-5 * e - 1.32689043961446E-4 * d + 5.60833691242812E-4 * b - .195152027534049) + d * (.00174418132927582 * d - .00255243321439347 * b + .116935020465145) + b * (-3.43531996510555E-4 * b + .24165260232407);
                                    return a.subarray(0, g);
                                },
                                J: function(a) {
                                    for (var d, f, e, b = 0, g = a.length; b < g; b += 4) d = a[b], f = a[b + 1], e = a[b + 2], 
                                    a[b] = 434.456 - d - 1.402 * e, a[b + 1] = 119.541 - d + .344 * f + .714 * e, a[b + 2] = 481.816 - d - 1.772 * f;
                                    return a;
                                },
                                H: function(a) {
                                    for (var d, f, e, b, g = 0, k = 1 / 255, l = 0, r = a.length; l < r; l += 4) d = a[l] * k, 
                                    f = a[l + 1] * k, e = a[l + 2] * k, b = a[l + 3] * k, a[g++] = 255 + d * (-4.387332384609988 * d + 54.48615194189176 * f + 18.82290502165302 * e + 212.25662451639585 * b - 285.2331026137004) + f * (1.7149763477362134 * f - 5.6096736904047315 * e - 17.873870861415444 * b - 5.497006427196366) + e * (-2.5217340131683033 * e - 21.248923337353073 * b + 17.5119270841813) - b * (21.86122147463605 * b + 189.48180835922747), 
                                    a[g++] = 255 + d * (8.841041422036149 * d + 60.118027045597366 * f + 6.871425592049007 * e + 31.159100130055922 * b - 79.2970844816548) + f * (-15.310361306967817 * f + 17.575251261109482 * e + 131.35250912493976 * b - 190.9453302588951) + e * (4.444339102852739 * e + 9.8632861493405 * b - 24.86741582555878) - b * (20.737325471181034 * b + 187.80453709719578), 
                                    a[g++] = 255 + d * (.8842522430003296 * d + 8.078677503112928 * f + 30.89978309703729 * e - .23883238689178934 * b - 14.183576799673286) + f * (10.49593273432072 * f + 63.02378494754052 * e + 50.606957656360734 * b - 112.23884253719248) + e * (.03296041114873217 * e + 115.60384449646641 * b - 193.58209356861505) - b * (22.33816807309886 * b + 180.12613974708367);
                                    return a.subarray(0, g);
                                },
                                getData: function(a, d, f) {
                                    if (4 < this.i) throw new D("Unsupported color mode");
                                    if (a = this.L(a, d), 1 === this.i && f) {
                                        f = a.length, d = new Uint8ClampedArray(3 * f);
                                        for (var e = 0, b = 0; b < f; b++) {
                                            var g = a[b];
                                            d[e++] = g, d[e++] = g, d[e++] = g;
                                        }
                                        return d;
                                    }
                                    if (3 === this.i && this.w()) return this.I(a);
                                    if (4 === this.i) {
                                        if (this.w()) return f ? this.K(a) : this.J(a);
                                        if (f) return this.H(a);
                                    }
                                    return a;
                                }
                            }, UTIF.JpegDecoder = g;
                        }(), UTIF.encodeImage = function(rgba, w, h, metadata) {
                            var idf = {
                                t256: [ w ],
                                t257: [ h ],
                                t258: [ 8, 8, 8, 8 ],
                                t259: [ 1 ],
                                t262: [ 2 ],
                                t273: [ 1000 ],
                                t277: [ 4 ],
                                t278: [ h ],
                                t279: [ w * h * 4 ],
                                t282: [ 1 ],
                                t283: [ 1 ],
                                t284: [ 1 ],
                                t286: [ 0 ],
                                t287: [ 0 ],
                                t296: [ 1 ],
                                t305: [ "Photopea (UTIF.js)" ],
                                t338: [ 1 ]
                            };
                            if (metadata) for (var i in metadata) idf[i] = metadata[i];
                            var prfx = new Uint8Array(UTIF.encode([ idf ])), img = new Uint8Array(rgba), data = new Uint8Array(1000 + w * h * 4);
                            for (i = 0; i < prfx.length; i++) data[i] = prfx[i];
                            for (i = 0; i < img.length; i++) data[1000 + i] = img[i];
                            return data.buffer;
                        }, UTIF.encode = function(ifds) {
                            var data = new Uint8Array(20000), offset = 4, bin = UTIF._binBE;
                            data[0] = 77, data[1] = 77, data[3] = 42;
                            var ifdo = 8;
                            bin.writeUint(data, offset, ifdo), offset += 4;
                            for (var i = 0; i < ifds.length; i++) {
                                var noffs = UTIF._writeIFD(bin, data, ifdo, ifds[i]);
                                ifdo = noffs[1], i < ifds.length - 1 && bin.writeUint(data, noffs[0], ifdo);
                            }
                            return data.slice(0, ifdo).buffer;
                        }, UTIF.decode = function(buff) {
                            UTIF.decode._decodeG3.allow2D = null;
                            var data = new Uint8Array(buff), offset = 0, id = UTIF._binBE.readASCII(data, offset, 2);
                            offset += 2;
                            var bin = "II" == id ? UTIF._binLE : UTIF._binBE;
                            bin.readUshort(data, offset), offset += 2;
                            var ifdo = bin.readUint(data, offset);
                            offset += 4;
                            for (var ifds = []; ;) {
                                var noff = UTIF._readIFD(bin, data, ifdo, ifds);
                                if (0 == (ifdo = bin.readUint(data, noff))) break;
                            }
                            return ifds;
                        }, UTIF.decodeImages = function(buff, ifds) {
                            for (var data = new Uint8Array(buff), id = UTIF._binBE.readASCII(data, 0, 2), ii = 0; ii < ifds.length; ii++) {
                                var img = ifds[ii];
                                if (null != img.t256) {
                                    img.isLE = "II" == id, img.width = img.t256[0], img.height = img.t257[0];
                                    var cmpr = img.t259 ? img.t259[0] : 1, fo = img.t266 ? img.t266[0] : 1;
                                    img.t284 && 2 == img.t284[0] && log("PlanarConfiguration 2 should not be used!");
                                    var bipp = (img.t258 ? Math.min(32, img.t258[0]) : 1) * (img.t277 ? img.t277[0] : 1), bipl = 8 * Math.ceil(img.width * bipp / 8), soff = img.t273;
                                    null == soff && (soff = img.t324);
                                    var bcnt = img.t279;
                                    1 == cmpr && 1 == soff.length && (bcnt = [ img.height * (bipl >>> 3) ]), null == bcnt && (bcnt = img.t325);
                                    var bytes = new Uint8Array(img.height * (bipl >>> 3)), bilen = 0;
                                    if (null != img.t322) {
                                        for (var tw = img.t322[0], th = img.t323[0], tx = Math.floor((img.width + tw - 1) / tw), ty = Math.floor((img.height + th - 1) / th), tbuff = new Uint8Array(0 | Math.ceil(tw * th * bipp / 8)), y = 0; y < ty; y++) for (var x = 0; x < tx; x++) {
                                            for (var i = y * tx + x, j = 0; j < tbuff.length; j++) tbuff[j] = 0;
                                            UTIF.decode._decompress(img, data, soff[i], bcnt[i], cmpr, tbuff, 0, fo), 6 == cmpr ? bytes = tbuff : UTIF._copyTile(tbuff, 0 | Math.ceil(tw * bipp / 8), th, bytes, 0 | Math.ceil(img.width * bipp / 8), img.height, 0 | Math.ceil(x * tw * bipp / 8), y * th);
                                        }
                                        bilen = 8 * bytes.length;
                                    } else {
                                        var rps = img.t278 ? img.t278[0] : img.height;
                                        for (rps = Math.min(rps, img.height), i = 0; i < soff.length; i++) UTIF.decode._decompress(img, data, soff[i], bcnt[i], cmpr, bytes, 0 | Math.ceil(bilen / 8), fo), 
                                        bilen += bipl * rps;
                                        bilen = Math.min(bilen, 8 * bytes.length);
                                    }
                                    img.data = new Uint8Array(bytes.buffer, 0, 0 | Math.ceil(bilen / 8));
                                }
                            }
                        }, UTIF.decode._decompress = function(img, data, off, len, cmpr, tgt, toff, fo) {
                            if (1 == cmpr) for (var j = 0; j < len; j++) tgt[toff + j] = data[off + j]; else if (3 == cmpr) UTIF.decode._decodeG3(data, off, len, tgt, toff, img.width, fo); else if (4 == cmpr) UTIF.decode._decodeG4(data, off, len, tgt, toff, img.width, fo); else if (5 == cmpr) UTIF.decode._decodeLZW(data, off, tgt, toff); else if (6 == cmpr) UTIF.decode._decodeOldJPEG(img, data, off, len, tgt, toff); else if (7 == cmpr) UTIF.decode._decodeNewJPEG(img, data, off, len, tgt, toff); else if (8 == cmpr) for (var src = new Uint8Array(data.buffer, off, len), bin = pako.inflate(src), i = 0; i < bin.length; i++) tgt[toff + i] = bin[i]; else 32773 == cmpr ? UTIF.decode._decodePackBits(data, off, len, tgt, toff) : 32809 == cmpr ? UTIF.decode._decodeThunder(data, off, len, tgt, toff) : log("Unknown compression", cmpr);
                            if (img.t317 && 2 == img.t317[0]) for (var noc = img.t277 ? img.t277[0] : 1, h = img.t278 ? img.t278[0] : img.height, bpr = img.width * noc, y = 0; y < h; y++) {
                                var ntoff = toff + y * bpr;
                                if (3 == noc) for (j = 3; j < bpr; j += 3) tgt[ntoff + j] = tgt[ntoff + j] + tgt[ntoff + j - 3] & 255, 
                                tgt[ntoff + j + 1] = tgt[ntoff + j + 1] + tgt[ntoff + j - 2] & 255, tgt[ntoff + j + 2] = tgt[ntoff + j + 2] + tgt[ntoff + j - 1] & 255; else for (j = noc; j < bpr; j++) tgt[ntoff + j] = tgt[ntoff + j] + tgt[ntoff + j - noc] & 255;
                            }
                        }, UTIF.decode._decodeNikon = function(data, off, len, tgt, toff) {
                            var ver0, ver1;
                            log(data.slice(off, off + 100)), ver0 = data[off], ver1 = data[++off], off++, log(ver0.toString(16), ver1.toString(16), len);
                        }, UTIF.decode._decodeNewJPEG = function(img, data, off, len, tgt, toff) {
                            var tables = img.t347, tlen = tables ? tables.length : 0, buff = new Uint8Array(tlen + len);
                            if (tables) {
                                for (var boff = 0, i = 0; i < tlen - 1 && (255 != tables[i] || 217 != tables[i + 1]); i++) buff[boff++] = tables[i];
                                var byte1 = data[off], byte2 = data[off + 1];
                                for (255 == byte1 && 216 == byte2 || (buff[boff++] = byte1, buff[boff++] = byte2), 
                                i = 2; i < len; i++) buff[boff++] = data[off + i];
                            } else for (i = 0; i < len; i++) buff[i] = data[off + i];
                            if (32803 == img.t262) {
                                var bps = img.t258[0], out = (new LosslessJpegDecoder).decode(buff), olen = out.length;
                                if (16 == bps) for (i = 0; i < olen; i++) tgt[toff++] = 255 & out[i], tgt[toff++] = out[i] >>> 8; else {
                                    if (12 != bps) throw new Error("unsupported bit depth " + bps);
                                    for (i = 0; i < olen; i += 2) tgt[toff++] = out[i] >>> 4, tgt[toff++] = 255 & (out[i] << 4 | out[i + 1] >>> 8), 
                                    tgt[toff++] = 255 & out[i + 1];
                                }
                            } else {
                                var parser = new UTIF.JpegDecoder;
                                parser.parse(buff);
                                var decoded = parser.getData(parser.width, parser.height);
                                for (i = 0; i < decoded.length; i++) tgt[toff + i] = decoded[i];
                            }
                            6 == img.t262[0] && (img.t262[0] = 2);
                        }, UTIF.decode._decodeOldJPEGInit = function(img, data, off, len) {
                            var tables, sosMarker, i, j, k, joff = 0, soff = 0, isTiled = !1, jpgIchgFmt = img.t513, jifoff = jpgIchgFmt ? jpgIchgFmt[0] : 0, jpgIchgFmtLen = img.t514, jiflen = jpgIchgFmtLen ? jpgIchgFmtLen[0] : 0, soffTag = img.t324 || img.t273 || jpgIchgFmt, ycbcrss = img.t530, ssx = 0, ssy = 0, spp = img.t277 ? img.t277[0] : 1, jpgresint = img.t515;
                            if (soffTag && (soff = soffTag[0], isTiled = soffTag.length > 1), !isTiled) {
                                if (255 == data[off] && 216 == data[off + 1]) return {
                                    jpegOffset: off
                                };
                                if (null != jpgIchgFmt && (255 == data[off + jifoff] && 216 == data[off + jifoff + 1] ? joff = off + jifoff : log("JPEGInterchangeFormat does not point to SOI"), 
                                null == jpgIchgFmtLen ? log("JPEGInterchangeFormatLength field is missing") : (jifoff >= soff || jifoff + jiflen <= soff) && log("JPEGInterchangeFormatLength field value is invalid"), 
                                null != joff)) return {
                                    jpegOffset: joff
                                };
                            }
                            if (null != ycbcrss && (ssx = ycbcrss[0], ssy = ycbcrss[1]), null != jpgIchgFmt && null != jpgIchgFmtLen) if (jiflen >= 2 && jifoff + jiflen <= soff) {
                                for (tables = 255 == data[off + jifoff + jiflen - 2] && 216 == data[off + jifoff + jiflen - 1] ? new Uint8Array(jiflen - 2) : new Uint8Array(jiflen), 
                                i = 0; i < tables.length; i++) tables[i] = data[off + jifoff + i];
                                log("Incorrect JPEG interchange format: using JPEGInterchangeFormat offset to derive tables");
                            } else log("JPEGInterchangeFormat+JPEGInterchangeFormatLength > offset to first strip or tile");
                            if (null == tables) {
                                var ooff = 0, out = [];
                                out[ooff++] = 255, out[ooff++] = 216;
                                var qtables = img.t519;
                                if (null == qtables) throw new Error("JPEGQTables tag is missing");
                                for (i = 0; i < qtables.length; i++) for (out[ooff++] = 255, out[ooff++] = 219, 
                                out[ooff++] = 0, out[ooff++] = 67, out[ooff++] = i, j = 0; j < 64; j++) out[ooff++] = data[off + qtables[i] + j];
                                for (k = 0; k < 2; k++) {
                                    var htables = img[0 == k ? "t520" : "t521"];
                                    if (null == htables) throw new Error((0 == k ? "JPEGDCTables" : "JPEGACTables") + " tag is missing");
                                    for (i = 0; i < htables.length; i++) {
                                        out[ooff++] = 255, out[ooff++] = 196;
                                        var nc = 19;
                                        for (j = 0; j < 16; j++) nc += data[off + htables[i] + j];
                                        for (out[ooff++] = nc >>> 8, out[ooff++] = 255 & nc, out[ooff++] = i | k << 4, j = 0; j < 16; j++) out[ooff++] = data[off + htables[i] + j];
                                        for (j = 0; j < nc; j++) out[ooff++] = data[off + htables[i] + 16 + j];
                                    }
                                }
                                if (out[ooff++] = 255, out[ooff++] = 192, out[ooff++] = 0, out[ooff++] = 8 + 3 * spp, 
                                out[ooff++] = 8, out[ooff++] = img.height >>> 8 & 255, out[ooff++] = 255 & img.height, 
                                out[ooff++] = img.width >>> 8 & 255, out[ooff++] = 255 & img.width, out[ooff++] = spp, 
                                1 == spp) out[ooff++] = 1, out[ooff++] = 17, out[ooff++] = 0; else for (i = 0; i < 3; i++) out[ooff++] = i + 1, 
                                out[ooff++] = 0 != i ? 17 : (15 & ssx) << 4 | 15 & ssy, out[ooff++] = i;
                                null != jpgresint && 0 != jpgresint[0] && (out[ooff++] = 255, out[ooff++] = 221, 
                                out[ooff++] = 0, out[ooff++] = 4, out[ooff++] = jpgresint[0] >>> 8 & 255, out[ooff++] = 255 & jpgresint[0]), 
                                tables = new Uint8Array(out);
                            }
                            var sofpos = -1;
                            for (i = 0; i < tables.length - 1; ) {
                                if (255 == tables[i] && 192 == tables[i + 1]) {
                                    sofpos = i;
                                    break;
                                }
                                i++;
                            }
                            if (-1 == sofpos) {
                                var tmptab = new Uint8Array(tables.length + 10 + 3 * spp);
                                tmptab.set(tables);
                                var tmpoff = tables.length;
                                if (sofpos = tables.length, (tables = tmptab)[tmpoff++] = 255, tables[tmpoff++] = 192, 
                                tables[tmpoff++] = 0, tables[tmpoff++] = 8 + 3 * spp, tables[tmpoff++] = 8, tables[tmpoff++] = img.height >>> 8 & 255, 
                                tables[tmpoff++] = 255 & img.height, tables[tmpoff++] = img.width >>> 8 & 255, tables[tmpoff++] = 255 & img.width, 
                                tables[tmpoff++] = spp, 1 == spp) tables[tmpoff++] = 1, tables[tmpoff++] = 17, tables[tmpoff++] = 0; else for (i = 0; i < 3; i++) tables[tmpoff++] = i + 1, 
                                tables[tmpoff++] = 0 != i ? 17 : (15 & ssx) << 4 | 15 & ssy, tables[tmpoff++] = i;
                            }
                            if (255 == data[soff] && 218 == data[soff + 1]) {
                                var soslen = data[soff + 2] << 8 | data[soff + 3];
                                for ((sosMarker = new Uint8Array(soslen + 2))[0] = data[soff], sosMarker[1] = data[soff + 1], 
                                sosMarker[2] = data[soff + 2], sosMarker[3] = data[soff + 3], i = 0; i < soslen - 2; i++) sosMarker[i + 4] = data[soff + i + 4];
                            } else {
                                var sosoff = 0;
                                if ((sosMarker = new Uint8Array(8 + 2 * spp))[sosoff++] = 255, sosMarker[sosoff++] = 218, 
                                sosMarker[sosoff++] = 0, sosMarker[sosoff++] = 6 + 2 * spp, sosMarker[sosoff++] = spp, 
                                1 == spp) sosMarker[sosoff++] = 1, sosMarker[sosoff++] = 0; else for (i = 0; i < 3; i++) sosMarker[sosoff++] = i + 1, 
                                sosMarker[sosoff++] = i << 4 | i;
                                sosMarker[sosoff++] = 0, sosMarker[sosoff++] = 63, sosMarker[sosoff++] = 0;
                            }
                            return {
                                jpegOffset: off,
                                tables,
                                sosMarker,
                                sofPosition: sofpos
                            };
                        }, UTIF.decode._decodeOldJPEG = function(img, data, off, len, tgt, toff) {
                            var dlen, tlen, buff, jpegData = UTIF.decode._decodeOldJPEGInit(img, data, off, len);
                            if (null != jpegData.jpegOffset) for (dlen = off + len - jpegData.jpegOffset, buff = new Uint8Array(dlen), 
                            i = 0; i < dlen; i++) buff[i] = data[jpegData.jpegOffset + i]; else {
                                for (tlen = jpegData.tables.length, (buff = new Uint8Array(tlen + jpegData.sosMarker.length + len + 2)).set(jpegData.tables), 
                                buff[jpegData.sofPosition + 5] = img.height >>> 8 & 255, buff[jpegData.sofPosition + 6] = 255 & img.height, 
                                buff[jpegData.sofPosition + 7] = img.width >>> 8 & 255, buff[jpegData.sofPosition + 8] = 255 & img.width, 
                                255 == data[off] && data[off + 1] == SOS || (buff.set(jpegData.sosMarker, bufoff), 
                                bufoff += sosMarker.length), i = 0; i < len; i++) buff[bufoff++] = data[off + i];
                                buff[bufoff++] = 255, buff[bufoff++] = EOI;
                            }
                            var parser = new UTIF.JpegDecoder;
                            parser.parse(buff);
                            for (var decoded = parser.getData(parser.width, parser.height), i = 0; i < decoded.length; i++) tgt[toff + i] = decoded[i];
                            6 == img.t262[0] && (img.t262[0] = 2);
                        }, UTIF.decode._decodePackBits = function(data, off, len, tgt, toff) {
                            for (var sa = new Int8Array(data.buffer), ta = new Int8Array(tgt.buffer), lim = off + len; off < lim; ) {
                                var n = sa[off];
                                if (off++, n >= 0 && n < 128) for (var i = 0; i < n + 1; i++) ta[toff] = sa[off], 
                                toff++, off++;
                                if (n >= -127 && n < 0) {
                                    for (i = 0; i < 1 - n; i++) ta[toff] = sa[off], toff++;
                                    off++;
                                }
                            }
                        }, UTIF.decode._decodeThunder = function(data, off, len, tgt, toff) {
                            for (var d2 = [ 0, 1, 0, -1 ], d3 = [ 0, 1, 2, 3, 0, -3, -2, -1 ], lim = off + len, qoff = 2 * toff, px = 0; off < lim; ) {
                                var b = data[off], msk = b >>> 6, n = 63 & b;
                                if (off++, 3 == msk && (px = 15 & n, tgt[qoff >>> 1] |= px << 4 * (1 - qoff & 1), 
                                qoff++), 0 == msk) for (var i = 0; i < n; i++) tgt[qoff >>> 1] |= px << 4 * (1 - qoff & 1), 
                                qoff++;
                                if (2 == msk) for (i = 0; i < 2; i++) 4 != (d = n >>> 3 * (1 - i) & 7) && (px += d3[d], 
                                tgt[qoff >>> 1] |= px << 4 * (1 - qoff & 1), qoff++);
                                if (1 == msk) for (i = 0; i < 3; i++) {
                                    var d;
                                    2 != (d = n >>> 2 * (2 - i) & 3) && (px += d2[d], tgt[qoff >>> 1] |= px << 4 * (1 - qoff & 1), 
                                    qoff++);
                                }
                            }
                        }, UTIF.decode._dmap = {
                            1: 0,
                            "011": 1,
                            "000011": 2,
                            "0000011": 3,
                            "010": -1,
                            "000010": -2,
                            "0000010": -3
                        }, UTIF.decode._lens = function() {
                            var addKeys = function(lens, arr, i0, inc) {
                                for (var i = 0; i < arr.length; i++) lens[arr[i]] = i0 + i * inc;
                            }, termW = "00110101,000111,0111,1000,1011,1100,1110,1111,10011,10100,00111,01000,001000,000011,110100,110101,101010,101011,0100111,0001100,0001000,0010111,0000011,0000100,0101000,0101011,0010011,0100100,0011000,00000010,00000011,00011010,00011011,00010010,00010011,00010100,00010101,00010110,00010111,00101000,00101001,00101010,00101011,00101100,00101101,00000100,00000101,00001010,00001011,01010010,01010011,01010100,01010101,00100100,00100101,01011000,01011001,01011010,01011011,01001010,01001011,00110010,00110011,00110100", termB = "0000110111,010,11,10,011,0011,0010,00011,000101,000100,0000100,0000101,0000111,00000100,00000111,000011000,0000010111,0000011000,0000001000,00001100111,00001101000,00001101100,00000110111,00000101000,00000010111,00000011000,000011001010,000011001011,000011001100,000011001101,000001101000,000001101001,000001101010,000001101011,000011010010,000011010011,000011010100,000011010101,000011010110,000011010111,000001101100,000001101101,000011011010,000011011011,000001010100,000001010101,000001010110,000001010111,000001100100,000001100101,000001010010,000001010011,000000100100,000000110111,000000111000,000000100111,000000101000,000001011000,000001011001,000000101011,000000101100,000001011010,000001100110,000001100111", makeW = "11011,10010,010111,0110111,00110110,00110111,01100100,01100101,01101000,01100111,011001100,011001101,011010010,011010011,011010100,011010101,011010110,011010111,011011000,011011001,011011010,011011011,010011000,010011001,010011010,011000,010011011", makeB = "0000001111,000011001000,000011001001,000001011011,000000110011,000000110100,000000110101,0000001101100,0000001101101,0000001001010,0000001001011,0000001001100,0000001001101,0000001110010,0000001110011,0000001110100,0000001110101,0000001110110,0000001110111,0000001010010,0000001010011,0000001010100,0000001010101,0000001011010,0000001011011,0000001100100,0000001100101", makeA = "00000001000,00000001100,00000001101,000000010010,000000010011,000000010100,000000010101,000000010110,000000010111,000000011100,000000011101,000000011110,000000011111";
                            termW = termW.split(","), termB = termB.split(","), makeW = makeW.split(","), makeB = makeB.split(","), 
                            makeA = makeA.split(",");
                            var lensW = {}, lensB = {};
                            return addKeys(lensW, termW, 0, 1), addKeys(lensW, makeW, 64, 64), addKeys(lensW, makeA, 1792, 64), 
                            addKeys(lensB, termB, 0, 1), addKeys(lensB, makeB, 64, 64), addKeys(lensB, makeA, 1792, 64), 
                            [ lensW, lensB ];
                        }(), UTIF.decode._decodeG4 = function(data, off, slen, tgt, toff, w, fo) {
                            for (var U = UTIF.decode, boff = off << 3, len = 0, wrd = "", line = [], pline = [], i = 0; i < w; i++) pline.push(0);
                            pline = U._makeDiff(pline);
                            for (var a0 = 0, a1 = 0, b1 = 0, b2 = 0, clr = 0, y = 0, mode = "", toRead = 0, bipl = 8 * Math.ceil(w / 8); boff >>> 3 < off + slen; ) {
                                b1 = U._findDiff(pline, a0 + (0 == a0 ? 0 : 1), 1 - clr), b2 = U._findDiff(pline, b1, clr);
                                var bit = 0;
                                if (1 == fo && (bit = data[boff >>> 3] >>> 7 - (7 & boff) & 1), 2 == fo && (bit = data[boff >>> 3] >>> (7 & boff) & 1), 
                                boff++, wrd += bit, "H" == mode) {
                                    if (null != U._lens[clr][wrd]) {
                                        var dl = U._lens[clr][wrd];
                                        wrd = "", len += dl, dl < 64 && (U._addNtimes(line, len, clr), a0 += len, clr = 1 - clr, 
                                        len = 0, 0 == --toRead && (mode = ""));
                                    }
                                } else "0001" == wrd && (wrd = "", U._addNtimes(line, b2 - a0, clr), a0 = b2), "001" == wrd && (wrd = "", 
                                mode = "H", toRead = 2), null != U._dmap[wrd] && (a1 = b1 + U._dmap[wrd], U._addNtimes(line, a1 - a0, clr), 
                                a0 = a1, wrd = "", clr = 1 - clr);
                                line.length == w && "" == mode && (U._writeBits(line, tgt, 8 * toff + y * bipl), 
                                clr = 0, y++, a0 = 0, pline = U._makeDiff(line), line = []);
                            }
                        }, UTIF.decode._findDiff = function(line, x, clr) {
                            for (var i = 0; i < line.length; i += 2) if (line[i] >= x && line[i + 1] == clr) return line[i];
                        }, UTIF.decode._makeDiff = function(line) {
                            var out = [];
                            1 == line[0] && out.push(0, 1);
                            for (var i = 1; i < line.length; i++) line[i - 1] != line[i] && out.push(i, line[i]);
                            return out.push(line.length, 0, line.length, 1), out;
                        }, UTIF.decode._decodeG3 = function(data, off, slen, tgt, toff, w, fo) {
                            for (var U = UTIF.decode, boff = off << 3, len = 0, wrd = "", line = [], pline = [], i = 0; i < w; i++) line.push(0);
                            for (var a0 = 0, a1 = 0, b1 = 0, b2 = 0, clr = 0, y = -1, mode = "", toRead = 0, is1D = !1, bipl = 8 * Math.ceil(w / 8); boff >>> 3 < off + slen; ) {
                                b1 = U._findDiff(pline, a0 + (0 == a0 ? 0 : 1), 1 - clr), b2 = U._findDiff(pline, b1, clr);
                                var bit = 0;
                                if (1 == fo && (bit = data[boff >>> 3] >>> 7 - (7 & boff) & 1), 2 == fo && (bit = data[boff >>> 3] >>> (7 & boff) & 1), 
                                boff++, wrd += bit, is1D) {
                                    if (null != U._lens[clr][wrd]) {
                                        var dl = U._lens[clr][wrd];
                                        wrd = "", len += dl, dl < 64 && (U._addNtimes(line, len, clr), clr = 1 - clr, len = 0);
                                    }
                                } else "H" == mode ? null != U._lens[clr][wrd] && (dl = U._lens[clr][wrd], wrd = "", 
                                len += dl, dl < 64 && (U._addNtimes(line, len, clr), a0 += len, clr = 1 - clr, len = 0, 
                                0 == --toRead && (mode = ""))) : ("0001" == wrd && (wrd = "", U._addNtimes(line, b2 - a0, clr), 
                                a0 = b2), "001" == wrd && (wrd = "", mode = "H", toRead = 2), null != U._dmap[wrd] && (a1 = b1 + U._dmap[wrd], 
                                U._addNtimes(line, a1 - a0, clr), a0 = a1, wrd = "", clr = 1 - clr));
                                wrd.endsWith("000000000001") && (y >= 0 && U._writeBits(line, tgt, 8 * toff + y * bipl), 
                                1 == fo && (is1D = 1 == (data[boff >>> 3] >>> 7 - (7 & boff) & 1)), 2 == fo && (is1D = 1 == (data[boff >>> 3] >>> (7 & boff) & 1)), 
                                boff++, null == U._decodeG3.allow2D && (U._decodeG3.allow2D = is1D), U._decodeG3.allow2D || (is1D = !0, 
                                boff--), wrd = "", clr = 0, y++, a0 = 0, pline = U._makeDiff(line), line = []);
                            }
                            line.length == w && U._writeBits(line, tgt, 8 * toff + y * bipl);
                        }, UTIF.decode._addNtimes = function(arr, n, val) {
                            for (var i = 0; i < n; i++) arr.push(val);
                        }, UTIF.decode._writeBits = function(bits, tgt, boff) {
                            for (var i = 0; i < bits.length; i++) tgt[boff + i >>> 3] |= bits[i] << 7 - (boff + i & 7);
                        }, UTIF.decode._decodeLZW = function(data, off, tgt, toff) {
                            if (null == UTIF.decode._lzwTab) {
                                for (var tb = new Uint32Array(0xffff), tn = new Uint16Array(0xffff), chr = new Uint8Array(2e6), i = 0; i < 256; i++) chr[i << 2] = i, 
                                tb[i] = i << 2, tn[i] = 1;
                                UTIF.decode._lzwTab = [ tb, tn, chr ];
                            }
                            for (var copy = UTIF.decode._copyData, tab = UTIF.decode._lzwTab[0], tln = UTIF.decode._lzwTab[1], totl = (chr = UTIF.decode._lzwTab[2], 
                            258), chrl = 1032, bits = 9, boff = off << 3, Code = 0, OldCode = 0; Code = (data[boff >>> 3] << 16 | data[boff + 8 >>> 3] << 8 | data[boff + 16 >>> 3]) >> 24 - (7 & boff) - bits & (1 << bits) - 1, 
                            boff += bits, 257 != Code; ) {
                                if (256 == Code) {
                                    if (bits = 9, totl = 258, chrl = 1032, Code = (data[boff >>> 3] << 16 | data[boff + 8 >>> 3] << 8 | data[boff + 16 >>> 3]) >> 24 - (7 & boff) - bits & (1 << bits) - 1, 
                                    boff += bits, 257 == Code) break;
                                    tgt[toff] = Code, toff++;
                                } else if (Code < totl) {
                                    var cd = tab[Code], cl = tln[Code];
                                    copy(chr, cd, tgt, toff, cl), toff += cl, OldCode >= totl ? (tab[totl] = chrl, chr[tab[totl]] = cd[0], 
                                    tln[totl] = 1, chrl = chrl + 1 + 3 & -4, totl++) : (tab[totl] = chrl, copy(chr, tab[OldCode], chr, chrl, nil = tln[OldCode]), 
                                    chr[chrl + nil] = chr[cd], nil++, tln[totl] = nil, totl++, chrl = chrl + nil + 3 & -4), 
                                    totl + 1 == 1 << bits && bits++;
                                } else {
                                    var nil;
                                    OldCode >= totl ? (tab[totl] = chrl, tln[totl] = 0, totl++) : (tab[totl] = chrl, 
                                    copy(chr, tab[OldCode], chr, chrl, nil = tln[OldCode]), chr[chrl + nil] = chr[chrl], 
                                    nil++, tln[totl] = nil, totl++, copy(chr, chrl, tgt, toff, nil), toff += nil, chrl = chrl + nil + 3 & -4), 
                                    totl + 1 == 1 << bits && bits++;
                                }
                                OldCode = Code;
                            }
                        }, UTIF.decode._copyData = function(s, so, t, to, l) {
                            for (var i = 0; i < l; i += 4) t[to + i] = s[so + i], t[to + i + 1] = s[so + i + 1], 
                            t[to + i + 2] = s[so + i + 2], t[to + i + 3] = s[so + i + 3];
                        }, UTIF.tags = {
                            254: "NewSubfileType",
                            255: "SubfileType",
                            256: "ImageWidth",
                            257: "ImageLength",
                            258: "BitsPerSample",
                            259: "Compression",
                            262: "PhotometricInterpretation",
                            266: "FillOrder",
                            269: "DocumentName",
                            270: "ImageDescription",
                            271: "Make",
                            272: "Model",
                            273: "StripOffset",
                            274: "Orientation",
                            277: "SamplesPerPixel",
                            278: "RowsPerStrip",
                            279: "StripByteCounts",
                            280: "MinSampleValue",
                            281: "MaxSampleValue",
                            282: "XResolution",
                            283: "YResolution",
                            284: "PlanarConfiguration",
                            285: "PageName",
                            286: "XPosition",
                            287: "YPosition",
                            292: "T4Options",
                            296: "ResolutionUnit",
                            297: "PageNumber",
                            305: "Software",
                            306: "DateTime",
                            315: "Artist",
                            316: "HostComputer",
                            317: "Predictor",
                            318: "WhitePoint",
                            319: "PrimaryChromaticities",
                            320: "ColorMap",
                            321: "HalftoneHints",
                            322: "TileWidth",
                            323: "TileLength",
                            324: "TileOffset",
                            325: "TileByteCounts",
                            330: "SubIFDs",
                            336: "DotRange",
                            338: "ExtraSample",
                            339: "SampleFormat",
                            347: "JPEGTables",
                            512: "JPEGProc",
                            513: "JPEGInterchangeFormat",
                            514: "JPEGInterchangeFormatLength",
                            519: "JPEGQTables",
                            520: "JPEGDCTables",
                            521: "JPEGACTables",
                            529: "YCbCrCoefficients",
                            530: "YCbCrSubSampling",
                            531: "YCbCrPositioning",
                            532: "ReferenceBlackWhite",
                            700: "XMP",
                            33421: "CFARepeatPatternDim",
                            33422: "CFAPattern",
                            33432: "Copyright",
                            33434: "ExposureTime",
                            33437: "FNumber",
                            33723: "IPTC/NAA",
                            34377: "Photoshop",
                            34665: "ExifIFD",
                            34675: "ICC Profile",
                            34850: "ExposureProgram",
                            34853: "GPSInfo",
                            34855: "ISOSpeedRatings",
                            34858: "TimeZoneOffset",
                            34859: "SelfTimeMode",
                            36867: "DateTimeOriginal",
                            36868: "DateTimeDigitized",
                            37377: "ShutterSpeedValue",
                            37378: "ApertureValue",
                            37380: "ExposureBiasValue",
                            37383: "MeteringMode",
                            37385: "Flash",
                            37386: "FocalLength",
                            37390: "FocalPlaneXResolution",
                            37391: "FocalPlaneYResolution",
                            37392: "FocalPlaneResolutionUnit",
                            37393: "ImageNumber",
                            37398: "TIFF/EPStandardID",
                            37399: "SensingMethod",
                            37500: "MakerNote",
                            37510: "UserComment",
                            37724: "ImageSourceData",
                            40092: "XPComment",
                            40094: "XPKeywords",
                            40961: "ColorSpace",
                            40962: "PixelXDimension",
                            40963: "PixelXDimension",
                            41486: "FocalPlaneXResolution",
                            41487: "FocalPlaneYResolution",
                            41488: "FocalPlaneResolutionUnit",
                            41985: "CustomRendered",
                            41986: "ExposureMode",
                            41987: "WhiteBalance",
                            41990: "SceneCaptureType",
                            50706: "DNGVersion",
                            50707: "DNGBackwardVersion",
                            50708: "UniqueCameraModel",
                            50709: "LocalizedCameraModel",
                            50710: "CFAPlaneColor",
                            50711: "CFALayout",
                            50712: "LinearizationTable",
                            50713: "BlackLevelRepeatDim",
                            50714: "BlackLevel",
                            50716: "BlackLevelDeltaV",
                            50717: "WhiteLevel",
                            50718: "DefaultScale",
                            50719: "DefaultCropOrigin",
                            50720: "DefaultCropSize",
                            50733: "BayerGreenSplit",
                            50738: "AntiAliasStrength",
                            50721: "ColorMatrix1",
                            50722: "ColorMatrix2",
                            50723: "CameraCalibration1",
                            50724: "CameraCalibration2",
                            50727: "AnalogBalance",
                            50728: "AsShotNeutral",
                            50730: "BaselineExposure",
                            50731: "BaselineNoise",
                            50732: "BaselineSharpness",
                            50734: "LinearResponseLimit",
                            50735: "CameraSerialNumber",
                            50736: "LensInfo",
                            50739: "ShadowScale",
                            50740: "DNGPrivateData",
                            50741: "MakerNoteSafety",
                            50778: "CalibrationIlluminant1",
                            50779: "CalibrationIlluminant2",
                            50780: "BestQualityScale",
                            50781: "RawDataUniqueID",
                            50827: "OriginalRawFileName",
                            50829: "ActiveArea",
                            50830: "MaskedAreas",
                            50931: "CameraCalibrationSignature",
                            50932: "ProfileCalibrationSignature",
                            50935: "NoiseReductionApplied",
                            50936: "ProfileName",
                            50937: "ProfileHueSatMapDims",
                            50938: "ProfileHueSatMapData1",
                            50939: "ProfileHueSatMapData2",
                            50940: "ProfileToneCurve",
                            50941: "ProfileEmbedPolicy",
                            50942: "ProfileCopyright",
                            50964: "ForwardMatrix1",
                            50965: "ForwardMatrix2",
                            50966: "PreviewApplicationName",
                            50967: "PreviewApplicationVersion",
                            50969: "PreviewSettingsDigest",
                            50970: "PreviewColorSpace",
                            50971: "PreviewDateTime",
                            50972: "RawImageDigest",
                            51008: "OpcodeList1",
                            51009: "OpcodeList2",
                            51022: "OpcodeList3",
                            51041: "NoiseProfile",
                            51089: "OriginalDefaultFinalSize",
                            51090: "OriginalBestQualityFinalSize",
                            51091: "OriginalDefaultCropSize",
                            51125: "DefaultUserCrop"
                        }, UTIF.ttypes = {
                            256: 3,
                            257: 3,
                            258: 3,
                            259: 3,
                            262: 3,
                            273: 4,
                            274: 3,
                            277: 3,
                            278: 4,
                            279: 4,
                            282: 5,
                            283: 5,
                            284: 3,
                            286: 5,
                            287: 5,
                            296: 3,
                            305: 2,
                            306: 2,
                            338: 3,
                            513: 4,
                            514: 4,
                            34665: 4
                        }, UTIF._readIFD = function(bin, data, offset, ifds) {
                            var cnt = bin.readUshort(data, offset);
                            offset += 2;
                            var ifd = {};
                            ifds.push(ifd);
                            for (var i = 0; i < cnt; i++) {
                                var tag = bin.readUshort(data, offset);
                                offset += 2;
                                var type = bin.readUshort(data, offset);
                                offset += 2;
                                var num = bin.readUint(data, offset);
                                offset += 4;
                                var voff = bin.readUint(data, offset);
                                offset += 4;
                                var arr = [];
                                if (ifd["t" + tag] = arr, 1 == type || 7 == type) for (var j = 0; j < num; j++) arr.push(data[(num < 5 ? offset - 4 : voff) + j]);
                                if (2 == type && arr.push(bin.readASCII(data, num < 5 ? offset - 4 : voff, num - 1)), 
                                3 == type) for (j = 0; j < num; j++) arr.push(bin.readUshort(data, (num < 3 ? offset - 4 : voff) + 2 * j));
                                if (4 == type) for (j = 0; j < num; j++) arr.push(bin.readUint(data, (num < 2 ? offset - 4 : voff) + 4 * j));
                                if (5 == type) for (j = 0; j < num; j++) arr.push(bin.readUint(data, voff + 8 * j) / bin.readUint(data, voff + 8 * j + 4));
                                if (8 == type) for (j = 0; j < num; j++) arr.push(bin.readShort(data, (num < 3 ? offset - 4 : voff) + 2 * j));
                                if (9 == type) for (j = 0; j < num; j++) arr.push(bin.readInt(data, (num < 2 ? offset - 4 : voff) + 4 * j));
                                if (10 == type) for (j = 0; j < num; j++) arr.push(bin.readInt(data, voff + 8 * j) / bin.readInt(data, voff + 8 * j + 4));
                                if (11 == type) for (j = 0; j < num; j++) arr.push(bin.readFloat(data, voff + 4 * j));
                                if (12 == type) for (j = 0; j < num; j++) arr.push(bin.readDouble(data, voff + 8 * j));
                                if (0 != num && 0 == arr.length && log("unknown TIFF tag type: ", type, "num:", num), 
                                330 == tag) for (j = 0; j < num; j++) UTIF._readIFD(bin, data, arr[j], ifds);
                            }
                            return offset;
                        }, UTIF._writeIFD = function(bin, data, offset, ifd) {
                            var keys = Object.keys(ifd);
                            bin.writeUshort(data, offset, keys.length);
                            for (var eoff = (offset += 2) + 12 * keys.length + 4, ki = 0; ki < keys.length; ki++) {
                                var key = keys[ki], tag = parseInt(key.slice(1)), type = UTIF.ttypes[tag];
                                if (null == type) throw new Error("unknown type of tag: " + tag);
                                var val = ifd[key];
                                2 == type && (val = val[0] + "\0");
                                var num = val.length;
                                bin.writeUshort(data, offset, tag), offset += 2, bin.writeUshort(data, offset, type), 
                                offset += 2, bin.writeUint(data, offset, num);
                                var dlen = [ -1, 1, 1, 2, 4, 8, 0, 0, 0, 0, 0, 0, 8 ][type] * num, toff = offset += 4;
                                if (dlen > 4 && (bin.writeUint(data, offset, eoff), toff = eoff), 2 == type && bin.writeASCII(data, toff, val), 
                                3 == type) for (var i = 0; i < num; i++) bin.writeUshort(data, toff + 2 * i, val[i]);
                                if (4 == type) for (i = 0; i < num; i++) bin.writeUint(data, toff + 4 * i, val[i]);
                                if (5 == type) for (i = 0; i < num; i++) bin.writeUint(data, toff + 8 * i, Math.round(10000 * val[i])), 
                                bin.writeUint(data, toff + 8 * i + 4, 10000);
                                if (12 == type) for (i = 0; i < num; i++) bin.writeDouble(data, toff + 8 * i, val[i]);
                                dlen > 4 && (eoff += dlen += 1 & dlen), offset += 4;
                            }
                            return [ offset, eoff ];
                        }, UTIF.toRGBA8 = function(out) {
                            var w = out.width, h = out.height, area = w * h, qarea = 4 * area, data = out.data, img = new Uint8Array(4 * area), intp = out.t262[0], bps = out.t258 ? Math.min(32, out.t258[0]) : 1, isLE = out.isLE ? 1 : 0;
                            if (0 == intp) for (var bpl = Math.ceil(bps * w / 8), y = 0; y < h; y++) {
                                var off = y * bpl, io = y * w;
                                if (1 == bps) for (var i = 0; i < w; i++) {
                                    var qi = io + i << 2, px = data[off + (i >> 3)] >> 7 - (7 & i) & 1;
                                    img[qi] = img[qi + 1] = img[qi + 2] = 255 * (1 - px), img[qi + 3] = 255;
                                }
                                if (4 == bps) for (i = 0; i < w; i++) qi = io + i << 2, px = data[off + (i >> 1)] >> 4 - 4 * (1 & i) & 15, 
                                img[qi] = img[qi + 1] = img[qi + 2] = 17 * (15 - px), img[qi + 3] = 255;
                                if (8 == bps) for (i = 0; i < w; i++) qi = io + i << 2, px = data[off + i], img[qi] = img[qi + 1] = img[qi + 2] = 255 - px, 
                                img[qi + 3] = 255;
                            } else if (1 == intp) for (bpl = Math.ceil(bps * w / 8), y = 0; y < h; y++) {
                                if (off = y * bpl, io = y * w, 1 == bps) for (i = 0; i < w; i++) qi = io + i << 2, 
                                px = data[off + (i >> 3)] >> 7 - (7 & i) & 1, img[qi] = img[qi + 1] = img[qi + 2] = 255 * px, 
                                img[qi + 3] = 255;
                                if (2 == bps) for (i = 0; i < w; i++) qi = io + i << 2, px = data[off + (i >> 2)] >> 6 - 2 * (3 & i) & 3, 
                                img[qi] = img[qi + 1] = img[qi + 2] = 85 * px, img[qi + 3] = 255;
                                if (8 == bps) for (i = 0; i < w; i++) qi = io + i << 2, px = data[off + i], img[qi] = img[qi + 1] = img[qi + 2] = px, 
                                img[qi + 3] = 255;
                                if (16 == bps) for (i = 0; i < w; i++) qi = io + i << 2, px = data[off + (2 * i + isLE)], 
                                img[qi] = img[qi + 1] = img[qi + 2] = Math.min(255, px), img[qi + 3] = 255;
                            } else if (2 == intp) if (8 == bps) if (out.t338) if (out.t338[0] > 0) for (i = 0; i < qarea; i++) img[i] = data[i]; else for (i = 0; i < qarea; i += 4) img[i] = data[i], 
                            img[i + 1] = data[i + 1], img[i + 2] = data[i + 2], img[i + 3] = 255; else {
                                if (4 == (smpls = out.t258 ? out.t258.length : 3)) for (i = 0; i < qarea; i++) img[i] = data[i];
                                if (3 == smpls) for (i = 0; i < area; i++) {
                                    var ti = 3 * i;
                                    img[qi = i << 2] = data[ti], img[qi + 1] = data[ti + 1], img[qi + 2] = data[ti + 2], 
                                    img[qi + 3] = 255;
                                }
                            } else for (i = 0; i < area; i++) ti = 6 * i, img[qi = i << 2] = data[ti], img[qi + 1] = data[ti + 2], 
                            img[qi + 2] = data[ti + 4], img[qi + 3] = 255; else if (3 == intp) {
                                var map = out.t320;
                                for (i = 0; i < area; i++) {
                                    qi = i << 2;
                                    var mi = data[i];
                                    img[qi] = map[mi] >> 8, img[qi + 1] = map[256 + mi] >> 8, img[qi + 2] = map[512 + mi] >> 8, 
                                    img[qi + 3] = 255;
                                }
                            } else if (5 == intp) {
                                var smpls, gotAlpha = (smpls = out.t258 ? out.t258.length : 4) > 4 ? 1 : 0;
                                for (i = 0; i < area; i++) {
                                    qi = i << 2;
                                    var si = i * smpls, C = 255 - data[si], M = 255 - data[si + 1], Y = 255 - data[si + 2], K = (255 - data[si + 3]) * (1 / 255);
                                    img[qi] = ~~(C * K + 0.5), img[qi + 1] = ~~(M * K + 0.5), img[qi + 2] = ~~(Y * K + 0.5), 
                                    img[qi + 3] = 255 * (1 - gotAlpha) + data[si + 4] * gotAlpha;
                                }
                            } else log("Unknown Photometric interpretation: " + intp);
                            return img;
                        }, UTIF.replaceIMG = function() {
                            for (var imgs = document.getElementsByTagName("img"), i = 0; i < imgs.length; i++) {
                                var img = imgs[i], src = img.getAttribute("src");
                                if (null != src) {
                                    var suff = src.split(".").pop().toLowerCase();
                                    if ("tif" == suff || "tiff" == suff) {
                                        var xhr = new XMLHttpRequest;
                                        UTIF._xhrs.push(xhr), UTIF._imgs.push(img), xhr.open("GET", src), xhr.responseType = "arraybuffer", 
                                        xhr.onload = UTIF._imgLoaded, xhr.send();
                                    }
                                }
                            }
                        }, UTIF._xhrs = [], UTIF._imgs = [], UTIF._imgLoaded = function(e) {
                            var buff = e.target.response, ifds = UTIF.decode(buff), page = ifds[0];
                            UTIF.decodeImages(buff, ifds);
                            var rgba = UTIF.toRGBA8(page), w = page.width, h = page.height, ind = UTIF._xhrs.indexOf(e.target), img = UTIF._imgs[ind];
                            UTIF._xhrs.splice(ind, 1), UTIF._imgs.splice(ind, 1);
                            var cnv = document.createElement("canvas");
                            cnv.width = w, cnv.height = h;
                            for (var ctx = cnv.getContext("2d"), imgd = ctx.createImageData(w, h), i = 0; i < rgba.length; i++) imgd.data[i] = rgba[i];
                            ctx.putImageData(imgd, 0, 0);
                            var attr = [ "style", "class", "id" ];
                            for (i = 0; i < attr.length; i++) cnv.setAttribute(attr[i], img.getAttribute(attr[i]));
                            img.parentNode.replaceChild(cnv, img);
                        }, UTIF._binBE = {
                            nextZero: function(data, o) {
                                for (;0 != data[o]; ) o++;
                                return o;
                            },
                            readUshort: function(buff, p) {
                                return buff[p] << 8 | buff[p + 1];
                            },
                            readShort: function(buff, p) {
                                var a = UTIF._binBE.ui8;
                                return a[0] = buff[p + 1], a[1] = buff[p + 0], UTIF._binBE.i16[0];
                            },
                            readInt: function(buff, p) {
                                var a = UTIF._binBE.ui8;
                                return a[0] = buff[p + 3], a[1] = buff[p + 2], a[2] = buff[p + 1], a[3] = buff[p + 0], 
                                UTIF._binBE.i32[0];
                            },
                            readUint: function(buff, p) {
                                var a = UTIF._binBE.ui8;
                                return a[0] = buff[p + 3], a[1] = buff[p + 2], a[2] = buff[p + 1], a[3] = buff[p + 0], 
                                UTIF._binBE.ui32[0];
                            },
                            readASCII: function(buff, p, l) {
                                for (var s = "", i = 0; i < l; i++) s += String.fromCharCode(buff[p + i]);
                                return s;
                            },
                            readFloat: function(buff, p) {
                                for (var a = UTIF._binBE.ui8, i = 0; i < 4; i++) a[i] = buff[p + 3 - i];
                                return UTIF._binBE.fl32[0];
                            },
                            readDouble: function(buff, p) {
                                for (var a = UTIF._binBE.ui8, i = 0; i < 8; i++) a[i] = buff[p + 7 - i];
                                return UTIF._binBE.fl64[0];
                            },
                            writeUshort: function(buff, p, n) {
                                buff[p] = n >> 8 & 255, buff[p + 1] = 255 & n;
                            },
                            writeUint: function(buff, p, n) {
                                buff[p] = n >> 24 & 255, buff[p + 1] = n >> 16 & 255, buff[p + 2] = n >> 8 & 255, 
                                buff[p + 3] = n >> 0 & 255;
                            },
                            writeASCII: function(buff, p, s) {
                                for (var i = 0; i < s.length; i++) buff[p + i] = s.charCodeAt(i);
                            },
                            writeDouble: function(buff, p, n) {
                                UTIF._binBE.fl64[0] = n;
                                for (var i = 0; i < 8; i++) buff[p + i] = UTIF._binBE.ui8[7 - i];
                            }
                        }, UTIF._binBE.ui8 = new Uint8Array(8), UTIF._binBE.i16 = new Int16Array(UTIF._binBE.ui8.buffer), 
                        UTIF._binBE.i32 = new Int32Array(UTIF._binBE.ui8.buffer), UTIF._binBE.ui32 = new Uint32Array(UTIF._binBE.ui8.buffer), 
                        UTIF._binBE.fl32 = new Float32Array(UTIF._binBE.ui8.buffer), UTIF._binBE.fl64 = new Float64Array(UTIF._binBE.ui8.buffer), 
                        UTIF._binLE = {
                            nextZero: UTIF._binBE.nextZero,
                            readUshort: function(buff, p) {
                                return buff[p + 1] << 8 | buff[p];
                            },
                            readShort: function(buff, p) {
                                var a = UTIF._binBE.ui8;
                                return a[0] = buff[p + 0], a[1] = buff[p + 1], UTIF._binBE.i16[0];
                            },
                            readInt: function(buff, p) {
                                var a = UTIF._binBE.ui8;
                                return a[0] = buff[p + 0], a[1] = buff[p + 1], a[2] = buff[p + 2], a[3] = buff[p + 3], 
                                UTIF._binBE.i32[0];
                            },
                            readUint: function(buff, p) {
                                var a = UTIF._binBE.ui8;
                                return a[0] = buff[p + 0], a[1] = buff[p + 1], a[2] = buff[p + 2], a[3] = buff[p + 3], 
                                UTIF._binBE.ui32[0];
                            },
                            readASCII: UTIF._binBE.readASCII,
                            readFloat: function(buff, p) {
                                for (var a = UTIF._binBE.ui8, i = 0; i < 4; i++) a[i] = buff[p + i];
                                return UTIF._binBE.fl32[0];
                            },
                            readDouble: function(buff, p) {
                                for (var a = UTIF._binBE.ui8, i = 0; i < 8; i++) a[i] = buff[p + i];
                                return UTIF._binBE.fl64[0];
                            }
                        }, UTIF._copyTile = function(tb, tw, th, b, w, h, xoff, yoff) {
                            for (var xlim = Math.min(tw, w - xoff), ylim = Math.min(th, h - yoff), y = 0; y < ylim; y++) for (var tof = (yoff + y) * w + xoff, sof = y * tw, x = 0; x < xlim; x++) b[tof + x] = tb[sof + x];
                        };
                    }(UTIF, "function" == typeof require ? require("pako") : self.pako);
                }();
            }).call(this, require("_process"));
        }, {
            _process: 133,
            pako: 86
        } ],
        183: [ function(require, module, exports) {
            (function(global) {
                function config(name) {
                    try {
                        if (!global.localStorage) return !1;
                    } catch (_) {
                        return !1;
                    }
                    var val = global.localStorage[name];
                    return null != val && "true" === String(val).toLowerCase();
                }
                module.exports = function deprecate(fn, msg) {
                    if (config("noDeprecation")) return fn;
                    var warned = !1;
                    return function deprecated() {
                        if (!warned) {
                            if (config("throwDeprecation")) throw new Error(msg);
                            config("traceDeprecation") ? console.trace(msg) : console.warn(msg), warned = !0;
                        }
                        return fn.apply(this, arguments);
                    };
                };
            }).call(this, void 0 !== commonjsGlobal ? commonjsGlobal : "undefined" != typeof self ? self : void 0 !== window ? window : {});
        }, {} ],
        184: [ function(require, module, exports) {
            arguments[4][26][0].apply(exports, arguments);
        }, {
            dup: 26
        } ],
        185: [ function(require, module, exports) {
            arguments[4][27][0].apply(exports, arguments);
        }, {
            dup: 27
        } ],
        186: [ function(require, module, exports) {
            arguments[4][28][0].apply(exports, arguments);
        }, {
            "./support/isBuffer": 185,
            _process: 133,
            dup: 28,
            inherits: 184
        } ],
        187: [ function(require, module, exports) {
            var window = require("global/window"), isFunction = require("is-function"), parseHeaders = require("parse-headers"), xtend = require("xtend");
            function initParams(uri, options, callback) {
                var params = uri;
                return isFunction(options) ? (callback = options, "string" == typeof uri && (params = {
                    uri
                })) : params = xtend(options, {
                    uri
                }), params.callback = callback, params;
            }
            function createXHR(uri, options, callback) {
                return _createXHR(options = initParams(uri, options, callback));
            }
            function _createXHR(options) {
                if (void 0 === options.callback) throw new Error("callback argument missing");
                var called = !1, callback = function cbOnce(err, response, body) {
                    called || (called = !0, options.callback(err, response, body));
                };
                function getBody() {
                    var body = void 0;
                    if (body = xhr.response ? xhr.response : xhr.responseText || function getXml(xhr) {
                        try {
                            if ("document" === xhr.responseType) return xhr.responseXML;
                            var firefoxBugTakenEffect = xhr.responseXML && "parsererror" === xhr.responseXML.documentElement.nodeName;
                            if ("" === xhr.responseType && !firefoxBugTakenEffect) return xhr.responseXML;
                        } catch (e) {}
                        return null;
                    }(xhr), isJson) try {
                        body = JSON.parse(body);
                    } catch (e) {}
                    return body;
                }
                function errorFunc(evt) {
                    return clearTimeout(timeoutTimer), evt instanceof Error || (evt = new Error("" + (evt || "Unknown XMLHttpRequest Error"))), 
                    evt.statusCode = 0, callback(evt, failureResponse);
                }
                function loadFunc() {
                    if (!aborted) {
                        var status;
                        clearTimeout(timeoutTimer), status = options.useXDR && void 0 === xhr.status ? 200 : 1223 === xhr.status ? 204 : xhr.status;
                        var response = failureResponse, err = null;
                        return 0 !== status ? (response = {
                            body: getBody(),
                            statusCode: status,
                            method,
                            headers: {},
                            url: uri,
                            rawRequest: xhr
                        }, xhr.getAllResponseHeaders && (response.headers = parseHeaders(xhr.getAllResponseHeaders()))) : err = new Error("Internal XMLHttpRequest Error"), 
                        callback(err, response, response.body);
                    }
                }
                var key, aborted, xhr = options.xhr || null;
                xhr || (xhr = options.cors || options.useXDR ? new createXHR.XDomainRequest : new createXHR.XMLHttpRequest);
                var timeoutTimer, uri = xhr.url = options.uri || options.url, method = xhr.method = options.method || "GET", body = options.body || options.data, headers = xhr.headers = options.headers || {}, sync = !!options.sync, isJson = !1, failureResponse = {
                    body: void 0,
                    headers: {},
                    statusCode: 0,
                    method,
                    url: uri,
                    rawRequest: xhr
                };
                if ("json" in options && !1 !== options.json && (isJson = !0, headers.accept || headers.Accept || (headers.Accept = "application/json"), 
                "GET" !== method && "HEAD" !== method && (headers["content-type"] || headers["Content-Type"] || (headers["Content-Type"] = "application/json"), 
                body = JSON.stringify(!0 === options.json ? body : options.json))), xhr.onreadystatechange = function readystatechange() {
                    4 === xhr.readyState && setTimeout(loadFunc, 0);
                }, xhr.onload = loadFunc, xhr.onerror = errorFunc, xhr.onprogress = function() {}, 
                xhr.onabort = function() {
                    aborted = !0;
                }, xhr.ontimeout = errorFunc, xhr.open(method, uri, !sync, options.username, options.password), 
                sync || (xhr.withCredentials = !!options.withCredentials), !sync && options.timeout > 0 && (timeoutTimer = setTimeout((function() {
                    if (!aborted) {
                        aborted = !0, xhr.abort("timeout");
                        var e = new Error("XMLHttpRequest timeout");
                        e.code = "ETIMEDOUT", errorFunc(e);
                    }
                }), options.timeout)), xhr.setRequestHeader) for (key in headers) headers.hasOwnProperty(key) && xhr.setRequestHeader(key, headers[key]); else if (options.headers && !function isEmpty(obj) {
                    for (var i in obj) if (obj.hasOwnProperty(i)) return !1;
                    return !0;
                }(options.headers)) throw new Error("Headers cannot be set on an XDomainRequest object");
                return "responseType" in options && (xhr.responseType = options.responseType), "beforeSend" in options && "function" == typeof options.beforeSend && options.beforeSend(xhr), 
                xhr.send(body || null), xhr;
            }
            module.exports = createXHR, module.exports.default = createXHR, createXHR.XMLHttpRequest = window.XMLHttpRequest || function noop() {}, 
            createXHR.XDomainRequest = "withCredentials" in new createXHR.XMLHttpRequest ? createXHR.XMLHttpRequest : window.XDomainRequest, 
            function forEachArray(array, iterator) {
                for (var i = 0; i < array.length; i++) iterator(array[i]);
            }([ "get", "put", "post", "patch", "head", "delete" ], (function(method) {
                createXHR["delete" === method ? "del" : method] = function(uri, options, callback) {
                    return (options = initParams(uri, options, callback)).method = method.toUpperCase(), 
                    _createXHR(options);
                };
            }));
        }, {
            "global/window": 71,
            "is-function": 78,
            "parse-headers": 106,
            xtend: 189
        } ],
        188: [ function(require, module, exports) {
            module.exports = function xmlparser() {
                return void 0 !== self.DOMParser ? function(str) {
                    return (new self.DOMParser).parseFromString(str, "application/xml");
                } : void 0 !== self.ActiveXObject && new self.ActiveXObject("Microsoft.XMLDOM") ? function(str) {
                    var xmlDoc = new self.ActiveXObject("Microsoft.XMLDOM");
                    return xmlDoc.async = "false", xmlDoc.loadXML(str), xmlDoc;
                } : function(str) {
                    var div = document.createElement("div");
                    return div.innerHTML = str, div;
                };
            }();
        }, {} ],
        189: [ function(require, module, exports) {
            module.exports = function extend() {
                for (var target = {}, i = 0; i < arguments.length; i++) {
                    var source = arguments[i];
                    for (var key in source) hasOwnProperty.call(source, key) && (target[key] = source[key]);
                }
                return target;
            };
            var hasOwnProperty = Object.prototype.hasOwnProperty;
        }, {} ],
        190: [ function(require, module, exports) {
            Object.defineProperty(exports, "__esModule", {
                value: !0
            }), exports.srcOver = function srcOver(src, dst) {
                var ops = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1;
                src.a *= ops;
                var a = dst.a + src.a - dst.a * src.a;
                return {
                    r: (src.r * src.a + dst.r * dst.a * (1 - src.a)) / a,
                    g: (src.g * src.a + dst.g * dst.a * (1 - src.a)) / a,
                    b: (src.b * src.a + dst.b * dst.a * (1 - src.a)) / a,
                    a
                };
            }, exports.dstOver = function dstOver(src, dst) {
                var ops = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1;
                src.a *= ops;
                var a = dst.a + src.a - dst.a * src.a;
                return {
                    r: (dst.r * dst.a + src.r * src.a * (1 - dst.a)) / a,
                    g: (dst.g * dst.a + src.g * src.a * (1 - dst.a)) / a,
                    b: (dst.b * dst.a + src.b * src.a * (1 - dst.a)) / a,
                    a
                };
            }, exports.multiply = function multiply(src, dst) {
                var ops = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1;
                src.a *= ops;
                var a = dst.a + src.a - dst.a * src.a, sra = src.r * src.a, sga = src.g * src.a, sba = src.b * src.a, dra = dst.r * dst.a, dga = dst.g * dst.a, dba = dst.b * dst.a;
                return {
                    r: (sra * dra + sra * (1 - dst.a) + dra * (1 - src.a)) / a,
                    g: (sga * dga + sga * (1 - dst.a) + dga * (1 - src.a)) / a,
                    b: (sba * dba + sba * (1 - dst.a) + dba * (1 - src.a)) / a,
                    a
                };
            }, exports.add = function add(src, dst) {
                var ops = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1;
                src.a *= ops;
                var a = dst.a + src.a - dst.a * src.a, sra = src.r * src.a, sga = src.g * src.a, sba = src.b * src.a;
                return {
                    r: (sra + dst.r * dst.a) / a,
                    g: (sga + dst.g * dst.a) / a,
                    b: (sba + dst.b * dst.a) / a,
                    a
                };
            }, exports.screen = function screen(src, dst) {
                var ops = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1;
                src.a *= ops;
                var a = dst.a + src.a - dst.a * src.a, sra = src.r * src.a, sga = src.g * src.a, sba = src.b * src.a, dra = dst.r * dst.a, dga = dst.g * dst.a, dba = dst.b * dst.a;
                return {
                    r: (sra * dst.a + dra * src.a - sra * dra + sra * (1 - dst.a) + dra * (1 - src.a)) / a,
                    g: (sga * dst.a + dga * src.a - sga * dga + sga * (1 - dst.a) + dga * (1 - src.a)) / a,
                    b: (sba * dst.a + dba * src.a - sba * dba + sba * (1 - dst.a) + dba * (1 - src.a)) / a,
                    a
                };
            }, exports.overlay = function overlay(src, dst) {
                var ops = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1;
                src.a *= ops;
                var a = dst.a + src.a - dst.a * src.a, sra = src.r * src.a, sga = src.g * src.a, sba = src.b * src.a, dra = dst.r * dst.a, dga = dst.g * dst.a, dba = dst.b * dst.a;
                return {
                    r: (2 * dra <= dst.a ? 2 * sra * dra + sra * (1 - dst.a) + dra * (1 - src.a) : sra * (1 + dst.a) + dra * (1 + src.a) - 2 * dra * sra - dst.a * src.a) / a,
                    g: (2 * dga <= dst.a ? 2 * sga * dga + sga * (1 - dst.a) + dga * (1 - src.a) : sga * (1 + dst.a) + dga * (1 + src.a) - 2 * dga * sga - dst.a * src.a) / a,
                    b: (2 * dba <= dst.a ? 2 * sba * dba + sba * (1 - dst.a) + dba * (1 - src.a) : sba * (1 + dst.a) + dba * (1 + src.a) - 2 * dba * sba - dst.a * src.a) / a,
                    a
                };
            }, exports.darken = function darken(src, dst) {
                var ops = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1;
                src.a *= ops;
                var a = dst.a + src.a - dst.a * src.a, sra = src.r * src.a, sga = src.g * src.a, sba = src.b * src.a, dra = dst.r * dst.a, dga = dst.g * dst.a, dba = dst.b * dst.a;
                return {
                    r: (Math.min(sra * dst.a, dra * src.a) + sra * (1 - dst.a) + dra * (1 - src.a)) / a,
                    g: (Math.min(sga * dst.a, dga * src.a) + sga * (1 - dst.a) + dga * (1 - src.a)) / a,
                    b: (Math.min(sba * dst.a, dba * src.a) + sba * (1 - dst.a) + dba * (1 - src.a)) / a,
                    a
                };
            }, exports.lighten = function lighten(src, dst) {
                var ops = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1;
                src.a *= ops;
                var a = dst.a + src.a - dst.a * src.a, sra = src.r * src.a, sga = src.g * src.a, sba = src.b * src.a, dra = dst.r * dst.a, dga = dst.g * dst.a, dba = dst.b * dst.a;
                return {
                    r: (Math.max(sra * dst.a, dra * src.a) + sra * (1 - dst.a) + dra * (1 - src.a)) / a,
                    g: (Math.max(sga * dst.a, dga * src.a) + sga * (1 - dst.a) + dga * (1 - src.a)) / a,
                    b: (Math.max(sba * dst.a, dba * src.a) + sba * (1 - dst.a) + dba * (1 - src.a)) / a,
                    a
                };
            }, exports.hardLight = function hardLight(src, dst) {
                var ops = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1;
                src.a *= ops;
                var a = dst.a + src.a - dst.a * src.a, sra = src.r * src.a, sga = src.g * src.a, sba = src.b * src.a, dra = dst.r * dst.a, dga = dst.g * dst.a, dba = dst.b * dst.a;
                return {
                    r: (2 * sra <= src.a ? 2 * sra * dra + sra * (1 - dst.a) + dra * (1 - src.a) : sra * (1 + dst.a) + dra * (1 + src.a) - 2 * dra * sra - dst.a * src.a) / a,
                    g: (2 * sga <= src.a ? 2 * sga * dga + sga * (1 - dst.a) + dga * (1 - src.a) : sga * (1 + dst.a) + dga * (1 + src.a) - 2 * dga * sga - dst.a * src.a) / a,
                    b: (2 * sba <= src.a ? 2 * sba * dba + sba * (1 - dst.a) + dba * (1 - src.a) : sba * (1 + dst.a) + dba * (1 + src.a) - 2 * dba * sba - dst.a * src.a) / a,
                    a
                };
            }, exports.difference = function difference(src, dst) {
                var ops = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1;
                src.a *= ops;
                var a = dst.a + src.a - dst.a * src.a, sra = src.r * src.a, sga = src.g * src.a, sba = src.b * src.a, dra = dst.r * dst.a, dga = dst.g * dst.a, dba = dst.b * dst.a;
                return {
                    r: (sra + dra - 2 * Math.min(sra * dst.a, dra * src.a)) / a,
                    g: (sga + dga - 2 * Math.min(sga * dst.a, dga * src.a)) / a,
                    b: (sba + dba - 2 * Math.min(sba * dst.a, dba * src.a)) / a,
                    a
                };
            }, exports.exclusion = function exclusion(src, dst) {
                var ops = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 1;
                src.a *= ops;
                var a = dst.a + src.a - dst.a * src.a, sra = src.r * src.a, sga = src.g * src.a, sba = src.b * src.a, dra = dst.r * dst.a, dga = dst.g * dst.a, dba = dst.b * dst.a;
                return {
                    r: (sra * dst.a + dra * src.a - 2 * sra * dra + sra * (1 - dst.a) + dra * (1 - src.a)) / a,
                    g: (sga * dst.a + dga * src.a - 2 * sga * dga + sga * (1 - dst.a) + dga * (1 - src.a)) / a,
                    b: (sba * dst.a + dba * src.a - 2 * sba * dba + sba * (1 - dst.a) + dba * (1 - src.a)) / a,
                    a
                };
            };
        }, {} ],
        191: [ function(require, module, exports) {
            var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");
            Object.defineProperty(exports, "__esModule", {
                value: !0
            }), exports.default = function composite(src, x, y) {
                var options = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {}, cb = arguments.length > 4 ? arguments[4] : void 0;
                if ("function" == typeof options && (cb = options, options = {}), !(src instanceof this.constructor)) return _utils.throwError.call(this, "The source must be a Jimp image", cb);
                if ("number" != typeof x || "number" != typeof y) return _utils.throwError.call(this, "x and y must be numbers", cb);
                var _options = options, mode = _options.mode, opacitySource = _options.opacitySource, opacityDest = _options.opacityDest;
                mode || (mode = constants.BLEND_SOURCE_OVER), ("number" != typeof opacitySource || opacitySource < 0 || opacitySource > 1) && (opacitySource = 1.0), 
                ("number" != typeof opacityDest || opacityDest < 0 || opacityDest > 1) && (opacityDest = 1.0);
                var blendmode = compositeModes[mode];
                x = Math.round(x), y = Math.round(y);
                var baseImage = this;
                return 1.0 !== opacityDest && baseImage.opacity(opacityDest), src.scanQuiet(0, 0, src.bitmap.width, src.bitmap.height, (function(sx, sy, idx) {
                    var dstIdx = baseImage.getPixelIndex(x + sx, y + sy, constants.EDGE_CROP), blended = blendmode({
                        r: this.bitmap.data[idx + 0] / 255,
                        g: this.bitmap.data[idx + 1] / 255,
                        b: this.bitmap.data[idx + 2] / 255,
                        a: this.bitmap.data[idx + 3] / 255
                    }, {
                        r: baseImage.bitmap.data[dstIdx + 0] / 255,
                        g: baseImage.bitmap.data[dstIdx + 1] / 255,
                        b: baseImage.bitmap.data[dstIdx + 2] / 255,
                        a: baseImage.bitmap.data[dstIdx + 3] / 255
                    }, opacitySource);
                    baseImage.bitmap.data[dstIdx + 0] = this.constructor.limit255(255 * blended.r), 
                    baseImage.bitmap.data[dstIdx + 1] = this.constructor.limit255(255 * blended.g), 
                    baseImage.bitmap.data[dstIdx + 2] = this.constructor.limit255(255 * blended.b), 
                    baseImage.bitmap.data[dstIdx + 3] = this.constructor.limit255(255 * blended.a);
                })), (0, _utils.isNodePattern)(cb) && cb.call(this, null, this), this;
            };
            var _utils = require("@jimp/utils"), constants = _interopRequireWildcard(require("../constants")), compositeModes = _interopRequireWildcard(require("./composite-modes"));
            module.exports = exports.default;
        }, {
            "../constants": 192,
            "./composite-modes": 190,
            "@babel/runtime/helpers/interopRequireWildcard": 12,
            "@jimp/utils": 235
        } ],
        192: [ function(require, module, exports) {
            Object.defineProperty(exports, "__esModule", {
                value: !0
            }), exports.EDGE_CROP = exports.EDGE_WRAP = exports.EDGE_EXTEND = exports.BLEND_EXCLUSION = exports.BLEND_DIFFERENCE = exports.BLEND_HARDLIGHT = exports.BLEND_LIGHTEN = exports.BLEND_DARKEN = exports.BLEND_OVERLAY = exports.BLEND_SCREEN = exports.BLEND_ADD = exports.BLEND_MULTIPLY = exports.BLEND_DESTINATION_OVER = exports.BLEND_SOURCE_OVER = exports.VERTICAL_ALIGN_BOTTOM = exports.VERTICAL_ALIGN_MIDDLE = exports.VERTICAL_ALIGN_TOP = exports.HORIZONTAL_ALIGN_RIGHT = exports.HORIZONTAL_ALIGN_CENTER = exports.HORIZONTAL_ALIGN_LEFT = exports.AUTO = void 0, 
            exports.AUTO = -1, exports.HORIZONTAL_ALIGN_LEFT = 1, exports.HORIZONTAL_ALIGN_CENTER = 2, 
            exports.HORIZONTAL_ALIGN_RIGHT = 4, exports.VERTICAL_ALIGN_TOP = 8, exports.VERTICAL_ALIGN_MIDDLE = 16, 
            exports.VERTICAL_ALIGN_BOTTOM = 32, exports.BLEND_SOURCE_OVER = "srcOver", exports.BLEND_DESTINATION_OVER = "dstOver", 
            exports.BLEND_MULTIPLY = "multiply", exports.BLEND_ADD = "add", exports.BLEND_SCREEN = "screen", 
            exports.BLEND_OVERLAY = "overlay", exports.BLEND_DARKEN = "darken", exports.BLEND_LIGHTEN = "lighten", 
            exports.BLEND_HARDLIGHT = "hardLight", exports.BLEND_DIFFERENCE = "difference", 
            exports.BLEND_EXCLUSION = "exclusion", exports.EDGE_EXTEND = 1, exports.EDGE_WRAP = 2, 
            exports.EDGE_CROP = 3;
        }, {} ],
        193: [ function(require, module, exports) {
            (function(Buffer) {
                var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard"), _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
                Object.defineProperty(exports, "__esModule", {
                    value: !0
                }), exports.addConstants = addConstants, exports.addJimpMethods = addJimpMethods, 
                exports.jimpEvMethod = jimpEvMethod, exports.jimpEvChange = jimpEvChange, Object.defineProperty(exports, "addType", {
                    enumerable: !0,
                    get: function get() {
                        return MIME.addType;
                    }
                }), exports.default = void 0;
                for (var _construct2 = _interopRequireDefault(require("@babel/runtime/helpers/construct")), _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray")), _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck")), _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass")), _possibleConstructorReturn2 = _interopRequireDefault(require("@babel/runtime/helpers/possibleConstructorReturn")), _getPrototypeOf2 = _interopRequireDefault(require("@babel/runtime/helpers/getPrototypeOf")), _assertThisInitialized2 = _interopRequireDefault(require("@babel/runtime/helpers/assertThisInitialized")), _inherits2 = _interopRequireDefault(require("@babel/runtime/helpers/inherits")), _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty")), _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof")), _fs = _interopRequireDefault(require("fs")), _path = _interopRequireDefault(require("path")), _events = _interopRequireDefault(require("events")), _utils = require("@jimp/utils"), _anyBase = _interopRequireDefault(require("any-base")), _mkdirp = _interopRequireDefault(require("mkdirp")), _pixelmatch = _interopRequireDefault(require("pixelmatch")), _tinycolor = _interopRequireDefault(require("tinycolor2")), _phash = _interopRequireDefault(require("./modules/phash")), _request = _interopRequireDefault(require("./request")), _composite = _interopRequireDefault(require("./composite")), _promisify = _interopRequireDefault(require("./utils/promisify")), MIME = _interopRequireWildcard(require("./utils/mime")), _imageBitmap = require("./utils/image-bitmap"), constants = _interopRequireWildcard(require("./constants")), alphabet = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_", maxHashLength = [ NaN, NaN ], i = 2; i < 65; i++) {
                    var maxHash = (0, _anyBase.default)(_anyBase.default.BIN, alphabet.slice(0, i))(new Array(65).join("1"));
                    maxHashLength.push(maxHash.length);
                }
                function noop() {}
                function isArrayBuffer(test) {
                    return Object.prototype.toString.call(test).toLowerCase().indexOf("arraybuffer") > -1;
                }
                function bufferFromArrayBuffer(arrayBuffer) {
                    for (var buffer = Buffer.alloc(arrayBuffer.byteLength), view = new Uint8Array(arrayBuffer), _i = 0; _i < buffer.length; ++_i) buffer[_i] = view[_i];
                    return buffer;
                }
                function loadFromURL(options, cb) {
                    (0, _request.default)(options, (function(err, response, data) {
                        if (err) return cb(err);
                        if ("headers" in response && "location" in response.headers) return options.url = response.headers.location, 
                        loadFromURL(options, cb);
                        if ("object" === (0, _typeof2.default)(data) && Buffer.isBuffer(data)) return cb(null, data);
                        var msg = "Could not load Buffer from <" + options.url + "> (HTTP: " + response.statusCode + ")";
                        return new Error(msg);
                    }));
                }
                function loadBufferFromPath(src, cb) {
                    _fs.default && "function" == typeof _fs.default.readFile && !src.match(/^(http|ftp)s?:\/\/./) ? _fs.default.readFile(src, cb) : loadFromURL({
                        url: src
                    }, cb);
                }
                function isRawRGBAData(obj) {
                    return obj && "object" === (0, _typeof2.default)(obj) && "number" == typeof obj.width && "number" == typeof obj.height && (Buffer.isBuffer(obj.data) || obj.data instanceof Uint8Array || "function" == typeof Uint8ClampedArray && obj.data instanceof Uint8ClampedArray) && (obj.data.length === obj.width * obj.height * 4 || obj.data.length === obj.width * obj.height * 3);
                }
                function makeRGBABufferFromRGB(buffer) {
                    if (buffer.length % 3 != 0) throw new Error("Buffer length is incorrect");
                    for (var rgbaBuffer = Buffer.allocUnsafe(buffer.length / 3 * 4), j = 0, _i2 = 0; _i2 < buffer.length; _i2++) rgbaBuffer[j] = buffer[_i2], 
                    (_i2 + 1) % 3 == 0 && (rgbaBuffer[++j] = 255), j++;
                    return rgbaBuffer;
                }
                var emptyBitmap = {
                    data: null,
                    width: null,
                    height: null
                }, Jimp = function(_EventEmitter) {
                    function Jimp() {
                        for (var _this, _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
                        (0, _classCallCheck2.default)(this, Jimp), _this = (0, _possibleConstructorReturn2.default)(this, (0, 
                        _getPrototypeOf2.default)(Jimp).call(this)), (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "bitmap", emptyBitmap), 
                        (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "_background", 0x00000000), 
                        (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "_originalMime", Jimp.MIME_PNG), 
                        (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "_exif", null), 
                        (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "_rgba", !0), 
                        (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "writeAsync", (function(path) {
                            return (0, _promisify.default)(_this.write, (0, _assertThisInitialized2.default)(_this), path);
                        })), (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "getBase64Async", (function(mime) {
                            return (0, _promisify.default)(_this.getBase64, (0, _assertThisInitialized2.default)(_this), mime);
                        })), (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "getBuffer", _imageBitmap.getBuffer), 
                        (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "getBufferAsync", _imageBitmap.getBufferAsync), 
                        (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "getPixelColour", _this.getPixelColor), 
                        (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this), "setPixelColour", _this.setPixelColor);
                        var jimpInstance = (0, _assertThisInitialized2.default)(_this), cb = noop;
                        function finish() {
                            for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) args[_key2] = arguments[_key2];
                            var err = args[0];
                            (err || {}).methodName = "constructor", setTimeout((function() {
                                var _cb;
                                err && cb === noop ? jimpInstance.emitError("constructor", err) : err || jimpInstance.emitMulti("constructor", "initialized"), 
                                (_cb = cb).call.apply(_cb, [ jimpInstance ].concat(args));
                            }), 1);
                        }
                        if (isArrayBuffer(args[0]) && (args[0] = bufferFromArrayBuffer(args[0])), "number" == typeof args[0] && "number" == typeof args[1] || parseInt(args[0], 10) && parseInt(args[1], 10)) {
                            var w = parseInt(args[0], 10), h = parseInt(args[1], 10);
                            if (cb = args[2], "number" == typeof args[2] && (_this._background = args[2], cb = args[3]), 
                            "string" == typeof args[2] && (_this._background = Jimp.cssColorToHex(args[2]), 
                            cb = args[3]), void 0 === cb && (cb = noop), "function" != typeof cb) return (0, 
                            _possibleConstructorReturn2.default)(_this, _utils.throwError.call((0, _assertThisInitialized2.default)(_this), "cb must be a function", finish));
                            _this.bitmap = {
                                data: Buffer.alloc(w * h * 4),
                                width: w,
                                height: h
                            };
                            for (var _i3 = 0; _i3 < _this.bitmap.data.length; _i3 += 4) _this.bitmap.data.writeUInt32BE(_this._background, _i3);
                            finish(null, (0, _assertThisInitialized2.default)(_this));
                        } else if ("object" === (0, _typeof2.default)(args[0]) && args[0].url) {
                            if ("function" != typeof (cb = args[1] || noop)) return (0, _possibleConstructorReturn2.default)(_this, _utils.throwError.call((0, 
                            _assertThisInitialized2.default)(_this), "cb must be a function", finish));
                            loadFromURL(args[0], (function(err, data) {
                                if (err) return _utils.throwError.call((0, _assertThisInitialized2.default)(_this), err, finish);
                                _this.parseBitmap(data, args[0].url, finish);
                            }));
                        } else if (args[0] instanceof Jimp) {
                            var original = args[0];
                            if (void 0 === (cb = args[1]) && (cb = noop), "function" != typeof cb) return (0, 
                            _possibleConstructorReturn2.default)(_this, _utils.throwError.call((0, _assertThisInitialized2.default)(_this), "cb must be a function", finish));
                            _this.bitmap = {
                                data: Buffer.from(original.bitmap.data),
                                width: original.bitmap.width,
                                height: original.bitmap.height
                            }, _this._quality = original._quality, _this._deflateLevel = original._deflateLevel, 
                            _this._deflateStrategy = original._deflateStrategy, _this._filterType = original._filterType, 
                            _this._rgba = original._rgba, _this._background = original._background, _this._originalMime = original._originalMime, 
                            finish(null, (0, _assertThisInitialized2.default)(_this));
                        } else if (isRawRGBAData(args[0])) {
                            var imageData = args[0];
                            cb = args[1] || noop;
                            var buffer = imageData.width * imageData.height * 4 === imageData.data.length ? Buffer.from(imageData.data) : makeRGBABufferFromRGB(imageData.data);
                            _this.bitmap = {
                                data: buffer,
                                width: imageData.width,
                                height: imageData.height
                            }, finish(null, (0, _assertThisInitialized2.default)(_this));
                        } else if ("string" == typeof args[0]) {
                            var path = args[0];
                            if (void 0 === (cb = args[1]) && (cb = noop), "function" != typeof cb) return (0, 
                            _possibleConstructorReturn2.default)(_this, _utils.throwError.call((0, _assertThisInitialized2.default)(_this), "cb must be a function", finish));
                            loadBufferFromPath(path, (function(err, data) {
                                if (err) return _utils.throwError.call((0, _assertThisInitialized2.default)(_this), err, finish);
                                _this.parseBitmap(data, path, finish);
                            }));
                        } else if ("object" === (0, _typeof2.default)(args[0]) && Buffer.isBuffer(args[0])) {
                            var data = args[0];
                            if ("function" != typeof (cb = args[1])) return (0, _possibleConstructorReturn2.default)(_this, _utils.throwError.call((0, 
                            _assertThisInitialized2.default)(_this), "cb must be a function", finish));
                            _this.parseBitmap(data, null, finish);
                        } else {
                            "function" != typeof (cb = args[args.length - 1]) && "function" != typeof (cb = args[args.length - 2]) && (cb = noop);
                            var extraConstructor = Jimp.__extraConstructors.find((function(c) {
                                return c.test.apply(c, args);
                            }));
                            if (!extraConstructor) return (0, _possibleConstructorReturn2.default)(_this, _utils.throwError.call((0, 
                            _assertThisInitialized2.default)(_this), "No matching constructor overloading was found. Please see the docs for how to call the Jimp constructor.", finish));
                            new Promise((function(resolve, reject) {
                                var _extraConstructor$run;
                                return (_extraConstructor$run = extraConstructor.run).call.apply(_extraConstructor$run, [ (0, 
                                _assertThisInitialized2.default)(_this), resolve, reject ].concat(args));
                            })).then((function() {
                                return finish(null, (0, _assertThisInitialized2.default)(_this));
                            })).catch(finish);
                        }
                        return _this;
                    }
                    return (0, _inherits2.default)(Jimp, _EventEmitter), (0, _createClass2.default)(Jimp, [ {
                        key: "parseBitmap",
                        value: function parseBitmap(data, path, finish) {
                            _imageBitmap.parseBitmap.call(this, data, null, finish);
                        }
                    }, {
                        key: "rgba",
                        value: function rgba(bool, cb) {
                            return "boolean" != typeof bool ? _utils.throwError.call(this, "bool must be a boolean, true for RGBA or false for RGB", cb) : (this._rgba = bool, 
                            (0, _utils.isNodePattern)(cb) && cb.call(this, null, this), this);
                        }
                    }, {
                        key: "emitMulti",
                        value: function emitMulti(methodName, eventName) {
                            var data = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
                            data = Object.assign(data, {
                                methodName,
                                eventName
                            }), this.emit("any", data), methodName && this.emit(methodName, data), this.emit(eventName, data);
                        }
                    }, {
                        key: "emitError",
                        value: function emitError(methodName, err) {
                            this.emitMulti(methodName, "error", err);
                        }
                    }, {
                        key: "getHeight",
                        value: function getHeight() {
                            return this.bitmap.height;
                        }
                    }, {
                        key: "getWidth",
                        value: function getWidth() {
                            return this.bitmap.width;
                        }
                    }, {
                        key: "inspect",
                        value: function inspect() {
                            return "<Jimp " + (this.bitmap === emptyBitmap ? "pending..." : this.bitmap.width + "x" + this.bitmap.height) + ">";
                        }
                    }, {
                        key: "toString",
                        value: function toString() {
                            return "[object Jimp]";
                        }
                    }, {
                        key: "getMIME",
                        value: function getMIME() {
                            return this._originalMime || Jimp.MIME_PNG;
                        }
                    }, {
                        key: "getExtension",
                        value: function getExtension() {
                            var mime = this.getMIME();
                            return MIME.getExtension(mime);
                        }
                    }, {
                        key: "write",
                        value: function write(path, cb) {
                            var _this2 = this;
                            if (!_fs.default || !_fs.default.createWriteStream) throw new Error("Cant access the filesystem. You can use the getBase64 method.");
                            if ("string" != typeof path) return _utils.throwError.call(this, "path must be a string", cb);
                            if (void 0 === cb && (cb = noop), "function" != typeof cb) return _utils.throwError.call(this, "cb must be a function", cb);
                            var mime = MIME.getType(path) || this.getMIME(), pathObj = _path.default.parse(path);
                            return pathObj.dir && _mkdirp.default.sync(pathObj.dir), this.getBuffer(mime, (function(err, buffer) {
                                if (err) return _utils.throwError.call(_this2, err, cb);
                                var stream = _fs.default.createWriteStream(path);
                                stream.on("open", (function() {
                                    stream.write(buffer), stream.end();
                                })).on("error", (function(err) {
                                    return _utils.throwError.call(_this2, err, cb);
                                })), stream.on("finish", (function() {
                                    cb.call(_this2, null, _this2);
                                }));
                            })), this;
                        }
                    }, {
                        key: "getBase64",
                        value: function getBase64(mime, cb) {
                            return mime === Jimp.AUTO && (mime = this.getMIME()), "string" != typeof mime ? _utils.throwError.call(this, "mime must be a string", cb) : "function" != typeof cb ? _utils.throwError.call(this, "cb must be a function", cb) : (this.getBuffer(mime, (function(err, data) {
                                if (err) return _utils.throwError.call(this, err, cb);
                                var src = "data:" + mime + ";base64," + data.toString("base64");
                                cb.call(this, null, src);
                            })), this);
                        }
                    }, {
                        key: "hash",
                        value: function hash(base, cb) {
                            if ("function" == typeof (base = base || 64) && (cb = base, base = 64), "number" != typeof base) return _utils.throwError.call(this, "base must be a number", cb);
                            if (base < 2 || base > 64) return _utils.throwError.call(this, "base must be a number between 2 and 64", cb);
                            var hash = this.pHash();
                            for (hash = (0, _anyBase.default)(_anyBase.default.BIN, alphabet.slice(0, base))(hash); hash.length < maxHashLength[base]; ) hash = "0" + hash;
                            return (0, _utils.isNodePattern)(cb) && cb.call(this, null, hash), hash;
                        }
                    }, {
                        key: "pHash",
                        value: function pHash() {
                            var pHash = new _phash.default;
                            return pHash.getHash(this);
                        }
                    }, {
                        key: "distanceFromHash",
                        value: function distanceFromHash(compareHash) {
                            var pHash = new _phash.default, currentHash = pHash.getHash(this);
                            return pHash.distance(currentHash, compareHash);
                        }
                    }, {
                        key: "getPixelIndex",
                        value: function getPixelIndex(x, y, edgeHandling, cb) {
                            var xi, yi;
                            if ("function" == typeof edgeHandling && void 0 === cb && (cb = edgeHandling, edgeHandling = null), 
                            edgeHandling || (edgeHandling = Jimp.EDGE_EXTEND), "number" != typeof x || "number" != typeof y) return _utils.throwError.call(this, "x and y must be numbers", cb);
                            xi = x = Math.round(x), yi = y = Math.round(y), edgeHandling === Jimp.EDGE_EXTEND && (x < 0 && (xi = 0), 
                            x >= this.bitmap.width && (xi = this.bitmap.width - 1), y < 0 && (yi = 0), y >= this.bitmap.height && (yi = this.bitmap.height - 1)), 
                            edgeHandling === Jimp.EDGE_WRAP && (x < 0 && (xi = this.bitmap.width + x), x >= this.bitmap.width && (xi = x % this.bitmap.width), 
                            y < 0 && (xi = this.bitmap.height + y), y >= this.bitmap.height && (yi = y % this.bitmap.height));
                            var i = this.bitmap.width * yi + xi << 2;
                            return (xi < 0 || xi >= this.bitmap.width) && (i = -1), (yi < 0 || yi >= this.bitmap.height) && (i = -1), 
                            (0, _utils.isNodePattern)(cb) && cb.call(this, null, i), i;
                        }
                    }, {
                        key: "getPixelColor",
                        value: function getPixelColor(x, y, cb) {
                            if ("number" != typeof x || "number" != typeof y) return _utils.throwError.call(this, "x and y must be numbers", cb);
                            x = Math.round(x), y = Math.round(y);
                            var idx = this.getPixelIndex(x, y), hex = this.bitmap.data.readUInt32BE(idx);
                            return (0, _utils.isNodePattern)(cb) && cb.call(this, null, hex), hex;
                        }
                    }, {
                        key: "setPixelColor",
                        value: function setPixelColor(hex, x, y, cb) {
                            if ("number" != typeof hex || "number" != typeof x || "number" != typeof y) return _utils.throwError.call(this, "hex, x and y must be numbers", cb);
                            x = Math.round(x), y = Math.round(y);
                            var idx = this.getPixelIndex(x, y);
                            return this.bitmap.data.writeUInt32BE(hex, idx), (0, _utils.isNodePattern)(cb) && cb.call(this, null, this), 
                            this;
                        }
                    }, {
                        key: "hasAlpha",
                        value: function hasAlpha() {
                            for (var yIndex = 0; yIndex < this.bitmap.height; yIndex++) for (var xIndex = 0; xIndex < this.bitmap.width; xIndex++) {
                                var idx = this.bitmap.width * yIndex + xIndex << 2;
                                if (0xff !== this.bitmap.data[idx + 3]) return !0;
                            }
                            return !1;
                        }
                    }, {
                        key: "scanIterator",
                        value: function scanIterator(x, y, w, h) {
                            return "number" != typeof x || "number" != typeof y ? _utils.throwError.call(this, "x and y must be numbers") : "number" != typeof w || "number" != typeof h ? _utils.throwError.call(this, "w and h must be numbers") : (0, 
                            _utils.scanIterator)(this, x, y, w, h);
                        }
                    } ]), Jimp;
                }(_events.default);
                function addConstants(constants) {
                    var jimpInstance = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Jimp;
                    Object.entries(constants).forEach((function(_ref) {
                        var _ref2 = (0, _slicedToArray2.default)(_ref, 2), name = _ref2[0], value = _ref2[1];
                        jimpInstance[name] = value;
                    }));
                }
                function addJimpMethods(methods) {
                    var jimpInstance = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Jimp;
                    Object.entries(methods).forEach((function(_ref3) {
                        var _ref4 = (0, _slicedToArray2.default)(_ref3, 2), name = _ref4[0], value = _ref4[1];
                        jimpInstance.prototype[name] = value;
                    }));
                }
                function jimpEvMethod(methodName, evName, method) {
                    var evNameBefore = "before-" + evName, evNameAfter = evName.replace(/e$/, "") + "ed";
                    Jimp.prototype[methodName] = function() {
                        for (var wrappedCb, _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) args[_key4] = arguments[_key4];
                        var result, cb = args[method.length - 1], jimpInstance = this;
                        "function" == typeof cb ? (wrappedCb = function wrappedCb() {
                            for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) args[_key5] = arguments[_key5];
                            var err = args[0], data = args[1];
                            err ? jimpInstance.emitError(methodName, err) : jimpInstance.emitMulti(methodName, evNameAfter, (0, 
                            _defineProperty2.default)({}, methodName, data)), cb.apply(this, args);
                        }, args[args.length - 1] = wrappedCb) : wrappedCb = !1, this.emitMulti(methodName, evNameBefore);
                        try {
                            result = method.apply(this, args), wrappedCb || this.emitMulti(methodName, evNameAfter, (0, 
                            _defineProperty2.default)({}, methodName, result));
                        } catch (error) {
                            error.methodName = methodName, this.emitError(methodName, error);
                        }
                        return result;
                    }, Jimp.prototype[methodName + "Quiet"] = method;
                }
                function jimpEvChange(methodName, method) {
                    jimpEvMethod(methodName, "change", method);
                }
                addConstants(constants), addJimpMethods({
                    composite: _composite.default
                }), Jimp.__extraConstructors = [], Jimp.appendConstructorOption = function(name, test, run) {
                    Jimp.__extraConstructors.push({
                        name,
                        test,
                        run
                    });
                }, Jimp.read = function() {
                    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) args[_key3] = arguments[_key3];
                    return new Promise((function(resolve, reject) {
                        (0, _construct2.default)(Jimp, args.concat([ function(err, image) {
                            err ? reject(err) : resolve(image);
                        } ]));
                    }));
                }, Jimp.create = Jimp.read, Jimp.rgbaToInt = function(r, g, b, a, cb) {
                    if ("number" != typeof r || "number" != typeof g || "number" != typeof b || "number" != typeof a) return _utils.throwError.call(this, "r, g, b and a must be numbers", cb);
                    if (r < 0 || r > 255) return _utils.throwError.call(this, "r must be between 0 and 255", cb);
                    if ((g < 0 || g > 255) && _utils.throwError.call(this, "g must be between 0 and 255", cb), 
                    b < 0 || b > 255) return _utils.throwError.call(this, "b must be between 0 and 255", cb);
                    if (a < 0 || a > 255) return _utils.throwError.call(this, "a must be between 0 and 255", cb);
                    r = Math.round(r), b = Math.round(b), g = Math.round(g), a = Math.round(a);
                    var i = r * Math.pow(256, 3) + g * Math.pow(256, 2) + b * Math.pow(256, 1) + a * Math.pow(256, 0);
                    return (0, _utils.isNodePattern)(cb) && cb.call(this, null, i), i;
                }, Jimp.intToRGBA = function(i, cb) {
                    if ("number" != typeof i) return _utils.throwError.call(this, "i must be a number", cb);
                    var rgba = {};
                    return rgba.r = Math.floor(i / Math.pow(256, 3)), rgba.g = Math.floor((i - rgba.r * Math.pow(256, 3)) / Math.pow(256, 2)), 
                    rgba.b = Math.floor((i - rgba.r * Math.pow(256, 3) - rgba.g * Math.pow(256, 2)) / Math.pow(256, 1)), 
                    rgba.a = Math.floor((i - rgba.r * Math.pow(256, 3) - rgba.g * Math.pow(256, 2) - rgba.b * Math.pow(256, 1)) / Math.pow(256, 0)), 
                    (0, _utils.isNodePattern)(cb) && cb.call(this, null, rgba), rgba;
                }, Jimp.cssColorToHex = function(cssColor) {
                    return "number" == typeof (cssColor = cssColor || 0) ? Number(cssColor) : parseInt((0, 
                    _tinycolor.default)(cssColor).toHex8(), 16);
                }, Jimp.limit255 = function(n) {
                    return n = Math.max(n, 0), Math.min(n, 255);
                }, Jimp.diff = function(img1, img2) {
                    var threshold = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0.1;
                    if (!(img1 instanceof Jimp && img2 instanceof Jimp)) return _utils.throwError.call(this, "img1 and img2 must be an Jimp images");
                    var bmp1 = img1.bitmap, bmp2 = img2.bitmap;
                    if (bmp1.width === bmp2.width && bmp1.height === bmp2.height || (bmp1.width * bmp1.height > bmp2.width * bmp2.height ? img1 = img1.cloneQuiet().resize(bmp2.width, bmp2.height) : img2 = img2.cloneQuiet().resize(bmp1.width, bmp1.height)), 
                    "number" != typeof threshold || threshold < 0 || threshold > 1) return _utils.throwError.call(this, "threshold must be a number between 0 and 1");
                    var diff = new Jimp(bmp1.width, bmp1.height, 0xffffffff);
                    return {
                        percent: (0, _pixelmatch.default)(bmp1.data, bmp2.data, diff.bitmap.data, diff.bitmap.width, diff.bitmap.height, {
                            threshold
                        }) / (diff.bitmap.width * diff.bitmap.height),
                        image: diff
                    };
                }, Jimp.distance = function(img1, img2) {
                    var phash = new _phash.default, hash1 = phash.getHash(img1), hash2 = phash.getHash(img2);
                    return phash.distance(hash1, hash2);
                }, Jimp.compareHashes = function(hash1, hash2) {
                    return (new _phash.default).distance(hash1, hash2);
                }, Jimp.colorDiff = function(rgba1, rgba2) {
                    var pow = function pow(n) {
                        return Math.pow(n, 2);
                    }, max = Math.max;
                    return 0 === rgba1.a || rgba1.a || (rgba1.a = 255), 0 === rgba2.a || rgba2.a || (rgba2.a = 255), 
                    (max(pow(rgba1.r - rgba2.r), pow(rgba1.r - rgba2.r - rgba1.a + rgba2.a)) + max(pow(rgba1.g - rgba2.g), pow(rgba1.g - rgba2.g - rgba1.a + rgba2.a)) + max(pow(rgba1.b - rgba2.b), pow(rgba1.b - rgba2.b - rgba1.a + rgba2.a))) / 195075;
                }, jimpEvMethod("clone", "clone", (function(cb) {
                    var clone = new Jimp(this);
                    return (0, _utils.isNodePattern)(cb) && cb.call(clone, null, clone), clone;
                })), jimpEvChange("background", (function(hex, cb) {
                    return "number" != typeof hex ? _utils.throwError.call(this, "hex must be a hexadecimal rgba value", cb) : (this._background = hex, 
                    (0, _utils.isNodePattern)(cb) && cb.call(this, null, this), this);
                })), jimpEvChange("scan", (function(x, y, w, h, f, cb) {
                    if ("number" != typeof x || "number" != typeof y) return _utils.throwError.call(this, "x and y must be numbers", cb);
                    if ("number" != typeof w || "number" != typeof h) return _utils.throwError.call(this, "w and h must be numbers", cb);
                    if ("function" != typeof f) return _utils.throwError.call(this, "f must be a function", cb);
                    var result = (0, _utils.scan)(this, x, y, w, h, f);
                    return (0, _utils.isNodePattern)(cb) && cb.call(this, null, result), result;
                }));
                var _default = Jimp;
                exports.default = _default;
            }).call(this, require("buffer").Buffer);
        }, {
            "./composite": 191,
            "./constants": 192,
            "./modules/phash": 194,
            "./request": 195,
            "./utils/image-bitmap": 196,
            "./utils/mime": 197,
            "./utils/promisify": 198,
            "@babel/runtime/helpers/assertThisInitialized": 3,
            "@babel/runtime/helpers/classCallCheck": 4,
            "@babel/runtime/helpers/construct": 5,
            "@babel/runtime/helpers/createClass": 6,
            "@babel/runtime/helpers/defineProperty": 7,
            "@babel/runtime/helpers/getPrototypeOf": 9,
            "@babel/runtime/helpers/inherits": 10,
            "@babel/runtime/helpers/interopRequireDefault": 11,
            "@babel/runtime/helpers/interopRequireWildcard": 12,
            "@babel/runtime/helpers/possibleConstructorReturn": 17,
            "@babel/runtime/helpers/slicedToArray": 19,
            "@babel/runtime/helpers/typeof": 21,
            "@jimp/utils": 235,
            "any-base": 23,
            buffer: 48,
            events: 52,
            fs: 47,
            mkdirp: 83,
            path: 107,
            pixelmatch: 109,
            tinycolor2: 178
        } ],
        194: [ function(require, module, exports) {
            function ImagePHash(size, smallerSize) {
                this.size = this.size || size, this.smallerSize = this.smallerSize || smallerSize, 
                function initCoefficients(size) {
                    for (var i = 1; i < size; i++) c[i] = 1;
                    c[0] = 1 / Math.sqrt(2.0);
                }(this.size);
            }
            ImagePHash.prototype.size = 32, ImagePHash.prototype.smallerSize = 8, ImagePHash.prototype.distance = function(s1, s2) {
                for (var counter = 0, k = 0; k < s1.length; k++) s1[k] !== s2[k] && counter++;
                return counter / s1.length;
            }, ImagePHash.prototype.getHash = function(img) {
                (img = img.clone().resize(this.size, this.size)).grayscale();
                for (var vals = [], x = 0; x < img.bitmap.width; x++) {
                    vals[x] = [];
                    for (var y = 0; y < img.bitmap.height; y++) vals[x][y] = (i = img.getPixelColor(x, y), 
                    rgba = void 0, rgba = {}, rgba.r = Math.floor(i / Math.pow(256, 3)), rgba.g = Math.floor((i - rgba.r * Math.pow(256, 3)) / Math.pow(256, 2)), 
                    rgba.b = Math.floor((i - rgba.r * Math.pow(256, 3) - rgba.g * Math.pow(256, 2)) / Math.pow(256, 1)), 
                    rgba.a = Math.floor((i - rgba.r * Math.pow(256, 3) - rgba.g * Math.pow(256, 2) - rgba.b * Math.pow(256, 1)) / Math.pow(256, 0)), 
                    rgba).b;
                }
                for (var i, rgba, dctVals = function applyDCT(f, size) {
                    for (var N = size, F = [], u = 0; u < N; u++) {
                        F[u] = [];
                        for (var v = 0; v < N; v++) {
                            for (var sum = 0, i = 0; i < N; i++) for (var j = 0; j < N; j++) sum += Math.cos((2 * i + 1) / (2.0 * N) * u * Math.PI) * Math.cos((2 * j + 1) / (2.0 * N) * v * Math.PI) * f[i][j];
                            sum *= c[u] * c[v] / 4, F[u][v] = sum;
                        }
                    }
                    return F;
                }(vals, this.size), total = 0, _x = 0; _x < this.smallerSize; _x++) for (var _y = 0; _y < this.smallerSize; _y++) total += dctVals[_x][_y];
                for (var avg = total / (this.smallerSize * this.smallerSize), hash = "", _x2 = 0; _x2 < this.smallerSize; _x2++) for (var _y2 = 0; _y2 < this.smallerSize; _y2++) hash += dctVals[_x2][_y2] > avg ? "1" : "0";
                return hash;
            };
            var c = [];
            module.exports = ImagePHash;
        }, {} ],
        195: [ function(require, module, exports) {
            (function(process, Buffer) {
                var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
                _interopRequireDefault(require("@babel/runtime/helpers/defineProperty")), _interopRequireDefault(require("@babel/runtime/helpers/extends")), 
                process.browser, module.exports = function(options, cb) {
                    var xhr = new XMLHttpRequest;
                    xhr.open("GET", options.url, !0), xhr.responseType = "arraybuffer", xhr.addEventListener("load", (function() {
                        if (xhr.status < 400) try {
                            var data = Buffer.from(this.response);
                            cb(null, xhr, data);
                        } catch (error) {
                            return cb(new Error("Response is not a buffer for url " + options.url + ". Error: " + error.message));
                        } else cb(new Error("HTTP Status " + xhr.status + " for url " + options.url));
                    })), xhr.addEventListener("error", (function(e) {
                        cb(e);
                    })), xhr.send();
                };
            }).call(this, require("_process"), require("buffer").Buffer);
        }, {
            "@babel/runtime/helpers/defineProperty": 7,
            "@babel/runtime/helpers/extends": 8,
            "@babel/runtime/helpers/interopRequireDefault": 11,
            _process: 133,
            buffer: 48,
            phin: 108
        } ],
        196: [ function(require, module, exports) {
            (function(Buffer) {
                var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard"), _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
                Object.defineProperty(exports, "__esModule", {
                    value: !0
                }), exports.parseBitmap = function parseBitmap(data, path, cb) {
                    var mime = function getMIMEFromBuffer(buffer, path) {
                        var fileTypeFromBuffer = (0, _fileType.default)(buffer);
                        return fileTypeFromBuffer ? fileTypeFromBuffer.mime : path ? MIME.getType(path) : null;
                    }(data, path);
                    if ("string" != typeof mime) return cb(new Error("Could not find MIME for Buffer <" + path + ">"));
                    this._originalMime = mime.toLowerCase();
                    try {
                        var _mime = this.getMIME();
                        if (!this.constructor.decoders[_mime]) return _utils.throwError.call(this, "Unsupported MIME type: " + _mime, cb);
                        this.bitmap = this.constructor.decoders[_mime](data);
                    } catch (error) {
                        return cb.call(this, error, this);
                    }
                    try {
                        this._exif = _exifParser.default.create(data).parse(), function exifRotate(img) {
                            if (!(getExifOrientation(img) < 2)) {
                                var transformation = function getExifOrientationTransformation(img) {
                                    var w = img.getWidth(), h = img.getHeight();
                                    switch (getExifOrientation(img)) {
                                      case 1:
                                      default:
                                        return null;

                                      case 2:
                                        return function(x, y) {
                                            return [ w - x - 1, y ];
                                        };

                                      case 3:
                                        return function(x, y) {
                                            return [ w - x - 1, h - y - 1 ];
                                        };

                                      case 4:
                                        return function(x, y) {
                                            return [ x, h - y - 1 ];
                                        };

                                      case 5:
                                        return function(x, y) {
                                            return [ y, x ];
                                        };

                                      case 6:
                                        return function(x, y) {
                                            return [ y, h - x - 1 ];
                                        };

                                      case 7:
                                        return function(x, y) {
                                            return [ w - y - 1, h - x - 1 ];
                                        };

                                      case 8:
                                        return function(x, y) {
                                            return [ w - y - 1, x ];
                                        };
                                    }
                                }(img), swapDimensions = getExifOrientation(img) > 4;
                                !function transformBitmap(img, width, height, transformation) {
                                    for (var _data = img.bitmap.data, _width = img.bitmap.width, data = Buffer.alloc(_data.length), x = 0; x < width; x++) for (var y = 0; y < height; y++) {
                                        var _transformation = transformation(x, y), _transformation2 = (0, _slicedToArray2.default)(_transformation, 2), _x = _transformation2[0], idx = width * y + x << 2, _idx = _width * _transformation2[1] + _x << 2, pixel = _data.readUInt32BE(_idx);
                                        data.writeUInt32BE(pixel, idx);
                                    }
                                    img.bitmap.data = data, img.bitmap.width = width, img.bitmap.height = height;
                                }(img, swapDimensions ? img.bitmap.height : img.bitmap.width, swapDimensions ? img.bitmap.width : img.bitmap.height, transformation);
                            }
                        }(this);
                    } catch (error) {}
                    return cb.call(this, null, this), this;
                }, exports.getBuffer = getBuffer, exports.getBufferAsync = function getBufferAsync(mime) {
                    return (0, _promisify.default)(getBuffer, this, mime);
                };
                var _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray")), _fileType = _interopRequireDefault(require("file-type")), _exifParser = _interopRequireDefault(require("exif-parser")), _utils = require("@jimp/utils"), constants = _interopRequireWildcard(require("../constants")), MIME = _interopRequireWildcard(require("./mime")), _promisify = _interopRequireDefault(require("./promisify"));
                function getExifOrientation(img) {
                    return img._exif && img._exif.tags && img._exif.tags.Orientation || 1;
                }
                function getBuffer(mime, cb) {
                    if (mime === constants.AUTO && (mime = this.getMIME()), "string" != typeof mime) return _utils.throwError.call(this, "mime must be a string", cb);
                    if ("function" != typeof cb) return _utils.throwError.call(this, "cb must be a function", cb);
                    if (mime = mime.toLowerCase(), this._rgba && this.constructor.hasAlpha[mime] ? this.bitmap.data = Buffer.from(this.bitmap.data) : this.bitmap.data = function compositeBitmapOverBackground(Jimp, image) {
                        return new Jimp(image.bitmap.width, image.bitmap.height, image._background).composite(image, 0, 0).bitmap;
                    }(this.constructor, this).data, this.constructor.encoders[mime]) {
                        var buffer = this.constructor.encoders[mime](this);
                        cb.call(this, null, buffer);
                    } else cb.call(this, "Unsupported MIME type: " + mime);
                    return this;
                }
            }).call(this, require("buffer").Buffer);
        }, {
            "../constants": 192,
            "./mime": 197,
            "./promisify": 198,
            "@babel/runtime/helpers/interopRequireDefault": 11,
            "@babel/runtime/helpers/interopRequireWildcard": 12,
            "@babel/runtime/helpers/slicedToArray": 19,
            "@jimp/utils": 235,
            buffer: 48,
            "exif-parser": 53,
            "file-type": 62
        } ],
        197: [ function(require, module, exports) {
            Object.defineProperty(exports, "__esModule", {
                value: !0
            }), exports.getExtension = exports.getType = exports.addType = void 0;
            var mimeTypes = {};
            exports.addType = function addType(mime, extensions) {
                mimeTypes[mime] = extensions;
            }, exports.getType = function getType(path) {
                var pathParts = path.split("/").slice(-1);
                return function findType(extension) {
                    return Object.entries(mimeTypes).find((function(type) {
                        return type[1].includes(extension);
                    })) || [];
                }(pathParts[pathParts.length - 1].split(".").pop())[0];
            }, exports.getExtension = function getExtension(type) {
                return (mimeTypes[type.toLowerCase()] || [])[0];
            };
        }, {} ],
        198: [ function(require, module, exports) {
            Object.defineProperty(exports, "__esModule", {
                value: !0
            }), exports.default = void 0;
            exports.default = function promisify(fun, ctx) {
                for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) args[_key - 2] = arguments[_key];
                return new Promise((function(resolve, reject) {
                    args.push((function(err, data) {
                        err && reject(err), resolve(data);
                    })), fun.bind(ctx).apply(void 0, args);
                }));
            }, module.exports = exports.default;
        }, {} ],
        199: [ function(require, module, exports) {
            var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard"), _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
            Object.defineProperty(exports, "__esModule", {
                value: !0
            }), exports.default = function configure(configuration) {
                var jimpInstance = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : _core.default, jimpConfig = {
                    hasAlpha: {},
                    encoders: {},
                    decoders: {},
                    class: {},
                    constants: {}
                };
                function addToConfig(newConfig) {
                    Object.entries(newConfig).forEach((function(_ref) {
                        var _ref2 = (0, _slicedToArray2.default)(_ref, 2), key = _ref2[0], value = _ref2[1];
                        jimpConfig[key] = _objectSpread({}, jimpConfig[key], {}, value);
                    }));
                }
                function addImageType(typeModule) {
                    var type = typeModule();
                    Array.isArray(type.mime) ? _core.addType.apply(void 0, (0, _toConsumableArray2.default)(type.mime)) : Object.entries(type.mime).forEach((function(mimeType) {
                        return _core.addType.apply(void 0, (0, _toConsumableArray2.default)(mimeType));
                    })), delete type.mime, addToConfig(type);
                }
                function addPlugin(pluginModule) {
                    var plugin = pluginModule(_core.jimpEvChange) || {};
                    plugin.class || plugin.constants ? addToConfig(plugin) : addToConfig({
                        class: plugin
                    });
                }
                return configuration.types && (configuration.types.forEach(addImageType), jimpInstance.decoders = _objectSpread({}, jimpInstance.decoders, {}, jimpConfig.decoders), 
                jimpInstance.encoders = _objectSpread({}, jimpInstance.encoders, {}, jimpConfig.encoders), 
                jimpInstance.hasAlpha = _objectSpread({}, jimpInstance.hasAlpha, {}, jimpConfig.hasAlpha)), 
                configuration.plugins && configuration.plugins.forEach(addPlugin), (0, _core.addJimpMethods)(jimpConfig.class, jimpInstance), 
                (0, _core.addConstants)(jimpConfig.constants, jimpInstance), _core.default;
            };
            var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray")), _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty")), _slicedToArray2 = _interopRequireDefault(require("@babel/runtime/helpers/slicedToArray")), _core = _interopRequireWildcard(require("@jimp/core"));
            function ownKeys(object, enumerableOnly) {
                var keys = Object.keys(object);
                if (Object.getOwnPropertySymbols) {
                    var symbols = Object.getOwnPropertySymbols(object);
                    enumerableOnly && (symbols = symbols.filter((function(sym) {
                        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
                    }))), keys.push.apply(keys, symbols);
                }
                return keys;
            }
            function _objectSpread(target) {
                for (var i = 1; i < arguments.length; i++) {
                    var source = null != arguments[i] ? arguments[i] : {};
                    i % 2 ? ownKeys(source, !0).forEach((function(key) {
                        (0, _defineProperty2.default)(target, key, source[key]);
                    })) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(source).forEach((function(key) {
                        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
                    }));
                }
                return target;
            }
            module.exports = exports.default;
        }, {
            "@babel/runtime/helpers/defineProperty": 7,
            "@babel/runtime/helpers/interopRequireDefault": 11,
            "@babel/runtime/helpers/interopRequireWildcard": 12,
            "@babel/runtime/helpers/slicedToArray": 19,
            "@babel/runtime/helpers/toConsumableArray": 20,
            "@jimp/core": 193
        } ],
        200: [ function(require, module, exports) {
            var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
            Object.defineProperty(exports, "__esModule", {
                value: !0
            }), exports.default = void 0;
            var _custom = _interopRequireDefault(require("@jimp/custom")), _types = _interopRequireDefault(require("@jimp/types")), _plugins = _interopRequireDefault(require("@jimp/plugins")), _default = (0, 
            _custom.default)({
                types: [ _types.default ],
                plugins: [ _plugins.default ]
            });
            exports.default = _default, module.exports = exports.default;
        }, {
            "@babel/runtime/helpers/interopRequireDefault": 11,
            "@jimp/custom": 199,
            "@jimp/plugins": 228,
            "@jimp/types": 234
        } ],
        201: [ function(require, module, exports) {
            var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
            Object.defineProperty(exports, "__esModule", {
                value: !0
            }), exports.default = void 0;
            var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof")), _utils = require("@jimp/utils");
            exports.default = function _default() {
                return {
                    blit: function blit(src, x, y, srcx, srcy, srcw, srch, cb) {
                        if (!(src instanceof this.constructor)) return _utils.throwError.call(this, "The source must be a Jimp image", cb);
                        if ("number" != typeof x || "number" != typeof y) return _utils.throwError.call(this, "x and y must be numbers", cb);
                        if ("function" == typeof srcx) cb = srcx, srcx = 0, srcy = 0, srcw = src.bitmap.width, 
                        srch = src.bitmap.height; else {
                            if ((0, _typeof2.default)(srcx) !== (0, _typeof2.default)(srcy) || (0, _typeof2.default)(srcy) !== (0, 
                            _typeof2.default)(srcw) || (0, _typeof2.default)(srcw) !== (0, _typeof2.default)(srch)) return _utils.throwError.call(this, "srcx, srcy, srcw, srch must be numbers", cb);
                            srcx = srcx || 0, srcy = srcy || 0, srcw = srcw || src.bitmap.width, srch = srch || src.bitmap.height;
                        }
                        x = Math.round(x), y = Math.round(y), srcx = Math.round(srcx), srcy = Math.round(srcy), 
                        srcw = Math.round(srcw), srch = Math.round(srch);
                        var maxWidth = this.bitmap.width, maxHeight = this.bitmap.height, baseImage = this;
                        return src.scanQuiet(srcx, srcy, srcw, srch, (function(sx, sy, idx) {
                            var xOffset = x + sx - srcx, yOffset = y + sy - srcy;
                            if (xOffset >= 0 && yOffset >= 0 && maxWidth - xOffset > 0 && maxHeight - yOffset > 0) {
                                var dstIdx = baseImage.getPixelIndex(xOffset, yOffset), _src = {
                                    r: this.bitmap.data[idx],
                                    g: this.bitmap.data[idx + 1],
                                    b: this.bitmap.data[idx + 2],
                                    a: this.bitmap.data[idx + 3]
                                }, dst = {
                                    r: baseImage.bitmap.data[dstIdx],
                                    g: baseImage.bitmap.data[dstIdx + 1],
                                    b: baseImage.bitmap.data[dstIdx + 2],
                                    a: baseImage.bitmap.data[dstIdx + 3]
                                };
                                baseImage.bitmap.data[dstIdx] = (_src.a * (_src.r - dst.r) - dst.r + 255 >> 8) + dst.r, 
                                baseImage.bitmap.data[dstIdx + 1] = (_src.a * (_src.g - dst.g) - dst.g + 255 >> 8) + dst.g, 
                                baseImage.bitmap.data[dstIdx + 2] = (_src.a * (_src.b - dst.b) - dst.b + 255 >> 8) + dst.b, 
                                baseImage.bitmap.data[dstIdx + 3] = this.constructor.limit255(dst.a + _src.a);
                            }
                        })), (0, _utils.isNodePattern)(cb) && cb.call(this, null, this), this;
                    }
                };
            }, module.exports = exports.default;
        }, {
            "@babel/runtime/helpers/interopRequireDefault": 11,
            "@babel/runtime/helpers/typeof": 21,
            "@jimp/utils": 235
        } ],
        202: [ function(require, module, exports) {
            Object.defineProperty(exports, "__esModule", {
                value: !0
            }), exports.shgTable = exports.mulTable = void 0, exports.mulTable = [ 1, 57, 41, 21, 203, 34, 97, 73, 227, 91, 149, 62, 105, 45, 39, 137, 241, 107, 3, 173, 39, 71, 65, 238, 219, 101, 187, 87, 81, 151, 141, 133, 249, 117, 221, 209, 197, 187, 177, 169, 5, 153, 73, 139, 133, 127, 243, 233, 223, 107, 103, 99, 191, 23, 177, 171, 165, 159, 77, 149, 9, 139, 135, 131, 253, 245, 119, 231, 224, 109, 211, 103, 25, 195, 189, 23, 45, 175, 171, 83, 81, 79, 155, 151, 147, 9, 141, 137, 67, 131, 129, 251, 123, 30, 235, 115, 113, 221, 217, 53, 13, 51, 50, 49, 193, 189, 185, 91, 179, 175, 43, 169, 83, 163, 5, 79, 155, 19, 75, 147, 145, 143, 35, 69, 17, 67, 33, 65, 255, 251, 247, 243, 239, 59, 29, 229, 113, 111, 219, 27, 213, 105, 207, 51, 201, 199, 49, 193, 191, 47, 93, 183, 181, 179, 11, 87, 43, 85, 167, 165, 163, 161, 159, 157, 155, 77, 19, 75, 37, 73, 145, 143, 141, 35, 138, 137, 135, 67, 33, 131, 129, 255, 63, 250, 247, 61, 121, 239, 237, 117, 29, 229, 227, 225, 111, 55, 109, 216, 213, 211, 209, 207, 205, 203, 201, 199, 197, 195, 193, 48, 190, 47, 93, 185, 183, 181, 179, 178, 176, 175, 173, 171, 85, 21, 167, 165, 41, 163, 161, 5, 79, 157, 78, 154, 153, 19, 75, 149, 74, 147, 73, 144, 143, 71, 141, 140, 139, 137, 17, 135, 134, 133, 66, 131, 65, 129, 1 ], 
            exports.shgTable = [ 0, 9, 10, 10, 14, 12, 14, 14, 16, 15, 16, 15, 16, 15, 15, 17, 18, 17, 12, 18, 16, 17, 17, 19, 19, 18, 19, 18, 18, 19, 19, 19, 20, 19, 20, 20, 20, 20, 20, 20, 15, 20, 19, 20, 20, 20, 21, 21, 21, 20, 20, 20, 21, 18, 21, 21, 21, 21, 20, 21, 17, 21, 21, 21, 22, 22, 21, 22, 22, 21, 22, 21, 19, 22, 22, 19, 20, 22, 22, 21, 21, 21, 22, 22, 22, 18, 22, 22, 21, 22, 22, 23, 22, 20, 23, 22, 22, 23, 23, 21, 19, 21, 21, 21, 23, 23, 23, 22, 23, 23, 21, 23, 22, 23, 18, 22, 23, 20, 22, 23, 23, 23, 21, 22, 20, 22, 21, 22, 24, 24, 24, 24, 24, 22, 21, 24, 23, 23, 24, 21, 24, 23, 24, 22, 24, 24, 22, 24, 24, 22, 23, 24, 24, 24, 20, 23, 22, 23, 24, 24, 24, 24, 24, 24, 24, 23, 21, 23, 22, 23, 24, 24, 24, 22, 24, 24, 24, 23, 22, 24, 24, 25, 23, 25, 25, 23, 24, 25, 25, 24, 22, 25, 25, 25, 24, 23, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 23, 25, 23, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 24, 22, 25, 25, 23, 25, 25, 20, 24, 25, 24, 25, 25, 22, 24, 25, 24, 25, 24, 25, 25, 24, 25, 25, 25, 25, 22, 25, 25, 25, 24, 25, 24, 25, 18 ];
        }, {} ],
        203: [ function(require, module, exports) {
            Object.defineProperty(exports, "__esModule", {
                value: !0
            }), exports.default = void 0;
            var _utils = require("@jimp/utils"), _blurTables = require("./blur-tables");
            exports.default = function _default() {
                return {
                    blur: function blur(r, cb) {
                        if ("number" != typeof r) return _utils.throwError.call(this, "r must be a number", cb);
                        if (r < 1) return _utils.throwError.call(this, "r must be greater than 0", cb);
                        for (var rsum, gsum, bsum, asum, x, y, i, p, p1, p2, yp, yi, yw, pa, wm = this.bitmap.width - 1, hm = this.bitmap.height - 1, rad1 = r + 1, mulSum = _blurTables.mulTable[r], shgSum = _blurTables.shgTable[r], red = [], green = [], blue = [], alpha = [], vmin = [], vmax = [], iterations = 2; iterations-- > 0; ) {
                            for (yi = 0, yw = 0, y = 0; y < this.bitmap.height; y++) {
                                for (rsum = this.bitmap.data[yw] * rad1, gsum = this.bitmap.data[yw + 1] * rad1, 
                                bsum = this.bitmap.data[yw + 2] * rad1, asum = this.bitmap.data[yw + 3] * rad1, 
                                i = 1; i <= r; i++) p = yw + ((i > wm ? wm : i) << 2), rsum += this.bitmap.data[p++], 
                                gsum += this.bitmap.data[p++], bsum += this.bitmap.data[p++], asum += this.bitmap.data[p];
                                for (x = 0; x < this.bitmap.width; x++) red[yi] = rsum, green[yi] = gsum, blue[yi] = bsum, 
                                alpha[yi] = asum, 0 === y && (vmin[x] = ((p = x + rad1) < wm ? p : wm) << 2, vmax[x] = (p = x - r) > 0 ? p << 2 : 0), 
                                p1 = yw + vmin[x], p2 = yw + vmax[x], rsum += this.bitmap.data[p1++] - this.bitmap.data[p2++], 
                                gsum += this.bitmap.data[p1++] - this.bitmap.data[p2++], bsum += this.bitmap.data[p1++] - this.bitmap.data[p2++], 
                                asum += this.bitmap.data[p1] - this.bitmap.data[p2], yi++;
                                yw += this.bitmap.width << 2;
                            }
                            for (x = 0; x < this.bitmap.width; x++) {
                                for (rsum = red[yp = x] * rad1, gsum = green[yp] * rad1, bsum = blue[yp] * rad1, 
                                asum = alpha[yp] * rad1, i = 1; i <= r; i++) rsum += red[yp += i > hm ? 0 : this.bitmap.width], 
                                gsum += green[yp], bsum += blue[yp], asum += alpha[yp];
                                for (yi = x << 2, y = 0; y < this.bitmap.height; y++) pa = asum * mulSum >>> shgSum, 
                                this.bitmap.data[yi + 3] = pa, pa > 255 && (this.bitmap.data[yi + 3] = 255), pa > 0 ? (pa = 255 / pa, 
                                this.bitmap.data[yi] = (rsum * mulSum >>> shgSum) * pa, this.bitmap.data[yi + 1] = (gsum * mulSum >>> shgSum) * pa, 
                                this.bitmap.data[yi + 2] = (bsum * mulSum >>> shgSum) * pa) : (this.bitmap.data[yi + 2] = 0, 
                                this.bitmap.data[yi + 1] = 0, this.bitmap.data[yi] = 0), 0 === x && (vmin[y] = ((p = y + rad1) < hm ? p : hm) * this.bitmap.width, 
                                vmax[y] = (p = y - r) > 0 ? p * this.bitmap.width : 0), p1 = x + vmin[y], p2 = x + vmax[y], 
                                rsum += red[p1] - red[p2], gsum += green[p1] - green[p2], bsum += blue[p1] - blue[p2], 
                                asum += alpha[p1] - alpha[p2], yi += this.bitmap.width << 2;
                            }
                        }
                        return (0, _utils.isNodePattern)(cb) && cb.call(this, null, this), this;
                    }
                };
            }, module.exports = exports.default;
        }, {
            "./blur-tables": 202,
            "@jimp/utils": 235
        } ],
        204: [ function(require, module, exports) {
            Object.defineProperty(exports, "__esModule", {
                value: !0
            }), exports.default = void 0;
            var _utils = require("@jimp/utils");
            exports.default = function _default() {
                return {
                    circle: function circle() {
                        var options = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, cb = arguments.length > 1 ? arguments[1] : void 0;
                        "function" == typeof options && (cb = options, options = {});
                        var radius = options.radius || (this.bitmap.width > this.bitmap.height ? this.bitmap.height : this.bitmap.width) / 2, center = {
                            x: "number" == typeof options.x ? options.x : this.bitmap.width / 2,
                            y: "number" == typeof options.y ? options.y : this.bitmap.height / 2
                        };
                        return this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, (function(x, y, idx) {
                            var curR = Math.sqrt(Math.pow(x - center.x, 2) + Math.pow(y - center.y, 2));
                            radius - curR <= 0.0 ? this.bitmap.data[idx + 3] = 0 : radius - curR < 1.0 && (this.bitmap.data[idx + 3] = 255 * (radius - curR));
                        })), (0, _utils.isNodePattern)(cb) && cb.call(this, null, this), this;
                    }
                };
            }, module.exports = exports.default;
        }, {
            "@jimp/utils": 235
        } ],
        205: [ function(require, module, exports) {
            (function(Buffer) {
                var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
                Object.defineProperty(exports, "__esModule", {
                    value: !0
                }), exports.default = void 0;
                var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray")), _tinycolor = _interopRequireDefault(require("tinycolor2")), _utils = require("@jimp/utils");
                function applyKernel(im, kernel, x, y) {
                    for (var value = [ 0, 0, 0 ], size = (kernel.length - 1) / 2, kx = 0; kx < kernel.length; kx += 1) for (var ky = 0; ky < kernel[kx].length; ky += 1) {
                        var idx = im.getPixelIndex(x + kx - size, y + ky - size);
                        value[0] += im.bitmap.data[idx] * kernel[kx][ky], value[1] += im.bitmap.data[idx + 1] * kernel[kx][ky], 
                        value[2] += im.bitmap.data[idx + 2] * kernel[kx][ky];
                    }
                    return value;
                }
                var isDef = function isDef(v) {
                    return null != v;
                };
                function greyscale(cb) {
                    return this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, (function(x, y, idx) {
                        var grey = parseInt(0.2126 * this.bitmap.data[idx] + 0.7152 * this.bitmap.data[idx + 1] + 0.0722 * this.bitmap.data[idx + 2], 10);
                        this.bitmap.data[idx] = grey, this.bitmap.data[idx + 1] = grey, this.bitmap.data[idx + 2] = grey;
                    })), (0, _utils.isNodePattern)(cb) && cb.call(this, null, this), this;
                }
                function mix(clr, clr2) {
                    var p = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 50;
                    return {
                        r: (clr2.r - clr.r) * (p / 100) + clr.r,
                        g: (clr2.g - clr.g) * (p / 100) + clr.g,
                        b: (clr2.b - clr.b) * (p / 100) + clr.b
                    };
                }
                function colorFn(actions, cb) {
                    var _this = this;
                    return actions && Array.isArray(actions) ? (actions = actions.map((function(action) {
                        return "xor" !== action.apply && "mix" !== action.apply || (action.params[0] = (0, 
                        _tinycolor.default)(action.params[0]).toRgb()), action;
                    })), this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, (function(x, y, idx) {
                        var clr = {
                            r: _this.bitmap.data[idx],
                            g: _this.bitmap.data[idx + 1],
                            b: _this.bitmap.data[idx + 2]
                        }, colorModifier = function colorModifier(i, amount) {
                            return _this.constructor.limit255(clr[i] + amount);
                        };
                        actions.forEach((function(action) {
                            if ("mix" === action.apply) clr = mix(clr, action.params[0], action.params[1]); else if ("tint" === action.apply) clr = mix(clr, {
                                r: 255,
                                g: 255,
                                b: 255
                            }, action.params[0]); else if ("shade" === action.apply) clr = mix(clr, {
                                r: 0,
                                g: 0,
                                b: 0
                            }, action.params[0]); else if ("xor" === action.apply) clr = {
                                r: clr.r ^ action.params[0].r,
                                g: clr.g ^ action.params[0].g,
                                b: clr.b ^ action.params[0].b
                            }; else if ("red" === action.apply) clr.r = colorModifier("r", action.params[0]); else if ("green" === action.apply) clr.g = colorModifier("g", action.params[0]); else if ("blue" === action.apply) clr.b = colorModifier("b", action.params[0]); else {
                                var _clr;
                                if ("hue" === action.apply && (action.apply = "spin"), !(clr = (0, _tinycolor.default)(clr))[action.apply]) return _utils.throwError.call(_this, "action " + action.apply + " not supported", cb);
                                clr = (_clr = clr)[action.apply].apply(_clr, (0, _toConsumableArray2.default)(action.params)).toRgb();
                            }
                        })), _this.bitmap.data[idx] = clr.r, _this.bitmap.data[idx + 1] = clr.g, _this.bitmap.data[idx + 2] = clr.b;
                    })), (0, _utils.isNodePattern)(cb) && cb.call(this, null, this), this) : _utils.throwError.call(this, "actions must be an array", cb);
                }
                exports.default = function _default() {
                    return {
                        brightness: function brightness(val, cb) {
                            return "number" != typeof val ? _utils.throwError.call(this, "val must be numbers", cb) : val < -1 || val > 1 ? _utils.throwError.call(this, "val must be a number between -1 and +1", cb) : (this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, (function(x, y, idx) {
                                val < 0.0 ? (this.bitmap.data[idx] = this.bitmap.data[idx] * (1 + val), this.bitmap.data[idx + 1] = this.bitmap.data[idx + 1] * (1 + val), 
                                this.bitmap.data[idx + 2] = this.bitmap.data[idx + 2] * (1 + val)) : (this.bitmap.data[idx] = this.bitmap.data[idx] + (255 - this.bitmap.data[idx]) * val, 
                                this.bitmap.data[idx + 1] = this.bitmap.data[idx + 1] + (255 - this.bitmap.data[idx + 1]) * val, 
                                this.bitmap.data[idx + 2] = this.bitmap.data[idx + 2] + (255 - this.bitmap.data[idx + 2]) * val);
                            })), (0, _utils.isNodePattern)(cb) && cb.call(this, null, this), this);
                        },
                        contrast: function contrast(val, cb) {
                            if ("number" != typeof val) return _utils.throwError.call(this, "val must be numbers", cb);
                            if (val < -1 || val > 1) return _utils.throwError.call(this, "val must be a number between -1 and +1", cb);
                            var factor = (val + 1) / (1 - val);
                            function adjust(value) {
                                return (value = Math.floor(factor * (value - 127) + 127)) < 0 ? 0 : value > 255 ? 255 : value;
                            }
                            return this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, (function(x, y, idx) {
                                this.bitmap.data[idx] = adjust(this.bitmap.data[idx]), this.bitmap.data[idx + 1] = adjust(this.bitmap.data[idx + 1]), 
                                this.bitmap.data[idx + 2] = adjust(this.bitmap.data[idx + 2]);
                            })), (0, _utils.isNodePattern)(cb) && cb.call(this, null, this), this;
                        },
                        posterize: function posterize(n, cb) {
                            return "number" != typeof n ? _utils.throwError.call(this, "n must be numbers", cb) : (n < 2 && (n = 2), 
                            this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, (function(x, y, idx) {
                                this.bitmap.data[idx] = Math.floor(this.bitmap.data[idx] / 255 * (n - 1)) / (n - 1) * 255, 
                                this.bitmap.data[idx + 1] = Math.floor(this.bitmap.data[idx + 1] / 255 * (n - 1)) / (n - 1) * 255, 
                                this.bitmap.data[idx + 2] = Math.floor(this.bitmap.data[idx + 2] / 255 * (n - 1)) / (n - 1) * 255;
                            })), (0, _utils.isNodePattern)(cb) && cb.call(this, null, this), this);
                        },
                        greyscale,
                        grayscale: greyscale,
                        opacity: function opacity(f, cb) {
                            return "number" != typeof f ? _utils.throwError.call(this, "f must be a number", cb) : f < 0 || f > 1 ? _utils.throwError.call(this, "f must be a number from 0 to 1", cb) : (this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, (function(x, y, idx) {
                                var v = this.bitmap.data[idx + 3] * f;
                                this.bitmap.data[idx + 3] = v;
                            })), (0, _utils.isNodePattern)(cb) && cb.call(this, null, this), this);
                        },
                        sepia: function sepia(cb) {
                            return this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, (function(x, y, idx) {
                                var red = this.bitmap.data[idx], green = this.bitmap.data[idx + 1], blue = this.bitmap.data[idx + 2];
                                blue = 0.272 * (red = 0.393 * red + 0.769 * green + 0.189 * blue) + 0.534 * (green = 0.349 * red + 0.686 * green + 0.168 * blue) + 0.131 * blue, 
                                this.bitmap.data[idx] = red < 255 ? red : 255, this.bitmap.data[idx + 1] = green < 255 ? green : 255, 
                                this.bitmap.data[idx + 2] = blue < 255 ? blue : 255;
                            })), (0, _utils.isNodePattern)(cb) && cb.call(this, null, this), this;
                        },
                        fade: function fade(f, cb) {
                            return "number" != typeof f ? _utils.throwError.call(this, "f must be a number", cb) : f < 0 || f > 1 ? _utils.throwError.call(this, "f must be a number from 0 to 1", cb) : (this.opacity(1 - f), 
                            (0, _utils.isNodePattern)(cb) && cb.call(this, null, this), this);
                        },
                        convolution: function convolution(kernel, edgeHandling, cb) {
                            "function" == typeof edgeHandling && void 0 === cb && (cb = edgeHandling, edgeHandling = null), 
                            edgeHandling || (edgeHandling = this.constructor.EDGE_EXTEND);
                            var weight, rSum, gSum, bSum, ri, gi, bi, xi, yi, idxi, newData = Buffer.from(this.bitmap.data), kRows = kernel.length, kCols = kernel[0].length, rowEnd = Math.floor(kRows / 2), colEnd = Math.floor(kCols / 2), rowIni = -rowEnd, colIni = -colEnd;
                            return this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, (function(x, y, idx) {
                                bSum = 0, gSum = 0, rSum = 0;
                                for (var row = rowIni; row <= rowEnd; row++) for (var col = colIni; col <= colEnd; col++) xi = x + col, 
                                yi = y + row, weight = kernel[row + rowEnd][col + colEnd], -1 === (idxi = this.getPixelIndex(xi, yi, edgeHandling)) ? (bi = 0, 
                                gi = 0, ri = 0) : (ri = this.bitmap.data[idxi + 0], gi = this.bitmap.data[idxi + 1], 
                                bi = this.bitmap.data[idxi + 2]), rSum += weight * ri, gSum += weight * gi, bSum += weight * bi;
                                rSum < 0 && (rSum = 0), gSum < 0 && (gSum = 0), bSum < 0 && (bSum = 0), rSum > 255 && (rSum = 255), 
                                gSum > 255 && (gSum = 255), bSum > 255 && (bSum = 255), newData[idx + 0] = rSum, 
                                newData[idx + 1] = gSum, newData[idx + 2] = bSum;
                            })), this.bitmap.data = newData, (0, _utils.isNodePattern)(cb) && cb.call(this, null, this), 
                            this;
                        },
                        opaque: function opaque(cb) {
                            return this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, (function(x, y, idx) {
                                this.bitmap.data[idx + 3] = 255;
                            })), (0, _utils.isNodePattern)(cb) && cb.call(this, null, this), this;
                        },
                        pixelate: function pixelate(size, x, y, w, h, cb) {
                            if ("function" == typeof x) cb = x, h = null, w = null, y = null, x = null; else {
                                if ("number" != typeof size) return _utils.throwError.call(this, "size must be a number", cb);
                                if (isDef(x) && "number" != typeof x) return _utils.throwError.call(this, "x must be a number", cb);
                                if (isDef(y) && "number" != typeof y) return _utils.throwError.call(this, "y must be a number", cb);
                                if (isDef(w) && "number" != typeof w) return _utils.throwError.call(this, "w must be a number", cb);
                                if (isDef(h) && "number" != typeof h) return _utils.throwError.call(this, "h must be a number", cb);
                            }
                            var kernel = [ [ 1 / 16, 2 / 16, 1 / 16 ], [ 2 / 16, .25, 2 / 16 ], [ 1 / 16, 2 / 16, 1 / 16 ] ];
                            x = x || 0, y = y || 0, w = isDef(w) ? w : this.bitmap.width - x, h = isDef(h) ? h : this.bitmap.height - y;
                            var source = this.cloneQuiet();
                            return this.scanQuiet(x, y, w, h, (function(xx, yx, idx) {
                                xx = size * Math.floor(xx / size), yx = size * Math.floor(yx / size);
                                var value = applyKernel(source, kernel, xx, yx);
                                this.bitmap.data[idx] = value[0], this.bitmap.data[idx + 1] = value[1], this.bitmap.data[idx + 2] = value[2];
                            })), (0, _utils.isNodePattern)(cb) && cb.call(this, null, this), this;
                        },
                        convolute: function convolute(kernel, x, y, w, h, cb) {
                            if (!Array.isArray(kernel)) return _utils.throwError.call(this, "the kernel must be an array", cb);
                            if ("function" == typeof x) cb = x, x = null, y = null, w = null, h = null; else {
                                if (isDef(x) && "number" != typeof x) return _utils.throwError.call(this, "x must be a number", cb);
                                if (isDef(y) && "number" != typeof y) return _utils.throwError.call(this, "y must be a number", cb);
                                if (isDef(w) && "number" != typeof w) return _utils.throwError.call(this, "w must be a number", cb);
                                if (isDef(h) && "number" != typeof h) return _utils.throwError.call(this, "h must be a number", cb);
                            }
                            var ksize = (kernel.length - 1) / 2;
                            x = isDef(x) ? x : ksize, y = isDef(y) ? y : ksize, w = isDef(w) ? w : this.bitmap.width - x, 
                            h = isDef(h) ? h : this.bitmap.height - y;
                            var source = this.cloneQuiet();
                            return this.scanQuiet(x, y, w, h, (function(xx, yx, idx) {
                                var value = applyKernel(source, kernel, xx, yx);
                                this.bitmap.data[idx] = this.constructor.limit255(value[0]), this.bitmap.data[idx + 1] = this.constructor.limit255(value[1]), 
                                this.bitmap.data[idx + 2] = this.constructor.limit255(value[2]);
                            })), (0, _utils.isNodePattern)(cb) && cb.call(this, null, this), this;
                        },
                        color: colorFn,
                        colour: colorFn
                    };
                }, module.exports = exports.default;
            }).call(this, require("buffer").Buffer);
        }, {
            "@babel/runtime/helpers/interopRequireDefault": 11,
            "@babel/runtime/helpers/toConsumableArray": 20,
            "@jimp/utils": 235,
            buffer: 48,
            tinycolor2: 178
        } ],
        206: [ function(require, module, exports) {
            Object.defineProperty(exports, "__esModule", {
                value: !0
            }), exports.default = void 0;
            var _utils = require("@jimp/utils");
            exports.default = function _default() {
                return {
                    contain: function contain(w, h, alignBits, mode, cb) {
                        if ("number" != typeof w || "number" != typeof h) return _utils.throwError.call(this, "w and h must be numbers", cb);
                        "string" == typeof alignBits && ("function" == typeof mode && void 0 === cb && (cb = mode), 
                        mode = alignBits, alignBits = null), "function" == typeof alignBits && (void 0 === cb && (cb = alignBits), 
                        mode = null, alignBits = null), "function" == typeof mode && void 0 === cb && (cb = mode, 
                        mode = null);
                        var hbits = 7 & (alignBits = alignBits || this.constructor.HORIZONTAL_ALIGN_CENTER | this.constructor.VERTICAL_ALIGN_MIDDLE), vbits = alignBits >> 3;
                        if ((0 === hbits || hbits & hbits - 1) && (0 === vbits || vbits & vbits - 1)) return _utils.throwError.call(this, "only use one flag per alignment direction", cb);
                        var alignH = hbits >> 1, alignV = vbits >> 1, f = w / h > this.bitmap.width / this.bitmap.height ? h / this.bitmap.height : w / this.bitmap.width, c = this.cloneQuiet().scale(f, mode);
                        return this.resize(w, h, mode), this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, (function(x, y, idx) {
                            this.bitmap.data.writeUInt32BE(this._background, idx);
                        })), this.blit(c, (this.bitmap.width - c.bitmap.width) / 2 * alignH, (this.bitmap.height - c.bitmap.height) / 2 * alignV), 
                        (0, _utils.isNodePattern)(cb) && cb.call(this, null, this), this;
                    }
                };
            }, module.exports = exports.default;
        }, {
            "@jimp/utils": 235
        } ],
        207: [ function(require, module, exports) {
            Object.defineProperty(exports, "__esModule", {
                value: !0
            }), exports.default = void 0;
            var _utils = require("@jimp/utils");
            exports.default = function _default() {
                return {
                    cover: function cover(w, h, alignBits, mode, cb) {
                        if ("number" != typeof w || "number" != typeof h) return _utils.throwError.call(this, "w and h must be numbers", cb);
                        alignBits && "function" == typeof alignBits && void 0 === cb ? (cb = alignBits, 
                        alignBits = null, mode = null) : "function" == typeof mode && void 0 === cb && (cb = mode, 
                        mode = null);
                        var hbits = 7 & (alignBits = alignBits || this.constructor.HORIZONTAL_ALIGN_CENTER | this.constructor.VERTICAL_ALIGN_MIDDLE), vbits = alignBits >> 3;
                        if ((0 === hbits || hbits & hbits - 1) && (0 === vbits || vbits & vbits - 1)) return _utils.throwError.call(this, "only use one flag per alignment direction", cb);
                        var alignH = hbits >> 1, alignV = vbits >> 1, f = w / h > this.bitmap.width / this.bitmap.height ? w / this.bitmap.width : h / this.bitmap.height;
                        return this.scale(f, mode), this.crop((this.bitmap.width - w) / 2 * alignH, (this.bitmap.height - h) / 2 * alignV, w, h), 
                        (0, _utils.isNodePattern)(cb) && cb.call(this, null, this), this;
                    }
                };
            }, module.exports = exports.default;
        }, {
            "@jimp/utils": 235
        } ],
        208: [ function(require, module, exports) {
            (function(Buffer) {
                var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
                Object.defineProperty(exports, "__esModule", {
                    value: !0
                }), exports.default = function pluginCrop(event) {
                    return event("crop", (function(x, y, w, h, cb) {
                        if ("number" != typeof x || "number" != typeof y) return _utils.throwError.call(this, "x and y must be numbers", cb);
                        if ("number" != typeof w || "number" != typeof h) return _utils.throwError.call(this, "w and h must be numbers", cb);
                        if (x = Math.round(x), y = Math.round(y), w = Math.round(w), h = Math.round(h), 
                        0 === x && w === this.bitmap.width) {
                            var start = w * y + x << 2, end = start + h * w << 2;
                            this.bitmap.data = this.bitmap.data.slice(start, end);
                        } else {
                            var bitmap = Buffer.allocUnsafe(w * h * 4), offset = 0;
                            this.scanQuiet(x, y, w, h, (function(x, y, idx) {
                                var data = this.bitmap.data.readUInt32BE(idx, !0);
                                bitmap.writeUInt32BE(data, offset, !0), offset += 4;
                            })), this.bitmap.data = bitmap;
                        }
                        return this.bitmap.width = w, this.bitmap.height = h, (0, _utils.isNodePattern)(cb) && cb.call(this, null, this), 
                        this;
                    })), {
                        class: {
                            autocrop: function autocrop() {
                                for (var cb, w = this.bitmap.width, h = this.bitmap.height, minPixelsPerSide = 1, leaveBorder = 0, tolerance = 0.0002, cropOnlyFrames = !0, cropSymmetric = !1, ignoreSides = {
                                    north: !1,
                                    south: !1,
                                    east: !1,
                                    west: !1
                                }, _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
                                for (var a = 0, len = args.length; a < len; a++) if ("number" == typeof args[a] && (tolerance = args[a]), 
                                "boolean" == typeof args[a] && (cropOnlyFrames = args[a]), "function" == typeof args[a] && (cb = args[a]), 
                                "object" === (0, _typeof2.default)(args[a])) {
                                    var config = args[a];
                                    void 0 !== config.tolerance && (tolerance = config.tolerance), void 0 !== config.cropOnlyFrames && (cropOnlyFrames = config.cropOnlyFrames), 
                                    void 0 !== config.cropSymmetric && (cropSymmetric = config.cropSymmetric), void 0 !== config.leaveBorder && (leaveBorder = config.leaveBorder), 
                                    void 0 !== config.ignoreSides && (ignoreSides = config.ignoreSides);
                                }
                                var colorTarget = this.getPixelColor(0, 0), rgba1 = this.constructor.intToRGBA(colorTarget), northPixelsToCrop = 0, eastPixelsToCrop = 0, southPixelsToCrop = 0, westPixelsToCrop = 0;
                                if (colorTarget = this.getPixelColor(0, 0), !ignoreSides.north) north: for (var y = 0; y < h - minPixelsPerSide; y++) {
                                    for (var x = 0; x < w; x++) {
                                        var colorXY = this.getPixelColor(x, y), rgba2 = this.constructor.intToRGBA(colorXY);
                                        if (this.constructor.colorDiff(rgba1, rgba2) > tolerance) break north;
                                    }
                                    northPixelsToCrop++;
                                }
                                if (colorTarget = this.getPixelColor(w, 0), !ignoreSides.east) east: for (var _x = 0; _x < w - minPixelsPerSide; _x++) {
                                    for (var _y = 0 + northPixelsToCrop; _y < h; _y++) {
                                        var _colorXY = this.getPixelColor(_x, _y), _rgba = this.constructor.intToRGBA(_colorXY);
                                        if (this.constructor.colorDiff(rgba1, _rgba) > tolerance) break east;
                                    }
                                    eastPixelsToCrop++;
                                }
                                if (colorTarget = this.getPixelColor(0, h), !ignoreSides.south) south: for (var _y2 = h - 1; _y2 >= northPixelsToCrop + minPixelsPerSide; _y2--) {
                                    for (var _x2 = w - eastPixelsToCrop - 1; _x2 >= 0; _x2--) {
                                        var _colorXY2 = this.getPixelColor(_x2, _y2), _rgba2 = this.constructor.intToRGBA(_colorXY2);
                                        if (this.constructor.colorDiff(rgba1, _rgba2) > tolerance) break south;
                                    }
                                    southPixelsToCrop++;
                                }
                                if (colorTarget = this.getPixelColor(w, h), !ignoreSides.west) west: for (var _x3 = w - 1; _x3 >= 0 + eastPixelsToCrop + minPixelsPerSide; _x3--) {
                                    for (var _y3 = h - 1; _y3 >= 0 + northPixelsToCrop; _y3--) {
                                        var _colorXY3 = this.getPixelColor(_x3, _y3), _rgba3 = this.constructor.intToRGBA(_colorXY3);
                                        if (this.constructor.colorDiff(rgba1, _rgba3) > tolerance) break west;
                                    }
                                    westPixelsToCrop++;
                                }
                                if (westPixelsToCrop -= leaveBorder, eastPixelsToCrop -= leaveBorder, northPixelsToCrop -= leaveBorder, 
                                southPixelsToCrop -= leaveBorder, cropSymmetric) {
                                    var horizontal = Math.min(eastPixelsToCrop, westPixelsToCrop), vertical = Math.min(northPixelsToCrop, southPixelsToCrop);
                                    westPixelsToCrop = horizontal, eastPixelsToCrop = horizontal, northPixelsToCrop = vertical, 
                                    southPixelsToCrop = vertical;
                                }
                                var widthOfRemainingPixels = w - ((westPixelsToCrop = westPixelsToCrop >= 0 ? westPixelsToCrop : 0) + (eastPixelsToCrop = eastPixelsToCrop >= 0 ? eastPixelsToCrop : 0)), heightOfRemainingPixels = h - ((southPixelsToCrop = southPixelsToCrop >= 0 ? southPixelsToCrop : 0) + (northPixelsToCrop = northPixelsToCrop >= 0 ? northPixelsToCrop : 0));
                                return (cropOnlyFrames ? 0 !== eastPixelsToCrop && 0 !== northPixelsToCrop && 0 !== westPixelsToCrop && 0 !== southPixelsToCrop : 0 !== eastPixelsToCrop || 0 !== northPixelsToCrop || 0 !== westPixelsToCrop || 0 !== southPixelsToCrop) && this.crop(eastPixelsToCrop, northPixelsToCrop, widthOfRemainingPixels, heightOfRemainingPixels), 
                                (0, _utils.isNodePattern)(cb) && cb.call(this, null, this), this;
                            }
                        }
                    };
                };
                var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof")), _utils = require("@jimp/utils");
                module.exports = exports.default;
            }).call(this, require("buffer").Buffer);
        }, {
            "@babel/runtime/helpers/interopRequireDefault": 11,
            "@babel/runtime/helpers/typeof": 21,
            "@jimp/utils": 235,
            buffer: 48
        } ],
        209: [ function(require, module, exports) {
            var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
            Object.defineProperty(exports, "__esModule", {
                value: !0
            }), exports.default = void 0;
            var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof")), _utils = require("@jimp/utils");
            exports.default = function _default() {
                return {
                    displace: function displace(map, offset, cb) {
                        if ("object" !== (0, _typeof2.default)(map) || map.constructor !== this.constructor) return _utils.throwError.call(this, "The source must be a Jimp image", cb);
                        if ("number" != typeof offset) return _utils.throwError.call(this, "factor must be a number", cb);
                        var source = this.cloneQuiet();
                        return this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, (function(x, y, idx) {
                            var displacement = map.bitmap.data[idx] / 256 * offset;
                            displacement = Math.round(displacement);
                            var ids = this.getPixelIndex(x + displacement, y);
                            this.bitmap.data[ids] = source.bitmap.data[idx], this.bitmap.data[ids + 1] = source.bitmap.data[idx + 1], 
                            this.bitmap.data[ids + 2] = source.bitmap.data[idx + 2];
                        })), (0, _utils.isNodePattern)(cb) && cb.call(this, null, this), this;
                    }
                };
            }, module.exports = exports.default;
        }, {
            "@babel/runtime/helpers/interopRequireDefault": 11,
            "@babel/runtime/helpers/typeof": 21,
            "@jimp/utils": 235
        } ],
        210: [ function(require, module, exports) {
            Object.defineProperty(exports, "__esModule", {
                value: !0
            }), exports.default = void 0;
            var _utils = require("@jimp/utils");
            function dither(cb) {
                var rgb565Matrix = [ 1, 9, 3, 11, 13, 5, 15, 7, 4, 12, 2, 10, 16, 8, 14, 6 ];
                return this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, (function(x, y, idx) {
                    var dither = rgb565Matrix[((3 & y) << 2) + x % 4];
                    this.bitmap.data[idx] = Math.min(this.bitmap.data[idx] + dither, 0xff), this.bitmap.data[idx + 1] = Math.min(this.bitmap.data[idx + 1] + dither, 0xff), 
                    this.bitmap.data[idx + 2] = Math.min(this.bitmap.data[idx + 2] + dither, 0xff);
                })), (0, _utils.isNodePattern)(cb) && cb.call(this, null, this), this;
            }
            exports.default = function _default() {
                return {
                    dither565: dither,
                    dither16: dither
                };
            }, module.exports = exports.default;
        }, {
            "@jimp/utils": 235
        } ],
        211: [ function(require, module, exports) {
            Object.defineProperty(exports, "__esModule", {
                value: !0
            }), exports.default = void 0;
            var _utils = require("@jimp/utils");
            exports.default = function _default() {
                return {
                    fisheye: function fisheye() {
                        var _this = this, options = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {
                            r: 2.5
                        }, cb = arguments.length > 1 ? arguments[1] : void 0;
                        "function" == typeof options && (cb = options, options = {
                            r: 2.5
                        });
                        var source = this.cloneQuiet(), _source$bitmap = source.bitmap, width = _source$bitmap.width, height = _source$bitmap.height;
                        return source.scanQuiet(0, 0, width, height, (function(x, y) {
                            var hx = x / width, hy = y / height, r = Math.sqrt(Math.pow(hx - 0.5, 2) + Math.pow(hy - 0.5, 2)), rn = 2 * Math.pow(r, options.r), cosA = (hx - 0.5) / r, sinA = (hy - 0.5) / r, newX = Math.round((rn * cosA + 0.5) * width), newY = Math.round((rn * sinA + 0.5) * height), color = source.getPixelColor(newX, newY);
                            _this.setPixelColor(color, x, y);
                        })), this.setPixelColor(source.getPixelColor(width / 2, height / 2), width / 2, height / 2), 
                        (0, _utils.isNodePattern)(cb) && cb.call(this, null, this), this;
                    }
                };
            }, module.exports = exports.default;
        }, {
            "@jimp/utils": 235
        } ],
        212: [ function(require, module, exports) {
            (function(Buffer) {
                Object.defineProperty(exports, "__esModule", {
                    value: !0
                }), exports.default = void 0;
                var _utils = require("@jimp/utils");
                function flipFn(horizontal, vertical, cb) {
                    if ("boolean" != typeof horizontal || "boolean" != typeof vertical) return _utils.throwError.call(this, "horizontal and vertical must be Booleans", cb);
                    var bitmap = Buffer.alloc(this.bitmap.data.length);
                    return this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, (function(x, y, idx) {
                        var _x = horizontal ? this.bitmap.width - 1 - x : x, _y = vertical ? this.bitmap.height - 1 - y : y, _idx = this.bitmap.width * _y + _x << 2, data = this.bitmap.data.readUInt32BE(idx);
                        bitmap.writeUInt32BE(data, _idx);
                    })), this.bitmap.data = Buffer.from(bitmap), (0, _utils.isNodePattern)(cb) && cb.call(this, null, this), 
                    this;
                }
                exports.default = function _default() {
                    return {
                        flip: flipFn,
                        mirror: flipFn
                    };
                }, module.exports = exports.default;
            }).call(this, require("buffer").Buffer);
        }, {
            "@jimp/utils": 235,
            buffer: 48
        } ],
        213: [ function(require, module, exports) {
            Object.defineProperty(exports, "__esModule", {
                value: !0
            }), exports.default = void 0;
            var _utils = require("@jimp/utils");
            exports.default = function _default() {
                return {
                    gaussian: function gaussian(r, cb) {
                        if ("number" != typeof r) return _utils.throwError.call(this, "r must be a number", cb);
                        if (r < 1) return _utils.throwError.call(this, "r must be greater than 0", cb);
                        for (var rs = Math.ceil(2.57 * r), range = 2 * rs + 1, rr2 = r * r * 2, rr2pi = rr2 * Math.PI, weights = [], y = 0; y < range; y++) {
                            weights[y] = [];
                            for (var x = 0; x < range; x++) {
                                var dsq = Math.pow(x - rs, 2) + Math.pow(y - rs, 2);
                                weights[y][x] = Math.exp(-dsq / rr2) / rr2pi;
                            }
                        }
                        for (var _y = 0; _y < this.bitmap.height; _y++) for (var _x = 0; _x < this.bitmap.width; _x++) for (var red = 0, green = 0, blue = 0, alpha = 0, wsum = 0, iy = 0; iy < range; iy++) {
                            for (var ix = 0; ix < range; ix++) {
                                var x1 = Math.min(this.bitmap.width - 1, Math.max(0, ix + _x - rs)), y1 = Math.min(this.bitmap.height - 1, Math.max(0, iy + _y - rs)), weight = weights[iy][ix], _idx = y1 * this.bitmap.width + x1 << 2;
                                red += this.bitmap.data[_idx] * weight, green += this.bitmap.data[_idx + 1] * weight, 
                                blue += this.bitmap.data[_idx + 2] * weight, alpha += this.bitmap.data[_idx + 3] * weight, 
                                wsum += weight;
                            }
                            var idx = _y * this.bitmap.width + _x << 2;
                            this.bitmap.data[idx] = Math.round(red / wsum), this.bitmap.data[idx + 1] = Math.round(green / wsum), 
                            this.bitmap.data[idx + 2] = Math.round(blue / wsum), this.bitmap.data[idx + 3] = Math.round(alpha / wsum);
                        }
                        return (0, _utils.isNodePattern)(cb) && cb.call(this, null, this), this;
                    }
                };
            }, module.exports = exports.default;
        }, {
            "@jimp/utils": 235
        } ],
        214: [ function(require, module, exports) {
            Object.defineProperty(exports, "__esModule", {
                value: !0
            }), exports.default = void 0;
            var _utils = require("@jimp/utils");
            exports.default = function _default() {
                return {
                    invert: function invert(cb) {
                        return this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, (function(x, y, idx) {
                            this.bitmap.data[idx] = 255 - this.bitmap.data[idx], this.bitmap.data[idx + 1] = 255 - this.bitmap.data[idx + 1], 
                            this.bitmap.data[idx + 2] = 255 - this.bitmap.data[idx + 2];
                        })), (0, _utils.isNodePattern)(cb) && cb.call(this, null, this), this;
                    }
                };
            }, module.exports = exports.default;
        }, {
            "@jimp/utils": 235
        } ],
        215: [ function(require, module, exports) {
            Object.defineProperty(exports, "__esModule", {
                value: !0
            }), exports.default = void 0;
            var _utils = require("@jimp/utils");
            exports.default = function _default() {
                return {
                    mask: function mask(src) {
                        var x = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, y = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : 0, cb = arguments.length > 3 ? arguments[3] : void 0;
                        if (!(src instanceof this.constructor)) return _utils.throwError.call(this, "The source must be a Jimp image", cb);
                        if ("number" != typeof x || "number" != typeof y) return _utils.throwError.call(this, "x and y must be numbers", cb);
                        x = Math.round(x), y = Math.round(y);
                        var w = this.bitmap.width, h = this.bitmap.height, baseImage = this;
                        return src.scanQuiet(0, 0, src.bitmap.width, src.bitmap.height, (function(sx, sy, idx) {
                            var destX = x + sx, destY = y + sy;
                            if (destX >= 0 && destY >= 0 && destX < w && destY < h) {
                                var dstIdx = baseImage.getPixelIndex(destX, destY), data = this.bitmap.data, avg = (data[idx + 0] + data[idx + 1] + data[idx + 2]) / 3;
                                baseImage.bitmap.data[dstIdx + 3] *= avg / 255;
                            }
                        })), (0, _utils.isNodePattern)(cb) && cb.call(this, null, this), this;
                    }
                };
            }, module.exports = exports.default;
        }, {
            "@jimp/utils": 235
        } ],
        216: [ function(require, module, exports) {
            Object.defineProperty(exports, "__esModule", {
                value: !0
            }), exports.default = void 0;
            var _utils = require("@jimp/utils");
            function histogram() {
                var histogram = {
                    r: new Array(256).fill(0),
                    g: new Array(256).fill(0),
                    b: new Array(256).fill(0)
                };
                return this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, (function(x, y, index) {
                    histogram.r[this.bitmap.data[index + 0]]++, histogram.g[this.bitmap.data[index + 1]]++, 
                    histogram.b[this.bitmap.data[index + 2]]++;
                })), histogram;
            }
            var _normalize = function normalize(value, min, max) {
                return 255 * (value - min) / (max - min);
            }, getBounds = function getBounds(histogramChannel) {
                return [ histogramChannel.findIndex((function(value) {
                    return value > 0;
                })), 255 - histogramChannel.slice().reverse().findIndex((function(value) {
                    return value > 0;
                })) ];
            };
            exports.default = function _default() {
                return {
                    normalize: function normalize(cb) {
                        var h = histogram.call(this), bounds = {
                            r: getBounds(h.r),
                            g: getBounds(h.g),
                            b: getBounds(h.b)
                        };
                        return this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, (function(x, y, idx) {
                            var r = this.bitmap.data[idx + 0], g = this.bitmap.data[idx + 1], b = this.bitmap.data[idx + 2];
                            this.bitmap.data[idx + 0] = _normalize(r, bounds.r[0], bounds.r[1]), this.bitmap.data[idx + 1] = _normalize(g, bounds.g[0], bounds.g[1]), 
                            this.bitmap.data[idx + 2] = _normalize(b, bounds.b[0], bounds.b[1]);
                        })), (0, _utils.isNodePattern)(cb) && cb.call(this, null, this), this;
                    }
                };
            }, module.exports = exports.default;
        }, {
            "@jimp/utils": 235
        } ],
        217: [ function(require, module, exports) {
            (function(__dirname) {
                var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
                Object.defineProperty(exports, "__esModule", {
                    value: !0
                }), exports.default = void 0;
                var _typeof2 = _interopRequireDefault(require("@babel/runtime/helpers/typeof")), _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray")), _path = _interopRequireDefault(require("path")), _loadBmfont = _interopRequireDefault(require("load-bmfont")), _utils = require("@jimp/utils"), _measureText = require("./measure-text");
                function drawCharacter(image, font, x, y, _char) {
                    if (_char.width > 0 && _char.height > 0) {
                        var characterPage = font.pages[_char.page];
                        image.blit(characterPage, x + _char.xoffset, y + _char.yoffset, _char.x, _char.y, _char.width, _char.height);
                    }
                    return image;
                }
                function printText(font, x, y, text, defaultCharWidth) {
                    for (var i = 0; i < text.length; i++) {
                        var _char2;
                        _char2 = font.chars[text[i]] ? text[i] : /\s/.test(text[i]) ? "" : "?";
                        var fontChar = font.chars[_char2] || {}, fontKerning = font.kernings[_char2];
                        drawCharacter(this, font, x, y, fontChar || {}), x += (fontKerning && fontKerning[text[i + 1]] ? fontKerning[text[i + 1]] : 0) + (fontChar.xadvance || defaultCharWidth);
                    }
                }
                var dir = "browser/lib/";
                exports.default = function _default() {
                    return {
                        constants: {
                            measureText: _measureText.measureText,
                            measureTextHeight: _measureText.measureTextHeight,
                            FONT_SANS_8_BLACK: _path.default.join(dir, "fonts/open-sans/open-sans-8-black/open-sans-8-black.fnt"),
                            FONT_SANS_10_BLACK: _path.default.join(dir, "fonts/open-sans/open-sans-10-black/open-sans-10-black.fnt"),
                            FONT_SANS_12_BLACK: _path.default.join(dir, "fonts/open-sans/open-sans-12-black/open-sans-12-black.fnt"),
                            FONT_SANS_14_BLACK: _path.default.join(dir, "fonts/open-sans/open-sans-14-black/open-sans-14-black.fnt"),
                            FONT_SANS_16_BLACK: _path.default.join(dir, "fonts/open-sans/open-sans-16-black/open-sans-16-black.fnt"),
                            FONT_SANS_32_BLACK: _path.default.join(dir, "fonts/open-sans/open-sans-32-black/open-sans-32-black.fnt"),
                            FONT_SANS_64_BLACK: _path.default.join(dir, "fonts/open-sans/open-sans-64-black/open-sans-64-black.fnt"),
                            FONT_SANS_128_BLACK: _path.default.join(dir, "fonts/open-sans/open-sans-128-black/open-sans-128-black.fnt"),
                            FONT_SANS_8_WHITE: _path.default.join(dir, "fonts/open-sans/open-sans-8-white/open-sans-8-white.fnt"),
                            FONT_SANS_16_WHITE: _path.default.join(dir, "fonts/open-sans/open-sans-16-white/open-sans-16-white.fnt"),
                            FONT_SANS_32_WHITE: _path.default.join(dir, "fonts/open-sans/open-sans-32-white/open-sans-32-white.fnt"),
                            FONT_SANS_64_WHITE: _path.default.join(dir, "fonts/open-sans/open-sans-64-white/open-sans-64-white.fnt"),
                            FONT_SANS_128_WHITE: _path.default.join(dir, "fonts/open-sans/open-sans-128-white/open-sans-128-white.fnt"),
                            loadFont: function loadFont(file, cb) {
                                var _this = this;
                                return "string" != typeof file ? _utils.throwError.call(this, "file must be a string", cb) : new Promise((function(resolve, reject) {
                                    cb = cb || function(err, font) {
                                        err ? reject(err) : resolve(font);
                                    }, (0, _loadBmfont.default)(file, (function(err, font) {
                                        var chars = {}, kernings = {};
                                        if (err) return _utils.throwError.call(_this, err, cb);
                                        for (var i = 0; i < font.chars.length; i++) chars[String.fromCharCode(font.chars[i].id)] = font.chars[i];
                                        for (var _i = 0; _i < font.kernings.length; _i++) {
                                            var firstString = String.fromCharCode(font.kernings[_i].first);
                                            kernings[firstString] = kernings[firstString] || {}, kernings[firstString][String.fromCharCode(font.kernings[_i].second)] = font.kernings[_i].amount;
                                        }
                                        (function loadPages(Jimp, dir, pages) {
                                            var newPages = pages.map((function(page) {
                                                return Jimp.read(dir + "/" + page);
                                            }));
                                            return Promise.all(newPages);
                                        })(_this, _path.default.dirname(file), font.pages).then((function(pages) {
                                            cb(null, {
                                                chars,
                                                kernings,
                                                pages,
                                                common: font.common,
                                                info: font.info
                                            });
                                        }));
                                    }));
                                }));
                            }
                        },
                        class: {
                            print: function print(font, x, y, text, maxWidth, maxHeight, cb) {
                                var alignmentX, alignmentY, _this2 = this;
                                if ("function" == typeof maxWidth && void 0 === cb && (cb = maxWidth, maxWidth = 1 / 0), 
                                void 0 === maxWidth && (maxWidth = 1 / 0), "function" == typeof maxHeight && void 0 === cb && (cb = maxHeight, 
                                maxHeight = 1 / 0), void 0 === maxHeight && (maxHeight = 1 / 0), "object" !== (0, 
                                _typeof2.default)(font)) return _utils.throwError.call(this, "font must be a Jimp loadFont", cb);
                                if ("number" != typeof x || "number" != typeof y || "number" != typeof maxWidth) return _utils.throwError.call(this, "x, y and maxWidth must be numbers", cb);
                                if ("number" != typeof maxWidth) return _utils.throwError.call(this, "maxWidth must be a number", cb);
                                if ("number" != typeof maxHeight) return _utils.throwError.call(this, "maxHeight must be a number", cb);
                                "object" === (0, _typeof2.default)(text) && null !== text.text && void 0 !== text.text ? (alignmentX = text.alignmentX || this.constructor.HORIZONTAL_ALIGN_LEFT, 
                                alignmentY = text.alignmentY || this.constructor.VERTICAL_ALIGN_TOP, text = text.text) : (alignmentX = this.constructor.HORIZONTAL_ALIGN_LEFT, 
                                alignmentY = this.constructor.VERTICAL_ALIGN_TOP, text = text.toString()), maxHeight !== 1 / 0 && alignmentY === this.constructor.VERTICAL_ALIGN_BOTTOM ? y += maxHeight - (0, 
                                _measureText.measureTextHeight)(font, text, maxWidth) : maxHeight !== 1 / 0 && alignmentY === this.constructor.VERTICAL_ALIGN_MIDDLE && (y += maxHeight / 2 - (0, 
                                _measureText.measureTextHeight)(font, text, maxWidth) / 2);
                                var defaultCharWidth = Object.entries(font.chars)[0][1].xadvance, _splitLines = function splitLines(font, text, maxWidth) {
                                    var words = text.split(" "), lines = [], currentLine = [], longestLine = 0;
                                    return words.forEach((function(word) {
                                        var line = [].concat((0, _toConsumableArray2.default)(currentLine), [ word ]).join(" "), length = (0, 
                                        _measureText.measureText)(font, line);
                                        length <= maxWidth ? (length > longestLine && (longestLine = length), currentLine.push(word)) : (lines.push(currentLine), 
                                        currentLine = [ word ]);
                                    })), lines.push(currentLine), {
                                        lines,
                                        longestLine
                                    };
                                }(font, text, maxWidth), lines = _splitLines.lines, longestLine = _splitLines.longestLine;
                                return lines.forEach((function(line) {
                                    var lineString = line.join(" "), alignmentWidth = function xOffsetBasedOnAlignment(constants, font, line, maxWidth, alignment) {
                                        return alignment === constants.HORIZONTAL_ALIGN_LEFT ? 0 : alignment === constants.HORIZONTAL_ALIGN_CENTER ? (maxWidth - (0, 
                                        _measureText.measureText)(font, line)) / 2 : maxWidth - (0, _measureText.measureText)(font, line);
                                    }(_this2.constructor, font, lineString, maxWidth, alignmentX);
                                    printText.call(_this2, font, x + alignmentWidth, y, lineString, defaultCharWidth), 
                                    y += font.common.lineHeight;
                                })), (0, _utils.isNodePattern)(cb) && cb.call(this, null, this, {
                                    x: x + longestLine,
                                    y
                                }), this;
                            }
                        }
                    };
                }, module.exports = exports.default;
            }).call(this, "/../../node_modules/@jimp/plugin-print/dist");
        }, {
            "./measure-text": 218,
            "@babel/runtime/helpers/interopRequireDefault": 11,
            "@babel/runtime/helpers/toConsumableArray": 20,
            "@babel/runtime/helpers/typeof": 21,
            "@jimp/utils": 235,
            "load-bmfont": 219,
            path: 107
        } ],
        218: [ function(require, module, exports) {
            function measureText(font, text) {
                for (var x = 0, i = 0; i < text.length; i++) if (font.chars[text[i]]) {
                    var kerning = font.kernings[text[i]] && font.kernings[text[i]][text[i + 1]] ? font.kernings[text[i]][text[i + 1]] : 0;
                    x += (font.chars[text[i]].xadvance || 0) + kerning;
                }
                return x;
            }
            Object.defineProperty(exports, "__esModule", {
                value: !0
            }), exports.measureText = measureText, exports.measureTextHeight = function measureTextHeight(font, text, maxWidth) {
                for (var words = text.split(" "), line = "", textTotalHeight = font.common.lineHeight, n = 0; n < words.length; n++) {
                    var testLine = line + words[n] + " ";
                    measureText(font, testLine) > maxWidth && n > 0 ? (textTotalHeight += font.common.lineHeight, 
                    line = words[n] + " ") : line = testLine;
                }
                return textTotalHeight;
            };
        }, {} ],
        219: [ function(require, module, exports) {
            (function(Buffer) {
                var xhr = require("xhr"), noop = function() {}, parseASCII = require("parse-bmfont-ascii"), parseXML = require("parse-bmfont-xml"), readBinary = require("parse-bmfont-binary"), isBinaryFormat = require("./lib/is-binary"), xtend = require("xtend"), xml2 = function hasXML2() {
                    return self.XMLHttpRequest && "withCredentials" in new XMLHttpRequest;
                }();
                module.exports = function(opt, cb) {
                    cb = "function" == typeof cb ? cb : noop, "string" == typeof opt ? opt = {
                        uri: opt
                    } : opt || (opt = {}), opt.binary && (opt = function getBinaryOpts(opt) {
                        if (xml2) return xtend(opt, {
                            responseType: "arraybuffer"
                        });
                        if (void 0 === self.XMLHttpRequest) throw new Error("your browser does not support XHR loading");
                        var req = new self.XMLHttpRequest;
                        return req.overrideMimeType("text/plain; charset=x-user-defined"), xtend({
                            xhr: req
                        }, opt);
                    }(opt)), xhr(opt, (function(err, res, body) {
                        if (err) return cb(err);
                        if (!/^2/.test(res.statusCode)) return cb(new Error("http status code: " + res.statusCode));
                        if (!body) return cb(new Error("no body result"));
                        var result, binary = !1;
                        if (function isArrayBuffer(arr) {
                            return "[object ArrayBuffer]" === Object.prototype.toString.call(arr);
                        }(body)) {
                            var array = new Uint8Array(body);
                            body = new Buffer(array, "binary");
                        }
                        isBinaryFormat(body) && (binary = !0, "string" == typeof body && (body = new Buffer(body, "binary"))), 
                        binary || (Buffer.isBuffer(body) && (body = body.toString(opt.encoding)), body = body.trim());
                        try {
                            var type = res.headers["content-type"];
                            result = binary ? readBinary(body) : /json/.test(type) || "{" === body.charAt(0) ? JSON.parse(body) : /xml/.test(type) || "<" === body.charAt(0) ? parseXML(body) : parseASCII(body);
                        } catch (e) {
                            cb(new Error("error parsing font " + e.message)), cb = noop;
                        }
                        cb(null, result);
                    }));
                };
            }).call(this, require("buffer").Buffer);
        }, {
            "./lib/is-binary": 220,
            buffer: 48,
            "parse-bmfont-ascii": 102,
            "parse-bmfont-binary": 103,
            "parse-bmfont-xml": 104,
            xhr: 187,
            xtend: 189
        } ],
        220: [ function(require, module, exports) {
            (function(Buffer) {
                var equal = require("buffer-equal"), HEADER = new Buffer([ 66, 77, 70, 3 ]);
                module.exports = function(buf) {
                    return "string" == typeof buf ? "BMF" === buf.substring(0, 3) : buf.length > 4 && equal(buf.slice(0, 4), HEADER);
                };
            }).call(this, require("buffer").Buffer);
        }, {
            buffer: 48,
            "buffer-equal": 49
        } ],
        221: [ function(require, module, exports) {
            (function(Buffer) {
                var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
                Object.defineProperty(exports, "__esModule", {
                    value: !0
                }), exports.default = void 0;
                var _utils = require("@jimp/utils"), _resize = _interopRequireDefault(require("./modules/resize")), _resize2 = _interopRequireDefault(require("./modules/resize2"));
                exports.default = function _default() {
                    return {
                        constants: {
                            RESIZE_NEAREST_NEIGHBOR: "nearestNeighbor",
                            RESIZE_BILINEAR: "bilinearInterpolation",
                            RESIZE_BICUBIC: "bicubicInterpolation",
                            RESIZE_HERMITE: "hermiteInterpolation",
                            RESIZE_BEZIER: "bezierInterpolation"
                        },
                        class: {
                            resize: function resize(w, h, mode, cb) {
                                if ("number" != typeof w || "number" != typeof h) return _utils.throwError.call(this, "w and h must be numbers", cb);
                                if ("function" == typeof mode && void 0 === cb && (cb = mode, mode = null), w === this.constructor.AUTO && h === this.constructor.AUTO) return _utils.throwError.call(this, "w and h cannot both be set to auto", cb);
                                if (w === this.constructor.AUTO && (w = this.bitmap.width * (h / this.bitmap.height)), 
                                h === this.constructor.AUTO && (h = this.bitmap.height * (w / this.bitmap.width)), 
                                w < 0 || h < 0) return _utils.throwError.call(this, "w and h must be positive numbers", cb);
                                if (w = Math.round(w), h = Math.round(h), "function" == typeof _resize2.default[mode]) {
                                    var dst = {
                                        data: Buffer.alloc(w * h * 4),
                                        width: w,
                                        height: h
                                    };
                                    _resize2.default[mode](this.bitmap, dst), this.bitmap = dst;
                                } else {
                                    var image = this, resize = new _resize.default(this.bitmap.width, this.bitmap.height, w, h, !0, !0, (function(buffer) {
                                        image.bitmap.data = Buffer.from(buffer), image.bitmap.width = w, image.bitmap.height = h;
                                    }));
                                    resize.resize(this.bitmap.data);
                                }
                                return (0, _utils.isNodePattern)(cb) && cb.call(this, null, this), this;
                            }
                        }
                    };
                }, module.exports = exports.default;
            }).call(this, require("buffer").Buffer);
        }, {
            "./modules/resize": 222,
            "./modules/resize2": 223,
            "@babel/runtime/helpers/interopRequireDefault": 11,
            "@jimp/utils": 235,
            buffer: 48
        } ],
        222: [ function(require, module, exports) {
            function Resize(widthOriginal, heightOriginal, targetWidth, targetHeight, blendAlpha, interpolationPass, resizeCallback) {
                this.widthOriginal = Math.abs(Math.floor(widthOriginal) || 0), this.heightOriginal = Math.abs(Math.floor(heightOriginal) || 0), 
                this.targetWidth = Math.abs(Math.floor(targetWidth) || 0), this.targetHeight = Math.abs(Math.floor(targetHeight) || 0), 
                this.colorChannels = blendAlpha ? 4 : 3, this.interpolationPass = Boolean(interpolationPass), 
                this.resizeCallback = "function" == typeof resizeCallback ? resizeCallback : function() {}, 
                this.targetWidthMultipliedByChannels = this.targetWidth * this.colorChannels, this.originalWidthMultipliedByChannels = this.widthOriginal * this.colorChannels, 
                this.originalHeightMultipliedByChannels = this.heightOriginal * this.colorChannels, 
                this.widthPassResultSize = this.targetWidthMultipliedByChannels * this.heightOriginal, 
                this.finalResultSize = this.targetWidthMultipliedByChannels * this.targetHeight, 
                this.initialize();
            }
            Resize.prototype.initialize = function() {
                if (!(this.widthOriginal > 0 && this.heightOriginal > 0 && this.targetWidth > 0 && this.targetHeight > 0)) throw new Error("Invalid settings specified for the resizer.");
                this.configurePasses();
            }, Resize.prototype.configurePasses = function() {
                this.widthOriginal === this.targetWidth ? this.resizeWidth = this.bypassResizer : (this.ratioWeightWidthPass = this.widthOriginal / this.targetWidth, 
                this.ratioWeightWidthPass < 1 && this.interpolationPass ? (this.initializeFirstPassBuffers(!0), 
                this.resizeWidth = 4 === this.colorChannels ? this.resizeWidthInterpolatedRGBA : this.resizeWidthInterpolatedRGB) : (this.initializeFirstPassBuffers(!1), 
                this.resizeWidth = 4 === this.colorChannels ? this.resizeWidthRGBA : this.resizeWidthRGB)), 
                this.heightOriginal === this.targetHeight ? this.resizeHeight = this.bypassResizer : (this.ratioWeightHeightPass = this.heightOriginal / this.targetHeight, 
                this.ratioWeightHeightPass < 1 && this.interpolationPass ? (this.initializeSecondPassBuffers(!0), 
                this.resizeHeight = this.resizeHeightInterpolated) : (this.initializeSecondPassBuffers(!1), 
                this.resizeHeight = 4 === this.colorChannels ? this.resizeHeightRGBA : this.resizeHeightRGB));
            }, Resize.prototype._resizeWidthInterpolatedRGBChannels = function(buffer, fourthChannel) {
                var targetPosition, interpolationWidthSourceReadStop, channelsNum = fourthChannel ? 4 : 3, ratioWeight = this.ratioWeightWidthPass, outputBuffer = this.widthBuffer, weight = 0, finalOffset = 0, pixelOffset = 0, firstWeight = 0, secondWeight = 0;
                for (targetPosition = 0; weight < 1 / 3; targetPosition += channelsNum, weight += ratioWeight) for (finalOffset = targetPosition, 
                pixelOffset = 0; finalOffset < this.widthPassResultSize; pixelOffset += this.originalWidthMultipliedByChannels, 
                finalOffset += this.targetWidthMultipliedByChannels) outputBuffer[finalOffset] = buffer[pixelOffset], 
                outputBuffer[finalOffset + 1] = buffer[pixelOffset + 1], outputBuffer[finalOffset + 2] = buffer[pixelOffset + 2], 
                fourthChannel && (outputBuffer[finalOffset + 3] = buffer[pixelOffset + 3]);
                for (weight -= 1 / 3, interpolationWidthSourceReadStop = this.widthOriginal - 1; weight < interpolationWidthSourceReadStop; targetPosition += channelsNum, 
                weight += ratioWeight) for (firstWeight = 1 - (secondWeight = weight % 1), finalOffset = targetPosition, 
                pixelOffset = Math.floor(weight) * channelsNum; finalOffset < this.widthPassResultSize; pixelOffset += this.originalWidthMultipliedByChannels, 
                finalOffset += this.targetWidthMultipliedByChannels) outputBuffer[finalOffset + 0] = buffer[pixelOffset + 0] * firstWeight + buffer[pixelOffset + channelsNum + 0] * secondWeight, 
                outputBuffer[finalOffset + 1] = buffer[pixelOffset + 1] * firstWeight + buffer[pixelOffset + channelsNum + 1] * secondWeight, 
                outputBuffer[finalOffset + 2] = buffer[pixelOffset + 2] * firstWeight + buffer[pixelOffset + channelsNum + 2] * secondWeight, 
                fourthChannel && (outputBuffer[finalOffset + 3] = buffer[pixelOffset + 3] * firstWeight + buffer[pixelOffset + channelsNum + 3] * secondWeight);
                for (interpolationWidthSourceReadStop = this.originalWidthMultipliedByChannels - channelsNum; targetPosition < this.targetWidthMultipliedByChannels; targetPosition += channelsNum) for (finalOffset = targetPosition, 
                pixelOffset = interpolationWidthSourceReadStop; finalOffset < this.widthPassResultSize; pixelOffset += this.originalWidthMultipliedByChannels, 
                finalOffset += this.targetWidthMultipliedByChannels) outputBuffer[finalOffset] = buffer[pixelOffset], 
                outputBuffer[finalOffset + 1] = buffer[pixelOffset + 1], outputBuffer[finalOffset + 2] = buffer[pixelOffset + 2], 
                fourthChannel && (outputBuffer[finalOffset + 3] = buffer[pixelOffset + 3]);
                return outputBuffer;
            }, Resize.prototype._resizeWidthRGBChannels = function(buffer, fourthChannel) {
                var channelsNum = fourthChannel ? 4 : 3, ratioWeight = this.ratioWeightWidthPass, ratioWeightDivisor = 1 / ratioWeight, nextLineOffsetOriginalWidth = this.originalWidthMultipliedByChannels - channelsNum + 1, nextLineOffsetTargetWidth = this.targetWidthMultipliedByChannels - channelsNum + 1, output = this.outputWidthWorkBench, outputBuffer = this.widthBuffer, trustworthyColorsCount = this.outputWidthWorkBenchOpaquePixelsCount, weight = 0, amountToNext = 0, actualPosition = 0, currentPosition = 0, line = 0, pixelOffset = 0, outputOffset = 0, multiplier = 1, r = 0, g = 0, b = 0, a = 0;
                do {
                    for (line = 0; line < this.originalHeightMultipliedByChannels; ) output[line++] = 0, 
                    output[line++] = 0, output[line++] = 0, fourthChannel && (output[line++] = 0, trustworthyColorsCount[line / channelsNum - 1] = 0);
                    weight = ratioWeight;
                    do {
                        for (amountToNext = 1 + actualPosition - currentPosition, multiplier = Math.min(weight, amountToNext), 
                        line = 0, pixelOffset = actualPosition; line < this.originalHeightMultipliedByChannels; pixelOffset += nextLineOffsetOriginalWidth) r = buffer[pixelOffset], 
                        g = buffer[++pixelOffset], b = buffer[++pixelOffset], a = fourthChannel ? buffer[++pixelOffset] : 255, 
                        output[line++] += (a ? r : 0) * multiplier, output[line++] += (a ? g : 0) * multiplier, 
                        output[line++] += (a ? b : 0) * multiplier, fourthChannel && (output[line++] += a * multiplier, 
                        trustworthyColorsCount[line / channelsNum - 1] += a ? multiplier : 0);
                        if (!(weight >= amountToNext)) {
                            currentPosition += weight;
                            break;
                        }
                        currentPosition = actualPosition += channelsNum, weight -= amountToNext;
                    } while (weight > 0 && actualPosition < this.originalWidthMultipliedByChannels);
                    for (line = 0, pixelOffset = outputOffset; line < this.originalHeightMultipliedByChannels; pixelOffset += nextLineOffsetTargetWidth) weight = fourthChannel ? trustworthyColorsCount[line / channelsNum] : 1, 
                    multiplier = fourthChannel ? weight ? 1 / weight : 0 : ratioWeightDivisor, outputBuffer[pixelOffset] = output[line++] * multiplier, 
                    outputBuffer[++pixelOffset] = output[line++] * multiplier, outputBuffer[++pixelOffset] = output[line++] * multiplier, 
                    fourthChannel && (outputBuffer[++pixelOffset] = output[line++] * ratioWeightDivisor);
                    outputOffset += channelsNum;
                } while (outputOffset < this.targetWidthMultipliedByChannels);
                return outputBuffer;
            }, Resize.prototype._resizeHeightRGBChannels = function(buffer, fourthChannel) {
                var ratioWeight = this.ratioWeightHeightPass, ratioWeightDivisor = 1 / ratioWeight, output = this.outputHeightWorkBench, outputBuffer = this.heightBuffer, trustworthyColorsCount = this.outputHeightWorkBenchOpaquePixelsCount, weight = 0, amountToNext = 0, actualPosition = 0, currentPosition = 0, pixelOffset = 0, outputOffset = 0, caret = 0, multiplier = 1, r = 0, g = 0, b = 0, a = 0;
                do {
                    for (pixelOffset = 0; pixelOffset < this.targetWidthMultipliedByChannels; ) output[pixelOffset++] = 0, 
                    output[pixelOffset++] = 0, output[pixelOffset++] = 0, fourthChannel && (output[pixelOffset++] = 0, 
                    trustworthyColorsCount[pixelOffset / 4 - 1] = 0);
                    weight = ratioWeight;
                    do {
                        for (amountToNext = 1 + actualPosition - currentPosition, multiplier = Math.min(weight, amountToNext), 
                        caret = actualPosition, pixelOffset = 0; pixelOffset < this.targetWidthMultipliedByChannels; ) r = buffer[caret++], 
                        g = buffer[caret++], b = buffer[caret++], a = fourthChannel ? buffer[caret++] : 255, 
                        output[pixelOffset++] += (a ? r : 0) * multiplier, output[pixelOffset++] += (a ? g : 0) * multiplier, 
                        output[pixelOffset++] += (a ? b : 0) * multiplier, fourthChannel && (output[pixelOffset++] += a * multiplier, 
                        trustworthyColorsCount[pixelOffset / 4 - 1] += a ? multiplier : 0);
                        if (!(weight >= amountToNext)) {
                            currentPosition += weight;
                            break;
                        }
                        currentPosition = actualPosition = caret, weight -= amountToNext;
                    } while (weight > 0 && actualPosition < this.widthPassResultSize);
                    for (pixelOffset = 0; pixelOffset < this.targetWidthMultipliedByChannels; ) weight = fourthChannel ? trustworthyColorsCount[pixelOffset / 4] : 1, 
                    multiplier = fourthChannel ? weight ? 1 / weight : 0 : ratioWeightDivisor, outputBuffer[outputOffset++] = Math.round(output[pixelOffset++] * multiplier), 
                    outputBuffer[outputOffset++] = Math.round(output[pixelOffset++] * multiplier), outputBuffer[outputOffset++] = Math.round(output[pixelOffset++] * multiplier), 
                    fourthChannel && (outputBuffer[outputOffset++] = Math.round(output[pixelOffset++] * ratioWeightDivisor));
                } while (outputOffset < this.finalResultSize);
                return outputBuffer;
            }, Resize.prototype.resizeWidthInterpolatedRGB = function(buffer) {
                return this._resizeWidthInterpolatedRGBChannels(buffer, !1);
            }, Resize.prototype.resizeWidthInterpolatedRGBA = function(buffer) {
                return this._resizeWidthInterpolatedRGBChannels(buffer, !0);
            }, Resize.prototype.resizeWidthRGB = function(buffer) {
                return this._resizeWidthRGBChannels(buffer, !1);
            }, Resize.prototype.resizeWidthRGBA = function(buffer) {
                return this._resizeWidthRGBChannels(buffer, !0);
            }, Resize.prototype.resizeHeightInterpolated = function(buffer) {
                for (var interpolationHeightSourceReadStop, ratioWeight = this.ratioWeightHeightPass, outputBuffer = this.heightBuffer, weight = 0, finalOffset = 0, pixelOffset = 0, pixelOffsetAccumulated = 0, pixelOffsetAccumulated2 = 0, firstWeight = 0, secondWeight = 0; weight < 1 / 3; weight += ratioWeight) for (pixelOffset = 0; pixelOffset < this.targetWidthMultipliedByChannels; ) outputBuffer[finalOffset++] = Math.round(buffer[pixelOffset++]);
                for (weight -= 1 / 3, interpolationHeightSourceReadStop = this.heightOriginal - 1; weight < interpolationHeightSourceReadStop; weight += ratioWeight) for (firstWeight = 1 - (secondWeight = weight % 1), 
                pixelOffsetAccumulated2 = (pixelOffsetAccumulated = Math.floor(weight) * this.targetWidthMultipliedByChannels) + this.targetWidthMultipliedByChannels, 
                pixelOffset = 0; pixelOffset < this.targetWidthMultipliedByChannels; ++pixelOffset) outputBuffer[finalOffset++] = Math.round(buffer[pixelOffsetAccumulated++] * firstWeight + buffer[pixelOffsetAccumulated2++] * secondWeight);
                for (;finalOffset < this.finalResultSize; ) for (pixelOffset = 0, pixelOffsetAccumulated = interpolationHeightSourceReadStop * this.targetWidthMultipliedByChannels; pixelOffset < this.targetWidthMultipliedByChannels; ++pixelOffset) outputBuffer[finalOffset++] = Math.round(buffer[pixelOffsetAccumulated++]);
                return outputBuffer;
            }, Resize.prototype.resizeHeightRGB = function(buffer) {
                return this._resizeHeightRGBChannels(buffer, !1);
            }, Resize.prototype.resizeHeightRGBA = function(buffer) {
                return this._resizeHeightRGBChannels(buffer, !0);
            }, Resize.prototype.resize = function(buffer) {
                this.resizeCallback(this.resizeHeight(this.resizeWidth(buffer)));
            }, Resize.prototype.bypassResizer = function(buffer) {
                return buffer;
            }, Resize.prototype.initializeFirstPassBuffers = function(BILINEARAlgo) {
                this.widthBuffer = this.generateFloatBuffer(this.widthPassResultSize), BILINEARAlgo || (this.outputWidthWorkBench = this.generateFloatBuffer(this.originalHeightMultipliedByChannels), 
                this.colorChannels > 3 && (this.outputWidthWorkBenchOpaquePixelsCount = this.generateFloat64Buffer(this.heightOriginal)));
            }, Resize.prototype.initializeSecondPassBuffers = function(BILINEARAlgo) {
                this.heightBuffer = this.generateUint8Buffer(this.finalResultSize), BILINEARAlgo || (this.outputHeightWorkBench = this.generateFloatBuffer(this.targetWidthMultipliedByChannels), 
                this.colorChannels > 3 && (this.outputHeightWorkBenchOpaquePixelsCount = this.generateFloat64Buffer(this.targetWidth)));
            }, Resize.prototype.generateFloatBuffer = function(bufferLength) {
                try {
                    return new Float32Array(bufferLength);
                } catch (error) {
                    return [];
                }
            }, Resize.prototype.generateFloat64Buffer = function(bufferLength) {
                try {
                    return new Float64Array(bufferLength);
                } catch (error) {
                    return [];
                }
            }, Resize.prototype.generateUint8Buffer = function(bufferLength) {
                try {
                    return new Uint8Array(bufferLength);
                } catch (error) {
                    return [];
                }
            }, module.exports = Resize;
        }, {} ],
        223: [ function(require, module, exports) {
            (function(Buffer) {
                module.exports = {
                    nearestNeighbor: function nearestNeighbor(src, dst) {
                        for (var wSrc = src.width, hSrc = src.height, wDst = dst.width, hDst = dst.height, bufSrc = src.data, bufDst = dst.data, i = 0; i < hDst; i++) for (var j = 0; j < wDst; j++) {
                            var posDst = 4 * (i * wDst + j), posSrc = 4 * (Math.floor(i * hSrc / hDst) * wSrc + Math.floor(j * wSrc / wDst));
                            bufDst[posDst++] = bufSrc[posSrc++], bufDst[posDst++] = bufSrc[posSrc++], bufDst[posDst++] = bufSrc[posSrc++], 
                            bufDst[posDst++] = bufSrc[posSrc++];
                        }
                    },
                    bilinearInterpolation: function bilinearInterpolation(src, dst) {
                        for (var wSrc = src.width, hSrc = src.height, wDst = dst.width, hDst = dst.height, bufSrc = src.data, bufDst = dst.data, interpolate = function interpolate(k, kMin, vMin, kMax, vMax) {
                            return kMin === kMax ? vMin : Math.round((k - kMin) * vMax + (kMax - k) * vMin);
                        }, assign = function assign(pos, offset, x, xMin, xMax, y, yMin, yMax) {
                            var posMin = 4 * (yMin * wSrc + xMin) + offset, posMax = 4 * (yMin * wSrc + xMax) + offset, vMin = interpolate(x, xMin, bufSrc[posMin], xMax, bufSrc[posMax]);
                            if (yMax === yMin) bufDst[pos + offset] = vMin; else {
                                posMax = 4 * (yMax * wSrc + xMax) + offset;
                                var vMax = interpolate(x, xMin, bufSrc[posMin = 4 * (yMax * wSrc + xMin) + offset], xMax, bufSrc[posMax]);
                                bufDst[pos + offset] = interpolate(y, yMin, vMin, yMax, vMax);
                            }
                        }, i = 0; i < hDst; i++) for (var j = 0; j < wDst; j++) {
                            var posDst = 4 * (i * wDst + j), x = j * wSrc / wDst, xMin = Math.floor(x), xMax = Math.min(Math.ceil(x), wSrc - 1), y = i * hSrc / hDst, yMin = Math.floor(y), yMax = Math.min(Math.ceil(y), hSrc - 1);
                            assign(posDst, 0, x, xMin, xMax, y, yMin, yMax), assign(posDst, 1, x, xMin, xMax, y, yMin, yMax), 
                            assign(posDst, 2, x, xMin, xMax, y, yMin, yMax), assign(posDst, 3, x, xMin, xMax, y, yMin, yMax);
                        }
                    },
                    _interpolate2D: function _interpolate2D(src, dst, options, interpolate) {
                        for (var bufSrc = src.data, bufDst = dst.data, wSrc = src.width, hSrc = src.height, wDst = dst.width, hDst = dst.height, wM = Math.max(1, Math.floor(wSrc / wDst)), wDst2 = wDst * wM, hM = Math.max(1, Math.floor(hSrc / hDst)), hDst2 = hDst * hM, buf1 = Buffer.alloc(wDst2 * hSrc * 4), i = 0; i < hSrc; i++) for (var j = 0; j < wDst2; j++) for (var x = j * (wSrc - 1) / wDst2, xPos = Math.floor(x), t = x - xPos, srcPos = 4 * (i * wSrc + xPos), buf1Pos = 4 * (i * wDst2 + j), k = 0; k < 4; k++) {
                            var kPos = srcPos + k, x0 = xPos > 0 ? bufSrc[kPos - 4] : 2 * bufSrc[kPos] - bufSrc[kPos + 4], x1 = bufSrc[kPos], x2 = bufSrc[kPos + 4], x3 = xPos < wSrc - 2 ? bufSrc[kPos + 8] : 2 * bufSrc[kPos + 4] - bufSrc[kPos];
                            buf1[buf1Pos + k] = interpolate(x0, x1, x2, x3, t);
                        }
                        for (var buf2 = Buffer.alloc(wDst2 * hDst2 * 4), _i = 0; _i < hDst2; _i++) for (var _j = 0; _j < wDst2; _j++) for (var y = _i * (hSrc - 1) / hDst2, yPos = Math.floor(y), _t = y - yPos, _buf1Pos = 4 * (yPos * wDst2 + _j), buf2Pos = 4 * (_i * wDst2 + _j), _k = 0; _k < 4; _k++) {
                            var _kPos = _buf1Pos + _k, y0 = yPos > 0 ? buf1[_kPos - 4 * wDst2] : 2 * buf1[_kPos] - buf1[_kPos + 4 * wDst2], y1 = buf1[_kPos], y2 = buf1[_kPos + 4 * wDst2], y3 = yPos < hSrc - 2 ? buf1[_kPos + 8 * wDst2] : 2 * buf1[_kPos + 4 * wDst2] - buf1[_kPos];
                            buf2[buf2Pos + _k] = interpolate(y0, y1, y2, y3, _t);
                        }
                        var m = wM * hM;
                        if (m > 1) for (var _i2 = 0; _i2 < hDst; _i2++) for (var _j2 = 0; _j2 < wDst; _j2++) {
                            for (var r = 0, g = 0, b = 0, a = 0, realColors = 0, _y = 0; _y < hM; _y++) for (var _yPos = _i2 * hM + _y, _x = 0; _x < wM; _x++) {
                                var xyPos = 4 * (_yPos * wDst2 + (_j2 * wM + _x)), pixelAlpha = buf2[xyPos + 3];
                                pixelAlpha && (r += buf2[xyPos], g += buf2[xyPos + 1], b += buf2[xyPos + 2], realColors++), 
                                a += pixelAlpha;
                            }
                            var pos = 4 * (_i2 * wDst + _j2);
                            bufDst[pos] = realColors ? Math.round(r / realColors) : 0, bufDst[pos + 1] = realColors ? Math.round(g / realColors) : 0, 
                            bufDst[pos + 2] = realColors ? Math.round(b / realColors) : 0, bufDst[pos + 3] = Math.round(a / m);
                        } else dst.data = buf2;
                    },
                    bicubicInterpolation: function bicubicInterpolation(src, dst, options) {
                        return this._interpolate2D(src, dst, options, (function interpolateCubic(x0, x1, x2, x3, t) {
                            var a0 = x3 - x2 - x0 + x1, a1 = x0 - x1 - a0, a2 = x2 - x0, a3 = x1;
                            return Math.max(0, Math.min(255, a0 * (t * t * t) + a1 * (t * t) + a2 * t + a3));
                        }));
                    },
                    hermiteInterpolation: function hermiteInterpolation(src, dst, options) {
                        return this._interpolate2D(src, dst, options, (function interpolateHermite(x0, x1, x2, x3, t) {
                            var c0 = x1, c1 = 0.5 * (x2 - x0), c2 = x0 - 2.5 * x1 + 2 * x2 - 0.5 * x3, c3 = 0.5 * (x3 - x0) + 1.5 * (x1 - x2);
                            return Math.max(0, Math.min(255, Math.round(((c3 * t + c2) * t + c1) * t + c0)));
                        }));
                    },
                    bezierInterpolation: function bezierInterpolation(src, dst, options) {
                        return this._interpolate2D(src, dst, options, (function interpolateBezier(x0, x1, x2, x3, t) {
                            var nt = 1 - t, c0 = x1 * nt * nt * nt, c1 = 3 * (x1 + (x2 - x0) / 4) * nt * nt * t, c2 = 3 * (x2 - (x3 - x1) / 4) * nt * t * t, c3 = x2 * t * t * t;
                            return Math.max(0, Math.min(255, Math.round(c0 + c1 + c2 + c3)));
                        }));
                    }
                };
            }).call(this, require("buffer").Buffer);
        }, {
            buffer: 48
        } ],
        224: [ function(require, module, exports) {
            (function(Buffer) {
                Object.defineProperty(exports, "__esModule", {
                    value: !0
                }), exports.default = void 0;
                var _utils = require("@jimp/utils");
                function advancedRotate(deg, mode) {
                    var rad = (deg %= 360) * Math.PI / 180, cosine = Math.cos(rad), sine = Math.sin(rad), w = this.bitmap.width, h = this.bitmap.height;
                    if (!0 === mode || "string" == typeof mode) {
                        (w = Math.ceil(Math.abs(this.bitmap.width * cosine) + Math.abs(this.bitmap.height * sine)) + 1) % 2 != 0 && w++, 
                        (h = Math.ceil(Math.abs(this.bitmap.width * sine) + Math.abs(this.bitmap.height * cosine)) + 1) % 2 != 0 && h++;
                        var c = this.cloneQuiet();
                        this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, (function(x, y, idx) {
                            this.bitmap.data.writeUInt32BE(this._background, idx);
                        }));
                        var max = Math.max(w, h, this.bitmap.width, this.bitmap.height);
                        this.resize(max, max, mode), this.blit(c, this.bitmap.width / 2 - c.bitmap.width / 2, this.bitmap.height / 2 - c.bitmap.height / 2);
                    }
                    var bW = this.bitmap.width, bH = this.bitmap.height, dstBuffer = Buffer.alloc(this.bitmap.data.length);
                    function createTranslationFunction(deltaX, deltaY) {
                        return function(x, y) {
                            return {
                                x: x + deltaX,
                                y: y + deltaY
                            };
                        };
                    }
                    for (var translate2Cartesian = createTranslationFunction(-bW / 2, -bH / 2), translate2Screen = createTranslationFunction(bW / 2 + 0.5, bH / 2 + 0.5), y = 1; y <= bH; y++) for (var x = 1; x <= bW; x++) {
                        var cartesian = translate2Cartesian(x, y), source = translate2Screen(cosine * cartesian.x - sine * cartesian.y, cosine * cartesian.y + sine * cartesian.x), dstIdx = bW * (y - 1) + x - 1 << 2;
                        if (source.x >= 0 && source.x < bW && source.y >= 0 && source.y < bH) {
                            var srcIdx = (bW * (0 | source.y) + source.x | 0) << 2, pixelRGBA = this.bitmap.data.readUInt32BE(srcIdx);
                            dstBuffer.writeUInt32BE(pixelRGBA, dstIdx);
                        } else dstBuffer.writeUInt32BE(this._background, dstIdx);
                    }
                    if (this.bitmap.data = dstBuffer, !0 === mode || "string" == typeof mode) {
                        var _x = bW / 2 - w / 2, _y = bH / 2 - h / 2;
                        this.crop(_x, _y, w, h);
                    }
                }
                exports.default = function _default() {
                    return {
                        rotate: function rotate(deg, mode, cb) {
                            return null == mode && (mode = !0), "function" == typeof mode && void 0 === cb && (cb = mode, 
                            mode = !0), "number" != typeof deg ? _utils.throwError.call(this, "deg must be a number", cb) : "boolean" != typeof mode && "string" != typeof mode ? _utils.throwError.call(this, "mode must be a boolean or a string", cb) : (advancedRotate.call(this, deg, mode, cb), 
                            (0, _utils.isNodePattern)(cb) && cb.call(this, null, this), this);
                        }
                    };
                }, module.exports = exports.default;
            }).call(this, require("buffer").Buffer);
        }, {
            "@jimp/utils": 235,
            buffer: 48
        } ],
        225: [ function(require, module, exports) {
            Object.defineProperty(exports, "__esModule", {
                value: !0
            }), exports.default = void 0;
            var _utils = require("@jimp/utils");
            exports.default = function _default() {
                return {
                    scale: function scale(f, mode, cb) {
                        if ("number" != typeof f) return _utils.throwError.call(this, "f must be a number", cb);
                        if (f < 0) return _utils.throwError.call(this, "f must be a positive number", cb);
                        "function" == typeof mode && void 0 === cb && (cb = mode, mode = null);
                        var w = this.bitmap.width * f, h = this.bitmap.height * f;
                        return this.resize(w, h, mode), (0, _utils.isNodePattern)(cb) && cb.call(this, null, this), 
                        this;
                    },
                    scaleToFit: function scaleToFit(w, h, mode, cb) {
                        if ("number" != typeof w || "number" != typeof h) return _utils.throwError.call(this, "w and h must be numbers", cb);
                        "function" == typeof mode && void 0 === cb && (cb = mode, mode = null);
                        var f = w / h > this.bitmap.width / this.bitmap.height ? h / this.bitmap.height : w / this.bitmap.width;
                        return this.scale(f, mode), (0, _utils.isNodePattern)(cb) && cb.call(this, null, this), 
                        this;
                    }
                };
            }, module.exports = exports.default;
        }, {
            "@jimp/utils": 235
        } ],
        226: [ function(require, module, exports) {
            Object.defineProperty(exports, "__esModule", {
                value: !0
            }), exports.default = void 0;
            var _utils = require("@jimp/utils");
            exports.default = function _default() {
                return {
                    shadow: function shadow() {
                        var _this = this, options = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {}, cb = arguments.length > 1 ? arguments[1] : void 0;
                        "function" == typeof options && (cb = options, options = {});
                        var _options = options, _options$opacity = _options.opacity, opacity = void 0 === _options$opacity ? 0.7 : _options$opacity, _options$size = _options.size, size = void 0 === _options$size ? 1.1 : _options$size, _options$x = _options.x, x = void 0 === _options$x ? -25 : _options$x, _options$y = _options.y, y = void 0 === _options$y ? 25 : _options$y, _options$blur = _options.blur, blur = void 0 === _options$blur ? 5 : _options$blur, orig = this.clone(), shadow = this.clone();
                        return shadow.scan(0, 0, shadow.bitmap.width, shadow.bitmap.height, (function(x, y, idx) {
                            shadow.bitmap.data[idx] = 0x00, shadow.bitmap.data[idx + 1] = 0x00, shadow.bitmap.data[idx + 2] = 0x00, 
                            shadow.bitmap.data[idx + 3] = shadow.constructor.limit255(shadow.bitmap.data[idx + 3] * opacity), 
                            _this.bitmap.data[idx] = 0x00, _this.bitmap.data[idx + 1] = 0x00, _this.bitmap.data[idx + 2] = 0x00, 
                            _this.bitmap.data[idx + 3] = 0x00;
                        })), shadow.resize(shadow.bitmap.width * size, shadow.bitmap.height * size).blur(blur), 
                        this.composite(shadow, x, y), this.composite(orig, 0, 0), (0, _utils.isNodePattern)(cb) && cb.call(this, null, this), 
                        this;
                    }
                };
            }, module.exports = exports.default;
        }, {
            "@jimp/utils": 235
        } ],
        227: [ function(require, module, exports) {
            Object.defineProperty(exports, "__esModule", {
                value: !0
            }), exports.default = void 0;
            var _utils = require("@jimp/utils");
            exports.default = function _default() {
                return {
                    threshold: function threshold(_ref, cb) {
                        var _this = this, max = _ref.max, _ref$replace = _ref.replace, replace = void 0 === _ref$replace ? 255 : _ref$replace, _ref$autoGreyscale = _ref.autoGreyscale, autoGreyscale = void 0 === _ref$autoGreyscale || _ref$autoGreyscale;
                        return "number" != typeof max ? _utils.throwError.call(this, "max must be a number", cb) : "number" != typeof replace ? _utils.throwError.call(this, "replace must be a number", cb) : "boolean" != typeof autoGreyscale ? _utils.throwError.call(this, "autoGreyscale must be a boolean", cb) : (max = this.constructor.limit255(max), 
                        replace = this.constructor.limit255(replace), autoGreyscale && this.greyscale(), 
                        this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, (function(x, y, idx) {
                            var grey = _this.bitmap.data[idx] < max ? _this.bitmap.data[idx] : replace;
                            _this.bitmap.data[idx] = grey, _this.bitmap.data[idx + 1] = grey, _this.bitmap.data[idx + 2] = grey;
                        })), (0, _utils.isNodePattern)(cb) && cb.call(this, null, this), this);
                    }
                };
            }, module.exports = exports.default;
        }, {
            "@jimp/utils": 235
        } ],
        228: [ function(require, module, exports) {
            var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
            Object.defineProperty(exports, "__esModule", {
                value: !0
            }), exports.default = void 0;
            var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray")), _timm = require("timm"), _pluginBlit = _interopRequireDefault(require("@jimp/plugin-blit")), _pluginBlur = _interopRequireDefault(require("@jimp/plugin-blur")), _pluginCircle = _interopRequireDefault(require("@jimp/plugin-circle")), _pluginColor = _interopRequireDefault(require("@jimp/plugin-color")), _pluginContain = _interopRequireDefault(require("@jimp/plugin-contain")), _pluginCover = _interopRequireDefault(require("@jimp/plugin-cover")), _pluginCrop = _interopRequireDefault(require("@jimp/plugin-crop")), _pluginDisplace = _interopRequireDefault(require("@jimp/plugin-displace")), _pluginDither = _interopRequireDefault(require("@jimp/plugin-dither")), _pluginFisheye = _interopRequireDefault(require("@jimp/plugin-fisheye")), _pluginFlip = _interopRequireDefault(require("@jimp/plugin-flip")), _pluginGaussian = _interopRequireDefault(require("@jimp/plugin-gaussian")), _pluginInvert = _interopRequireDefault(require("@jimp/plugin-invert")), _pluginMask = _interopRequireDefault(require("@jimp/plugin-mask")), _pluginNormalize = _interopRequireDefault(require("@jimp/plugin-normalize")), _pluginPrint = _interopRequireDefault(require("@jimp/plugin-print")), _pluginResize = _interopRequireDefault(require("@jimp/plugin-resize")), _pluginRotate = _interopRequireDefault(require("@jimp/plugin-rotate")), _pluginScale = _interopRequireDefault(require("@jimp/plugin-scale")), _pluginShadow = _interopRequireDefault(require("@jimp/plugin-shadow")), _pluginThreshold = _interopRequireDefault(require("@jimp/plugin-threshold")), plugins = [ _pluginBlit.default, _pluginBlur.default, _pluginCircle.default, _pluginColor.default, _pluginContain.default, _pluginCover.default, _pluginCrop.default, _pluginDisplace.default, _pluginDither.default, _pluginFisheye.default, _pluginFlip.default, _pluginGaussian.default, _pluginInvert.default, _pluginMask.default, _pluginNormalize.default, _pluginPrint.default, _pluginResize.default, _pluginRotate.default, _pluginScale.default, _pluginShadow.default, _pluginThreshold.default ];
            exports.default = function _default(jimpEvChange) {
                var initializedPlugins = plugins.map((function(pluginModule) {
                    var plugin = pluginModule(jimpEvChange) || {};
                    return plugin.class || plugin.constants || (plugin = {
                        class: plugin
                    }), plugin;
                }));
                return _timm.mergeDeep.apply(void 0, (0, _toConsumableArray2.default)(initializedPlugins));
            }, module.exports = exports.default;
        }, {
            "@babel/runtime/helpers/interopRequireDefault": 11,
            "@babel/runtime/helpers/toConsumableArray": 20,
            "@jimp/plugin-blit": 201,
            "@jimp/plugin-blur": 203,
            "@jimp/plugin-circle": 204,
            "@jimp/plugin-color": 205,
            "@jimp/plugin-contain": 206,
            "@jimp/plugin-cover": 207,
            "@jimp/plugin-crop": 208,
            "@jimp/plugin-displace": 209,
            "@jimp/plugin-dither": 210,
            "@jimp/plugin-fisheye": 211,
            "@jimp/plugin-flip": 212,
            "@jimp/plugin-gaussian": 213,
            "@jimp/plugin-invert": 214,
            "@jimp/plugin-mask": 215,
            "@jimp/plugin-normalize": 216,
            "@jimp/plugin-print": 217,
            "@jimp/plugin-resize": 221,
            "@jimp/plugin-rotate": 224,
            "@jimp/plugin-scale": 225,
            "@jimp/plugin-shadow": 226,
            "@jimp/plugin-threshold": 227,
            timm: 177
        } ],
        229: [ function(require, module, exports) {
            var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
            Object.defineProperty(exports, "__esModule", {
                value: !0
            }), exports.default = void 0;
            var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty")), _bmpJs = _interopRequireDefault(require("bmp-js")), _utils = require("@jimp/utils"), decode = function decode(data) {
                return function fromAGBR(bitmap) {
                    return (0, _utils.scan)({
                        bitmap
                    }, 0, 0, bitmap.width, bitmap.height, (function(x, y, index) {
                        var alpha = this.bitmap.data[index + 0], blue = this.bitmap.data[index + 1], green = this.bitmap.data[index + 2], red = this.bitmap.data[index + 3];
                        this.bitmap.data[index + 0] = red, this.bitmap.data[index + 1] = green, this.bitmap.data[index + 2] = blue, 
                        this.bitmap.data[index + 3] = bitmap.is_with_alpha ? alpha : 0xff;
                    })).bitmap;
                }(_bmpJs.default.decode(data));
            }, encode = function encode(image) {
                return _bmpJs.default.encode(function toAGBR(image) {
                    return (0, _utils.scan)(image, 0, 0, image.bitmap.width, image.bitmap.height, (function(x, y, index) {
                        var red = this.bitmap.data[index + 0], green = this.bitmap.data[index + 1], blue = this.bitmap.data[index + 2], alpha = this.bitmap.data[index + 3];
                        this.bitmap.data[index + 0] = alpha, this.bitmap.data[index + 1] = blue, this.bitmap.data[index + 2] = green, 
                        this.bitmap.data[index + 3] = red;
                    })).bitmap;
                }(image)).data;
            };
            exports.default = function _default() {
                var _decoders, _encoders;
                return {
                    mime: (0, _defineProperty2.default)({}, "image/bmp", [ "bmp" ]),
                    constants: {
                        MIME_BMP: "image/bmp",
                        MIME_X_MS_BMP: "image/x-ms-bmp"
                    },
                    decoders: (_decoders = {}, (0, _defineProperty2.default)(_decoders, "image/bmp", decode), 
                    (0, _defineProperty2.default)(_decoders, "image/x-ms-bmp", decode), _decoders),
                    encoders: (_encoders = {}, (0, _defineProperty2.default)(_encoders, "image/bmp", encode), 
                    (0, _defineProperty2.default)(_encoders, "image/x-ms-bmp", encode), _encoders)
                };
            }, module.exports = exports.default;
        }, {
            "@babel/runtime/helpers/defineProperty": 7,
            "@babel/runtime/helpers/interopRequireDefault": 11,
            "@jimp/utils": 235,
            "bmp-js": 30
        } ],
        230: [ function(require, module, exports) {
            (function(Buffer) {
                var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
                Object.defineProperty(exports, "__esModule", {
                    value: !0
                }), exports.default = void 0;
                var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty")), _omggif = _interopRequireDefault(require("omggif")), _gifwrap = require("gifwrap");
                exports.default = function _default() {
                    return {
                        mime: (0, _defineProperty2.default)({}, "image/gif", [ "gif" ]),
                        constants: {
                            MIME_GIF: "image/gif"
                        },
                        decoders: (0, _defineProperty2.default)({}, "image/gif", (function(data) {
                            var gifObj = new _omggif.default.GifReader(data), gifData = Buffer.alloc(gifObj.width * gifObj.height * 4);
                            return gifObj.decodeAndBlitFrameRGBA(0, gifData), {
                                data: gifData,
                                width: gifObj.width,
                                height: gifObj.height
                            };
                        })),
                        encoders: (0, _defineProperty2.default)({}, "image/gif", (function(data) {
                            var bitmap = new _gifwrap.BitmapImage(data.bitmap);
                            _gifwrap.GifUtil.quantizeDekker(bitmap, 256);
                            var newFrame = new _gifwrap.GifFrame(bitmap);
                            return (new _gifwrap.GifCodec).encodeGif([ newFrame ], {}).then((function(newGif) {
                                return newGif.buffer;
                            }));
                        }))
                    };
                }, module.exports = exports.default;
            }).call(this, require("buffer").Buffer);
        }, {
            "@babel/runtime/helpers/defineProperty": 7,
            "@babel/runtime/helpers/interopRequireDefault": 11,
            buffer: 48,
            gifwrap: 70,
            omggif: 85
        } ],
        231: [ function(require, module, exports) {
            var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
            Object.defineProperty(exports, "__esModule", {
                value: !0
            }), exports.default = void 0;
            var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty")), _jpegJs = _interopRequireDefault(require("jpeg-js")), _utils = require("@jimp/utils");
            exports.default = function _default() {
                return {
                    mime: (0, _defineProperty2.default)({}, "image/jpeg", [ "jpeg", "jpg", "jpe" ]),
                    constants: {
                        MIME_JPEG: "image/jpeg"
                    },
                    decoders: (0, _defineProperty2.default)({}, "image/jpeg", _jpegJs.default.decode),
                    encoders: (0, _defineProperty2.default)({}, "image/jpeg", (function(image) {
                        return _jpegJs.default.encode(image.bitmap, image._quality).data;
                    })),
                    class: {
                        _quality: 100,
                        quality: function quality(n, cb) {
                            return "number" != typeof n ? _utils.throwError.call(this, "n must be a number", cb) : n < 0 || n > 100 ? _utils.throwError.call(this, "n must be a number 0 - 100", cb) : (this._quality = Math.round(n), 
                            (0, _utils.isNodePattern)(cb) && cb.call(this, null, this), this);
                        }
                    }
                };
            }, module.exports = exports.default;
        }, {
            "@babel/runtime/helpers/defineProperty": 7,
            "@babel/runtime/helpers/interopRequireDefault": 11,
            "@jimp/utils": 235,
            "jpeg-js": 80
        } ],
        232: [ function(require, module, exports) {
            var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
            Object.defineProperty(exports, "__esModule", {
                value: !0
            }), exports.default = void 0;
            var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty")), _pngjs = require("pngjs"), _utils = require("@jimp/utils");
            exports.default = function _default() {
                return {
                    mime: (0, _defineProperty2.default)({}, "image/png", [ "png" ]),
                    constants: {
                        MIME_PNG: "image/png",
                        PNG_FILTER_AUTO: -1,
                        PNG_FILTER_NONE: 0,
                        PNG_FILTER_SUB: 1,
                        PNG_FILTER_UP: 2,
                        PNG_FILTER_AVERAGE: 3,
                        PNG_FILTER_PATH: 4
                    },
                    hasAlpha: (0, _defineProperty2.default)({}, "image/png", !0),
                    decoders: (0, _defineProperty2.default)({}, "image/png", _pngjs.PNG.sync.read),
                    encoders: (0, _defineProperty2.default)({}, "image/png", (function(data) {
                        var png = new _pngjs.PNG({
                            width: data.bitmap.width,
                            height: data.bitmap.height
                        });
                        return png.data = data.bitmap.data, _pngjs.PNG.sync.write(png, {
                            width: data.bitmap.width,
                            height: data.bitmap.height,
                            deflateLevel: data._deflateLevel,
                            deflateStrategy: data._deflateStrategy,
                            filterType: data._filterType,
                            colorType: "number" == typeof data._colorType ? data._colorType : data._rgba ? 6 : 2,
                            inputHasAlpha: data._rgba
                        });
                    })),
                    class: {
                        _deflateLevel: 9,
                        _deflateStrategy: 3,
                        _filterType: -1,
                        _colorType: null,
                        deflateLevel: function deflateLevel(l, cb) {
                            return "number" != typeof l ? _utils.throwError.call(this, "l must be a number", cb) : l < 0 || l > 9 ? _utils.throwError.call(this, "l must be a number 0 - 9", cb) : (this._deflateLevel = Math.round(l), 
                            (0, _utils.isNodePattern)(cb) && cb.call(this, null, this), this);
                        },
                        deflateStrategy: function deflateStrategy(s, cb) {
                            return "number" != typeof s ? _utils.throwError.call(this, "s must be a number", cb) : s < 0 || s > 3 ? _utils.throwError.call(this, "s must be a number 0 - 3", cb) : (this._deflateStrategy = Math.round(s), 
                            (0, _utils.isNodePattern)(cb) && cb.call(this, null, this), this);
                        },
                        filterType: function filterType(f, cb) {
                            return "number" != typeof f ? _utils.throwError.call(this, "n must be a number", cb) : f < -1 || f > 4 ? _utils.throwError.call(this, "n must be -1 (auto) or a number 0 - 4", cb) : (this._filterType = Math.round(f), 
                            (0, _utils.isNodePattern)(cb) && cb.call(this, null, this), this);
                        },
                        colorType: function colorType(s, cb) {
                            return "number" != typeof s ? _utils.throwError.call(this, "s must be a number", cb) : 0 !== s && 2 !== s && 4 !== s && 6 !== s ? _utils.throwError.call(this, "s must be a number 0, 2, 4, 6.", cb) : (this._colorType = Math.round(s), 
                            (0, _utils.isNodePattern)(cb) && cb.call(this, null, this), this);
                        }
                    }
                };
            }, module.exports = exports.default;
        }, {
            "@babel/runtime/helpers/defineProperty": 7,
            "@babel/runtime/helpers/interopRequireDefault": 11,
            "@jimp/utils": 235,
            pngjs: 129
        } ],
        233: [ function(require, module, exports) {
            (function(Buffer) {
                var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
                Object.defineProperty(exports, "__esModule", {
                    value: !0
                }), exports.default = void 0;
                var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty")), _utif = _interopRequireDefault(require("utif"));
                exports.default = function _default() {
                    return {
                        mime: (0, _defineProperty2.default)({}, "image/tiff", [ "tiff", "tif" ]),
                        constants: {
                            MIME_TIFF: "image/tiff"
                        },
                        decoders: (0, _defineProperty2.default)({}, "image/tiff", (function(data) {
                            var ifds = _utif.default.decode(data), page = ifds[0];
                            _utif.default.decodeImages(data, ifds);
                            var rgba = _utif.default.toRGBA8(page);
                            return {
                                data: Buffer.from(rgba),
                                width: page.t256[0],
                                height: page.t257[0]
                            };
                        })),
                        encoders: (0, _defineProperty2.default)({}, "image/tiff", (function(image) {
                            var tiff = _utif.default.encodeImage(image.bitmap.data, image.bitmap.width, image.bitmap.height);
                            return Buffer.from(tiff);
                        }))
                    };
                }, module.exports = exports.default;
            }).call(this, require("buffer").Buffer);
        }, {
            "@babel/runtime/helpers/defineProperty": 7,
            "@babel/runtime/helpers/interopRequireDefault": 11,
            buffer: 48,
            utif: 182
        } ],
        234: [ function(require, module, exports) {
            var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
            Object.defineProperty(exports, "__esModule", {
                value: !0
            }), exports.default = void 0;
            var _timm = require("timm"), _jpeg = _interopRequireDefault(require("@jimp/jpeg")), _png = _interopRequireDefault(require("@jimp/png")), _bmp = _interopRequireDefault(require("@jimp/bmp")), _tiff = _interopRequireDefault(require("@jimp/tiff")), _gif = _interopRequireDefault(require("@jimp/gif"));
            exports.default = function _default() {
                return (0, _timm.mergeDeep)((0, _jpeg.default)(), (0, _png.default)(), (0, _bmp.default)(), (0, 
                _tiff.default)(), (0, _gif.default)());
            }, module.exports = exports.default;
        }, {
            "@babel/runtime/helpers/interopRequireDefault": 11,
            "@jimp/bmp": 229,
            "@jimp/gif": 230,
            "@jimp/jpeg": 231,
            "@jimp/png": 232,
            "@jimp/tiff": 233,
            timm: 177
        } ],
        235: [ function(require, module, exports) {
            var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
            Object.defineProperty(exports, "__esModule", {
                value: !0
            }), exports.isNodePattern = function isNodePattern(cb) {
                if (void 0 === cb) return !1;
                if ("function" != typeof cb) throw new TypeError("Callback must be a function");
                return !0;
            }, exports.throwError = function throwError(error, cb) {
                if ("string" == typeof error && (error = new Error(error)), "function" == typeof cb) return cb.call(this, error);
                throw error;
            }, exports.scan = function scan(image, x, y, w, h, f) {
                x = Math.round(x), y = Math.round(y), w = Math.round(w), h = Math.round(h);
                for (var _y = y; _y < y + h; _y++) for (var _x = x; _x < x + w; _x++) {
                    var idx = image.bitmap.width * _y + _x << 2;
                    f.call(image, _x, _y, idx);
                }
                return image;
            }, exports.scanIterator = scanIterator;
            var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator")), _marked = _regenerator.default.mark(scanIterator);
            function scanIterator(image, x, y, w, h) {
                var _y, _x, idx;
                return _regenerator.default.wrap((function scanIterator$(_context) {
                    for (;;) switch (_context.prev = _context.next) {
                      case 0:
                        x = Math.round(x), y = Math.round(y), w = Math.round(w), h = Math.round(h), _y = y;

                      case 5:
                        if (!(_y < y + h)) {
                            _context.next = 17;
                            break;
                        }
                        _x = x;

                      case 7:
                        if (!(_x < x + w)) {
                            _context.next = 14;
                            break;
                        }
                        return idx = image.bitmap.width * _y + _x << 2, _context.next = 11, {
                            x: _x,
                            y: _y,
                            idx,
                            image
                        };

                      case 11:
                        _x++, _context.next = 7;
                        break;

                      case 14:
                        _y++, _context.next = 5;
                        break;

                      case 17:
                      case "end":
                        return _context.stop();
                    }
                }), _marked);
            }
        }, {
            "@babel/runtime/helpers/interopRequireDefault": 11,
            "@babel/runtime/regenerator": 22
        } ]
    }, {}, [ 200 ])(200);
}();

var JimpImport = getDefaultExportFromCjs(jimp.exports);

const Jimp$7 = JimpImport;

function prepareRotateVariables(width, height) {
    let margin = (width - height) / 2;
    return height > width && (margin *= -1), {
        max: Math.max(width, height),
        margin
    };
}

const Jimp$6 = JimpImport;

function prepareSpinVariables(delay, centisecsPerRotation, reverse, width, height) {
    let degrees = 360 * delay / centisecsPerRotation;
    const interval = Math.floor(360 / degrees);
    degrees *= reverse ? 1 : -1;
    let margin = (width - height) / 2;
    return height > width && (margin *= -1), {
        degrees,
        interval,
        max: Math.max(width, height),
        margin
    };
}

const Jimp$5 = JimpImport;

function greatestCommonDenominator(a, b) {
    return b ? greatestCommonDenominator(b, a % b) : a;
}

const Jimp$4 = JimpImport;

function shiftColor(bitmap, index, shiftAmount, randomBlack, randomWhite) {
    const [firstColor, secondColor, thirdColor] = [ bitmap[index] ?? 0, bitmap[index + 1] ?? 0, bitmap[index + 2] ?? 0 ];
    let colors;
    return colors = firstColor <= 30 && secondColor <= 30 && thirdColor <= 30 ? [ randomWhite, 0.5, 0.2 ] : firstColor >= 220 && secondColor >= 220 && thirdColor >= 220 ? [ randomBlack, 0.5, 0.8 ] : function rgb2hsl(_r, _g, _b) {
        const r = _r / 255, g = _g / 255, b = _b / 255, max = Math.max(r, g, b), min = Math.min(r, g, b);
        let h, s;
        const l = (max + min) / 2;
        if (max === min) h = 0, s = 0; else {
            const d = max - min;
            switch (s = l > 0.5 ? d / (2 - max - min) : d / (max + min), max) {
              case r:
                h = (g - b) / d + (g < b ? 6 : 0);
                break;

              case g:
                h = (b - r) / d + 2;
                break;

              case b:
                h = (r - g) / d + 4;
                break;

              default:
                h = 0;
            }
            h /= 6;
        }
        return [ h, s, l ];
    }(firstColor, secondColor, thirdColor), colors[0] += shiftAmount, colors;
}

function hue2rgb(p, q, _t) {
    let t = _t;
    return t < 0 ? t++ : t > 1 && t--, t < 1 / 6 ? p + 6 * (q - p) * t : t < .5 ? q : t < 2 / 3 ? p + (q - p) * (2 / 3 - t) * 6 : p;
}

function hsl2rgb(h, s, l) {
    let r, g, b, q, p;
    return 0 === s ? (r = l, g = l, b = l) : (q = l < 0.5 ? l * (1 + s) : l + s - l * s, 
    p = 2 * l - q, r = hue2rgb(p, q, h + 1 / 3), g = hue2rgb(p, q, h), b = hue2rgb(p, q, h - 1 / 3)), 
    [ 255 * r, 255 * g, 255 * b ];
}

function shiftColors(bitmap, interval, randomBlack, randomWhite) {
    for (let i = 0; i < bitmap.data.length; i += 4) if ((bitmap.data[i + 3] ?? 0) > 0) {
        let colors = shiftColor(bitmap.data, i, interval, randomBlack, randomWhite);
        for (;colors[0] > 1; ) colors[0]--;
        colors = hsl2rgb(colors[0], colors[1], colors[2]), bitmap.data.set(colors, i);
    }
}

const Jimp$3 = JimpImport;

function prepareWiggleVariables(margin, height) {
    const shiftSize = Math.max(1, margin / 6);
    return {
        shiftSize,
        interval: 2 * (margin / shiftSize + 4),
        stripeHeight: Math.max(1, Math.floor(height / 32)),
        shift: margin / 2,
        left: !0
    };
}

function shiftWiggleStep(_shift, _left, margin, shiftSize) {
    let shift = _shift, left = _left;
    return left ? (shift -= shiftSize, shift < -shiftSize && (left = !1)) : (shift += shiftSize, 
    shift > margin + shiftSize && (left = !0)), [ shift, left ];
}

function getWiggledFrameData(oldFrame, _shift, _left, options) {
    const newFrame = new Jimp$3(options.width, oldFrame.bitmap.height);
    let shift = _shift, left = _left;
    for (let stripe = 0; stripe < oldFrame.bitmap.height; stripe += options.stripeHeight) newFrame.blit(oldFrame, shift, stripe, 0, stripe, oldFrame.bitmap.width, options.stripeHeight), 
    [shift, left] = shiftWiggleStep(shift, left, options.margin, options.shiftSize);
    return newFrame.bitmap;
}

const Jimp$2 = JimpImport;

function resetInfiniteScales(scalesAmount, scaleDiff, scaleStep) {
    const scales = [];
    for (let depth = 0; depth < scalesAmount; depth++) scales.push((scalesAmount - depth - 1) * scaleDiff + scaleStep);
    return scales;
}

function getInfiniteShiftedFrameData(frameBitmap, scales) {
    const newFrame = new Jimp$2(frameBitmap.width, frameBitmap.height, 0x00);
    return scales.forEach((scale => {
        const scaledFrame = new Jimp$2(frameBitmap);
        scaledFrame.scale(scale);
        const dx = (scaledFrame.bitmap.width - frameBitmap.width) / 2, dy = (scaledFrame.bitmap.height - frameBitmap.height) / 2;
        scale > 1 ? newFrame.blit(scaledFrame, 0, 0, dx, dy, frameBitmap.width, frameBitmap.height) : newFrame.blit(scaledFrame, -dx, -dy);
    })), newFrame.bitmap;
}

function shiftInfiniteScales(_scales, scaleDiff, scaleStep) {
    let scales = _scales;
    if ((scales[0] ?? 0) >= scales.length * scaleDiff) scales = resetInfiniteScales(scales.length, scaleDiff, scaleStep); else for (let depth = 0; depth < scales.length; depth++) scales[depth] += scaleStep;
    return scales;
}

const Jimp$1 = JimpImport;

function prepareSlidingVariables(width, speed) {
    const interval = 2 * speed;
    return {
        interval,
        shift: 0,
        shiftSize: width / interval
    };
}

function getShiftedFrameData(oldFrame, shift) {
    const {width} = oldFrame.bitmap, {height} = oldFrame.bitmap, newFrame = new Jimp$1(width, height, 0x00);
    return newFrame.blit(oldFrame, shift, 0, 0, 0, width - shift, height), newFrame.blit(oldFrame, 0, 0, width - shift, 0, shift, height), 
    newFrame.bitmap;
}

const Jimp = JimpImport;

function resetDrop(delay) {
    let speed = Math.random();
    const len = Math.floor(5 * speed + 1), size = Math.floor(2 * speed + 1);
    return speed = Math.floor(speed * delay + delay), {
        speed,
        len,
        size
    };
}

class Drop {
    width;
    height;
    delay;
    x;
    y;
    speed;
    len;
    size;
    r=0;
    g=0;
    b=0;
    constructor(width, height, delay) {
        this.width = width, this.height = height, this.delay = delay, this.x = Math.random() * width, 
        this.y = Math.random() * height;
        const {speed, len, size} = resetDrop(this.delay);
        this.speed = speed, this.len = len, this.size = size;
    }
    fall() {
        if (this.y += this.speed, this.y > this.height) {
            this.y = 0;
            const {speed, len, size} = resetDrop(this.delay);
            this.speed = speed, this.len = len, this.size = size;
        }
    }
    setColor(r, g, b) {
        this.r = r, this.g = g, this.b = b;
    }
}

function rainImageGenerator(width, height, glitter, delay) {
    const drops = [];
    for (let i = 0, amount = (width + height) / 5; i < amount; i++) drops.push(new Drop(width, height, delay));
    return glitter ? drops.forEach((drop => {
        drop.setColor(256 * Math.random(), 256 * Math.random(), 256 * Math.random());
    })) : drops.forEach((drop => drop.setColor(0, 120, 255))), {
        next() {
            const img = new Jimp(width, height, 0x00);
            return drops.forEach((drop => {
                for (let j = 0; j < drop.len; j++) for (let k = 0; k < drop.size; k++) {
                    const pos = 4 * (Math.floor(drop.y + j) * width + Math.floor(drop.x + k));
                    img.bitmap.data[pos + 0] = drop.r, img.bitmap.data[pos + 1] = drop.g, img.bitmap.data[pos + 2] = drop.b, 
                    img.bitmap.data[pos + 3] = 255;
                }
                drop.fall();
            })), img;
        }
    };
}

class GifsicleService extends BaseService {
    async start() {
        !function setBuffer(buffer) {
            Buffer$1 = buffer;
        }((await Promise.resolve().then((function() {
            return _interopNamespace(require("buffer"));
        }))).Buffer);
    }
    async modifyGif(url, options) {
        Logger.info("Got GIF request", url, options);
        const commands = this.getCommands(options);
        Logger.info("Processed request commands", commands);
        const buffer = await this.processCommands(url, commands);
        return Logger.info("Processed modified emote", {
            length: buffer.length
        }), buffer;
    }
    getCommands(options) {
        const normal = [], special = [], priority = [];
        return options.forEach((option => {
            switch (option[0]) {
              case "resize":
                {
                    const command = {
                        name: "--scale",
                        param: option[1]
                    }, split = command.param?.toString().split("x");
                    !0 === split?.some((axis => parseFloat(axis) > 1)) ? normal.push(command) : priority.push(command);
                    break;
                }

              case "reverse":
                normal.push({
                    name: "#-1-0"
                });
                break;

              case "flip":
                normal.push({
                    name: "--flip-horizontal"
                });
                break;

              case "flap":
                normal.push({
                    name: "--flip-vertical"
                });
                break;

              case "speed":
                {
                    const param = option[1]?.toString() ?? "";
                    param && normal.push({
                        name: `-d${Math.max(2, parseFloat(param))}`
                    });
                    break;
                }

              case "hyperspeed":
                normal.push({
                    name: "hyperspeed"
                });
                break;

              case "rotate":
                special.push({
                    name: option[0],
                    param: option[1]
                });
                break;

              case "wiggle":
                {
                    let size = 2;
                    const param = option[1];
                    "big" === param ? size = 4 : "bigger" === param ? size = 6 : "huge" === param && (size = 10), 
                    special.push({
                        name: option[0],
                        param: size
                    });
                    break;
                }

              case "rain":
                special.push({
                    name: option[0],
                    param: "glitter" === option[1] ? 1 : 0
                });
                break;

              case "spin":
              case "spinrev":
              case "shake":
              case "rainbow":
              case "infinite":
              case "slide":
              case "sliderev":
                {
                    let speed = 8;
                    const param = option[1];
                    "fast" === param ? speed = 6 : "faster" === param ? speed = 4 : "hyper" === param && (speed = 2), 
                    special.push({
                        name: option[0],
                        param: speed
                    });
                    break;
                }
            }
        })), {
            normal,
            special,
            priority
        };
    }
    async processCommands(url, commands) {
        const fileType = url.endsWith("gif") ? "gif" : "png";
        let size, buffer = await urlGetBuffer(url);
        if ("gif" === fileType && (commands.priority.length > 0 && (buffer = await this.doModification(buffer, commands.priority)), 
        buffer = await this.doModification(buffer, [ {
            name: "--unoptimize"
        } ])), "png" === fileType) {
            const scaleIndex = this.getCommandIndex(commands.priority, "--scale");
            void 0 !== scaleIndex && (size = commands.priority[scaleIndex]?.param);
        }
        if (commands.special.length > 0 && (buffer = await this.processSpecialCommands({
            data: buffer,
            commands: commands.special,
            fileType,
            size
        })), commands.normal.length > 0 && (buffer = await this.processNormalCommands(buffer, commands.normal)), 
        !(buffer instanceof Buffer$1)) throw Error("Did not process gif!");
        return buffer;
    }
    async doModification(data, options, _retryCount = 0) {
        if (0 === data.length) return Buffer$1.concat([]);
        let retryCount = _retryCount;
        const gifsicleParams = [];
        options.forEach((option => {
            const param = option.param ?? "";
            gifsicleParams.push(option.name), "" !== param && gifsicleParams.push(param.toString());
        }));
        const buffer = data, result = (await gifsicle.run({
            input: [ {
                file: buffer.buffer,
                name: "1.gif"
            } ],
            command: [ `${gifsicleParams.join(" ")} 1.gif -o /out/out.gif` ]
        }))[0];
        if (!result) return Buffer$1.from([]);
        const arrayBuffer = await result.arrayBuffer();
        return 0 === arrayBuffer.byteLength && retryCount < 5 ? (retryCount++, this.doModification(data, options, retryCount)) : Buffer$1.from(arrayBuffer);
    }
    getCommandIndex(commands, name) {
        const index = commands.findIndex((command => command.name === name));
        return -1 !== index ? index : void 0;
    }
    async processSpecialCommands(options) {
        const {commands} = options;
        let currentBuffer = options.data;
        Logger.info(`Commands count: ${commands.length}`);
        for (const [index, command] of commands.entries()) {
            const value = (command.param ?? 0).toString(), size = (options.size ?? 1).toString();
            currentBuffer = await this.processSpecialCommand({
                name: command.name,
                value: parseFloat(value),
                buffer: currentBuffer,
                type: 0 === index ? options.fileType : "gif",
                size,
                isResized: index > 0
            });
        }
        return currentBuffer;
    }
    processSpecialCommand(command) {
        switch (Logger.info(`Command name: ${command.name}`), command.name) {
          case "rotate":
            return function rotateEmote(options) {
                return "gif" === options.type ? async function createRotatedGIF(options) {
                    const inputGif = await getGifFromBuffer(options.buffer), max = Math.max(inputGif.width, inputGif.height), encoder = new GIFEncoder(max, max);
                    setEncoderProperties(encoder);
                    const degrees = -options.value, {margin} = prepareRotateVariables(inputGif.width, inputGif.height), {frames} = inputGif;
                    for (let i = 0; i < frames.length; i++) {
                        encoder.setDelay(10 * (frames[i]?.delayCentisecs ?? 0));
                        const adjustedImg = new Jimp$7(max, max);
                        inputGif.width > inputGif.height ? adjustedImg.blit(new Jimp$7(frames[i]?.bitmap), 0, margin) : adjustedImg.blit(new Jimp$7(frames[i]?.bitmap), margin, 0), 
                        adjustedImg.rotate(degrees, !1), encoder.addFrame(adjustedImg.bitmap.data);
                    }
                    return encoder.finish(), encoder.getAndResetBuffer();
                }(options) : async function createRotatedPNG(options) {
                    let image = await Jimp$7.read(options.buffer);
                    const {width, height} = preparePNGVariables(options, image.bitmap), degrees = options.value, {max, margin} = prepareRotateVariables(width, height), encoder = new GIFEncoder(max, max);
                    image.resize(width, height);
                    const resizedImage = new Jimp$7(max, max);
                    image = width > height ? resizedImage.blit(image, 0, margin) : resizedImage.blit(image, margin, 0), 
                    setEncoderProperties(encoder, 10 * options.value);
                    const rotatedImage = new Jimp$7(resizedImage.bitmap);
                    return rotatedImage.rotate(degrees, !1), encoder.addFrame(rotatedImage.bitmap.data), 
                    encoder.finish(), encoder.getAndResetBuffer();
                }(options);
            }(command);

          case "spin":
          case "spinrev":
            return function spinEmote(options) {
                return "gif" === options.type ? async function createSpinningGIF(options) {
                    const inputGif = await getGifFromBuffer(options.buffer), max = Math.max(inputGif.width, inputGif.height), encoder = new GIFEncoder(max, max);
                    setEncoderProperties(encoder);
                    const {degrees, interval, margin} = prepareSpinVariables(inputGif.frames[0]?.delayCentisecs ?? 0, 200 * options.value / 8, "spinrev" === options.name, inputGif.width, inputGif.height), frames = alignGif(inputGif.frames, interval);
                    for (let i = 0; i < frames.length; i++) {
                        encoder.setDelay(10 * (frames[i]?.delayCentisecs ?? 0));
                        const adjustedImg = new Jimp$6(max, max);
                        inputGif.width > inputGif.height ? adjustedImg.blit(new Jimp$6(frames[i]?.bitmap), 0, margin) : adjustedImg.blit(new Jimp$6(frames[i]?.bitmap), margin, 0), 
                        adjustedImg.rotate(i * degrees % 360, !1), encoder.addFrame(adjustedImg.bitmap.data);
                    }
                    return encoder.finish(), encoder.getAndResetBuffer();
                }(options) : async function createSpinningPNG(options) {
                    let image = await Jimp$6.read(options.buffer);
                    const {width, height} = preparePNGVariables(options, image.bitmap), {degrees, interval, max, margin} = prepareSpinVariables(options.value, 200 * options.value / 8, "spinrev" === options.name, width, height), encoder = new GIFEncoder(max, max);
                    image.resize(width, height);
                    const resizedImage = new Jimp$6(max, max);
                    image = width > height ? resizedImage.blit(image, 0, margin) : resizedImage.blit(image, margin, 0), 
                    setEncoderProperties(encoder, 10 * options.value);
                    for (let i = 0; i < interval; i++) {
                        const rotatedImage = new Jimp$6(resizedImage.bitmap);
                        rotatedImage.rotate(i * degrees, !1), encoder.addFrame(rotatedImage.bitmap.data);
                    }
                    return encoder.finish(), encoder.getAndResetBuffer();
                }(options);
            }(command);

          case "shake":
            return function shakeEmote(options) {
                return "gif" === options.type ? async function createShakingGIF(options) {
                    const inputGif = await getGifFromBuffer(options.buffer);
                    let speed = Math.max(2, options.value), delay = inputGif.frames[0]?.delayCentisecs ?? 0, {frames} = inputGif, interval = 1, incrValue = 1;
                    if (delay !== speed) {
                        const padAmount = function lowestCommonDenominator(a, b) {
                            return a * b / greatestCommonDenominator(a, b);
                        }(delay, speed) / speed;
                        if (frames.length * padAmount > 800 && (frames = frames.filter(((_, i) => i % 2 == 0)), 
                        delay *= 2, speed *= 2), frames = function padGif(frames, amountCopies) {
                            if (amountCopies < 2) return src.GifUtil.cloneFrames(frames);
                            const copiedFrames = [];
                            return frames.forEach((frame => {
                                for (let j = 0; j < amountCopies; j++) copiedFrames.push(new src.GifFrame(frame.bitmap));
                            })), copiedFrames;
                        }(frames, padAmount), delay > speed ? (delay /= padAmount, interval = speed / greatestCommonDenominator(delay, speed), 
                        1 === delay && (interval /= 2)) : delay < speed && (delay /= padAmount, incrValue = greatestCommonDenominator(delay, speed) / speed, 
                        1 === delay && (incrValue /= 2)), 1 === delay) {
                            if (frames.length % 2 != 0) {
                                const frameToDelete = Math.floor(Math.random() * frames.length - 1) + 1;
                                frames.splice(frameToDelete, 1);
                            }
                            frames = frames.filter(((_, i) => i % 2 == 0)), delay = 2;
                        }
                        incrValue *= 4;
                    }
                    let dx = 0, dy = 0, sx = 1, sy = 1, offsets = 3, state = 0;
                    const encoder = new GIFEncoder(inputGif.width, inputGif.height);
                    setEncoderProperties(encoder, 10 * delay);
                    for (let i = 0; i < frames.length; i++) {
                        state += incrValue, state >= interval && (state -= interval, offsets <<= 1, offsets > 16 && (offsets -= 15), 
                        dx = offsets >> 3, dy = offsets >> 2 & 1, sx = offsets >> 1 & 1, sy = 1 & offsets);
                        const shakenFrame = new Jimp$5(inputGif.width, inputGif.height, 0x00);
                        shakenFrame.blit(new Jimp$5(frames[i]?.bitmap), dx, dy, sx, sy, inputGif.width - 1, inputGif.height - 1), 
                        encoder.addFrame(shakenFrame.bitmap.data);
                    }
                    return encoder.finish(), encoder.getAndResetBuffer();
                }(options) : async function createShakingPNG(options) {
                    const image = await Jimp$5.read(options.buffer), {width, height, encoder} = preparePNGVariables(options, image.bitmap);
                    image.resize(width, height), setEncoderProperties(encoder, 10 * options.value);
                    for (let i = 0; i < 4; i++) {
                        const frame = new Jimp$5(width, height, 0x00);
                        switch (i) {
                          case 0:
                            frame.blit(new Jimp$5(image.bitmap), 0, 0, 1, 1, width - 1, height - 1);
                            break;

                          case 1:
                            frame.blit(new Jimp$5(image.bitmap), 0, 1, 1, 0, width - 1, height - 1);
                            break;

                          case 2:
                            frame.blit(new Jimp$5(image.bitmap), 1, 1, 0, 0, width - 1, height - 1);
                            break;

                          case 3:
                            frame.blit(new Jimp$5(image.bitmap), 1, 0, 0, 1, width - 1, height - 1);
                        }
                        encoder.addFrame(frame.bitmap.data);
                    }
                    return encoder.finish(), encoder.getAndResetBuffer();
                }(options);
            }(command);

          case "rainbow":
            return function rainbowEmote(options) {
                return "gif" === options.type ? async function createRainbowGIF(options) {
                    const inputGif = await getGifFromBuffer(options.buffer), encoder = new GIFEncoder(inputGif.width, inputGif.height);
                    setEncoderProperties(encoder);
                    const interval = 32 * options.value, frames = alignGif(inputGif.frames, interval), randomBlack = Math.random(), randomWhite = Math.random();
                    return frames.forEach(((frame, index) => {
                        encoder.setDelay(10 * frame.delayCentisecs), shiftColors(frame.bitmap, index % interval / interval, randomBlack, randomWhite), 
                        encoder.addFrame(frame.bitmap.data);
                    })), encoder.finish(), encoder.getAndResetBuffer();
                }(options) : async function createRainbowPNG(options) {
                    const image = await Jimp$4.read(options.buffer), {width, height, encoder} = preparePNGVariables(options, image.bitmap);
                    image.resize(width, height), setEncoderProperties(encoder, 10 * options.value);
                    const randomBlack = Math.random(), randomWhite = Math.random();
                    for (let i = 0; i < 32; i++) shiftColors(image.bitmap, .03125, randomBlack, randomWhite), 
                    encoder.addFrame(image.bitmap.data);
                    return encoder.finish(), encoder.getAndResetBuffer();
                }(options);
            }(command);

          case "wiggle":
            return function wiggleEmote(options) {
                return "gif" === options.type ? async function createWigglingGIF(options) {
                    const inputGif = await getGifFromBuffer(options.buffer), encoder = new GIFEncoder(inputGif.width, inputGif.height);
                    setEncoderProperties(encoder);
                    const margin = inputGif.width + 2 * Math.floor(inputGif.width * options.value * 0.1 / 15) - inputGif.width, wiggleVariables = prepareWiggleVariables(margin, inputGif.height), {shiftSize, interval, stripeHeight} = wiggleVariables;
                    let {shift, left} = wiggleVariables;
                    return alignGif(inputGif.frames, interval).forEach((frame => {
                        encoder.setDelay(10 * frame.delayCentisecs);
                        const wiggledBitmap = getWiggledFrameData(new Jimp$3(frame.bitmap), shift, left, {
                            stripeHeight,
                            shiftSize,
                            width: inputGif.width,
                            margin
                        });
                        encoder.addFrame(wiggledBitmap.data), [shift, left] = shiftWiggleStep(shift, left, margin, shiftSize);
                    })), encoder.finish(), encoder.getAndResetBuffer();
                }(options) : async function createWigglingPNG(options) {
                    const image = await Jimp$3.read(options.buffer), {width: imgWidth, height} = preparePNGVariables(options, image.bitmap);
                    image.resize(imgWidth, height);
                    const width = imgWidth + 2 * Math.floor(imgWidth * options.value * 0.1 / 15), margin = width - imgWidth, encoder = new GIFEncoder(width, height), wiggleVariables = prepareWiggleVariables(margin, height), {shiftSize, interval, stripeHeight} = wiggleVariables;
                    let {shift, left} = wiggleVariables;
                    setEncoderProperties(encoder, 80);
                    for (let i = 0; i < interval; i++) {
                        const wiggledBitmap = getWiggledFrameData(image, shift, left, {
                            stripeHeight,
                            shiftSize,
                            width,
                            margin
                        });
                        encoder.addFrame(wiggledBitmap.data), [shift, left] = shiftWiggleStep(shift, left, margin, shiftSize);
                    }
                    return encoder.finish(), encoder.getAndResetBuffer();
                }(options);
            }(command);

          case "infinite":
            return function infiniteEmote(options) {
                return "gif" === options.type ? async function createInfiniteGIF(options) {
                    const inputGif = await getGifFromBuffer(options.buffer), encoder = new GIFEncoder(inputGif.width, inputGif.height);
                    setEncoderProperties(encoder);
                    const scaleStep = .24 / options.value;
                    let scales = resetInfiniteScales(5, .9, scaleStep);
                    return alignGif(inputGif.frames, .9 / scaleStep).forEach((frame => {
                        encoder.setDelay(10 * frame.delayCentisecs);
                        const frameData = getInfiniteShiftedFrameData(frame.bitmap, scales);
                        encoder.addFrame(frameData.data), scales = shiftInfiniteScales(scales, .9, scaleStep);
                    })), encoder.finish(), encoder.getAndResetBuffer();
                }(options) : async function createInfinitePNG(options) {
                    const image = await Jimp$2.read(options.buffer), {width, height, encoder} = preparePNGVariables(options, image.bitmap);
                    image.resize(width, height), setEncoderProperties(encoder, 10 * options.value);
                    let scales = resetInfiniteScales(5, .9, .06);
                    for (let i = 0; i < 14.000000000000002; i++) {
                        const frameData = getInfiniteShiftedFrameData(image.bitmap, scales);
                        encoder.addFrame(frameData.data), scales = shiftInfiniteScales(scales, .9, .06);
                    }
                    return encoder.finish(), encoder.getAndResetBuffer();
                }(options);
            }(command);

          case "slide":
          case "sliderev":
            return function slideEmote(options) {
                return "gif" === options.type ? async function createSlidingGIF(options) {
                    const inputGif = await getGifFromBuffer(options.buffer), encoder = new GIFEncoder(inputGif.width, inputGif.height);
                    setEncoderProperties(encoder);
                    const {width} = inputGif, slidingVariables = prepareSlidingVariables(width, options.value), {interval, shiftSize} = slidingVariables;
                    let {shift} = slidingVariables;
                    const frames = alignGif(inputGif.frames, interval), direction = "sliderev" === options.name ? 1 : -1;
                    return frames.forEach((frame => {
                        encoder.setDelay(10 * frame.delayCentisecs);
                        const shiftedBitmap = getShiftedFrameData(new Jimp$1(frame.bitmap), shift);
                        encoder.addFrame(shiftedBitmap.data), shift = (shift + direction * shiftSize) % width;
                    })), encoder.finish(), encoder.getAndResetBuffer();
                }(options) : async function createSlidingPNG(options) {
                    const image = await Jimp$1.read(options.buffer), {width, height, encoder} = preparePNGVariables(options, image.bitmap);
                    image.resize(width, height);
                    const slidingVariables = prepareSlidingVariables(width, options.value), {interval, shiftSize} = slidingVariables;
                    let {shift} = slidingVariables;
                    setEncoderProperties(encoder, 40);
                    const direction = "sliderev" === options.name ? 1 : -1;
                    for (let i = 0; i < interval; i++) {
                        const frameData = getShiftedFrameData(image, shift);
                        encoder.addFrame(frameData.data), shift = (shift + direction * shiftSize) % width;
                    }
                    return encoder.finish(), encoder.getAndResetBuffer();
                }(options);
            }(command);

          case "rain":
            return function rainEmote(options) {
                return "gif" === options.type ? async function createRainingGIF(options) {
                    const inputGif = await getGifFromBuffer(options.buffer), encoder = new GIFEncoder(inputGif.width, inputGif.height);
                    setEncoderProperties(encoder);
                    const {frames} = inputGif, glitter = 1 === options.value, rainGenerator = rainImageGenerator(inputGif.width, inputGif.height, glitter, frames[0]?.delayCentisecs ?? 0);
                    return frames.forEach((frame => {
                        encoder.setDelay(10 * frame.delayCentisecs);
                        const jimpFrame = new Jimp(frame.bitmap);
                        jimpFrame.blit(rainGenerator.next(), 0, 0), encoder.addFrame(jimpFrame.bitmap.data);
                    })), encoder.finish(), encoder.getAndResetBuffer();
                }(options) : async function createRainingPNG(options) {
                    const image = await Jimp.read(options.buffer), {width, height, encoder} = preparePNGVariables(options, image.bitmap);
                    image.resize(width, height), setEncoderProperties(encoder, 80);
                    const rainGenerator = rainImageGenerator(width, height, 1 === options.value, 8);
                    for (let i = 0; i < 12; i++) {
                        const img = new Jimp(image.bitmap);
                        img.blit(rainGenerator.next(), 0, 0), encoder.addFrame(img.bitmap.data);
                    }
                    return encoder.finish(), encoder.getAndResetBuffer();
                }(options);
            }(command);

          default:
            return Promise.resolve(command.buffer);
        }
    }
    async processNormalCommands(buffer, _commands) {
        let commands = _commands;
        const info = await this.doModification(buffer, [ {
            name: "-I"
        } ]);
        commands.unshift({
            name: "-U"
        });
        const hyperspeedIndex = this.getCommandIndex(commands, "hyperspeed");
        return void 0 !== hyperspeedIndex && (commands.splice(hyperspeedIndex, 1), commands = this.removeEveryOtherFrame(2, commands, info)), 
        this.doModification(buffer, commands);
    }
    removeEveryOtherFrame(frameInterval, commands, data) {
        commands.push({
            name: "-d2"
        });
        const frameCount = data.toString("utf8").split("image #").length - 1;
        if (frameCount <= 4) return commands;
        commands.push({
            name: "--delete"
        });
        for (let i = 1; i < frameCount; i += frameInterval) commands.push({
            name: `#${i}`
        });
        return commands;
    }
    stop() {}
}

class ModulesService extends BaseService {
    selectedChannelStore;
    channelStore;
    uploader;
    draft;
    permissions;
    discordPermissions;
    dispatcher;
    componentDispatcher;
    pendingReplyDispatcher={};
    emojiStore;
    emojiSearch;
    emojiDisabledReasons;
    userStore;
    messageStore;
    classes;
    cloudUploader;
    start() {
        const [selectedChannelStore, channelStore, uploader, draft, permissions, discordPermissions, dispatcher, componentDispatcher, pendingReplyModule, emojiStore, emojiSearch, emojiDisabledReasons, userStore, messageStore, TextArea, Autocomplete, autocompleteAttached, Wrapper, Size, cloudUploader] = BdApi.Webpack.getBulk({
            filter: BdApi.Webpack.Filters.byProps("getChannelId", "getVoiceChannelId")
        }, {
            filter: BdApi.Webpack.Filters.byProps("getChannel", "hasChannel")
        }, {
            filter: BdApi.Webpack.Filters.byProps("instantBatchUpload")
        }, {
            filter: BdApi.Webpack.Filters.byProps("changeDraft")
        }, {
            filter: BdApi.Webpack.Filters.byProps("getChannelPermissions")
        }, {
            filter: module => "bigint" == typeof module.CREATE_INSTANT_INVITE,
            searchExports: !0
        }, {
            filter: BdApi.Webpack.Filters.byProps("dispatch", "subscribe")
        }, {
            filter: module => void 0 !== module.dispatchToLastSubscribed && module.emitter.listeners("SHAKE_APP").length > 0,
            searchExports: !0
        }, {
            filter: module => (Object.entries(module).forEach((([key, value]) => {
                if ("function" != typeof value) return;
                const valueString = value.toString();
                valueString.includes("DELETE_PENDING_REPLY") ? this.pendingReplyDispatcher.deletePendingReplyKey = key : valueString.includes("CREATE_PENDING_REPLY") && (this.pendingReplyDispatcher.createPendingReplyKey = key);
            })), void 0 !== this.pendingReplyDispatcher.deletePendingReplyKey)
        }, {
            filter: BdApi.Webpack.Filters.byProps("getEmojiUnavailableReason")
        }, {
            filter: BdApi.Webpack.Filters.byProps("getDisambiguatedEmojiContext")
        }, {
            filter: BdApi.Webpack.Filters.byProps("PREMIUM_LOCKED"),
            searchExports: !0
        }, {
            filter: BdApi.Webpack.Filters.byProps("getCurrentUser")
        }, {
            filter: BdApi.Webpack.Filters.byProps("sendMessage")
        }, {
            filter: BdApi.Webpack.Filters.byProps("channelTextArea", "textAreaHeight")
        }, {
            filter: BdApi.Webpack.Filters.byProps("autocomplete", "autocompleteInner", "autocompleteRowVertical")
        }, {
            filter: BdApi.Webpack.Filters.byProps("autocomplete", "autocompleteAttached")
        }, {
            filter: BdApi.Webpack.Filters.byProps("wrapper", "base")
        }, {
            filter: BdApi.Webpack.Filters.byProps("size12")
        }, {
            filter: module => Object.values(module).some((value => {
                if ("object" != typeof value || null === value) return !1;
                const curValue = value;
                return void 0 !== curValue.NOT_STARTED && void 0 !== curValue.UPLOADING;
            }))
        });
        return this.selectedChannelStore = selectedChannelStore, this.channelStore = channelStore, 
        this.uploader = uploader, this.draft = draft, this.permissions = permissions, this.discordPermissions = discordPermissions, 
        this.dispatcher = dispatcher, this.componentDispatcher = componentDispatcher, this.pendingReplyDispatcher.module = pendingReplyModule, 
        this.emojiSearch = emojiSearch, this.emojiDisabledReasons = emojiDisabledReasons, 
        this.emojiStore = emojiStore, this.userStore = userStore, this.messageStore = messageStore, 
        this.cloudUploader = cloudUploader, this.classes = {
            TextArea,
            Autocomplete: {
                ...Autocomplete,
                autocomplete: [ autocompleteAttached?.autocomplete, autocompleteAttached?.autocompleteAttached, Autocomplete?.autocomplete ].join(" ")
            },
            Wrapper,
            Size
        }, Promise.resolve();
    }
    stop() {}
}

/*
object-assign
(c) Sindre Sorhus
@license MIT
*/ var getOwnPropertySymbols = Object.getOwnPropertySymbols, hasOwnProperty = Object.prototype.hasOwnProperty, propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
    if (null == val) throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(val);
}

var wa, objectAssign = function shouldUseNative() {
    try {
        if (!Object.assign) return !1;
        var test1 = new String("abc");
        if (test1[5] = "de", "5" === Object.getOwnPropertyNames(test1)[0]) return !1;
        for (var test2 = {}, i = 0; i < 10; i++) test2["_" + String.fromCharCode(i)] = i;
        if ("0123456789" !== Object.getOwnPropertyNames(test2).map((function(n) {
            return test2[n];
        })).join("")) return !1;
        var test3 = {};
        return "abcdefghijklmnopqrst".split("").forEach((function(letter) {
            test3[letter] = letter;
        })), "abcdefghijklmnopqrst" === Object.keys(Object.assign({}, test3)).join("");
    } catch (err) {
        return !1;
    }
}() ? Object.assign : function(target, source) {
    for (var from, symbols, to = toObject(target), s = 1; s < arguments.length; s++) {
        for (var key in from = Object(arguments[s])) hasOwnProperty.call(from, key) && (to[key] = from[key]);
        if (getOwnPropertySymbols) {
            symbols = getOwnPropertySymbols(from);
            for (var i = 0; i < symbols.length; i++) propIsEnumerable.call(from, symbols[i]) && (to[symbols[i]] = from[symbols[i]]);
        }
    }
    return to;
}, bundleFn = arguments[3], sources = arguments[4], cache = arguments[5], stringify = JSON.stringify, assign$1 = objectAssign, DEFAULT_OPTIONS = {
    js: !0,
    wasm: !0
};

function MultiMath(options) {
    if (!(this instanceof MultiMath)) return new MultiMath(options);
    var opts = assign$1({}, DEFAULT_OPTIONS, options || {});
    if (this.options = opts, this.__cache = {}, this.__init_promise = null, this.__modules = opts.modules || {}, 
    this.__memory = null, this.__wasm = {}, this.__isLE = 1 === new Uint32Array(new Uint8Array([ 1, 0, 0, 0 ]).buffer)[0], 
    !this.options.js && !this.options.wasm) throw new Error('mathlib: at least "js" or "wasm" should be enabled');
}

MultiMath.prototype.has_wasm = function hasWebAssembly() {
    if (void 0 !== wa) return wa;
    if (wa = !1, "undefined" == typeof WebAssembly) return wa;
    try {
        var bin = new Uint8Array([ 0, 97, 115, 109, 1, 0, 0, 0, 1, 6, 1, 96, 1, 127, 1, 127, 3, 2, 1, 0, 5, 3, 1, 0, 1, 7, 8, 1, 4, 116, 101, 115, 116, 0, 0, 10, 16, 1, 14, 0, 32, 0, 65, 1, 54, 2, 0, 32, 0, 40, 2, 0, 11 ]), module = new WebAssembly.Module(bin);
        return 0 !== new WebAssembly.Instance(module, {}).exports.test(4) && (wa = !0), 
        wa;
    } catch (__) {}
    return wa;
}, MultiMath.prototype.use = function(module) {
    return this.__modules[module.name] = module, this.options.wasm && this.has_wasm() && module.wasm_fn ? this[module.name] = module.wasm_fn : this[module.name] = module.fn, 
    this;
}, MultiMath.prototype.init = function() {
    if (this.__init_promise) return this.__init_promise;
    if (!this.options.js && this.options.wasm && !this.has_wasm()) return Promise.reject(new Error('mathlib: only "wasm" was enabled, but it\'s not supported'));
    var self = this;
    return this.__init_promise = Promise.all(Object.keys(self.__modules).map((function(name) {
        var module = self.__modules[name];
        return self.options.wasm && self.has_wasm() && module.wasm_fn ? self.__wasm[name] ? null : WebAssembly.compile(self.__base64decode(module.wasm_src)).then((function(m) {
            self.__wasm[name] = m;
        })) : null;
    }))).then((function() {
        return self;
    })), this.__init_promise;
}, MultiMath.prototype.__base64decode = function base64decode(str) {
    for (var input = str.replace(/[\r\n=]/g, ""), max = input.length, out = new Uint8Array(3 * max >> 2), bits = 0, ptr = 0, idx = 0; idx < max; idx++) idx % 4 == 0 && idx && (out[ptr++] = bits >> 16 & 0xFF, 
    out[ptr++] = bits >> 8 & 0xFF, out[ptr++] = 0xFF & bits), bits = bits << 6 | "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".indexOf(input.charAt(idx));
    var tailbits = max % 4 * 6;
    return 0 === tailbits ? (out[ptr++] = bits >> 16 & 0xFF, out[ptr++] = bits >> 8 & 0xFF, 
    out[ptr++] = 0xFF & bits) : 18 === tailbits ? (out[ptr++] = bits >> 10 & 0xFF, out[ptr++] = bits >> 2 & 0xFF) : 12 === tailbits && (out[ptr++] = bits >> 4 & 0xFF), 
    out;
}, MultiMath.prototype.__reallocate = function mem_grow_to(bytes) {
    if (!this.__memory) return this.__memory = new WebAssembly.Memory({
        initial: Math.ceil(bytes / 65536)
    }), this.__memory;
    var mem_size = this.__memory.buffer.byteLength;
    return mem_size < bytes && this.__memory.grow(Math.ceil((bytes - mem_size) / 65536)), 
    this.__memory;
}, MultiMath.prototype.__instance = function instance(name, memsize, env_extra) {
    if (memsize && this.__reallocate(memsize), !this.__wasm[name]) {
        var module = this.__modules[name];
        this.__wasm[name] = new WebAssembly.Module(this.__base64decode(module.wasm_src));
    }
    if (!this.__cache[name]) {
        var env_base = {
            memoryBase: 0,
            memory: this.__memory,
            tableBase: 0,
            table: new WebAssembly.Table({
                initial: 0,
                element: "anyfunc"
            })
        };
        this.__cache[name] = new WebAssembly.Instance(this.__wasm[name], {
            env: assign$1(env_base, env_extra || {})
        });
    }
    return this.__cache[name];
}, MultiMath.prototype.__align = function align(number, base) {
    var reminder = number % (base = base || 8);
    return number + (reminder ? base - reminder : 0);
};

var a0, a1, a2, a3, b1, b2, multimath = MultiMath;

function convolveMono16(src, out, line, coeff, width, height) {
    var prev_src, curr_src, curr_out, prev_out, prev_prev_out, src_index, out_index, line_index, i, j, coeff_a0, coeff_a1, coeff_b1, coeff_b2;
    for (i = 0; i < height; i++) {
        for (out_index = i, line_index = 0, prev_out = prev_prev_out = (prev_src = src[src_index = i * width]) * coeff[6], 
        coeff_a0 = coeff[0], coeff_a1 = coeff[1], coeff_b1 = coeff[4], coeff_b2 = coeff[5], 
        j = 0; j < width; j++) curr_out = (curr_src = src[src_index]) * coeff_a0 + prev_src * coeff_a1 + prev_out * coeff_b1 + prev_prev_out * coeff_b2, 
        prev_prev_out = prev_out, prev_out = curr_out, prev_src = curr_src, line[line_index] = prev_out, 
        line_index++, src_index++;
        for (line_index--, out_index += height * (width - 1), prev_out = prev_prev_out = (prev_src = src[--src_index]) * coeff[7], 
        curr_src = prev_src, coeff_a0 = coeff[2], coeff_a1 = coeff[3], j = width - 1; j >= 0; j--) curr_out = curr_src * coeff_a0 + prev_src * coeff_a1 + prev_out * coeff_b1 + prev_prev_out * coeff_b2, 
        prev_prev_out = prev_out, prev_out = curr_out, prev_src = curr_src, curr_src = src[src_index], 
        out[out_index] = line[line_index] + prev_out, src_index--, line_index--, out_index -= height;
    }
}

var mm_unsharp_mask$1 = {
    name: "unsharp_mask",
    fn: function unsharp(img, width, height, amount, radius, threshold) {
        var v1, v2, vmul, diff, iTimes4;
        if (!(0 === amount || radius < 0.5)) {
            radius > 2.0 && (radius = 2.0);
            var brightness = function hsv_v16(img, width, height) {
                for (var r, g, b, max, size = width * height, out = new Uint16Array(size), i = 0; i < size; i++) r = img[4 * i], 
                g = img[4 * i + 1], b = img[4 * i + 2], max = r >= g && r >= b ? r : g >= b && g >= r ? g : b, 
                out[i] = max << 8;
                return out;
            }(img, width, height), blured = new Uint16Array(brightness);
            !function blurMono16(src, width, height, radius) {
                if (radius) {
                    var out = new Uint16Array(src.length), tmp_line = new Float32Array(Math.max(width, height)), coeff = function gaussCoef(sigma) {
                        sigma < 0.5 && (sigma = 0.5);
                        var a = Math.exp(.527076) / sigma, g1 = Math.exp(-a), g2 = Math.exp(-2 * a), k = (1 - g1) * (1 - g1) / (1 + 2 * a * g1 - g2);
                        return a0 = k, a1 = k * (a - 1) * g1, a2 = k * (a + 1) * g1, a3 = -k * g2, b1 = 2 * g1, 
                        b2 = -g2, new Float32Array([ a0, a1, a2, a3, b1, b2, (a0 + a1) / (1 - b1 - b2), (a2 + a3) / (1 - b1 - b2) ]);
                    }(radius);
                    convolveMono16(src, out, tmp_line, coeff, width, height), convolveMono16(out, src, tmp_line, coeff, height, width);
                }
            }(blured, width, height, radius);
            for (var amountFp = amount / 100 * 0x1000 + 0.5 | 0, thresholdFp = threshold << 8, size = width * height, i = 0; i < size; i++) diff = (v1 = brightness[i]) - blured[i], 
            Math.abs(diff) >= thresholdFp && (vmul = ((v2 = (v2 = (v2 = v1 + (amountFp * diff + 0x800 >> 12)) > 0xff00 ? 0xff00 : v2) < 0x0000 ? 0x0000 : v2) << 12) / (v1 = 0 !== v1 ? v1 : 1) | 0, 
            img[iTimes4 = 4 * i] = img[iTimes4] * vmul + 0x800 >> 12, img[iTimes4 + 1] = img[iTimes4 + 1] * vmul + 0x800 >> 12, 
            img[iTimes4 + 2] = img[iTimes4 + 2] * vmul + 0x800 >> 12);
        }
    },
    wasm_fn: function unsharp(img, width, height, amount, radius, threshold) {
        if (!(0 === amount || radius < 0.5)) {
            radius > 2.0 && (radius = 2.0);
            var pixels = width * height, img_bytes_cnt = 4 * pixels, hsv_bytes_cnt = 2 * pixels, blur_bytes_cnt = 2 * pixels, blur_line_byte_cnt = 4 * Math.max(width, height), hsv_offset = img_bytes_cnt, blur_offset = hsv_offset + hsv_bytes_cnt, blur_tmp_offset = blur_offset + blur_bytes_cnt, blur_line_offset = blur_tmp_offset + blur_bytes_cnt, blur_coeffs_offset = blur_line_offset + blur_line_byte_cnt, instance = this.__instance("unsharp_mask", img_bytes_cnt + hsv_bytes_cnt + 2 * blur_bytes_cnt + blur_line_byte_cnt + 32, {
                exp: Math.exp
            }), img32 = new Uint32Array(img.buffer);
            new Uint32Array(this.__memory.buffer).set(img32);
            var fn = instance.exports.hsv_v16 || instance.exports._hsv_v16;
            fn(0, hsv_offset, width, height), (fn = instance.exports.blurMono16 || instance.exports._blurMono16)(hsv_offset, blur_offset, blur_tmp_offset, blur_line_offset, blur_coeffs_offset, width, height, radius), 
            (fn = instance.exports.unsharp || instance.exports._unsharp)(0, 0, hsv_offset, blur_offset, width, height, amount, threshold), 
            img32.set(new Uint32Array(this.__memory.buffer, 0, pixels));
        }
    },
    wasm_src: "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"
};

const filter = {
    box: {
        win: 0.5,
        fn: function(x) {
            return x < 0 && (x = -x), x < 0.5 ? 1.0 : 0.0;
        }
    },
    hamming: {
        win: 1.0,
        fn: function(x) {
            if (x < 0 && (x = -x), x >= 1.0) return 0.0;
            if (x < 1.19209290E-07) return 1.0;
            var xpi = x * Math.PI;
            return Math.sin(xpi) / xpi * (0.54 + 0.46 * Math.cos(xpi / 1.0));
        }
    },
    lanczos2: {
        win: 2.0,
        fn: function(x) {
            if (x < 0 && (x = -x), x >= 2.0) return 0.0;
            if (x < 1.19209290E-07) return 1.0;
            var xpi = x * Math.PI;
            return Math.sin(xpi) / xpi * Math.sin(xpi / 2.0) / (xpi / 2.0);
        }
    },
    lanczos3: {
        win: 3.0,
        fn: function(x) {
            if (x < 0 && (x = -x), x >= 3.0) return 0.0;
            if (x < 1.19209290E-07) return 1.0;
            var xpi = x * Math.PI;
            return Math.sin(xpi) / xpi * Math.sin(xpi / 3.0) / (xpi / 3.0);
        }
    },
    mks2013: {
        win: 2.5,
        fn: function(x) {
            return x < 0 && (x = -x), x >= 2.5 ? 0.0 : x >= 1.5 ? -0.125 * (x - 2.5) * (x - 2.5) : x >= 0.5 ? 0.25 * (4 * x * x - 11 * x + 7) : 1.0625 - 1.75 * x * x;
        }
    }
};

var resize_filter_info = {
    filter,
    f2q: {
        box: 0,
        hamming: 1,
        lanczos2: 2,
        lanczos3: 3
    },
    q2f: [ "box", "hamming", "lanczos2", "lanczos3" ]
}, FILTER_INFO = resize_filter_info;

function toFixedPoint(num) {
    return Math.round(16383 * num);
}

var resize_filter_gen = function resizeFilterGen(filter, srcSize, destSize, scale, offset) {
    var destPixel, srcPixel, srcFirst, srcLast, filterElementSize, floatFilter, fxpFilter, total, pxl, idx, floatVal, filterTotal, filterVal, leftNotEmpty, rightNotEmpty, filterShift, filterSize, filterFunction = FILTER_INFO.filter[filter].fn, scaleInverted = 1.0 / scale, scaleClamped = Math.min(1.0, scale), srcWindow = FILTER_INFO.filter[filter].win / scaleClamped, maxFilterElementSize = Math.floor(2 * (srcWindow + 1)), packedFilter = new Int16Array((maxFilterElementSize + 2) * destSize), packedFilterPtr = 0, slowCopy = !packedFilter.subarray || !packedFilter.set;
    for (destPixel = 0; destPixel < destSize; destPixel++) {
        for (srcPixel = (destPixel + 0.5) * scaleInverted + offset, srcFirst = Math.max(0, Math.floor(srcPixel - srcWindow)), 
        filterElementSize = (srcLast = Math.min(srcSize - 1, Math.ceil(srcPixel + srcWindow))) - srcFirst + 1, 
        floatFilter = new Float32Array(filterElementSize), fxpFilter = new Int16Array(filterElementSize), 
        total = 0.0, pxl = srcFirst, idx = 0; pxl <= srcLast; pxl++, idx++) total += floatVal = filterFunction((pxl + 0.5 - srcPixel) * scaleClamped), 
        floatFilter[idx] = floatVal;
        for (filterTotal = 0, idx = 0; idx < floatFilter.length; idx++) filterTotal += filterVal = floatFilter[idx] / total, 
        fxpFilter[idx] = toFixedPoint(filterVal);
        for (fxpFilter[destSize >> 1] += toFixedPoint(1.0 - filterTotal), leftNotEmpty = 0; leftNotEmpty < fxpFilter.length && 0 === fxpFilter[leftNotEmpty]; ) leftNotEmpty++;
        if (leftNotEmpty < fxpFilter.length) {
            for (rightNotEmpty = fxpFilter.length - 1; rightNotEmpty > 0 && 0 === fxpFilter[rightNotEmpty]; ) rightNotEmpty--;
            if (filterShift = srcFirst + leftNotEmpty, filterSize = rightNotEmpty - leftNotEmpty + 1, 
            packedFilter[packedFilterPtr++] = filterShift, packedFilter[packedFilterPtr++] = filterSize, 
            slowCopy) for (idx = leftNotEmpty; idx <= rightNotEmpty; idx++) packedFilter[packedFilterPtr++] = fxpFilter[idx]; else packedFilter.set(fxpFilter.subarray(leftNotEmpty, rightNotEmpty + 1), packedFilterPtr), 
            packedFilterPtr += filterSize;
        } else packedFilter[packedFilterPtr++] = 0, packedFilter[packedFilterPtr++] = 0;
    }
    return packedFilter;
};

function clampTo8(i) {
    return i < 0 ? 0 : i > 255 ? 255 : i;
}

function clampNegative(i) {
    return i >= 0 ? i : 0;
}

var convolve = {
    convolveHor: function convolveHor$1(src, dest, srcW, srcH, destW, filters) {
        var r, g, b, a, filterPtr, filterShift, filterSize, srcPtr, srcY, destX, filterVal, srcOffset = 0, destOffset = 0;
        for (srcY = 0; srcY < srcH; srcY++) {
            for (filterPtr = 0, destX = 0; destX < destW; destX++) {
                for (filterShift = filters[filterPtr++], filterSize = filters[filterPtr++], srcPtr = srcOffset + 4 * filterShift | 0, 
                r = g = b = a = 0; filterSize > 0; filterSize--) a = a + (filterVal = filters[filterPtr++]) * src[srcPtr + 3] | 0, 
                b = b + filterVal * src[srcPtr + 2] | 0, g = g + filterVal * src[srcPtr + 1] | 0, 
                r = r + filterVal * src[srcPtr] | 0, srcPtr = srcPtr + 4 | 0;
                dest[destOffset + 3] = clampNegative(a >> 7), dest[destOffset + 2] = clampNegative(b >> 7), 
                dest[destOffset + 1] = clampNegative(g >> 7), dest[destOffset] = clampNegative(r >> 7), 
                destOffset = destOffset + 4 * srcH | 0;
            }
            destOffset = 4 * (srcY + 1) | 0, srcOffset = (srcY + 1) * srcW * 4 | 0;
        }
    },
    convolveVert: function convolveVert$1(src, dest, srcW, srcH, destW, filters) {
        var r, g, b, a, filterPtr, filterShift, filterSize, srcPtr, srcY, destX, filterVal, srcOffset = 0, destOffset = 0;
        for (srcY = 0; srcY < srcH; srcY++) {
            for (filterPtr = 0, destX = 0; destX < destW; destX++) {
                for (filterShift = filters[filterPtr++], filterSize = filters[filterPtr++], srcPtr = srcOffset + 4 * filterShift | 0, 
                r = g = b = a = 0; filterSize > 0; filterSize--) a = a + (filterVal = filters[filterPtr++]) * src[srcPtr + 3] | 0, 
                b = b + filterVal * src[srcPtr + 2] | 0, g = g + filterVal * src[srcPtr + 1] | 0, 
                r = r + filterVal * src[srcPtr] | 0, srcPtr = srcPtr + 4 | 0;
                r >>= 7, g >>= 7, b >>= 7, a >>= 7, dest[destOffset + 3] = clampTo8(a + 8192 >> 14), 
                dest[destOffset + 2] = clampTo8(b + 8192 >> 14), dest[destOffset + 1] = clampTo8(g + 8192 >> 14), 
                dest[destOffset] = clampTo8(r + 8192 >> 14), destOffset = destOffset + 4 * srcH | 0;
            }
            destOffset = 4 * (srcY + 1) | 0, srcOffset = (srcY + 1) * srcW * 4 | 0;
        }
    },
    convolveHorWithPre: function convolveHorWithPre$1(src, dest, srcW, srcH, destW, filters) {
        var r, g, b, a, alpha, filterPtr, filterShift, filterSize, srcPtr, srcY, destX, filterVal, srcOffset = 0, destOffset = 0;
        for (srcY = 0; srcY < srcH; srcY++) {
            for (filterPtr = 0, destX = 0; destX < destW; destX++) {
                for (filterShift = filters[filterPtr++], filterSize = filters[filterPtr++], srcPtr = srcOffset + 4 * filterShift | 0, 
                r = g = b = a = 0; filterSize > 0; filterSize--) a = a + (filterVal = filters[filterPtr++]) * (alpha = src[srcPtr + 3]) | 0, 
                b = b + filterVal * src[srcPtr + 2] * alpha | 0, g = g + filterVal * src[srcPtr + 1] * alpha | 0, 
                r = r + filterVal * src[srcPtr] * alpha | 0, srcPtr = srcPtr + 4 | 0;
                b = b / 255 | 0, g = g / 255 | 0, r = r / 255 | 0, dest[destOffset + 3] = clampNegative(a >> 7), 
                dest[destOffset + 2] = clampNegative(b >> 7), dest[destOffset + 1] = clampNegative(g >> 7), 
                dest[destOffset] = clampNegative(r >> 7), destOffset = destOffset + 4 * srcH | 0;
            }
            destOffset = 4 * (srcY + 1) | 0, srcOffset = (srcY + 1) * srcW * 4 | 0;
        }
    },
    convolveVertWithPre: function convolveVertWithPre$1(src, dest, srcW, srcH, destW, filters) {
        var r, g, b, a, filterPtr, filterShift, filterSize, srcPtr, srcY, destX, filterVal, srcOffset = 0, destOffset = 0;
        for (srcY = 0; srcY < srcH; srcY++) {
            for (filterPtr = 0, destX = 0; destX < destW; destX++) {
                for (filterShift = filters[filterPtr++], filterSize = filters[filterPtr++], srcPtr = srcOffset + 4 * filterShift | 0, 
                r = g = b = a = 0; filterSize > 0; filterSize--) a = a + (filterVal = filters[filterPtr++]) * src[srcPtr + 3] | 0, 
                b = b + filterVal * src[srcPtr + 2] | 0, g = g + filterVal * src[srcPtr + 1] | 0, 
                r = r + filterVal * src[srcPtr] | 0, srcPtr = srcPtr + 4 | 0;
                r >>= 7, g >>= 7, b >>= 7, (a = clampTo8(8192 + (a >>= 7) >> 14)) > 0 && (r = 255 * r / a | 0, 
                g = 255 * g / a | 0, b = 255 * b / a | 0), dest[destOffset + 3] = a, dest[destOffset + 2] = clampTo8(b + 8192 >> 14), 
                dest[destOffset + 1] = clampTo8(g + 8192 >> 14), dest[destOffset] = clampTo8(r + 8192 >> 14), 
                destOffset = destOffset + 4 * srcH | 0;
            }
            destOffset = 4 * (srcY + 1) | 0, srcOffset = (srcY + 1) * srcW * 4 | 0;
        }
    }
};

const createFilters$1 = resize_filter_gen, {convolveHor, convolveVert, convolveHorWithPre, convolveVertWithPre} = convolve, createFilters = resize_filter_gen;

let IS_LE = !0;

try {
    IS_LE = 1 === new Uint32Array(new Uint8Array([ 1, 0, 0, 0 ]).buffer)[0];
} catch (__) {}

function copyInt16asLE(src, target, target_offset) {
    if (IS_LE) target.set(function asUint8Array(src) {
        return new Uint8Array(src.buffer, 0, src.byteLength);
    }(src), target_offset); else for (let ptr = target_offset, i = 0; i < src.length; i++) {
        let data = src[i];
        target[ptr++] = 0xFF & data, target[ptr++] = data >> 8 & 0xFF;
    }
}

var mm_resize$1 = {
    name: "resize",
    fn: function resize(options) {
        const src = options.src, srcW = options.width, srcH = options.height, destW = options.toWidth, destH = options.toHeight, scaleX = options.scaleX || options.toWidth / options.width, scaleY = options.scaleY || options.toHeight / options.height, offsetX = options.offsetX || 0, offsetY = options.offsetY || 0, dest = options.dest || new Uint8Array(destW * destH * 4), filter = void 0 === options.filter ? "mks2013" : options.filter, filtersX = createFilters$1(filter, srcW, destW, scaleX, offsetX), filtersY = createFilters$1(filter, srcH, destH, scaleY, offsetY), tmp = new Uint16Array(destW * srcH * 4);
        return function hasAlpha$1(src, width, height) {
            let ptr = 3, len = width * height * 4 | 0;
            for (;ptr < len; ) {
                if (255 !== src[ptr]) return !0;
                ptr = ptr + 4 | 0;
            }
            return !1;
        }(src, srcW, srcH) ? (convolveHorWithPre(src, tmp, srcW, srcH, destW, filtersX), 
        convolveVertWithPre(tmp, dest, srcH, destW, destH, filtersY)) : (convolveHor(src, tmp, srcW, srcH, destW, filtersX), 
        convolveVert(tmp, dest, srcH, destW, destH, filtersY), function resetAlpha$1(dst, width, height) {
            let ptr = 3, len = width * height * 4 | 0;
            for (;ptr < len; ) dst[ptr] = 0xFF, ptr = ptr + 4 | 0;
        }(dest, destW, destH)), dest;
    },
    wasm_fn: function resize_wasm(options) {
        const src = options.src, srcW = options.width, srcH = options.height, destW = options.toWidth, destH = options.toHeight, scaleX = options.scaleX || options.toWidth / options.width, scaleY = options.scaleY || options.toHeight / options.height, offsetX = options.offsetX || 0.0, offsetY = options.offsetY || 0.0, dest = options.dest || new Uint8Array(destW * destH * 4), filter = void 0 === options.filter ? "mks2013" : options.filter, filtersX = createFilters(filter, srcW, destW, scaleX, offsetX), filtersY = createFilters(filter, srcH, destH, scaleY, offsetY), src_size = Math.max(src.byteLength, dest.byteLength), tmp_offset = this.__align(0 + src_size), tmp_size = srcH * destW * 4 * 2, filtersX_offset = this.__align(tmp_offset + tmp_size), filtersY_offset = this.__align(filtersX_offset + filtersX.byteLength), alloc_bytes = filtersY_offset + filtersY.byteLength, instance = this.__instance("resize", alloc_bytes), mem = new Uint8Array(this.__memory.buffer), mem32 = new Uint32Array(this.__memory.buffer), src32 = new Uint32Array(src.buffer);
        mem32.set(src32), copyInt16asLE(filtersX, mem, filtersX_offset), copyInt16asLE(filtersY, mem, filtersY_offset);
        const fn = instance.exports.convolveHV || instance.exports._convolveHV;
        return function hasAlpha(src, width, height) {
            let ptr = 3, len = width * height * 4 | 0;
            for (;ptr < len; ) {
                if (255 !== src[ptr]) return !0;
                ptr = ptr + 4 | 0;
            }
            return !1;
        }(src, srcW, srcH) ? fn(filtersX_offset, filtersY_offset, tmp_offset, srcW, srcH, destW, destH, 1) : (fn(filtersX_offset, filtersY_offset, tmp_offset, srcW, srcH, destW, destH, 0), 
        function resetAlpha(dst, width, height) {
            let ptr = 3, len = width * height * 4 | 0;
            for (;ptr < len; ) dst[ptr] = 0xFF, ptr = ptr + 4 | 0;
        }(dest, destW, destH)), new Uint32Array(dest.buffer).set(new Uint32Array(this.__memory.buffer, 0, destH * destW)), 
        dest;
    },
    wasm_src: "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"
};

const Multimath = multimath, mm_unsharp_mask = mm_unsharp_mask$1, mm_resize = mm_resize$1;

function MathLib$1(requested_features) {
    const __requested_features = requested_features || [];
    let features = {
        js: __requested_features.indexOf("js") >= 0,
        wasm: __requested_features.indexOf("wasm") >= 0
    };
    Multimath.call(this, features), this.features = {
        js: features.js,
        wasm: features.wasm && this.has_wasm()
    }, this.use(mm_unsharp_mask), this.use(mm_resize);
}

MathLib$1.prototype = Object.create(Multimath.prototype), MathLib$1.prototype.constructor = MathLib$1, 
MathLib$1.prototype.resizeAndUnsharp = function resizeAndUnsharp(options, cache) {
    let result = this.resize(options, cache);
    return options.unsharpAmount && this.unsharp_mask(result, options.toWidth, options.toHeight, options.unsharpAmount, options.unsharpRadius, options.unsharpThreshold), 
    result;
};

var mathlib = MathLib$1;

function Pool$1(create, idle) {
    this.create = create, this.available = [], this.acquired = {}, this.lastId = 1, 
    this.timeoutId = 0, this.idle = idle || 2000;
}

Pool$1.prototype.acquire = function() {
    let resource;
    return 0 !== this.available.length ? resource = this.available.pop() : (resource = this.create(), 
    resource.id = this.lastId++, resource.release = () => this.release(resource)), this.acquired[resource.id] = resource, 
    resource;
}, Pool$1.prototype.release = function(resource) {
    delete this.acquired[resource.id], resource.lastUsed = Date.now(), this.available.push(resource), 
    0 === this.timeoutId && (this.timeoutId = setTimeout((() => this.gc()), 100));
}, Pool$1.prototype.gc = function() {
    const now = Date.now();
    this.available = this.available.filter((resource => !(now - resource.lastUsed > this.idle && (resource.destroy(), 
    1)))), 0 !== this.available.length ? this.timeoutId = setTimeout((() => this.gc()), 100) : this.timeoutId = 0;
};

var pool = Pool$1, utils$1 = {};

function objClass(obj) {
    return Object.prototype.toString.call(obj);
}

function pixelFloor(x) {
    var nearest = Math.round(x);
    return Math.abs(x - nearest) < 1e-5 ? nearest : Math.floor(x);
}

function pixelCeil(x) {
    var nearest = Math.round(x);
    return Math.abs(x - nearest) < 1e-5 ? nearest : Math.ceil(x);
}

utils$1.isCanvas = function isCanvas(element) {
    let cname = objClass(element);
    return "[object HTMLCanvasElement]" === cname || "[object OffscreenCanvas]" === cname || "[object Canvas]" === cname;
}, utils$1.isImage = function isImage(element) {
    return "[object HTMLImageElement]" === objClass(element);
}, utils$1.isImageBitmap = function isImageBitmap(element) {
    return "[object ImageBitmap]" === objClass(element);
}, utils$1.limiter = function limiter(concurrency) {
    let active = 0, queue = [];
    function roll() {
        active < concurrency && queue.length && (active++, queue.shift()());
    }
    return function limit(fn) {
        return new Promise(((resolve, reject) => {
            queue.push((() => {
                fn().then((result => {
                    resolve(result), active--, roll();
                }), (err => {
                    reject(err), active--, roll();
                }));
            })), roll();
        }));
    };
}, utils$1.cib_quality_name = function cib_quality_name(num) {
    switch (num) {
      case 0:
        return "pixelated";

      case 1:
        return "low";

      case 2:
        return "medium";
    }
    return "high";
}, utils$1.cib_support = function cib_support(createCanvas) {
    return Promise.resolve().then((() => {
        if ("undefined" == typeof createImageBitmap) return !1;
        let c = createCanvas(100, 100);
        return createImageBitmap(c, 0, 0, 100, 100, {
            resizeWidth: 10,
            resizeHeight: 10,
            resizeQuality: "high"
        }).then((bitmap => {
            let status = 10 === bitmap.width;
            return bitmap.close(), c = null, status;
        }));
    })).catch((() => !1));
}, utils$1.worker_offscreen_canvas_support = function worker_offscreen_canvas_support() {
    return new Promise(((resolve, reject) => {
        if ("undefined" == typeof OffscreenCanvas) return void resolve(!1);
        let code = btoa(`(${function workerPayload(self) {
            "undefined" != typeof createImageBitmap ? Promise.resolve().then((() => {
                let canvas = new OffscreenCanvas(10, 10);
                return canvas.getContext("2d").rect(0, 0, 1, 1), createImageBitmap(canvas, 0, 0, 1, 1);
            })).then((() => self.postMessage(!0)), (() => self.postMessage(!1))) : self.postMessage(!1);
        }.toString()})(self);`), w = new Worker(`data:text/javascript;base64,${code}`);
        w.onmessage = ev => resolve(ev.data), w.onerror = reject;
    })).then((result => result), (() => !1));
}, utils$1.can_use_canvas = function can_use_canvas(createCanvas) {
    let usable = !1;
    try {
        let ctx = createCanvas(2, 1).getContext("2d"), d = ctx.createImageData(2, 1);
        d.data[0] = 12, d.data[1] = 23, d.data[2] = 34, d.data[3] = 255, d.data[4] = 45, 
        d.data[5] = 56, d.data[6] = 67, d.data[7] = 255, ctx.putImageData(d, 0, 0), d = null, 
        d = ctx.getImageData(0, 0, 2, 1), 12 === d.data[0] && 23 === d.data[1] && 34 === d.data[2] && 255 === d.data[3] && 45 === d.data[4] && 56 === d.data[5] && 67 === d.data[6] && 255 === d.data[7] && (usable = !0);
    } catch (err) {}
    return usable;
}, utils$1.cib_can_use_region = function cib_can_use_region() {
    return new Promise((resolve => {
        if ("undefined" == typeof Image || "undefined" == typeof createImageBitmap) return void resolve(!1);
        let image = new Image;
        image.src = "data:image/jpeg;base64,/9j/4QBiRXhpZgAATU0AKgAAAAgABQESAAMAAAABAAYAAAEaAAUAAAABAAAASgEbAAUAAAABAAAAUgEoAAMAAAABAAIAAAITAAMAAAABAAEAAAAAAAAAAABIAAAAAQAAAEgAAAAB/9sAQwAEAwMEAwMEBAMEBQQEBQYKBwYGBgYNCQoICg8NEBAPDQ8OERMYFBESFxIODxUcFRcZGRsbGxAUHR8dGh8YGhsa/9sAQwEEBQUGBQYMBwcMGhEPERoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoaGhoa/8IAEQgAAQACAwERAAIRAQMRAf/EABQAAQAAAAAAAAAAAAAAAAAAAAf/xAAUAQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIQAxAAAAF/P//EABQQAQAAAAAAAAAAAAAAAAAAAAD/2gAIAQEAAQUCf//EABQRAQAAAAAAAAAAAAAAAAAAAAD/2gAIAQMBAT8Bf//EABQRAQAAAAAAAAAAAAAAAAAAAAD/2gAIAQIBAT8Bf//EABQQAQAAAAAAAAAAAAAAAAAAAAD/2gAIAQEABj8Cf//EABQQAQAAAAAAAAAAAAAAAAAAAAD/2gAIAQEAAT8hf//aAAwDAQACAAMAAAAQH//EABQRAQAAAAAAAAAAAAAAAAAAAAD/2gAIAQMBAT8Qf//EABQRAQAAAAAAAAAAAAAAAAAAAAD/2gAIAQIBAT8Qf//EABQQAQAAAAAAAAAAAAAAAAAAAAD/2gAIAQEAAT8Qf//Z", 
        image.onload = () => {
            createImageBitmap(image, 0, 0, image.width, image.height).then((bitmap => {
                bitmap.width === image.width && bitmap.height === image.height ? resolve(!0) : resolve(!1);
            }), (() => resolve(!1)));
        }, image.onerror = () => resolve(!1);
    }));
};

const assign = objectAssign, webworkify = function(fn, options) {
    for (var wkey, cacheKeys = Object.keys(cache), i = 0, l = cacheKeys.length; i < l; i++) {
        var key = cacheKeys[i], exp = cache[key].exports;
        if (exp === fn || exp && exp.default === fn) {
            wkey = key;
            break;
        }
    }
    if (!wkey) {
        wkey = Math.floor(Math.pow(16, 8) * Math.random()).toString(16);
        var wcache = {};
        for (i = 0, l = cacheKeys.length; i < l; i++) wcache[key = cacheKeys[i]] = key;
        sources[wkey] = [ "function(require,module,exports){" + fn + "(self); }", wcache ];
    }
    var skey = Math.floor(Math.pow(16, 8) * Math.random()).toString(16), scache = {};
    scache[wkey] = wkey, sources[skey] = [ "function(require,module,exports){var f = require(" + stringify(wkey) + ");(f.default ? f.default : f)(self);}", scache ];
    var workerSources = {};
    !function resolveSources(key) {
        for (var depPath in workerSources[key] = !0, sources[key][1]) {
            var depKey = sources[key][1][depPath];
            workerSources[depKey] || resolveSources(depKey);
        }
    }(skey);
    var src = "(" + bundleFn + ")({" + Object.keys(workerSources).map((function(key) {
        return stringify(key) + ":[" + sources[key][0] + "," + stringify(sources[key][1]) + "]";
    })).join(",") + "},{},[" + stringify(skey) + "])", URL = window.URL || window.webkitURL || window.mozURL || window.msURL, blob = new Blob([ src ], {
        type: "text/javascript"
    });
    if (options && options.bare) return blob;
    var workerUrl = URL.createObjectURL(blob), worker = new Worker(workerUrl);
    return worker.objectURL = workerUrl, worker;
}, MathLib = mathlib, Pool = pool, utils = utils$1, worker = function() {
    const MathLib = mathlib;
    let mathLib;
    onmessage = function(ev) {
        let tileOpts = ev.data.opts;
        if (!tileOpts.src && tileOpts.srcBitmap) {
            let canvas = new OffscreenCanvas(tileOpts.width, tileOpts.height), ctx = canvas.getContext("2d");
            ctx.drawImage(tileOpts.srcBitmap, 0, 0), tileOpts.src = ctx.getImageData(0, 0, tileOpts.width, tileOpts.height).data, 
            canvas.width = canvas.height = 0, canvas = null, tileOpts.srcBitmap.close(), tileOpts.srcBitmap = null;
        }
        mathLib || (mathLib = new MathLib(ev.data.features));
        let data = mathLib.resizeAndUnsharp(tileOpts);
        postMessage({
            data
        }, [ data.buffer ]);
    };
}, filter_info = resize_filter_info, singletones = {};

let NEED_SAFARI_FIX = !1;

try {
    "undefined" != typeof navigator && navigator.userAgent && (NEED_SAFARI_FIX = navigator.userAgent.indexOf("Safari") >= 0);
} catch (e) {}

let concurrency = 1;

"undefined" != typeof navigator && (concurrency = Math.min(navigator.hardwareConcurrency || 1, 4));

const DEFAULT_PICA_OPTS = {
    tile: 1024,
    concurrency,
    features: [ "js", "wasm", "ww" ],
    idle: 2000,
    createCanvas: function(width, height) {
        let tmpCanvas = document.createElement("canvas");
        return tmpCanvas.width = width, tmpCanvas.height = height, tmpCanvas;
    }
}, DEFAULT_RESIZE_OPTS = {
    filter: "mks2013",
    unsharpAmount: 0,
    unsharpRadius: 0.0,
    unsharpThreshold: 0
};

let CAN_NEW_IMAGE_DATA = !1, CAN_CREATE_IMAGE_BITMAP = !1, CAN_USE_CANVAS_GET_IMAGE_DATA = !1, CAN_USE_OFFSCREEN_CANVAS = !1, CAN_USE_CIB_REGION_FOR_IMAGE = !1;

function workerFabric() {
    return {
        value: webworkify(worker),
        destroy: function() {
            if (this.value.terminate(), "undefined" != typeof window) {
                let url = window.URL || window.webkitURL || window.mozURL || window.msURL;
                url && url.revokeObjectURL && this.value.objectURL && url.revokeObjectURL(this.value.objectURL);
            }
        }
    };
}

function Pica(options) {
    if (!(this instanceof Pica)) return new Pica(options);
    this.options = assign({}, DEFAULT_PICA_OPTS, options || {});
    let limiter_key = `lk_${this.options.concurrency}`;
    this.__limit = singletones[limiter_key] || utils.limiter(this.options.concurrency), 
    singletones[limiter_key] || (singletones[limiter_key] = this.__limit), this.features = {
        js: !1,
        wasm: !1,
        cib: !1,
        ww: !1
    }, this.__workersPool = null, this.__requested_features = [], this.__mathlib = null;
}

Pica.prototype.init = function() {
    if (this.__initPromise) return this.__initPromise;
    if ("undefined" != typeof ImageData && "undefined" != typeof Uint8ClampedArray) try {
        new ImageData(new Uint8ClampedArray(400), 10, 10), CAN_NEW_IMAGE_DATA = !0;
    } catch (__) {}
    "undefined" != typeof ImageBitmap && (ImageBitmap.prototype && ImageBitmap.prototype.close ? CAN_CREATE_IMAGE_BITMAP = !0 : this.debug("ImageBitmap does not support .close(), disabled"));
    let features = this.options.features.slice();
    if (features.indexOf("all") >= 0 && (features = [ "cib", "wasm", "js", "ww" ]), 
    this.__requested_features = features, this.__mathlib = new MathLib(features), features.indexOf("ww") >= 0 && "undefined" != typeof window && "Worker" in window) try {
        require("webworkify")((function() {})).terminate(), this.features.ww = !0;
        let wpool_key = `wp_${JSON.stringify(this.options)}`;
        singletones[wpool_key] ? this.__workersPool = singletones[wpool_key] : (this.__workersPool = new Pool(workerFabric, this.options.idle), 
        singletones[wpool_key] = this.__workersPool);
    } catch (__) {}
    let checkCibResize, checkOffscreenCanvas, initMath = this.__mathlib.init().then((mathlib => {
        assign(this.features, mathlib.features);
    }));
    checkCibResize = CAN_CREATE_IMAGE_BITMAP ? utils.cib_support(this.options.createCanvas).then((status => {
        this.features.cib && features.indexOf("cib") < 0 ? this.debug("createImageBitmap() resize supported, but disabled by config") : features.indexOf("cib") >= 0 && (this.features.cib = status);
    })) : Promise.resolve(!1), CAN_USE_CANVAS_GET_IMAGE_DATA = utils.can_use_canvas(this.options.createCanvas), 
    checkOffscreenCanvas = CAN_CREATE_IMAGE_BITMAP && CAN_NEW_IMAGE_DATA && -1 !== features.indexOf("ww") ? utils.worker_offscreen_canvas_support() : Promise.resolve(!1), 
    checkOffscreenCanvas = checkOffscreenCanvas.then((result => {
        CAN_USE_OFFSCREEN_CANVAS = result;
    }));
    let checkCibRegion = utils.cib_can_use_region().then((result => {
        CAN_USE_CIB_REGION_FOR_IMAGE = result;
    }));
    return this.__initPromise = Promise.all([ initMath, checkCibResize, checkOffscreenCanvas, checkCibRegion ]).then((() => this)), 
    this.__initPromise;
}, Pica.prototype.__invokeResize = function(tileOpts, opts) {
    return opts.__mathCache = opts.__mathCache || {}, Promise.resolve().then((() => this.features.ww ? new Promise(((resolve, reject) => {
        let w = this.__workersPool.acquire();
        opts.cancelToken && opts.cancelToken.catch((err => reject(err))), w.value.onmessage = ev => {
            w.release(), ev.data.err ? reject(ev.data.err) : resolve(ev.data);
        };
        let transfer = [];
        tileOpts.src && transfer.push(tileOpts.src.buffer), tileOpts.srcBitmap && transfer.push(tileOpts.srcBitmap), 
        w.value.postMessage({
            opts: tileOpts,
            features: this.__requested_features,
            preload: {
                wasm_nodule: this.__mathlib.__
            }
        }, transfer);
    })) : {
        data: this.__mathlib.resizeAndUnsharp(tileOpts, opts.__mathCache)
    }));
}, Pica.prototype.__extractTileData = function(tile, from, opts, stageEnv, extractTo) {
    if (this.features.ww && CAN_USE_OFFSCREEN_CANVAS && (utils.isCanvas(from) || CAN_USE_CIB_REGION_FOR_IMAGE)) return this.debug("Create tile for OffscreenCanvas"), 
    createImageBitmap(stageEnv.srcImageBitmap || from, tile.x, tile.y, tile.width, tile.height).then((bitmap => (extractTo.srcBitmap = bitmap, 
    extractTo)));
    if (utils.isCanvas(from)) return stageEnv.srcCtx || (stageEnv.srcCtx = from.getContext("2d")), 
    this.debug("Get tile pixel data"), extractTo.src = stageEnv.srcCtx.getImageData(tile.x, tile.y, tile.width, tile.height).data, 
    extractTo;
    this.debug("Draw tile imageBitmap/image to temporary canvas");
    let tmpCanvas = this.options.createCanvas(tile.width, tile.height), tmpCtx = tmpCanvas.getContext("2d");
    return tmpCtx.globalCompositeOperation = "copy", tmpCtx.drawImage(stageEnv.srcImageBitmap || from, tile.x, tile.y, tile.width, tile.height, 0, 0, tile.width, tile.height), 
    this.debug("Get tile pixel data"), extractTo.src = tmpCtx.getImageData(0, 0, tile.width, tile.height).data, 
    tmpCanvas.width = tmpCanvas.height = 0, extractTo;
}, Pica.prototype.__landTileData = function(tile, result, stageEnv) {
    let toImageData;
    if (this.debug("Convert raw rgba tile result to ImageData"), result.bitmap) return stageEnv.toCtx.drawImage(result.bitmap, tile.toX, tile.toY), 
    null;
    if (CAN_NEW_IMAGE_DATA) toImageData = new ImageData(new Uint8ClampedArray(result.data), tile.toWidth, tile.toHeight); else if (toImageData = stageEnv.toCtx.createImageData(tile.toWidth, tile.toHeight), 
    toImageData.data.set) toImageData.data.set(result.data); else for (let i = toImageData.data.length - 1; i >= 0; i--) toImageData.data[i] = result.data[i];
    return this.debug("Draw tile"), NEED_SAFARI_FIX ? stageEnv.toCtx.putImageData(toImageData, tile.toX, tile.toY, tile.toInnerX - tile.toX, tile.toInnerY - tile.toY, tile.toInnerWidth + 1e-5, tile.toInnerHeight + 1e-5) : stageEnv.toCtx.putImageData(toImageData, tile.toX, tile.toY, tile.toInnerX - tile.toX, tile.toInnerY - tile.toY, tile.toInnerWidth, tile.toInnerHeight), 
    null;
}, Pica.prototype.__tileAndResize = function(from, to, opts) {
    let stageEnv = {
        srcCtx: null,
        srcImageBitmap: null,
        isImageBitmapReused: !1,
        toCtx: null
    };
    const processTile = tile => this.__limit((() => {
        if (opts.canceled) return opts.cancelToken;
        let tileOpts = {
            width: tile.width,
            height: tile.height,
            toWidth: tile.toWidth,
            toHeight: tile.toHeight,
            scaleX: tile.scaleX,
            scaleY: tile.scaleY,
            offsetX: tile.offsetX,
            offsetY: tile.offsetY,
            filter: opts.filter,
            unsharpAmount: opts.unsharpAmount,
            unsharpRadius: opts.unsharpRadius,
            unsharpThreshold: opts.unsharpThreshold
        };
        return this.debug("Invoke resize math"), Promise.resolve(tileOpts).then((tileOpts => this.__extractTileData(tile, from, opts, stageEnv, tileOpts))).then((tileOpts => (this.debug("Invoke resize math"), 
        this.__invokeResize(tileOpts, opts)))).then((result => opts.canceled ? opts.cancelToken : (stageEnv.srcImageData = null, 
        this.__landTileData(tile, result, stageEnv))));
    }));
    return Promise.resolve().then((() => {
        if (stageEnv.toCtx = to.getContext("2d"), utils.isCanvas(from)) return null;
        if (utils.isImageBitmap(from)) return stageEnv.srcImageBitmap = from, stageEnv.isImageBitmapReused = !0, 
        null;
        if (utils.isImage(from)) return CAN_CREATE_IMAGE_BITMAP ? (this.debug("Decode image via createImageBitmap"), 
        createImageBitmap(from).then((imageBitmap => {
            stageEnv.srcImageBitmap = imageBitmap;
        })).catch((e => null))) : null;
        throw new Error('Pica: ".from" should be Image, Canvas or ImageBitmap');
    })).then((() => {
        if (opts.canceled) return opts.cancelToken;
        this.debug("Calculate tiles");
        let jobs = function createRegions(options) {
            var x, y, innerX, innerY, toTileWidth, toTileHeight, scaleX = options.toWidth / options.width, scaleY = options.toHeight / options.height, innerTileWidth = pixelFloor(options.srcTileSize * scaleX) - 2 * options.destTileBorder, innerTileHeight = pixelFloor(options.srcTileSize * scaleY) - 2 * options.destTileBorder;
            if (innerTileWidth < 1 || innerTileHeight < 1) throw new Error("Internal error in pica: target tile width/height is too small.");
            var tile, tiles = [];
            for (innerY = 0; innerY < options.toHeight; innerY += innerTileHeight) for (innerX = 0; innerX < options.toWidth; innerX += innerTileWidth) (x = innerX - options.destTileBorder) < 0 && (x = 0), 
            x + (toTileWidth = innerX + innerTileWidth + options.destTileBorder - x) >= options.toWidth && (toTileWidth = options.toWidth - x), 
            (y = innerY - options.destTileBorder) < 0 && (y = 0), y + (toTileHeight = innerY + innerTileHeight + options.destTileBorder - y) >= options.toHeight && (toTileHeight = options.toHeight - y), 
            tile = {
                toX: x,
                toY: y,
                toWidth: toTileWidth,
                toHeight: toTileHeight,
                toInnerX: innerX,
                toInnerY: innerY,
                toInnerWidth: innerTileWidth,
                toInnerHeight: innerTileHeight,
                offsetX: x / scaleX - pixelFloor(x / scaleX),
                offsetY: y / scaleY - pixelFloor(y / scaleY),
                scaleX,
                scaleY,
                x: pixelFloor(x / scaleX),
                y: pixelFloor(y / scaleY),
                width: pixelCeil(toTileWidth / scaleX),
                height: pixelCeil(toTileHeight / scaleY)
            }, tiles.push(tile);
            return tiles;
        }({
            width: opts.width,
            height: opts.height,
            srcTileSize: this.options.tile,
            toWidth: opts.toWidth,
            toHeight: opts.toHeight,
            destTileBorder: opts.__destTileBorder
        }).map((tile => processTile(tile)));
        function cleanup(stageEnv) {
            stageEnv.srcImageBitmap && (stageEnv.isImageBitmapReused || stageEnv.srcImageBitmap.close(), 
            stageEnv.srcImageBitmap = null);
        }
        return this.debug("Process tiles"), Promise.all(jobs).then((() => (this.debug("Finished!"), 
        cleanup(stageEnv), to)), (err => {
            throw cleanup(stageEnv), err;
        }));
    }));
}, Pica.prototype.__processStages = function(stages, from, to, opts) {
    if (opts.canceled) return opts.cancelToken;
    let filter, tmpCanvas, [toWidth, toHeight] = stages.shift(), isLastStage = 0 === stages.length;
    return filter = isLastStage || filter_info.q2f.indexOf(opts.filter) < 0 ? opts.filter : "box" === opts.filter ? "box" : "hamming", 
    opts = assign({}, opts, {
        toWidth,
        toHeight,
        filter
    }), isLastStage || (tmpCanvas = this.options.createCanvas(toWidth, toHeight)), this.__tileAndResize(from, isLastStage ? to : tmpCanvas, opts).then((() => isLastStage ? to : (opts.width = toWidth, 
    opts.height = toHeight, this.__processStages(stages, tmpCanvas, to, opts)))).then((res => (tmpCanvas && (tmpCanvas.width = tmpCanvas.height = 0), 
    res)));
}, Pica.prototype.__resizeViaCreateImageBitmap = function(from, to, opts) {
    let toCtx = to.getContext("2d");
    return this.debug("Resize via createImageBitmap()"), createImageBitmap(from, {
        resizeWidth: opts.toWidth,
        resizeHeight: opts.toHeight,
        resizeQuality: utils.cib_quality_name(filter_info.f2q[opts.filter])
    }).then((imageBitmap => {
        if (opts.canceled) return opts.cancelToken;
        if (!opts.unsharpAmount) return toCtx.drawImage(imageBitmap, 0, 0), imageBitmap.close(), 
        toCtx = null, this.debug("Finished!"), to;
        this.debug("Unsharp result");
        let tmpCanvas = this.options.createCanvas(opts.toWidth, opts.toHeight), tmpCtx = tmpCanvas.getContext("2d");
        tmpCtx.drawImage(imageBitmap, 0, 0), imageBitmap.close();
        let iData = tmpCtx.getImageData(0, 0, opts.toWidth, opts.toHeight);
        return this.__mathlib.unsharp_mask(iData.data, opts.toWidth, opts.toHeight, opts.unsharpAmount, opts.unsharpRadius, opts.unsharpThreshold), 
        toCtx.putImageData(iData, 0, 0), tmpCanvas.width = tmpCanvas.height = 0, iData = tmpCtx = tmpCanvas = toCtx = null, 
        this.debug("Finished!"), to;
    }));
}, Pica.prototype.resize = function(from, to, options) {
    this.debug("Start resize...");
    let opts = assign({}, DEFAULT_RESIZE_OPTS);
    if (isNaN(options) ? options && (opts = assign(opts, options)) : opts = assign(opts, {
        quality: options
    }), opts.toWidth = to.width, opts.toHeight = to.height, opts.width = from.naturalWidth || from.width, 
    opts.height = from.naturalHeight || from.height, Object.prototype.hasOwnProperty.call(opts, "quality")) {
        if (opts.quality < 0 || opts.quality > 3) throw new Error(`Pica: .quality should be [0..3], got ${opts.quality}`);
        opts.filter = filter_info.q2f[opts.quality];
    }
    return 0 === to.width || 0 === to.height ? Promise.reject(new Error(`Invalid output size: ${to.width}x${to.height}`)) : (opts.unsharpRadius > 2 && (opts.unsharpRadius = 2), 
    opts.canceled = !1, opts.cancelToken && (opts.cancelToken = opts.cancelToken.then((data => {
        throw opts.canceled = !0, data;
    }), (err => {
        throw opts.canceled = !0, err;
    }))), opts.__destTileBorder = Math.ceil(Math.max(3, 2.5 * opts.unsharpRadius | 0)), 
    this.init().then((() => {
        if (opts.canceled) return opts.cancelToken;
        if (this.features.cib) {
            if (filter_info.q2f.indexOf(opts.filter) >= 0) return this.__resizeViaCreateImageBitmap(from, to, opts);
            this.debug("cib is enabled, but not supports provided filter, fallback to manual math");
        }
        if (!CAN_USE_CANVAS_GET_IMAGE_DATA) {
            let err = new Error("Pica: cannot use getImageData on canvas, make sure fingerprinting protection isn't enabled");
            throw err.code = "ERR_GET_IMAGE_DATA", err;
        }
        let stages = function createStages(fromWidth, fromHeight, toWidth, toHeight, srcTileSize, destTileBorder) {
            let scaleX = toWidth / fromWidth, scaleY = toHeight / fromHeight, minScale = (2 * destTileBorder + 2 + 1) / srcTileSize;
            if (minScale > 0.5) return [ [ toWidth, toHeight ] ];
            let stageCount = Math.ceil(Math.log(Math.min(scaleX, scaleY)) / Math.log(minScale));
            if (stageCount <= 1) return [ [ toWidth, toHeight ] ];
            let result = [];
            for (let i = 0; i < stageCount; i++) {
                let width = Math.round(Math.pow(Math.pow(fromWidth, stageCount - i - 1) * Math.pow(toWidth, i + 1), 1 / stageCount)), height = Math.round(Math.pow(Math.pow(fromHeight, stageCount - i - 1) * Math.pow(toHeight, i + 1), 1 / stageCount));
                result.push([ width, height ]);
            }
            return result;
        }(opts.width, opts.height, opts.toWidth, opts.toHeight, this.options.tile, opts.__destTileBorder);
        return this.__processStages(stages, from, to, opts);
    })));
}, Pica.prototype.resizeBuffer = function(options) {
    const opts = assign({}, DEFAULT_RESIZE_OPTS, options);
    if (Object.prototype.hasOwnProperty.call(opts, "quality")) {
        if (opts.quality < 0 || opts.quality > 3) throw new Error(`Pica: .quality should be [0..3], got ${opts.quality}`);
        opts.filter = filter_info.q2f[opts.quality];
    }
    return this.init().then((() => this.__mathlib.resizeAndUnsharp(opts)));
}, Pica.prototype.toBlob = function(canvas, mimeType, quality) {
    return mimeType = mimeType || "image/png", new Promise((resolve => {
        if (canvas.toBlob) return void canvas.toBlob((blob => resolve(blob)), mimeType, quality);
        if (canvas.convertToBlob) return void resolve(canvas.convertToBlob({
            type: mimeType,
            quality
        }));
        const asString = atob(canvas.toDataURL(mimeType, quality).split(",")[1]), len = asString.length, asBuffer = new Uint8Array(len);
        for (let i = 0; i < len; i++) asBuffer[i] = asString.charCodeAt(i);
        resolve(new Blob([ asBuffer ], {
            type: mimeType
        }));
    }));
}, Pica.prototype.debug = function() {};

var pica = Pica;

class SendMessageService extends BaseService {
    emoteService;
    attachService;
    modulesService;
    settingsService;
    gifsicleService;
    picaInstance;
    start(emoteService, attachService, modulesService, settingsService, gifsicleService) {
        return this.emoteService = emoteService, this.attachService = attachService, this.modulesService = modulesService, 
        this.settingsService = settingsService, this.gifsicleService = gifsicleService, 
        this.picaInstance = pica(), BdApi.Patcher.instead(this.plugin.meta.name, modulesService.messageStore, "sendMessage", ((_, args, original) => this.onSendMessage(args, original))), 
        Promise.resolve();
    }
    async onSendMessage(args, original) {
        const callDefault = original, message = args[1];
        if (message) try {
            const discordEmotes = this.getTargetEmoteFromMessage(message);
            let content = message.content;
            const foundEmote = this.getTextPos(content, {
                ...this.emoteService.emoteNames,
                ...discordEmotes
            });
            if (!foundEmote) return void callDefault(...args);
            if (!this.attachService.canAttach) return BdApi.showToast("This channel does not allow sending images!", {
                type: "error"
            }), void callDefault(...args);
            content = (content.substring(0, foundEmote.pos) + content.substring(foundEmote.pos + foundEmote.nameAndCommand.length)).trim(), 
            foundEmote.content = content;
            try {
                return this.attachService.pendingUpload = this.fetchBlobAndUpload(foundEmote), void await this.attachService.pendingUpload;
            } catch (error) {
                const errorMessage = error instanceof Error ? error.message : error;
                if (BdApi.showToast(errorMessage, {
                    type: "error"
                }), "" === content) return;
                message.content = content;
            } finally {
                this.attachService.pendingUpload = void 0;
            }
            return void callDefault(...args);
        } catch (error) {
            Logger.warn("Error in onSendMessage", error);
        } else callDefault(...args);
    }
    getTargetEmoteFromMessage(message) {
        const invalidEmojis = message.invalidEmojis ?? [], validNonShortcutEmojis = message.validNonShortcutEmojis ?? [];
        let emoji, validEmoji = !1;
        if (invalidEmojis.length > 0) emoji = invalidEmojis[invalidEmojis.length - 1]; else {
            if (!(validNonShortcutEmojis?.length > 0)) return {};
            if (emoji = validNonShortcutEmojis[validNonShortcutEmojis.length - 1], !0 === emoji?.managed) return {};
            validEmoji = !0 === emoji?.available && !this.attachService.externalEmotes.has(emoji.id);
        }
        if (!emoji) return {};
        const emojiName = emoji.originalName ?? emoji.name, allNamesString = emoji.allNamesString.replace(emoji.name, emojiName), emojiText = `<${emoji.animated ? "a" : ""}${allNamesString}${emoji.id}>`, result = {}, url = emoji.url.split("?")[0] ?? "";
        if (!url) return {};
        const extensionIndex = url.lastIndexOf(".");
        result[emojiText] = {
            name: emojiName,
            url: ".webp" === url.substring(extensionIndex) ? `${url.substring(0, extensionIndex)}.png` : url
        };
        const foundEmote = this.getTextPos(message.content, result);
        return foundEmote ? validEmoji && 0 === foundEmote.commands.length ? {} : result : {};
    }
    getTextPos(content, emoteCandidates) {
        const foundEmotes = [];
        return Object.entries(emoteCandidates).forEach((([key, value]) => {
            const regex = new RegExp("(?<!\\/)" + key + "(?<=\\b|>)", "g"), regexCommand = new RegExp(key + "(\\.\\S{4,}\\b)+"), matches = content.match(regex), command = content.match(regexCommand);
            if (matches && 0 !== matches.length) for (let i = 0; i < matches.length; i++) {
                const pos = this.getNthIndexOf(content, key, i), emote = {
                    name: "string" == typeof value ? key : value.name,
                    nameAndCommand: key,
                    url: "string" == typeof value ? value : value.url,
                    emoteLength: key.length,
                    pos,
                    spoiler: !1,
                    commands: []
                };
                if (command) {
                    const commands = command[0]?.split(".") ?? [];
                    emote.commands = commands.filter((command => command !== key)).map((command => {
                        const split = command.split("-");
                        return [ split[0] ?? void 0, split[1] ?? void 0 ];
                    })), emote.nameAndCommand = command[0] ?? "";
                }
                const beforeEmote = content.substring(0, pos), afterEmote = content.substring(pos + emote.nameAndCommand.length);
                if (beforeEmote.includes("||") && afterEmote.includes("||")) {
                    const spoilerStart = beforeEmote.substring(beforeEmote.indexOf("||"));
                    emote.nameAndCommand = spoilerStart + emote.nameAndCommand, emote.pos -= spoilerStart.length;
                    const spoilerEnd = afterEmote.substring(0, afterEmote.indexOf("||") + 2);
                    emote.nameAndCommand = emote.nameAndCommand + spoilerEnd, emote.spoiler = !0;
                }
                beforeEmote.includes("`") && afterEmote.includes("`") || foundEmotes.push(emote);
            }
        })), foundEmotes.pop();
    }
    getNthIndexOf(input, search, nth) {
        const firstIndex = input.indexOf(search), startPos = firstIndex + search.length;
        if (0 === nth) return firstIndex;
        {
            const inputAfterFirstOccurrence = input.substring(startPos), nextOccurrence = this.getNthIndexOf(inputAfterFirstOccurrence, search, nth - 1);
            return -1 === nextOccurrence ? -1 : startPos + nextOccurrence;
        }
    }
    async fetchBlobAndUpload(emote) {
        const url = emote.url, name = emote.name, commands = emote.commands;
        if (emote.channel = this.modulesService.selectedChannelStore.getChannelId(), url.endsWith(".gif") || this.findCommand(commands, this.getGifModifiers())) return this.getMetaAndModifyGif(emote);
        const resultBlob = await this.compress(url, commands) ?? new Blob([]);
        if (0 === resultBlob.size) throw new Error("Emote URL did not contain data");
        this.uploadFile({
            fileData: resultBlob,
            fullName: name + ".png",
            emote
        });
    }
    findCommand(commands, names) {
        let foundCommand;
        return commands.forEach((command => {
            names.forEach((name => {
                command[0] === name && (foundCommand = command);
            }));
        })), foundCommand;
    }
    getGifModifiers() {
        const gifModifiers = [];
        return this.emoteService.modifiers.forEach((modifier => {
            "gif" === modifier.type && gifModifiers.push(modifier.name);
        })), gifModifiers;
    }
    async getMetaAndModifyGif(emote) {
        const image = await loadImagePromise(emote.url), commands = emote.commands;
        this.addResizeCommand(commands, image), BdApi.showToast("Processing gif...", {
            type: "info"
        });
        const buffer = await this.gifsicleService.modifyGif(emote.url, commands);
        if (0 === buffer.length) throw Error("Failed to process gif");
        this.uploadFile({
            fileData: buffer,
            fullName: emote.name + ".gif",
            emote
        });
    }
    addResizeCommand(commands, image) {
        const scaleFactorNum = this.getScaleFactor(commands, image);
        let scaleFactor = scaleFactorNum.toString();
        const wideCommand = this.findCommand(commands, [ "wide" ]);
        wideCommand && (scaleFactor = `${scaleFactorNum * this.getEmoteWideness(wideCommand)}x${scaleFactorNum}}`), 
        commands.push([ "resize", scaleFactor ]);
    }
    getScaleFactor(commands, image) {
        const size = this.getEmoteSize(commands);
        let scaleFactor;
        return scaleFactor = "largest" === this.settingsService.settings.resizeMethod ? image.width > image.height ? size / image.width : size / image.height : image.width < image.height ? size / image.width : size / image.height, 
        scaleFactor;
    }
    getEmoteSize(commands) {
        let size, resizeCommand = [];
        commands.forEach(((command, index, object) => {
            "resize" === command[0] && (resizeCommand = command, object.splice(index, 1));
        }));
        const resizeCommandSize = resizeCommand[1] ?? "";
        if (size = "" !== resizeCommandSize ? resizeCommandSize : Math.round(this.settingsService.settings.emoteSize), 
        "large" === size || "big" === size) return 128;
        if ("medium" === size || "normal" === size) return 64;
        {
            const sizeNumber = "string" == typeof size ? parseInt(size) : size;
            return isNaN(sizeNumber) ? 48 : Math.min(Math.max(sizeNumber, 32), 128);
        }
    }
    getEmoteWideness(wideCommand) {
        const param = wideCommand[1], paramNum = parseInt(param ?? "");
        return isNaN(paramNum) ? "extreme" === param ? 8 : "huge" === param ? 6 : "big" === param ? 4 : 2 : Math.max(Math.min(paramNum, 8), 2);
    }
    uploadFile(params) {
        const {fileData, fullName, emote} = params, content = emote.content ?? "", channelId = emote.channel ?? "";
        if (!channelId) return void Logger.error("Channel ID not found for emote:", emote);
        const upload = new this.modulesService.cloudUploader.n({
            file: new File([ fileData ], fullName),
            platform: 1
        }, channelId);
        upload.spoiler = emote.spoiler;
        const uploadOptions = {
            channelId,
            uploads: [ upload ],
            draftType: 0,
            parsedMessage: {
                content,
                invalidEmojis: [],
                tts: !1,
                channel_id: channelId
            }
        }, pendingReply = this.attachService.pendingReply;
        pendingReply && (uploadOptions.options = {
            messageReference: {
                channel_id: pendingReply.message.channel_id,
                guild_id: pendingReply.channel.guild_id,
                message_id: pendingReply.message.id
            }
        }), this.modulesService.uploader.uploadFiles(uploadOptions);
    }
    async compress(url, commands) {
        const image = await loadImagePromise(url), ctx = (await this.applyScaling(image, commands)).getContext("2d");
        if (ctx) return await new Promise((resolve => {
            ctx.canvas.toBlob((blob => {
                resolve(blob ?? void 0);
            }), "image/png", 1);
        }));
    }
    async applyScaling(image, commands) {
        const scaleFactor = this.getScaleFactor(commands, image);
        let canvas = document.createElement("canvas");
        canvas.width = image.width, canvas.height = image.height, commands.length > 0 ? canvas = this.applyCommands(image, canvas, commands) : canvas.getContext("2d")?.drawImage(image, 0, 0);
        const resizedCanvas = document.createElement("canvas");
        return resizedCanvas.width = Math.ceil(canvas.width * scaleFactor), resizedCanvas.height = Math.ceil(canvas.height * scaleFactor), 
        await this.picaInstance.resize(canvas, resizedCanvas, {
            unsharpAmount: 70,
            unsharpRadius: 0.8,
            unsharpThreshold: 105
        });
    }
    applyCommands(image, canvas, commands) {
        let scaleH = 1, scaleV = 1, posX = 0, posY = 0;
        this.findCommand(commands, [ "flip" ]) && (scaleH = -1, posX = -1 * canvas.width), 
        this.findCommand(commands, [ "flap" ]) && (scaleV = -1, posY = -1 * canvas.height);
        const ctx = canvas.getContext("2d"), wideCommand = this.findCommand(commands, [ "wide" ]);
        if (wideCommand) {
            const wideness = this.getEmoteWideness(wideCommand);
            image.width = image.width * wideness, canvas.width = canvas.width * wideness;
        }
        const rotateCommand = this.findCommand(commands, [ "rotate" ]);
        if (rotateCommand) {
            const angle = parseInt(rotateCommand[1] ?? "0") * Math.PI / 180, sin = Math.sin(angle), cos = Math.cos(angle), newWidth = Math.abs(canvas.width * cos) + Math.abs(canvas.height * sin), newHeight = Math.abs(canvas.width * sin) + Math.abs(canvas.height * cos);
            canvas.width = newWidth, canvas.height = newHeight, ctx?.translate(canvas.width / 2, canvas.height / 2), 
            ctx?.rotate(angle), posX = -image.width / 2, posY = -image.height / 2;
        }
        return ctx?.scale(scaleH, scaleV), ctx?.drawImage(image, posX, posY, image.width, image.height), 
        canvas;
    }
    stop() {}
}

class HtmlService extends BaseService {
    modulesService;
    start(modulesService) {
        return this.modulesService = modulesService, Promise.resolve();
    }
    addClasses(element, ...classes) {
        for (const curClass of classes) {
            if (!curClass) continue;
            const split = curClass.split(" ");
            for (const curClassItem of split) element.classList.add(curClassItem);
        }
    }
    getClassSelector(classes) {
        return classes.split(" ").map((curClass => curClass.startsWith(".") ? curClass : `.${curClass}`)).join(" ");
    }
    getTextAreaField() {
        const textArea = this.modulesService.classes.TextArea.textArea;
        return document.querySelector(this.getClassSelector(textArea)) ?? void 0;
    }
    getTextAreaContainer() {
        const channelTextArea = this.modulesService.classes.TextArea.channelTextArea;
        return document.querySelector(this.getClassSelector(channelTextArea)) ?? void 0;
    }
    stop() {}
}

var index = void 0 === window.ZeresPluginLibrary ? class RawPlugin {
    meta;
    constructor(meta) {
        this.meta = meta, setLogger(meta.name);
    }
    start() {
        this.showLibraryMissingModal().catch((error => {
            Logger.error(error);
        }));
    }
    async showLibraryMissingModal() {
        const request = await Promise.resolve().then((function() {
            return _interopNamespace(require("request"));
        })), electron = await Promise.resolve().then((function() {
            return _interopNamespace(require("electron"));
        })), fs = await Promise.resolve().then((function() {
            return _interopNamespace(require("fs"));
        })), path = await Promise.resolve().then((function() {
            return _interopNamespace(require("path"));
        }));
        BdApi.showConfirmationModal("Library Missing", `The library plugin needed for ${this.meta.name} is missing. Please click Download Now to install it.`, {
            confirmText: "Download Now",
            cancelText: "Cancel",
            onConfirm: () => {
                request.get("https://rauenzi.github.io/BDPluginLibrary/release/0PluginLibrary.plugin.js", void 0, ((error, _response, body) => {
                    null == error ? fs.writeFile(path.join(BdApi.Plugins.folder, "0PluginLibrary.plugin.js"), body, (() => {})) : electron.shell.openExternal("https://betterdiscord.net/ghdl?url=https://raw.githubusercontent.com/rauenzi/BDPluginLibrary/master/release/0PluginLibrary.plugin.js").catch((error => {
                        Logger.error(error);
                    }));
                }));
            }
        });
    }
    stop() {}
} : class EmoteReplacerPlugin {
    settingsService;
    emoteService;
    completionsService;
    attachService;
    listenersService;
    gifsicleService;
    modulesService;
    sendMessageService;
    htmlService;
    meta;
    updateInterval;
    constructor(meta) {
        this.meta = meta, setLogger(meta.name);
    }
    start() {
        this.doStart().catch((error => {
            Logger.error(error);
        }));
    }
    async doStart() {
        const zeresPluginLibrary = window.ZeresPluginLibrary;
        this.showChangelogIfNeeded(zeresPluginLibrary), await this.startServicesAndPatches();
    }
    showChangelogIfNeeded(zeresPluginLibrary) {
        const currentVersionInfo = BdApi.loadData(this.meta.name, "currentVersionInfo") ?? {};
        if (!0 !== currentVersionInfo.hasShownChangelog || currentVersionInfo.version !== this.meta.version) {
            zeresPluginLibrary.Modals.showChangelogModal(`${this.meta.name} Changelog`, this.meta.version, PLUGIN_CHANGELOG);
            const newVersionInfo = {
                version: this.meta.version,
                hasShownChangelog: !0
            };
            BdApi.saveData(this.meta.name, "currentVersionInfo", newVersionInfo);
        }
    }
    async startServicesAndPatches() {
        const zeresPluginLibrary = window.ZeresPluginLibrary;
        this.listenersService = new ListenersService(this, zeresPluginLibrary), await this.listenersService.start(), 
        this.settingsService = new SettingsService(this, zeresPluginLibrary), await this.settingsService.start(this.listenersService), 
        this.modulesService = new ModulesService(this, zeresPluginLibrary), await this.modulesService.start(), 
        this.htmlService = new HtmlService(this, zeresPluginLibrary), await this.htmlService.start(this.modulesService), 
        this.emoteService = new EmoteService(this, zeresPluginLibrary), await this.emoteService.start(this.listenersService, this.settingsService, this.htmlService), 
        this.completionsService = new CompletionsService(this, zeresPluginLibrary), await this.completionsService.start(this.emoteService, this.settingsService, this.modulesService, this.listenersService, this.htmlService), 
        this.attachService = new AttachService(this, zeresPluginLibrary), await this.attachService.start(this.modulesService), 
        this.gifsicleService = new GifsicleService(this, zeresPluginLibrary), await this.gifsicleService.start(), 
        this.sendMessageService = new SendMessageService(this, zeresPluginLibrary), await this.sendMessageService.start(this.emoteService, this.attachService, this.modulesService, this.settingsService, this.gifsicleService);
        const pluginName = this.meta.name;
        (function changeDraftPatch(pluginName, attachService, completionsService, emoteService, modulesService) {
            BdApi.Patcher.before(pluginName, modulesService.draft, "changeDraft", ((_, args) => function onChangeDraft(args, attachService, completionsService, emoteService) {
                if (!attachService.canAttach) return;
                const draft = args[1];
                if (void 0 !== draft) {
                    completionsService.draft = draft;
                    try {
                        const lastText = completionsService.cached?.draft;
                        if (!emoteService.shouldCompleteEmote(draft) && !emoteService.shouldCompleteCommand(draft)) return void completionsService.destroyCompletions();
                        lastText !== draft && completionsService.renderCompletions();
                    } catch (err) {
                        Logger.warn("Error in onChangeDraft", err);
                    }
                }
            }(args, attachService, completionsService, emoteService)));
        })(pluginName, this.attachService, this.completionsService, this.emoteService, this.modulesService), 
        function pendingReplyPatch(pluginName, attachService, modulesService) {
            const pendingReplyDispatcher = modulesService.pendingReplyDispatcher, createPendingReply = pendingReplyDispatcher.createPendingReplyKey;
            if (void 0 === createPendingReply) return void Logger.warn("Create pending reply function name not found");
            const deletePendingReply = pendingReplyDispatcher.deletePendingReplyKey;
            void 0 !== deletePendingReply ? (BdApi.Patcher.before(pluginName, pendingReplyDispatcher.module, createPendingReply, ((_, args) => {
                if (!args[0]) return;
                const reply = args[0];
                attachService.pendingReply = reply;
            })), BdApi.Patcher.instead(pluginName, pendingReplyDispatcher.module, deletePendingReply, ((_, args, original) => async function onDeletePendingReply(args, original, attachService) {
                const callDefault = original;
                try {
                    attachService.pendingUpload && await attachService.pendingUpload, callDefault(...args);
                } catch (err) {
                    Logger.warn("Error in onDeletePendingReply", err);
                } finally {
                    attachService.pendingReply = void 0;
                }
            }(args, original, attachService)))) : Logger.warn("Delete pending reply function name not found");
        }(pluginName, this.attachService, this.modulesService), function emojiSearchPatch(pluginName, attachService, modulesService) {
            BdApi.Patcher.after(pluginName, modulesService.emojiSearch, "search", ((_, _2, result) => function onEmojiSearch(result, attachService) {
                if (!attachService.canAttach) return;
                const searchResult = result;
                searchResult.unlocked.push(...searchResult.locked), searchResult.locked = [];
            }(result, attachService)));
        }(pluginName, this.attachService, this.modulesService), function lockedEmojisPatch(pluginName, attachService, modulesService) {
            const emojiStore = modulesService.emojiStore;
            BdApi.Patcher.after(pluginName, emojiStore, "getEmojiUnavailableReason", ((_, args, result) => function onGetEmojiUnavailableReason(args, result, attachService, modulesService) {
                if (!attachService.canAttach) return result;
                const EmojiDisabledReasons = modulesService.emojiDisabledReasons, options = args[0];
                if (0 === options?.intention) return result;
                if (result === EmojiDisabledReasons.DISALLOW_EXTERNAL) {
                    const emojiId = options?.emoji?.id;
                    if (void 0 === emojiId) return result;
                    attachService.externalEmotes.add(emojiId), result = null;
                } else result !== EmojiDisabledReasons.PREMIUM_LOCKED && result !== EmojiDisabledReasons.GUILD_SUBSCRIPTION_UNAVAILABLE || (result = null);
                return result;
            }(args, result, attachService, modulesService))), BdApi.Patcher.after(pluginName, emojiStore, "isEmojiDisabled", ((_, args) => function onIsEmojiDisabled(args, emojiStore) {
                const [emoji, channel, intention] = args;
                return null !== emojiStore.getEmojiUnavailableReason({
                    emoji,
                    channel,
                    intention
                });
            }(args, emojiStore)));
        }(pluginName, this.attachService, this.modulesService);
    }
    observer(e) {
        if (!(e.addedNodes.length && e.addedNodes[0] instanceof Element)) return;
        const elem = e.addedNodes[0], modulesService = this.modulesService;
        if (!modulesService) return;
        const textAreaSelector = this.htmlService?.getClassSelector(modulesService.classes.TextArea.textArea);
        void 0 !== textAreaSelector && elem.querySelector(textAreaSelector) && this.listenersService?.requestAddListeners(CompletionsService.TAG);
    }
    onSwitch() {
        this.completionsService?.destroyCompletions();
    }
    getSettingsPanel() {
        return this.settingsService?.getSettingsElement() ?? new HTMLElement;
    }
    stop() {
        BdApi.Patcher.unpatchAll(this.meta.name), this.updateInterval && (clearTimeout(this.updateInterval), 
        this.updateInterval = void 0), this.sendMessageService?.stop(), this.sendMessageService = void 0, 
        this.gifsicleService?.stop(), this.gifsicleService = void 0, this.attachService?.stop(), 
        this.attachService = void 0, this.completionsService?.stop(), this.completionsService = void 0, 
        this.emoteService?.stop(), this.emoteService = void 0, this.htmlService?.stop(), 
        this.htmlService = void 0, this.modulesService?.stop(), this.modulesService = void 0, 
        this.settingsService?.stop(), this.settingsService = void 0, this.listenersService?.stop(), 
        this.listenersService = void 0;
    }
};

module.exports = index;
